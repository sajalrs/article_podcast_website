{"ast":null,"code":"const mongoose = require(\"mongoose\");\n\nconst fetch = require(\"node-fetch\");\n\nvar parser = require(\"xml2json\");\n\nconst bcrypt = require(\"bcryptjs\");\n\nconst jwt = require(\"jsonwebtoken\");\n\nconst {\n  loginValidation\n} = require(\"../validation/validation\");\n\nlet YoutubeLink;\n\ntry {\n  YoutubeLink = mongoose.model(\"YoutubeLinks\");\n} catch {\n  YoutubeLink = require(\"../models/YoutubeLinks\");\n}\n\nlet User;\n\ntry {\n  User = mongoose.model(\"Users\");\n} catch {\n  User = require(\"../models/Users\");\n}\n\nexport const resolvers = {\n  Query: {\n    youtubeLinks: async () => await YoutubeLink.find({}).sort(\"-date\"),\n    podcasts: async () => await fetch(`https://anchor.fm/s/333e122c/podcast/rss`).then(response => response.text()).then(data => {\n      let json = JSON.parse(parser.toJson(data, {\n        reversible: false\n      }));\n      return json.rss.channel.item.map(element => {\n        const text = element[\"description\"].replace(/<[^>]+>/g, \"\").replace(/&nbsp;/, \"\");\n        return {\n          title: element[\"title\"],\n          by: element[\"dc:creator\"],\n          link: element[\"enclosure\"][\"url\"],\n          date: element[\"pubDate\"],\n          image: element[\"itunes:image\"][\"href\"],\n          description: text.substring(0, text.indexOf(\"---\"))\n        };\n      });\n    }),\n    login: async (_, args, {\n      req,\n      res\n    }) => {\n      const {\n        error\n      } = loginValidation(args);\n\n      if (error) {\n        const toReturn = error.details[0].message.replace('\"email\"', \"Email\").replace('\"password\"', \"Password\");\n        throw Error(toReturn);\n      }\n\n      const user = await User.findOne({\n        email: req.body.email\n      });\n      if (!user) throw Error(\"The email or password is incorrect\");\n      const validPass = await bcrypt.compare(req.body.password, user.password);\n      if (!validPass) throw Error(\"The email or password is incorrect\");\n      const token = jwt.sign({\n        _id: user._id,\n        tokenCreated: new Date()\n      }, process.env.TOKEN_SECRET); // res.header('Auth-Token', token).send({token: token})\n      //   res.cookie(\"token\", token, { httpOnly: true }).json({ token: token });\n\n      res.setHeader(\"Set-Cookie\", serialize(\"token\", token, {\n        path: \"/\"\n      }, {\n        httpOnly: true\n      }));\n      return {\n        token: token\n      };\n    }\n  }\n};","map":{"version":3,"sources":["/home/sajalrs/ReactProgramming/article_podcast_website/pages/api/graphql/resolvers.js"],"names":["mongoose","require","fetch","parser","bcrypt","jwt","loginValidation","YoutubeLink","model","User","resolvers","Query","youtubeLinks","find","sort","podcasts","then","response","text","data","json","JSON","parse","toJson","reversible","rss","channel","item","map","element","replace","title","by","link","date","image","description","substring","indexOf","login","_","args","req","res","error","toReturn","details","message","Error","user","findOne","email","body","validPass","compare","password","token","sign","_id","tokenCreated","Date","process","env","TOKEN_SECRET","setHeader","serialize","path","httpOnly"],"mappings":"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","sourcesContent":["const mongoose = require(\"mongoose\");\nconst fetch = require(\"node-fetch\");\nvar parser = require(\"xml2json\");\nconst bcrypt = require(\"bcryptjs\");\nconst jwt = require(\"jsonwebtoken\");\nconst { loginValidation } = require(\"../validation/validation\");\n\nlet YoutubeLink;\ntry {\n  YoutubeLink = mongoose.model(\"YoutubeLinks\");\n} catch {\n  YoutubeLink = require(\"../models/YoutubeLinks\");\n}\n\nlet User;\ntry {\n  User = mongoose.model(\"Users\");\n} catch {\n  User = require(\"../models/Users\");\n}\n\nexport const resolvers = {\n  Query: {\n    youtubeLinks: async () => await YoutubeLink.find({}).sort(\"-date\"),\n\n    podcasts: async () =>\n      await fetch(`https://anchor.fm/s/333e122c/podcast/rss`)\n        .then((response) => response.text())\n        .then((data) => {\n          let json = JSON.parse(parser.toJson(data, { reversible: false }));\n          return json.rss.channel.item.map((element) => {\n            const text = element[\"description\"]\n              .replace(/<[^>]+>/g, \"\")\n              .replace(/&nbsp;/, \"\");\n            return {\n              title: element[\"title\"],\n              by: element[\"dc:creator\"],\n              link: element[\"enclosure\"][\"url\"],\n              date: element[\"pubDate\"],\n              image: element[\"itunes:image\"][\"href\"],\n              description: text.substring(0, text.indexOf(\"---\")),\n            };\n          });\n        }),\n\n    login: async (_, args, { req, res }) => {\n      const { error } = loginValidation(args);\n      if (error) {\n        const toReturn = error.details[0].message\n          .replace('\"email\"', \"Email\")\n          .replace('\"password\"', \"Password\");\n        throw Error(toReturn);\n      }\n\n      const user = await User.findOne({ email: req.body.email });\n\n      if (!user) throw Error(\"The email or password is incorrect\");\n\n      const validPass = await bcrypt.compare(req.body.password, user.password);\n      if (!validPass) throw Error(\"The email or password is incorrect\");\n\n      const token = jwt.sign(\n        { _id: user._id, tokenCreated: new Date() },\n        process.env.TOKEN_SECRET\n      );\n      // res.header('Auth-Token', token).send({token: token})\n      //   res.cookie(\"token\", token, { httpOnly: true }).json({ token: token });\n\n      res.setHeader(\n        \"Set-Cookie\",\n        serialize(\"token\", token, { path: \"/\" }, { httpOnly: true })\n      );\n\n      return { token: token };\n    },\n  },\n};\n"]},"metadata":{},"sourceType":"module"}