{"ast":null,"code":"import connectDb from \"../middlewares/dbMiddleware.js\";\nimport { serialize } from \"cookie\";\n\nconst mongoose = require(\"mongoose\");\n\nconst bcrypt = require(\"bcryptjs\");\n\nconst jwt = require(\"jsonwebtoken\");\n\nconst {\n  loginValidation\n} = require(\"../validation/validation\");\n\nlet User;\n\ntry {\n  User = mongoose.model(\"Users\");\n} catch {\n  User = require(\"../models/Users\");\n}\n\nconst handler = async (req, res) => {\n  const {\n    error\n  } = loginValidation(req.body);\n\n  if (error) {\n    const toReturn = error.details[0].message.replace('\"email\"', \"Email\").replace('\"password\"', \"Password\");\n    return res.status(400).send({\n      error: toReturn\n    });\n  }\n\n  const user = await User.findOne({\n    email: req.body.email\n  });\n  if (!user) return res.status(400).send({\n    error: \"The email or password is incorrect\"\n  });\n  const validPass = await bcrypt.compare(req.body.password, user.password);\n  if (!validPass) return res.status(400).send({\n    error: \"The email or password is incorrect\"\n  });\n  const token = jwt.sign({\n    _id: user._id,\n    tokenCreated: new Date()\n  }, process.env.TOKEN_SECRET); // res.header('Auth-Token', token).send({token: token})\n  //   res.cookie(\"token\", token, { httpOnly: true }).json({ token: token });\n\n  res.setHeader(\"Set-Cookie\", serialize(\"token\", token, {\n    path: \"/\"\n  }, {\n    httpOnly: true\n  }));\n  res.json({\n    token: token\n  }); // res.send({ token: token });\n};\n\nexport default connectDb(handler);","map":{"version":3,"sources":["/home/sajalrs/ReactProgramming/article_podcast_website/pages/api/auth/login.js"],"names":["connectDb","serialize","mongoose","require","bcrypt","jwt","loginValidation","User","model","handler","req","res","error","body","toReturn","details","message","replace","status","send","user","findOne","email","validPass","compare","password","token","sign","_id","tokenCreated","Date","process","env","TOKEN_SECRET","setHeader","path","httpOnly","json"],"mappings":"AAAA,OAAOA,SAAP,MAAsB,gCAAtB;AACA,SAASC,SAAT,QAA0B,QAA1B;;AACA,MAAMC,QAAQ,GAAGC,OAAO,CAAC,UAAD,CAAxB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,UAAD,CAAtB;;AACA,MAAME,GAAG,GAAGF,OAAO,CAAC,cAAD,CAAnB;;AACA,MAAM;AAAEG,EAAAA;AAAF,IAAsBH,OAAO,CAAC,0BAAD,CAAnC;;AAEA,IAAII,IAAJ;;AACA,IAAI;AACFA,EAAAA,IAAI,GAAGL,QAAQ,CAACM,KAAT,CAAe,OAAf,CAAP;AACD,CAFD,CAEE,MAAM;AACND,EAAAA,IAAI,GAAGJ,OAAO,CAAC,iBAAD,CAAd;AACD;;AAED,MAAMM,OAAO,GAAG,OAAOC,GAAP,EAAYC,GAAZ,KAAoB;AAClC,QAAM;AAAEC,IAAAA;AAAF,MAAYN,eAAe,CAACI,GAAG,CAACG,IAAL,CAAjC;;AACA,MAAID,KAAJ,EAAW;AACT,UAAME,QAAQ,GAAGF,KAAK,CAACG,OAAN,CAAc,CAAd,EAAiBC,OAAjB,CACdC,OADc,CACN,SADM,EACK,OADL,EAEdA,OAFc,CAEN,YAFM,EAEQ,UAFR,CAAjB;AAGA,WAAON,GAAG,CAACO,MAAJ,CAAW,GAAX,EAAgBC,IAAhB,CAAqB;AAAEP,MAAAA,KAAK,EAAEE;AAAT,KAArB,CAAP;AACD;;AAED,QAAMM,IAAI,GAAG,MAAMb,IAAI,CAACc,OAAL,CAAa;AAAEC,IAAAA,KAAK,EAAEZ,GAAG,CAACG,IAAJ,CAASS;AAAlB,GAAb,CAAnB;AAEA,MAAI,CAACF,IAAL,EACE,OAAOT,GAAG,CACPO,MADI,CACG,GADH,EAEJC,IAFI,CAEC;AAAEP,IAAAA,KAAK,EAAE;AAAT,GAFD,CAAP;AAIF,QAAMW,SAAS,GAAG,MAAMnB,MAAM,CAACoB,OAAP,CAAed,GAAG,CAACG,IAAJ,CAASY,QAAxB,EAAkCL,IAAI,CAACK,QAAvC,CAAxB;AACA,MAAI,CAACF,SAAL,EACE,OAAOZ,GAAG,CACPO,MADI,CACG,GADH,EAEJC,IAFI,CAEC;AAAEP,IAAAA,KAAK,EAAE;AAAT,GAFD,CAAP;AAIF,QAAMc,KAAK,GAAGrB,GAAG,CAACsB,IAAJ,CACZ;AAAEC,IAAAA,GAAG,EAAER,IAAI,CAACQ,GAAZ;AAAiBC,IAAAA,YAAY,EAAE,IAAIC,IAAJ;AAA/B,GADY,EAEZC,OAAO,CAACC,GAAR,CAAYC,YAFA,CAAd,CAtBkC,CA0BlC;AACA;;AAEAtB,EAAAA,GAAG,CAACuB,SAAJ,CACE,YADF,EAEEjC,SAAS,CAAC,OAAD,EAAUyB,KAAV,EAAiB;AAAES,IAAAA,IAAI,EAAE;AAAR,GAAjB,EAAgC;AAAEC,IAAAA,QAAQ,EAAE;AAAZ,GAAhC,CAFX;AAKAzB,EAAAA,GAAG,CAAC0B,IAAJ,CAAS;AAACX,IAAAA,KAAK,EAAEA;AAAR,GAAT,EAlCkC,CAoClC;AACD,CArCD;;AAuCA,eAAe1B,SAAS,CAACS,OAAD,CAAxB","sourcesContent":["import connectDb from \"../middlewares/dbMiddleware.js\";\nimport { serialize } from \"cookie\";\nconst mongoose = require(\"mongoose\");\nconst bcrypt = require(\"bcryptjs\");\nconst jwt = require(\"jsonwebtoken\");\nconst { loginValidation } = require(\"../validation/validation\");\n\nlet User;\ntry {\n  User = mongoose.model(\"Users\");\n} catch {\n  User = require(\"../models/Users\");\n}\n\nconst handler = async (req, res) => {\n  const { error } = loginValidation(req.body);\n  if (error) {\n    const toReturn = error.details[0].message\n      .replace('\"email\"', \"Email\")\n      .replace('\"password\"', \"Password\");\n    return res.status(400).send({ error: toReturn });\n  }\n\n  const user = await User.findOne({ email: req.body.email });\n\n  if (!user)\n    return res\n      .status(400)\n      .send({ error: \"The email or password is incorrect\" });\n\n  const validPass = await bcrypt.compare(req.body.password, user.password);\n  if (!validPass)\n    return res\n      .status(400)\n      .send({ error: \"The email or password is incorrect\" });\n\n  const token = jwt.sign(\n    { _id: user._id, tokenCreated: new Date() },\n    process.env.TOKEN_SECRET\n  );\n  // res.header('Auth-Token', token).send({token: token})\n  //   res.cookie(\"token\", token, { httpOnly: true }).json({ token: token });\n\n  res.setHeader(\n    \"Set-Cookie\",\n    serialize(\"token\", token, { path: \"/\" }, { httpOnly: true })\n  );\n\n  res.json({token: token});\n\n  // res.send({ token: token });\n};\n\nexport default connectDb(handler);\n"]},"metadata":{},"sourceType":"module"}