{"ast":null,"code":"const mongoose = require(\"mongoose\");\n\nconst fetch = require(\"node-fetch\");\n\nvar parser = require(\"xml2json\");\n\nimport { serialize } from \"cookie\";\n\nconst bcrypt = require(\"bcryptjs\");\n\nconst jwt = require(\"jsonwebtoken\");\n\nconst {\n  loginValidation,\n  registerValidation\n} = require(\"../validation/validation\");\n\nlet YoutubeLink;\n\ntry {\n  YoutubeLink = mongoose.model(\"YoutubeLinks\");\n} catch {\n  YoutubeLink = require(\"../models/YoutubeLinks\");\n}\n\nlet User;\n\ntry {\n  User = mongoose.model(\"Users\");\n} catch {\n  User = require(\"../models/Users\");\n}\n\nexport const resolvers = {\n  Query: {\n    youtubeLinks: async () => await YoutubeLink.find({}).sort(\"-date\"),\n    podcasts: async () => await fetch(`https://anchor.fm/s/333e122c/podcast/rss`).then(response => response.text()).then(data => {\n      let json = JSON.parse(parser.toJson(data, {\n        reversible: false\n      }));\n      return json.rss.channel.item.map(element => {\n        const text = element[\"description\"].replace(/<[^>]+>/g, \"\").replace(/&nbsp;/, \"\");\n        return {\n          title: element[\"title\"],\n          by: element[\"dc:creator\"],\n          link: element[\"enclosure\"][\"url\"],\n          date: element[\"pubDate\"],\n          image: element[\"itunes:image\"][\"href\"],\n          description: text.substring(0, text.indexOf(\"---\"))\n        };\n      });\n    }),\n    isLoggedIn: async (parent, args, ctx) => {\n      const {\n        authData\n      } = ctx;\n\n      if (!authData) {\n        throw Error(\"Please login to proceed\");\n      }\n\n      try {\n        const user = await User.findById(authData._id);\n        return user;\n      } catch (err) {\n        throw Error(err.message);\n      }\n    },\n    login: async (parent, args, ctx) => {\n      const {\n        error\n      } = loginValidation(args);\n\n      if (error) {\n        const toReturn = error.details[0].message.replace('\"email\"', \"Email\").replace('\"password\"', \"Password\");\n        throw Error(toReturn);\n      }\n\n      const {\n        cookie\n      } = ctx;\n      const {\n        email,\n        password\n      } = args;\n      const user = await User.findOne({\n        email: email\n      });\n      if (!user) throw Error(\"The email or password is incorrect\");\n      const validPass = await bcrypt.compare(password, user.password);\n      if (!validPass) throw Error(\"The email or password is incorrect\");\n      const token = jwt.sign({\n        _id: user._id,\n        tokenCreated: new Date()\n      }, process.env.TOKEN_SECRET);\n      cookie(\"token\", token, {\n        path: \"/\",\n        httpOnly: true,\n        sameSite: \"strict\"\n      });\n      return {\n        token: token\n      };\n    },\n    logout: (parent, args, ctx) => {\n      try {\n        const {\n          cookie\n        } = ctx;\n        cookie(\"token\", \"deleted\", {\n          path: \"/\",\n          httpOnly: true,\n          maxAge: 0,\n          sameSite: \"strict\"\n        });\n      } catch {\n        return false;\n      }\n\n      return true;\n    }\n  },\n  Mutation: {\n    register: async (parent, args, ctx) => {\n      const {\n        error\n      } = registerValidation(args);\n\n      if (error) {\n        const toReturn = error.details[0].message.replace('\"firstName\"', \"First Name\").replace('\"lastName\"', \"Last Name\").replace('\"email\"', \"Email\").replace('\"password\"', \"Password\");\n        throw Error(toReturn);\n      }\n\n      const emailExists = await User.findOne({\n        email: args.email\n      });\n      if (emailExists) throw Error(\"Email already exists\");\n      const salt = await bcrypt.genSalt(10);\n      const hashPassword = await bcrypt.hash(args.password, salt);\n      const user = new User({\n        firstName: args.firstName,\n        lastName: args.lastName,\n        email: args.email,\n        password: hashPassword,\n        isModerator: false,\n        isSubscribed: args.isSubscribed || false\n      });\n\n      try {\n        const savedUser = await user.save();\n        return savedUser;\n      } catch (err) {\n        throw Error(err.message);\n      }\n    },\n    subscribe: async (parent, args, ctx) => {\n      const {\n        authData\n      } = ctx;\n\n      if (!authData) {\n        throw Error(\"Please login to proceed\");\n      }\n\n      await User.findById(authData._id, async (err, user) => {\n        if (err) {\n          throw Error(err.message);\n        } else {\n          user.isSubscribed = args.isSubscribed;\n          await user.save((error, data) => {\n            if (error) {\n              throw Error(error.message);\n            } else {\n              return data;\n            }\n          });\n        }\n      });\n    }\n  }\n};","map":{"version":3,"sources":["/home/sajalrs/ReactProgramming/article_podcast_website/pages/api/graphql/resolvers.js"],"names":["mongoose","require","fetch","parser","serialize","bcrypt","jwt","loginValidation","registerValidation","YoutubeLink","model","User","resolvers","Query","youtubeLinks","find","sort","podcasts","then","response","text","data","json","JSON","parse","toJson","reversible","rss","channel","item","map","element","replace","title","by","link","date","image","description","substring","indexOf","isLoggedIn","parent","args","ctx","authData","Error","user","findById","_id","err","message","login","error","toReturn","details","cookie","email","password","findOne","validPass","compare","token","sign","tokenCreated","Date","process","env","TOKEN_SECRET","path","httpOnly","sameSite","logout","maxAge","Mutation","register","emailExists","salt","genSalt","hashPassword","hash","firstName","lastName","isModerator","isSubscribed","savedUser","save","subscribe"],"mappings":"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","sourcesContent":["const mongoose = require(\"mongoose\");\nconst fetch = require(\"node-fetch\");\nvar parser = require(\"xml2json\");\nimport { serialize } from \"cookie\";\nconst bcrypt = require(\"bcryptjs\");\nconst jwt = require(\"jsonwebtoken\");\nconst {\n  loginValidation,\n  registerValidation,\n} = require(\"../validation/validation\");\n\nlet YoutubeLink;\ntry {\n  YoutubeLink = mongoose.model(\"YoutubeLinks\");\n} catch {\n  YoutubeLink = require(\"../models/YoutubeLinks\");\n}\n\nlet User;\ntry {\n  User = mongoose.model(\"Users\");\n} catch {\n  User = require(\"../models/Users\");\n}\n\nexport const resolvers = {\n  Query: {\n    youtubeLinks: async () => await YoutubeLink.find({}).sort(\"-date\"),\n\n    podcasts: async () =>\n      await fetch(`https://anchor.fm/s/333e122c/podcast/rss`)\n        .then((response) => response.text())\n        .then((data) => {\n          let json = JSON.parse(parser.toJson(data, { reversible: false }));\n          return json.rss.channel.item.map((element) => {\n            const text = element[\"description\"]\n              .replace(/<[^>]+>/g, \"\")\n              .replace(/&nbsp;/, \"\");\n            return {\n              title: element[\"title\"],\n              by: element[\"dc:creator\"],\n              link: element[\"enclosure\"][\"url\"],\n              date: element[\"pubDate\"],\n              image: element[\"itunes:image\"][\"href\"],\n              description: text.substring(0, text.indexOf(\"---\")),\n            };\n          });\n        }),\n\n    isLoggedIn: async (parent, args, ctx) => {\n      const { authData } = ctx;\n      if (!authData) {\n        throw Error(\"Please login to proceed\");\n      }\n\n      try {\n        const user = await User.findById(authData._id);\n        return user;\n      } catch (err) {\n        throw Error(err.message);\n      }\n    },\n\n    login: async (parent, args, ctx) => {\n      const { error } = loginValidation(args);\n      if (error) {\n        const toReturn = error.details[0].message\n          .replace('\"email\"', \"Email\")\n          .replace('\"password\"', \"Password\");\n        throw Error(toReturn);\n      }\n      const { cookie } = ctx;\n      const { email, password } = args;\n      const user = await User.findOne({ email: email });\n\n      if (!user) throw Error(\"The email or password is incorrect\");\n\n      const validPass = await bcrypt.compare(password, user.password);\n      if (!validPass) throw Error(\"The email or password is incorrect\");\n\n      const token = jwt.sign(\n        { _id: user._id, tokenCreated: new Date() },\n        process.env.TOKEN_SECRET\n      );\n      cookie(\"token\", token, {\n        path: \"/\",\n        httpOnly: true,\n        sameSite: \"strict\",\n      });\n      return { token: token };\n    },\n\n    logout: (parent, args, ctx) => {\n      try {\n        const { cookie } = ctx;\n        cookie(\"token\", \"deleted\", {\n          path: \"/\",\n          httpOnly: true,\n          maxAge: 0,\n          sameSite: \"strict\",\n        });\n      } catch {\n        return false;\n      }\n      return true;\n    },\n  },\n\n  Mutation: {\n    register: async (parent, args, ctx) => {\n      const { error } = registerValidation(args);\n      if (error) {\n        const toReturn = error.details[0].message\n          .replace('\"firstName\"', \"First Name\")\n          .replace('\"lastName\"', \"Last Name\")\n          .replace('\"email\"', \"Email\")\n          .replace('\"password\"', \"Password\");\n        throw Error(toReturn);\n      }\n\n      const emailExists = await User.findOne({ email: args.email });\n\n      if (emailExists) throw Error(\"Email already exists\");\n\n      const salt = await bcrypt.genSalt(10);\n      const hashPassword = await bcrypt.hash(args.password, salt);\n\n      const user = new User({\n        firstName: args.firstName,\n        lastName: args.lastName,\n        email: args.email,\n        password: hashPassword,\n        isModerator: false,\n        isSubscribed: args.isSubscribed || false,\n      });\n\n      try {\n        const savedUser = await user.save();\n        return savedUser;\n      } catch (err) {\n        throw Error(err.message);\n      }\n    },\n\n    subscribe: async (parent, args, ctx) => {\n      const { authData } = ctx;\n      if (!authData) {\n        throw Error(\"Please login to proceed\");\n      }\n\n      await User.findById(authData._id, async (err, user) => {\n        if (err) {\n          throw Error(err.message);\n        } else {\n          user.isSubscribed = args.isSubscribed;\n          await user.save((error, data) => {\n            if (error) {\n              throw Error(error.message);\n            } else {\n              return data;\n            }\n          });\n        }\n      });\n    },\n  },\n};\n"]},"metadata":{},"sourceType":"module"}