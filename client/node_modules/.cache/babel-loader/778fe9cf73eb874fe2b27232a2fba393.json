{"ast":null,"code":"import React from 'react';\nvar isProduction = \"development\" === 'production';\nvar prefix = 'Invariant failed';\n\nvar index = function (condition, message) {\n  if (condition) {\n    return;\n  }\n\n  if (isProduction) {\n    throw new Error(prefix);\n  } else {\n    throw new Error(prefix + \": \" + (message || ''));\n  }\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n/*\n * Instance counter to enable unique marks for multiple Placeholder instances.\n */\n\n\nvar instanceCounter = 0;\n/**\n * A plugin that renders a React placeholder for a given Slate node.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction SlateReactPlaceholder() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var instanceId = instanceCounter++;\n  var placeholder = options.placeholder,\n      when = options.when,\n      _options$style = options.style,\n      style = _options$style === undefined ? {} : _options$style;\n  index(typeof placeholder === 'string', 'You must pass `SlateReactPlaceholder` an `options.placeholder` string.');\n  index(typeof when === 'string' || typeof when === 'function', 'You must pass `SlateReactPlaceholder` an `options.when` query.');\n  /**\n   * Decorate a match node with a placeholder mark when it fits the query.\n   *\n   * @param {Node} node\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Array}\n   */\n\n  function decorateNode(node, editor, next) {\n    if (!editor.query(when, node)) {\n      return next();\n    }\n\n    var others = next();\n\n    var _node$texts = node.texts(),\n        _node$texts2 = slicedToArray(_node$texts, 1),\n        first = _node$texts2[0];\n\n    var _node$texts3 = node.texts({\n      direction: 'backward'\n    }),\n        _node$texts4 = slicedToArray(_node$texts3, 1),\n        last = _node$texts4[0];\n\n    var _first = slicedToArray(first, 2),\n        firstNode = _first[0],\n        firstPath = _first[1];\n\n    var _last = slicedToArray(last, 2),\n        lastNode = _last[0],\n        lastPath = _last[1];\n\n    var decoration = {\n      type: 'placeholder',\n      data: {\n        key: instanceId\n      },\n      anchor: {\n        key: firstNode.key,\n        offset: 0,\n        path: firstPath\n      },\n      focus: {\n        key: lastNode.key,\n        offset: lastNode.text.length,\n        path: lastPath\n      }\n    };\n    return [].concat(toConsumableArray(others), [decoration]);\n  }\n  /**\n   * Render an inline placeholder for the placeholder mark.\n   *\n   * @param {Object} props\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Element}\n   */\n\n\n  function renderDecoration(props, editor, next) {\n    var children = props.children,\n        deco = props.decoration;\n\n    if (deco.type === 'placeholder' && deco.data.get('key') === instanceId) {\n      var placeHolderStyle = _extends({\n        pointerEvents: 'none',\n        display: 'inline-block',\n        width: '0',\n        maxWidth: '100%',\n        whiteSpace: 'nowrap',\n        opacity: '0.333',\n        verticalAlign: 'text-top'\n      }, style);\n\n      return React.createElement('span', null, React.createElement('span', {\n        contentEditable: false,\n        style: placeHolderStyle\n      }, placeholder), children);\n    }\n\n    return next();\n  }\n  /**\n   * Return the plugin.\n   *\n   * @return {Object}\n   */\n\n\n  return {\n    decorateNode: decorateNode,\n    renderDecoration: renderDecoration\n  };\n}\n\nexport default SlateReactPlaceholder;","map":{"version":3,"sources":["../../../node_modules/tiny-invariant/dist/tiny-invariant.esm.js","../src/index.js"],"names":["instanceCounter","options","instanceId","placeholder","when","style","editor","next","others","first","node","last","direction","firstNode","firstPath","lastNode","lastPath","decoration","key","offset","path","children","deco","props","placeHolderStyle","decorateNode","renderDecoration"],"mappings":"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","sourcesContent":["var isProduction = process.env.NODE_ENV === 'production';\nvar prefix = 'Invariant failed';\nvar index = (function (condition, message) {\n  if (condition) {\n    return;\n  }\n\n  if (isProduction) {\n    throw new Error(prefix);\n  } else {\n    throw new Error(prefix + \": \" + (message || ''));\n  }\n});\n\nexport default index;\n","import invariant from 'tiny-invariant'\nimport React from 'react'\n\n/*\n * Instance counter to enable unique marks for multiple Placeholder instances.\n */\n\nlet instanceCounter = 0\n\n/**\n * A plugin that renders a React placeholder for a given Slate node.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction SlateReactPlaceholder(options = {}) {\n  const instanceId = instanceCounter++\n  const { placeholder, when, style = {} } = options\n\n  invariant(\n    typeof placeholder === 'string',\n    'You must pass `SlateReactPlaceholder` an `options.placeholder` string.'\n  )\n\n  invariant(\n    typeof when === 'string' || typeof when === 'function',\n    'You must pass `SlateReactPlaceholder` an `options.when` query.'\n  )\n\n  /**\n   * Decorate a match node with a placeholder mark when it fits the query.\n   *\n   * @param {Node} node\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Array}\n   */\n\n  function decorateNode(node, editor, next) {\n    if (!editor.query(when, node)) {\n      return next()\n    }\n\n    const others = next()\n    const [first] = node.texts()\n    const [last] = node.texts({ direction: 'backward' })\n    const [firstNode, firstPath] = first\n    const [lastNode, lastPath] = last\n    const decoration = {\n      type: 'placeholder',\n      data: { key: instanceId },\n      anchor: { key: firstNode.key, offset: 0, path: firstPath },\n      focus: {\n        key: lastNode.key,\n        offset: lastNode.text.length,\n        path: lastPath,\n      },\n    }\n\n    return [...others, decoration]\n  }\n\n  /**\n   * Render an inline placeholder for the placeholder mark.\n   *\n   * @param {Object} props\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Element}\n   */\n\n  function renderDecoration(props, editor, next) {\n    const { children, decoration: deco } = props\n\n    if (deco.type === 'placeholder' && deco.data.get('key') === instanceId) {\n      const placeHolderStyle = {\n        pointerEvents: 'none',\n        display: 'inline-block',\n        width: '0',\n        maxWidth: '100%',\n        whiteSpace: 'nowrap',\n        opacity: '0.333',\n        verticalAlign: 'text-top',\n        ...style,\n      }\n\n      return (\n        <span>\n          <span contentEditable={false} style={placeHolderStyle}>\n            {placeholder}\n          </span>\n          {children}\n        </span>\n      )\n    }\n\n    return next()\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @return {Object}\n   */\n\n  return { decorateNode, renderDecoration }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default SlateReactPlaceholder\n"]},"metadata":{},"sourceType":"module"}