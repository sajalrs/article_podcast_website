{"ast":null,"code":"import isPlainObject from 'is-plain-object';\nimport { createDraft, finishDraft, isDraft, produce } from 'immer';\nimport { reverse } from 'esrever';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nvar DIRTY_PATHS = new WeakMap();\nvar FLUSHING = new WeakMap();\nvar NORMALIZING = new WeakMap();\nvar PATH_REFS = new WeakMap();\nvar POINT_REFS = new WeakMap();\nvar RANGE_REFS = new WeakMap();\n/**\r\n * Constants for string distance checking.\r\n */\n\nvar SPACE = /\\s/;\nvar PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\nvar CHAMELEON = /['\\u2018\\u2019]/;\nvar SURROGATE_START = 0xd800;\nvar SURROGATE_END = 0xdfff;\nvar ZERO_WIDTH_JOINER = 0x200d;\n/**\r\n * Get the distance to the end of the first character in a string of text.\r\n */\n\nvar getCharacterDistance = text => {\n  var offset = 0; // prev types:\n  // SURR: surrogate pair\n  // MOD: modifier (technically also surrogate pair)\n  // ZWJ: zero width joiner\n  // VAR: variation selector\n  // BMP: sequenceable character from basic multilingual plane\n\n  var prev = null;\n  var charCode = text.charCodeAt(0);\n\n  while (charCode) {\n    if (isSurrogate(charCode)) {\n      var modifier = isModifier(charCode, text, offset); // Early returns are the heart of this function, where we decide if previous and current\n      // codepoints should form a single character (in terms of how many of them should selection\n      // jump over).\n\n      if (prev === 'SURR' || prev === 'BMP') {\n        break;\n      }\n\n      offset += 2;\n      prev = modifier ? 'MOD' : 'SURR';\n      charCode = text.charCodeAt(offset); // Absolutely fine to `continue` without any checks because if `charCode` is NaN (which\n      // is the case when out of `text` range), next `while` loop won\"t execute and we\"re done.\n\n      continue;\n    }\n\n    if (charCode === ZERO_WIDTH_JOINER) {\n      offset += 1;\n      prev = 'ZWJ';\n      charCode = text.charCodeAt(offset);\n      continue;\n    }\n\n    if (isBMPEmoji(charCode)) {\n      if (prev && prev !== 'ZWJ' && prev !== 'VAR') {\n        break;\n      }\n\n      offset += 1;\n      prev = 'BMP';\n      charCode = text.charCodeAt(offset);\n      continue;\n    }\n\n    if (isVariationSelector(charCode)) {\n      if (prev && prev !== 'ZWJ') {\n        break;\n      }\n\n      offset += 1;\n      prev = 'VAR';\n      charCode = text.charCodeAt(offset);\n      continue;\n    } // Modifier 'groups up' with what ever character is before that (even whitespace), need to\n    // look ahead.\n\n\n    if (prev === 'MOD') {\n      offset += 1;\n      break;\n    } // If while loop ever gets here, we're done (e.g latin chars).\n\n\n    break;\n  }\n\n  return offset || 1;\n};\n/**\r\n * Get the distance to the end of the first word in a string of text.\r\n */\n\n\nvar getWordDistance = text => {\n  var length = 0;\n  var i = 0;\n  var started = false;\n  var char;\n\n  while (char = text.charAt(i)) {\n    var l = getCharacterDistance(char);\n    char = text.slice(i, i + l);\n    var rest = text.slice(i + l);\n\n    if (isWordCharacter(char, rest)) {\n      started = true;\n      length += l;\n    } else if (!started) {\n      length += l;\n    } else {\n      break;\n    }\n\n    i += l;\n  }\n\n  return length;\n};\n/**\r\n * Check if a character is a word character. The `remaining` argument is used\r\n * because sometimes you must read subsequent characters to truly determine it.\r\n */\n\n\nvar isWordCharacter = (char, remaining) => {\n  if (SPACE.test(char)) {\n    return false;\n  } // Chameleons count as word characters as long as they're in a word, so\n  // recurse to see if the next one is a word character or not.\n\n\n  if (CHAMELEON.test(char)) {\n    var next = remaining.charAt(0);\n    var length = getCharacterDistance(next);\n    next = remaining.slice(0, length);\n    var rest = remaining.slice(length);\n\n    if (isWordCharacter(next, rest)) {\n      return true;\n    }\n  }\n\n  if (PUNCTUATION.test(char)) {\n    return false;\n  }\n\n  return true;\n};\n/**\r\n * Determines if `code` is a surrogate\r\n */\n\n\nvar isSurrogate = code => SURROGATE_START <= code && code <= SURROGATE_END;\n/**\r\n * Does `code` form Modifier with next one.\r\n *\r\n * https://emojipedia.org/modifiers/\r\n */\n\n\nvar isModifier = (code, text, offset) => {\n  if (code === 0xd83c) {\n    var next = text.charCodeAt(offset + 1);\n    return next <= 0xdfff && next >= 0xdffb;\n  }\n\n  return false;\n};\n/**\r\n * Is `code` a Variation Selector.\r\n *\r\n * https://codepoints.net/variation_selectors\r\n */\n\n\nvar isVariationSelector = code => {\n  return code <= 0xfe0f && code >= 0xfe00;\n};\n/**\r\n * Is `code` one of the BMP codes used in emoji sequences.\r\n *\r\n * https://emojipedia.org/emoji-zwj-sequences/\r\n */\n\n\nvar isBMPEmoji = code => {\n  // This requires tiny bit of maintanance, better ideas?\n  // Fortunately it only happens if new Unicode Standard\n  // is released. Fails gracefully if upkeep lags behind,\n  // same way Slate previously behaved with all emojis.\n  return code === 0x2764 || // heart (❤)\n  code === 0x2642 || // male (♂)\n  code === 0x2640 || // female (♀)\n  code === 0x2620 || // scull (☠)\n  code === 0x2695 || // medical (⚕)\n  code === 0x2708 || // plane (✈️)\n  code === 0x25ef // large circle (◯)\n  ;\n};\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar Editor = {\n  /**\r\n   * Get the ancestor above a location in the document.\r\n   */\n  above(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      voids = false,\n      mode = 'lowest',\n      at = editor.selection,\n      match\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    var path = Editor.path(editor, at);\n    var reverse = mode === 'lowest';\n\n    for (var [n, p] of Editor.levels(editor, {\n      at: path,\n      voids,\n      match,\n      reverse\n    })) {\n      if (!Text.isText(n) && !Path.equals(path, p)) {\n        return [n, p];\n      }\n    }\n  },\n\n  /**\r\n   * Add a custom property to the leaf text nodes in the current selection.\r\n   *\r\n   * If the selection is currently collapsed, the marks will be added to the\r\n   * `editor.marks` property instead, and applied when text is inserted next.\r\n   */\n  addMark(editor, key, value) {\n    editor.addMark(key, value);\n  },\n\n  /**\r\n   * Get the point after a location.\r\n   */\n  after(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var anchor = Editor.point(editor, at, {\n      edge: 'end'\n    });\n    var focus = Editor.end(editor, []);\n    var range = {\n      anchor,\n      focus\n    };\n    var {\n      distance = 1\n    } = options;\n    var d = 0;\n    var target;\n\n    for (var p of Editor.positions(editor, _objectSpread({}, options, {\n      at: range\n    }))) {\n      if (d > distance) {\n        break;\n      }\n\n      if (d !== 0) {\n        target = p;\n      }\n\n      d++;\n    }\n\n    return target;\n  },\n\n  /**\r\n   * Get the point before a location.\r\n   */\n  before(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var anchor = Editor.start(editor, []);\n    var focus = Editor.point(editor, at, {\n      edge: 'start'\n    });\n    var range = {\n      anchor,\n      focus\n    };\n    var {\n      distance = 1\n    } = options;\n    var d = 0;\n    var target;\n\n    for (var p of Editor.positions(editor, _objectSpread({}, options, {\n      at: range,\n      reverse: true\n    }))) {\n      if (d > distance) {\n        break;\n      }\n\n      if (d !== 0) {\n        target = p;\n      }\n\n      d++;\n    }\n\n    return target;\n  },\n\n  /**\r\n   * Delete content in the editor backward from the current selection.\r\n   */\n  deleteBackward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      unit = 'character'\n    } = options;\n    editor.deleteBackward(unit);\n  },\n\n  /**\r\n   * Delete content in the editor forward from the current selection.\r\n   */\n  deleteForward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      unit = 'character'\n    } = options;\n    editor.deleteForward(unit);\n  },\n\n  /**\r\n   * Delete the content in the current selection.\r\n   */\n  deleteFragment(editor) {\n    editor.deleteFragment();\n  },\n\n  /**\r\n   * Get the start and end points of a location.\r\n   */\n  edges(editor, at) {\n    return [Editor.start(editor, at), Editor.end(editor, at)];\n  },\n\n  /**\r\n   * Get the end point of a location.\r\n   */\n  end(editor, at) {\n    return Editor.point(editor, at, {\n      edge: 'end'\n    });\n  },\n\n  /**\r\n   * Get the first node at a location.\r\n   */\n  first(editor, at) {\n    var path = Editor.path(editor, at, {\n      edge: 'start'\n    });\n    return Editor.node(editor, path);\n  },\n\n  /**\r\n   * Get the fragment at a location.\r\n   */\n  fragment(editor, at) {\n    var range = Editor.range(editor, at);\n    var fragment = Node.fragment(editor, range);\n    return fragment;\n  },\n\n  /**\r\n   * Check if a node has block children.\r\n   */\n  hasBlocks(editor, element) {\n    return element.children.some(n => Editor.isBlock(editor, n));\n  },\n\n  /**\r\n   * Check if a node has inline and text children.\r\n   */\n  hasInlines(editor, element) {\n    return element.children.some(n => Text.isText(n) || Editor.isInline(editor, n));\n  },\n\n  /**\r\n   * Check if a node has text children.\r\n   */\n  hasTexts(editor, element) {\n    return element.children.every(n => Text.isText(n));\n  },\n\n  /**\r\n   * Insert a block break at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertBreak(editor) {\n    editor.insertBreak();\n  },\n\n  /**\r\n   * Insert a fragment at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertFragment(editor, fragment) {\n    editor.insertFragment(fragment);\n  },\n\n  /**\r\n   * Insert a node at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertNode(editor, node) {\n    editor.insertNode(node);\n  },\n\n  /**\r\n   * Insert text at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertText(editor, text) {\n    editor.insertText(text);\n  },\n\n  /**\r\n   * Check if a value is a block `Element` object.\r\n   */\n  isBlock(editor, value) {\n    return Element.isElement(value) && !editor.isInline(value);\n  },\n\n  /**\r\n   * Check if a value is an `Editor` object.\r\n   */\n  isEditor(value) {\n    return isPlainObject(value) && typeof value.addMark === 'function' && typeof value.apply === 'function' && typeof value.deleteBackward === 'function' && typeof value.deleteForward === 'function' && typeof value.deleteFragment === 'function' && typeof value.insertBreak === 'function' && typeof value.insertFragment === 'function' && typeof value.insertNode === 'function' && typeof value.insertText === 'function' && typeof value.isInline === 'function' && typeof value.isVoid === 'function' && typeof value.normalizeNode === 'function' && typeof value.onChange === 'function' && typeof value.removeMark === 'function' && (value.marks === null || isPlainObject(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node.isNodeList(value.children) && Operation.isOperationList(value.operations);\n  },\n\n  /**\r\n   * Check if a point is the end point of a location.\r\n   */\n  isEnd(editor, point, at) {\n    var end = Editor.end(editor, at);\n    return Point.equals(point, end);\n  },\n\n  /**\r\n   * Check if a point is an edge of a location.\r\n   */\n  isEdge(editor, point, at) {\n    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);\n  },\n\n  /**\r\n   * Check if an element is empty, accounting for void nodes.\r\n   */\n  isEmpty(editor, element) {\n    var {\n      children\n    } = element;\n    var [first] = children;\n    return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === '' && !editor.isVoid(element);\n  },\n\n  /**\r\n   * Check if a value is an inline `Element` object.\r\n   */\n  isInline(editor, value) {\n    return Element.isElement(value) && editor.isInline(value);\n  },\n\n  /**\r\n   * Check if the editor is currently normalizing after each operation.\r\n   */\n  isNormalizing(editor) {\n    var isNormalizing = NORMALIZING.get(editor);\n    return isNormalizing === undefined ? true : isNormalizing;\n  },\n\n  /**\r\n   * Check if a point is the start point of a location.\r\n   */\n  isStart(editor, point, at) {\n    // PERF: If the offset isn't `0` we know it's not the start.\n    if (point.offset !== 0) {\n      return false;\n    }\n\n    var start = Editor.start(editor, at);\n    return Point.equals(point, start);\n  },\n\n  /**\r\n   * Check if a value is a void `Element` object.\r\n   */\n  isVoid(editor, value) {\n    return Element.isElement(value) && editor.isVoid(value);\n  },\n\n  /**\r\n   * Get the last node at a location.\r\n   */\n  last(editor, at) {\n    var path = Editor.path(editor, at, {\n      edge: 'end'\n    });\n    return Editor.node(editor, path);\n  },\n\n  /**\r\n   * Get the leaf text node at a location.\r\n   */\n  leaf(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node.leaf(editor, path);\n    return [node, path];\n  },\n\n  /**\r\n   * Iterate through all of the levels at a location.\r\n   */\n  *levels(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      at = editor.selection,\n      reverse = false,\n      voids = false\n    } = options;\n    var {\n      match\n    } = options;\n\n    if (match == null) {\n      match = () => true;\n    }\n\n    if (!at) {\n      return;\n    }\n\n    var levels = [];\n    var path = Editor.path(editor, at);\n\n    for (var [n, p] of Node.levels(editor, path)) {\n      if (!match(n)) {\n        continue;\n      }\n\n      levels.push([n, p]);\n\n      if (!voids && Editor.isVoid(editor, n)) {\n        break;\n      }\n    }\n\n    if (reverse) {\n      levels.reverse();\n    }\n\n    yield* levels;\n  },\n\n  /**\r\n   * Get the marks that would be added to text at the current selection.\r\n   */\n  marks(editor) {\n    var {\n      marks,\n      selection\n    } = editor;\n\n    if (!selection) {\n      return null;\n    }\n\n    if (marks) {\n      return marks;\n    }\n\n    if (Range.isExpanded(selection)) {\n      var [match] = Editor.nodes(editor, {\n        match: Text.isText\n      });\n\n      if (match) {\n        var [_node] = match;\n\n        var _rest = _objectWithoutProperties(_node, [\"text\"]);\n\n        return _rest;\n      } else {\n        return {};\n      }\n    }\n\n    var {\n      anchor\n    } = selection;\n    var {\n      path\n    } = anchor;\n    var [node] = Editor.leaf(editor, path);\n\n    if (anchor.offset === 0) {\n      var prev = Editor.previous(editor, {\n        at: path,\n        match: Text.isText\n      });\n      var block = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n)\n      });\n\n      if (prev && block) {\n        var [prevNode, prevPath] = prev;\n        var [, blockPath] = block;\n\n        if (Path.isAncestor(blockPath, prevPath)) {\n          node = prevNode;\n        }\n      }\n    }\n\n    var rest = _objectWithoutProperties(node, [\"text\"]);\n\n    return rest;\n  },\n\n  /**\r\n   * Get the matching node in the branch of the document after a location.\r\n   */\n  next(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      mode = 'lowest',\n      voids = false\n    } = options;\n    var {\n      match,\n      at = editor.selection\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    var [, from] = Editor.last(editor, at);\n    var [, to] = Editor.last(editor, []);\n    var span = [from, to];\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(\"Cannot get the next node from the root node!\");\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        var [parent] = Editor.parent(editor, at);\n\n        match = n => parent.children.includes(n);\n      } else {\n        match = () => true;\n      }\n    }\n\n    var [, next] = Editor.nodes(editor, {\n      at: span,\n      match,\n      mode,\n      voids\n    });\n    return next;\n  },\n\n  /**\r\n   * Get the node at a location.\r\n   */\n  node(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node.get(editor, path);\n    return [node, path];\n  },\n\n  /**\r\n   * Iterate through all of the nodes in the Editor.\r\n   */\n  *nodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      at = editor.selection,\n      mode = 'all',\n      universal = false,\n      reverse = false,\n      voids = false\n    } = options;\n    var {\n      match\n    } = options;\n\n    if (!match) {\n      match = () => true;\n    }\n\n    if (!at) {\n      return;\n    }\n\n    var from;\n    var to;\n\n    if (Span.isSpan(at)) {\n      from = at[0];\n      to = at[1];\n    } else {\n      var first = Editor.path(editor, at, {\n        edge: 'start'\n      });\n      var last = Editor.path(editor, at, {\n        edge: 'end'\n      });\n      from = reverse ? last : first;\n      to = reverse ? first : last;\n    }\n\n    var iterable = Node.nodes(editor, {\n      reverse,\n      from,\n      to,\n      pass: _ref => {\n        var [n] = _ref;\n        return voids ? false : Editor.isVoid(editor, n);\n      }\n    });\n    var matches = [];\n    var hit;\n\n    for (var [node, path] of iterable) {\n      var isLower = hit && Path.compare(path, hit[1]) === 0; // In highest mode any node lower than the last hit is not a match.\n\n      if (mode === 'highest' && isLower) {\n        continue;\n      }\n\n      if (!match(node)) {\n        // If we've arrived at a leaf text node that is not lower than the last\n        // hit, then we've found a branch that doesn't include a match, which\n        // means the match is not universal.\n        if (universal && !isLower && Text.isText(node)) {\n          return;\n        } else {\n          continue;\n        }\n      } // If there's a match and it's lower than the last, update the hit.\n\n\n      if (mode === 'lowest' && isLower) {\n        hit = [node, path];\n        continue;\n      } // In lowest mode we emit the last hit, once it's guaranteed lowest.\n\n\n      var emit = mode === 'lowest' ? hit : [node, path];\n\n      if (emit) {\n        if (universal) {\n          matches.push(emit);\n        } else {\n          yield emit;\n        }\n      }\n\n      hit = [node, path];\n    } // Since lowest is always emitting one behind, catch up at the end.\n\n\n    if (mode === 'lowest' && hit) {\n      if (universal) {\n        matches.push(hit);\n      } else {\n        yield hit;\n      }\n    } // Universal defers to ensure that the match occurs in every branch, so we\n    // yield all of the matches after iterating.\n\n\n    if (universal) {\n      yield* matches;\n    }\n  },\n\n  /**\r\n   * Normalize any dirty objects in the editor.\r\n   */\n  normalize(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      force = false\n    } = options;\n\n    var getDirtyPaths = editor => {\n      return DIRTY_PATHS.get(editor) || [];\n    };\n\n    if (!Editor.isNormalizing(editor)) {\n      return;\n    }\n\n    if (force) {\n      var allPaths = Array.from(Node.nodes(editor), _ref2 => {\n        var [, p] = _ref2;\n        return p;\n      });\n      DIRTY_PATHS.set(editor, allPaths);\n    }\n\n    if (getDirtyPaths(editor).length === 0) {\n      return;\n    }\n\n    Editor.withoutNormalizing(editor, () => {\n      var max = getDirtyPaths(editor).length * 42; // HACK: better way?\n\n      var m = 0;\n\n      while (getDirtyPaths(editor).length !== 0) {\n        if (m > max) {\n          throw new Error(\"\\n            Could not completely normalize the editor after \".concat(max, \" iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\\n          \"));\n        }\n\n        var path = getDirtyPaths(editor).pop();\n        var entry = Editor.node(editor, path);\n        editor.normalizeNode(entry);\n        m++;\n      }\n    });\n  },\n\n  /**\r\n   * Get the parent node of a location.\r\n   */\n  parent(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var parentPath = Path.parent(path);\n    var entry = Editor.node(editor, parentPath);\n    return entry;\n  },\n\n  /**\r\n   * Get the path of a location.\r\n   */\n  path(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      depth,\n      edge\n    } = options;\n\n    if (Path.isPath(at)) {\n      if (edge === 'start') {\n        var [, firstPath] = Node.first(editor, at);\n        at = firstPath;\n      } else if (edge === 'end') {\n        var [, lastPath] = Node.last(editor, at);\n        at = lastPath;\n      }\n    }\n\n    if (Range.isRange(at)) {\n      if (edge === 'start') {\n        at = Range.start(at);\n      } else if (edge === 'end') {\n        at = Range.end(at);\n      } else {\n        at = Path.common(at.anchor.path, at.focus.path);\n      }\n    }\n\n    if (Point.isPoint(at)) {\n      at = at.path;\n    }\n\n    if (depth != null) {\n      at = at.slice(0, depth);\n    }\n\n    return at;\n  },\n\n  /**\r\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  pathRef(editor, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      affinity = 'forward'\n    } = options;\n    var ref = {\n      current: path,\n      affinity,\n\n      unref() {\n        var {\n          current\n        } = ref;\n        var pathRefs = Editor.pathRefs(editor);\n        pathRefs.delete(ref);\n        ref.current = null;\n        return current;\n      }\n\n    };\n    var refs = Editor.pathRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked path refs of the editor.\r\n   */\n  pathRefs(editor) {\n    var refs = PATH_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      PATH_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Get the start or end point of a location.\r\n   */\n  point(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      edge = 'start'\n    } = options;\n\n    if (Path.isPath(at)) {\n      var path;\n\n      if (edge === 'end') {\n        var [, lastPath] = Node.last(editor, at);\n        path = lastPath;\n      } else {\n        var [, firstPath] = Node.first(editor, at);\n        path = firstPath;\n      }\n\n      var node = Node.get(editor, path);\n\n      if (!Text.isText(node)) {\n        throw new Error(\"Cannot get the \".concat(edge, \" point in the node at path [\").concat(at, \"] because it has no \").concat(edge, \" text node.\"));\n      }\n\n      return {\n        path,\n        offset: edge === 'end' ? node.text.length : 0\n      };\n    }\n\n    if (Range.isRange(at)) {\n      var [start, end] = Range.edges(at);\n      return edge === 'start' ? start : end;\n    }\n\n    return at;\n  },\n\n  /**\r\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  pointRef(editor, point) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      affinity = 'forward'\n    } = options;\n    var ref = {\n      current: point,\n      affinity,\n\n      unref() {\n        var {\n          current\n        } = ref;\n        var pointRefs = Editor.pointRefs(editor);\n        pointRefs.delete(ref);\n        ref.current = null;\n        return current;\n      }\n\n    };\n    var refs = Editor.pointRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked point refs of the editor.\r\n   */\n  pointRefs(editor) {\n    var refs = POINT_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      POINT_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Iterate through all of the positions in the document where a `Point` can be\r\n   * placed.\r\n   *\r\n   * By default it will move forward by individual offsets at a time,  but you\r\n   * can pass the `unit: 'character'` option to moved forward one character, word,\r\n   * or line at at time.\r\n   *\r\n   * Note: void nodes are treated as a single point, and iteration will not\r\n   * happen inside their content.\r\n   */\n  *positions(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      at = editor.selection,\n      unit = 'offset',\n      reverse: reverse$1 = false\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    var range = Editor.range(editor, at);\n    var [start, end] = Range.edges(range);\n    var first = reverse$1 ? end : start;\n    var string = '';\n    var available = 0;\n    var offset = 0;\n    var distance = null;\n    var isNewBlock = false;\n\n    var advance = () => {\n      if (distance == null) {\n        if (unit === 'character') {\n          distance = getCharacterDistance(string);\n        } else if (unit === 'word') {\n          distance = getWordDistance(string);\n        } else if (unit === 'line' || unit === 'block') {\n          distance = string.length;\n        } else {\n          distance = 1;\n        }\n\n        string = string.slice(distance);\n      } // Add or substract the offset.\n\n\n      offset = reverse$1 ? offset - distance : offset + distance; // Subtract the distance traveled from the available text.\n\n      available = available - distance; // If the available had room to spare, reset the distance so that it will\n      // advance again next time. Otherwise, set it to the overflow amount.\n\n      distance = available >= 0 ? null : 0 - available;\n    };\n\n    for (var [node, path] of Editor.nodes(editor, {\n      at,\n      reverse: reverse$1\n    })) {\n      if (Element.isElement(node)) {\n        // Void nodes are a special case, since we don't want to iterate over\n        // their content. We instead always just yield their first point.\n        if (editor.isVoid(node)) {\n          yield Editor.start(editor, path);\n          continue;\n        }\n\n        if (editor.isInline(node)) {\n          continue;\n        }\n\n        if (Editor.hasInlines(editor, node)) {\n          var e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);\n          var s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);\n          var text = Editor.string(editor, {\n            anchor: s,\n            focus: e\n          });\n          string = reverse$1 ? reverse(text) : text;\n          isNewBlock = true;\n        }\n      }\n\n      if (Text.isText(node)) {\n        var isFirst = Path.equals(path, first.path);\n        available = node.text.length;\n        offset = reverse$1 ? available : 0;\n\n        if (isFirst) {\n          available = reverse$1 ? first.offset : available - first.offset;\n          offset = first.offset;\n        }\n\n        if (isFirst || isNewBlock || unit === 'offset') {\n          yield {\n            path,\n            offset\n          };\n        }\n\n        while (true) {\n          // If there's no more string, continue to the next block.\n          if (string === '') {\n            break;\n          } else {\n            advance();\n          } // If the available space hasn't overflow, we have another point to\n          // yield in the current text node.\n\n\n          if (available >= 0) {\n            yield {\n              path,\n              offset\n            };\n          } else {\n            break;\n          }\n        }\n\n        isNewBlock = false;\n      }\n    }\n  },\n\n  /**\r\n   * Get the matching node in the branch of the document before a location.\r\n   */\n  previous(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      mode = 'lowest',\n      voids = false\n    } = options;\n    var {\n      match,\n      at = editor.selection\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    var [, from] = Editor.first(editor, at);\n    var [, to] = Editor.first(editor, []);\n    var span = [from, to];\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(\"Cannot get the previous node from the root node!\");\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        var [parent] = Editor.parent(editor, at);\n\n        match = n => parent.children.includes(n);\n      } else {\n        match = () => true;\n      }\n    }\n\n    var [, previous] = Editor.nodes(editor, {\n      reverse: true,\n      at: span,\n      match,\n      mode,\n      voids\n    });\n    return previous;\n  },\n\n  /**\r\n   * Get a range of a location.\r\n   */\n  range(editor, at, to) {\n    if (Range.isRange(at) && !to) {\n      return at;\n    }\n\n    var start = Editor.start(editor, at);\n    var end = Editor.end(editor, to || at);\n    return {\n      anchor: start,\n      focus: end\n    };\n  },\n\n  /**\r\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  rangeRef(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      affinity = 'forward'\n    } = options;\n    var ref = {\n      current: range,\n      affinity,\n\n      unref() {\n        var {\n          current\n        } = ref;\n        var rangeRefs = Editor.rangeRefs(editor);\n        rangeRefs.delete(ref);\n        ref.current = null;\n        return current;\n      }\n\n    };\n    var refs = Editor.rangeRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked range refs of the editor.\r\n   */\n  rangeRefs(editor) {\n    var refs = RANGE_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      RANGE_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Remove a custom property from all of the leaf text nodes in the current\r\n   * selection.\r\n   *\r\n   * If the selection is currently collapsed, the removal will be stored on\r\n   * `editor.marks` and applied to the text inserted next.\r\n   */\n  removeMark(editor, key) {\n    editor.removeMark(key);\n  },\n\n  /**\r\n   * Get the start point of a location.\r\n   */\n  start(editor, at) {\n    return Editor.point(editor, at, {\n      edge: 'start'\n    });\n  },\n\n  /**\r\n   * Get the text string content of a location.\r\n   *\r\n   * Note: the text of void nodes is presumed to be an empty string, regardless\r\n   * of what their actual content is.\r\n   */\n  string(editor, at) {\n    var range = Editor.range(editor, at);\n    var [start, end] = Range.edges(range);\n    var text = '';\n\n    for (var [node, path] of Editor.nodes(editor, {\n      at: range,\n      match: Text.isText\n    })) {\n      var t = node.text;\n\n      if (Path.equals(path, end.path)) {\n        t = t.slice(0, end.offset);\n      }\n\n      if (Path.equals(path, start.path)) {\n        t = t.slice(start.offset);\n      }\n\n      text += t;\n    }\n\n    return text;\n  },\n\n  /**\r\n   * Transform the editor by an operation.\r\n   */\n  transform(editor, op) {\n    editor.children = createDraft(editor.children);\n    var selection = editor.selection && createDraft(editor.selection);\n\n    switch (op.type) {\n      case 'insert_node':\n        {\n          var {\n            path,\n            node\n          } = op;\n          var parent = Node.parent(editor, path);\n          var index = path[path.length - 1];\n          parent.children.splice(index, 0, node);\n\n          if (selection) {\n            for (var [point, key] of Range.points(selection)) {\n              selection[key] = Point.transform(point, op);\n            }\n          }\n\n          break;\n        }\n\n      case 'insert_text':\n        {\n          var {\n            path: _path,\n            offset,\n            text\n          } = op;\n\n          var _node2 = Node.leaf(editor, _path);\n\n          var before = _node2.text.slice(0, offset);\n\n          var after = _node2.text.slice(offset);\n\n          _node2.text = before + text + after;\n\n          if (selection) {\n            for (var [_point, _key] of Range.points(selection)) {\n              selection[_key] = Point.transform(_point, op);\n            }\n          }\n\n          break;\n        }\n\n      case 'merge_node':\n        {\n          var {\n            path: _path2\n          } = op;\n\n          var _node3 = Node.get(editor, _path2);\n\n          var prevPath = Path.previous(_path2);\n          var prev = Node.get(editor, prevPath);\n\n          var _parent = Node.parent(editor, _path2);\n\n          var _index = _path2[_path2.length - 1];\n\n          if (Text.isText(_node3) && Text.isText(prev)) {\n            prev.text += _node3.text;\n          } else if (!Text.isText(_node3) && !Text.isText(prev)) {\n            prev.children.push(..._node3.children);\n          } else {\n            throw new Error(\"Cannot apply a \\\"merge_node\\\" operation at path [\".concat(_path2, \"] to nodes of different interaces: \").concat(_node3, \" \").concat(prev));\n          }\n\n          _parent.children.splice(_index, 1);\n\n          if (selection) {\n            for (var [_point2, _key2] of Range.points(selection)) {\n              selection[_key2] = Point.transform(_point2, op);\n            }\n          }\n\n          break;\n        }\n\n      case 'move_node':\n        {\n          var {\n            path: _path3,\n            newPath\n          } = op;\n\n          if (Path.isAncestor(_path3, newPath)) {\n            throw new Error(\"Cannot move a path [\".concat(_path3, \"] to new path [\").concat(newPath, \"] because the destination is inside itself.\"));\n          }\n\n          var _node4 = Node.get(editor, _path3);\n\n          var _parent2 = Node.parent(editor, _path3);\n\n          var _index2 = _path3[_path3.length - 1]; // This is tricky, but since the `path` and `newPath` both refer to\n          // the same snapshot in time, there's a mismatch. After either\n          // removing the original position, the second step's path can be out\n          // of date. So instead of using the `op.newPath` directly, we\n          // transform `op.path` to ascertain what the `newPath` would be after\n          // the operation was applied.\n\n          _parent2.children.splice(_index2, 1);\n\n          var truePath = Path.transform(_path3, op);\n          var newParent = Node.get(editor, Path.parent(truePath));\n          var newIndex = truePath[truePath.length - 1];\n          newParent.children.splice(newIndex, 0, _node4);\n\n          if (selection) {\n            for (var [_point3, _key3] of Range.points(selection)) {\n              selection[_key3] = Point.transform(_point3, op);\n            }\n          }\n\n          break;\n        }\n\n      case 'remove_node':\n        {\n          var {\n            path: _path4\n          } = op;\n          var _index3 = _path4[_path4.length - 1];\n\n          var _parent3 = Node.parent(editor, _path4);\n\n          _parent3.children.splice(_index3, 1); // Transform all of the points in the value, but if the point was in the\n          // node that was removed we need to update the range or remove it.\n\n\n          if (selection) {\n            for (var [_point4, _key4] of Range.points(selection)) {\n              var result = Point.transform(_point4, op);\n\n              if (selection != null && result != null) {\n                selection[_key4] = result;\n              } else {\n                var _prev = void 0;\n\n                var next = void 0;\n\n                for (var [n, p] of Node.texts(editor)) {\n                  if (Path.compare(p, _path4) === -1) {\n                    _prev = [n, p];\n                  } else {\n                    next = [n, p];\n                    break;\n                  }\n                }\n\n                if (_prev) {\n                  _point4.path = _prev[1];\n                  _point4.offset = _prev[0].text.length;\n                } else if (next) {\n                  _point4.path = next[1];\n                  _point4.offset = 0;\n                } else {\n                  selection = null;\n                }\n              }\n            }\n          }\n\n          break;\n        }\n\n      case 'remove_text':\n        {\n          var {\n            path: _path5,\n            offset: _offset,\n            text: _text2\n          } = op;\n\n          var _node5 = Node.leaf(editor, _path5);\n\n          var _before = _node5.text.slice(0, _offset);\n\n          var _after = _node5.text.slice(_offset + _text2.length);\n\n          _node5.text = _before + _after;\n\n          if (selection) {\n            for (var [_point5, _key5] of Range.points(selection)) {\n              selection[_key5] = Point.transform(_point5, op);\n            }\n          }\n\n          break;\n        }\n\n      case 'set_node':\n        {\n          var {\n            path: _path6,\n            newProperties\n          } = op;\n\n          if (_path6.length === 0) {\n            throw new Error(\"Cannot set properties on the root node!\");\n          }\n\n          var _node6 = Node.get(editor, _path6);\n\n          for (var _key6 in newProperties) {\n            if (_key6 === 'children' || _key6 === 'text') {\n              throw new Error(\"Cannot set the \\\"\".concat(_key6, \"\\\" property of nodes!\"));\n            }\n\n            var value = newProperties[_key6];\n\n            if (value == null) {\n              delete _node6[_key6];\n            } else {\n              _node6[_key6] = value;\n            }\n          }\n\n          break;\n        }\n\n      case 'set_selection':\n        {\n          var {\n            newProperties: _newProperties\n          } = op;\n\n          if (_newProperties == null) {\n            selection = _newProperties;\n          } else if (selection == null) {\n            if (!Range.isRange(_newProperties)) {\n              throw new Error(\"Cannot apply an incomplete \\\"set_selection\\\" operation properties \".concat(JSON.stringify(_newProperties), \" when there is no current selection.\"));\n            }\n\n            selection = _newProperties;\n          } else {\n            Object.assign(selection, _newProperties);\n          }\n\n          break;\n        }\n\n      case 'split_node':\n        {\n          var {\n            path: _path7,\n            position,\n            properties\n          } = op;\n\n          if (_path7.length === 0) {\n            throw new Error(\"Cannot apply a \\\"split_node\\\" operation at path [\".concat(_path7, \"] because the root node cannot be split.\"));\n          }\n\n          var _node7 = Node.get(editor, _path7);\n\n          var _parent4 = Node.parent(editor, _path7);\n\n          var _index4 = _path7[_path7.length - 1];\n          var newNode;\n\n          if (Text.isText(_node7)) {\n            var _before2 = _node7.text.slice(0, position);\n\n            var _after2 = _node7.text.slice(position);\n\n            _node7.text = _before2;\n            newNode = _objectSpread({}, _node7, {}, properties, {\n              text: _after2\n            });\n          } else {\n            var _before3 = _node7.children.slice(0, position);\n\n            var _after3 = _node7.children.slice(position);\n\n            _node7.children = _before3;\n            newNode = _objectSpread({}, _node7, {}, properties, {\n              children: _after3\n            });\n          }\n\n          _parent4.children.splice(_index4 + 1, 0, newNode);\n\n          if (selection) {\n            for (var [_point6, _key7] of Range.points(selection)) {\n              selection[_key7] = Point.transform(_point6, op);\n            }\n          }\n\n          break;\n        }\n    }\n\n    editor.children = finishDraft(editor.children);\n\n    if (selection) {\n      editor.selection = isDraft(selection) ? finishDraft(selection) : selection;\n    } else {\n      editor.selection = null;\n    }\n  },\n\n  /**\r\n   * Convert a range into a non-hanging one.\r\n   */\n  unhangRange(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      voids = false\n    } = options;\n    var [start, end] = Range.edges(range); // PERF: exit early if we can guarantee that the range isn't hanging.\n\n    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range)) {\n      return range;\n    }\n\n    var endBlock = Editor.above(editor, {\n      at: end,\n      match: n => Editor.isBlock(editor, n)\n    });\n    var blockPath = endBlock ? endBlock[1] : [];\n    var first = Editor.start(editor, []);\n    var before = {\n      anchor: first,\n      focus: end\n    };\n    var skip = true;\n\n    for (var [node, path] of Editor.nodes(editor, {\n      at: before,\n      match: Text.isText,\n      reverse: true,\n      voids\n    })) {\n      if (skip) {\n        skip = false;\n        continue;\n      }\n\n      if (node.text !== '' || Path.isBefore(path, blockPath)) {\n        end = {\n          path,\n          offset: node.text.length\n        };\n        break;\n      }\n    }\n\n    return {\n      anchor: start,\n      focus: end\n    };\n  },\n\n  /**\r\n   * Match a void node in the current branch of the editor.\r\n   */\n  void(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return Editor.above(editor, _objectSpread({}, options, {\n      match: n => Editor.isVoid(editor, n)\n    }));\n  },\n\n  /**\r\n   * Call a function, deferring normalization until after it completes.\r\n   */\n  withoutNormalizing(editor, fn) {\n    var value = Editor.isNormalizing(editor);\n    NORMALIZING.set(editor, false);\n    fn();\n    NORMALIZING.set(editor, value);\n    Editor.normalize(editor);\n  }\n\n};\nvar Element = {\n  /**\r\n   * Check if a value implements the `Element` interface.\r\n   */\n  isElement(value) {\n    return isPlainObject(value) && Node.isNodeList(value.children) && !Editor.isEditor(value);\n  },\n\n  /**\r\n   * Check if a value is an array of `Element` objects.\r\n   */\n  isElementList(value) {\n    return Array.isArray(value) && (value.length === 0 || Element.isElement(value[0]));\n  },\n\n  /**\r\n   * Check if an element matches set of properties.\r\n   *\r\n   * Note: this checks custom properties, and it does not ensure that any\r\n   * children are equivalent.\r\n   */\n  matches(element, props) {\n    for (var key in props) {\n      if (key === 'children') {\n        continue;\n      }\n\n      if (element[key] !== props[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n};\nvar Location = {\n  /**\r\n   * Check if a value implements the `Location` interface.\r\n   */\n  isLocation(value) {\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value);\n  }\n\n};\nvar Span = {\n  /**\r\n   * Check if a value implements the `Span` interface.\r\n   */\n  isSpan(value) {\n    return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);\n  }\n\n};\nvar Node = {\n  /**\r\n   * Get the node at a specific path, asserting that it's an ancestor node.\r\n   */\n  ancestor(root, path) {\n    var node = Node.get(root, path);\n\n    if (Text.isText(node)) {\n      throw new Error(\"Cannot get the ancestor node at path [\".concat(path, \"] because it refers to a text node instead: \").concat(node));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return an iterable of all the ancestor nodes above a specific path.\r\n   *\r\n   * By default the order is bottom-up, from lowest to highest ancestor in\r\n   * the tree, but you can pass the `reverse: true` option to go top-down.\r\n   */\n  *ancestors(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    for (var p of Path.ancestors(path, options)) {\n      var n = Node.ancestor(root, p);\n      var entry = [n, p];\n      yield entry;\n    }\n  },\n\n  /**\r\n   * Get the child of a node at a specific index.\r\n   */\n  child(root, index) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get the child of a text node: \".concat(JSON.stringify(root)));\n    }\n\n    var c = root.children[index];\n\n    if (c == null) {\n      throw new Error(\"Cannot get child at index `\".concat(index, \"` in node: \").concat(JSON.stringify(root)));\n    }\n\n    return c;\n  },\n\n  /**\r\n   * Iterate over the children of a node at a specific path.\r\n   */\n  *children(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      reverse = false\n    } = options;\n    var ancestor = Node.ancestor(root, path);\n    var {\n      children\n    } = ancestor;\n    var index = reverse ? children.length - 1 : 0;\n\n    while (reverse ? index >= 0 : index < children.length) {\n      var child = Node.child(ancestor, index);\n      var childPath = path.concat(index);\n      yield [child, childPath];\n      index = reverse ? index - 1 : index + 1;\n    }\n  },\n\n  /**\r\n   * Get an entry for the common ancesetor node of two paths.\r\n   */\n  common(root, path, another) {\n    var p = Path.common(path, another);\n    var n = Node.get(root, p);\n    return [n, p];\n  },\n\n  /**\r\n   * Get the node at a specific path, asserting that it's a descendant node.\r\n   */\n  descendant(root, path) {\n    var node = Node.get(root, path);\n\n    if (Editor.isEditor(node)) {\n      throw new Error(\"Cannot get the descendant node at path [\".concat(path, \"] because it refers to the root editor node instead: \").concat(node));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return an iterable of all the descendant node entries inside a root node.\r\n   */\n  *descendants(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for (var [node, path] of Node.nodes(root, options)) {\n      if (path.length !== 0) {\n        // NOTE: we have to coerce here because checking the path's length does\n        // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n        yield [node, path];\n      }\n    }\n  },\n\n  /**\r\n   * Return an iterable of all the element nodes inside a root node. Each iteration\r\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\r\n   * root node is an element it will be included in the iteration as well.\r\n   */\n  *elements(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for (var [node, path] of Node.nodes(root, options)) {\n      if (Element.isElement(node)) {\n        yield [node, path];\n      }\n    }\n  },\n\n  /**\r\n   * Get the first node entry in a root node from a path.\r\n   */\n  first(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        n = n.children[0];\n        p.push(0);\n      }\n    }\n\n    return [n, p];\n  },\n\n  /**\r\n   * Get the sliced fragment represented by a range inside a root node.\r\n   */\n  fragment(root, range) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get a fragment starting from a root text node: \".concat(JSON.stringify(root)));\n    }\n\n    var newRoot = produce(root, r => {\n      var [start, end] = Range.edges(range);\n      var iterable = Node.nodes(r, {\n        reverse: true,\n        pass: _ref => {\n          var [, path] = _ref;\n          return !Range.includes(range, path);\n        }\n      });\n\n      for (var [, path] of iterable) {\n        if (!Range.includes(range, path)) {\n          var parent = Node.parent(r, path);\n          var index = path[path.length - 1];\n          parent.children.splice(index, 1);\n        }\n\n        if (Path.equals(path, end.path)) {\n          var leaf = Node.leaf(r, path);\n          leaf.text = leaf.text.slice(0, end.offset);\n        }\n\n        if (Path.equals(path, start.path)) {\n          var _leaf = Node.leaf(r, path);\n\n          _leaf.text = _leaf.text.slice(start.offset);\n        }\n      }\n\n      delete r.selection;\n    });\n    return newRoot.children;\n  },\n\n  /**\r\n   * Get the descendant node referred to by a specific path. If the path is an\r\n   * empty array, it refers to the root node itself.\r\n   */\n  get(root, path) {\n    var node = root;\n\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n\n      if (Text.isText(node) || !node.children[p]) {\n        throw new Error(\"Cannot find a descendant at path [\".concat(path, \"] in node: \").concat(JSON.stringify(root)));\n      }\n\n      node = node.children[p];\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Check if a descendant node exists at a specific path.\r\n   */\n  has(root, path) {\n    var node = root;\n\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n\n      if (Text.isText(node) || !node.children[p]) {\n        return false;\n      }\n\n      node = node.children[p];\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Check if a value implements the `Node` interface.\r\n   */\n  isNode(value) {\n    return Text.isText(value) || Element.isElement(value) || Editor.isEditor(value);\n  },\n\n  /**\r\n   * Check if a value is a list of `Node` objects.\r\n   */\n  isNodeList(value) {\n    return Array.isArray(value) && (value.length === 0 || Node.isNode(value[0]));\n  },\n\n  /**\r\n   * Get the lash node entry in a root node from a path.\r\n   */\n  last(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        var i = n.children.length - 1;\n        n = n.children[i];\n        p.push(i);\n      }\n    }\n\n    return [n, p];\n  },\n\n  /**\r\n   * Get the node at a specific path, ensuring it's a leaf text node.\r\n   */\n  leaf(root, path) {\n    var node = Node.get(root, path);\n\n    if (!Text.isText(node)) {\n      throw new Error(\"Cannot get the leaf node at path [\".concat(path, \"] because it refers to a non-leaf node: \").concat(node));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return an iterable of the in a branch of the tree, from a specific path.\r\n   *\r\n   * By default the order is top-down, from lowest to highest node in the tree,\r\n   * but you can pass the `reverse: true` option to go bottom-up.\r\n   */\n  *levels(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    for (var p of Path.levels(path, options)) {\n      var n = Node.get(root, p);\n      yield [n, p];\n    }\n  },\n\n  /**\r\n   * Check if a node matches a set of props.\r\n   */\n  matches(node, props) {\n    return Element.isElement(node) && Element.matches(node, props) || Text.isText(node) && Text.matches(node, props);\n  },\n\n  /**\r\n   * Return an iterable of all the node entries of a root node. Each entry is\r\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\r\n   * position inside the root node.\r\n   */\n  *nodes(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      pass,\n      reverse = false\n    } = options;\n    var {\n      from = [],\n      to\n    } = options;\n    var visited = new Set();\n    var p = [];\n    var n = root;\n\n    while (true) {\n      if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n        break;\n      }\n\n      if (!visited.has(n)) {\n        yield [n, p];\n      } // If we're allowed to go downward and we haven't decsended yet, do.\n\n\n      if (!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([n, p]) === false)) {\n        visited.add(n);\n        var nextIndex = reverse ? n.children.length - 1 : 0;\n\n        if (Path.isAncestor(p, from)) {\n          nextIndex = from[p.length];\n        }\n\n        p = p.concat(nextIndex);\n        n = Node.get(root, p);\n        continue;\n      } // If we're at the root and we can't go down, we're done.\n\n\n      if (p.length === 0) {\n        break;\n      } // If we're going forward...\n\n\n      if (!reverse) {\n        var newPath = Path.next(p);\n\n        if (Node.has(root, newPath)) {\n          p = newPath;\n          n = Node.get(root, p);\n          continue;\n        }\n      } // If we're going backward...\n\n\n      if (reverse && p[p.length - 1] !== 0) {\n        var _newPath = Path.previous(p);\n\n        p = _newPath;\n        n = Node.get(root, p);\n        continue;\n      } // Otherwise we're going upward...\n\n\n      p = Path.parent(p);\n      n = Node.get(root, p);\n      visited.add(n);\n    }\n  },\n\n  /**\r\n   * Get the parent of a node at a specific path.\r\n   */\n  parent(root, path) {\n    var parentPath = Path.parent(path);\n    var p = Node.get(root, parentPath);\n\n    if (Text.isText(p)) {\n      throw new Error(\"Cannot get the parent of path [\".concat(path, \"] because it does not exist in the root.\"));\n    }\n\n    return p;\n  },\n\n  /**\r\n   * Get the concatenated text string of a node's content.\r\n   *\r\n   * Note that this will not include spaces or line breaks between block nodes.\r\n   * It is not a user-facing string, but a string for performing offset-related\r\n   * computations for a node.\r\n   */\n  string(node) {\n    if (Text.isText(node)) {\n      return node.text;\n    } else {\n      return node.children.map(Node.string).join('');\n    }\n  },\n\n  /**\r\n   * Return an iterable of all leaf text nodes in a root node.\r\n   */\n  *texts(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for (var [node, path] of Node.nodes(root, options)) {\n      if (Text.isText(node)) {\n        yield [node, path];\n      }\n    }\n  }\n\n};\n\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$1(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$1(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar Operation = {\n  /**\r\n   * Check of a value is a `NodeOperation` object.\r\n   */\n  isNodeOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_node');\n  },\n\n  /**\r\n   * Check of a value is an `Operation` object.\r\n   */\n  isOperation(value) {\n    if (!isPlainObject(value)) {\n      return false;\n    }\n\n    switch (value.type) {\n      case 'insert_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n\n      case 'insert_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n\n      case 'merge_node':\n        return typeof value.position === 'number' && Path.isPath(value.path) && isPlainObject(value.properties);\n\n      case 'move_node':\n        return Path.isPath(value.path) && Path.isPath(value.newPath);\n\n      case 'remove_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n\n      case 'remove_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n\n      case 'set_node':\n        return Path.isPath(value.path) && isPlainObject(value.properties) && isPlainObject(value.newProperties);\n\n      case 'set_selection':\n        return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || isPlainObject(value.properties) && isPlainObject(value.newProperties);\n\n      case 'split_node':\n        return Path.isPath(value.path) && typeof value.position === 'number' && isPlainObject(value.properties);\n\n      default:\n        return false;\n    }\n  },\n\n  /**\r\n   * Check if a value is a list of `Operation` objects.\r\n   */\n  isOperationList(value) {\n    return Array.isArray(value) && (value.length === 0 || Operation.isOperation(value[0]));\n  },\n\n  /**\r\n   * Check of a value is a `SelectionOperation` object.\r\n   */\n  isSelectionOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_selection');\n  },\n\n  /**\r\n   * Check of a value is a `TextOperation` object.\r\n   */\n  isTextOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_text');\n  },\n\n  /**\r\n   * Invert an operation, returning a new operation that will exactly undo the\r\n   * original when applied.\r\n   */\n  inverse(op) {\n    switch (op.type) {\n      case 'insert_node':\n        {\n          return _objectSpread$1({}, op, {\n            type: 'remove_node'\n          });\n        }\n\n      case 'insert_text':\n        {\n          return _objectSpread$1({}, op, {\n            type: 'remove_text'\n          });\n        }\n\n      case 'merge_node':\n        {\n          return _objectSpread$1({}, op, {\n            type: 'split_node',\n            path: Path.previous(op.path)\n          });\n        }\n\n      case 'move_node':\n        {\n          var {\n            newPath,\n            path\n          } = op; // PERF: in this case the move operation is a no-op anyways.\n\n          if (Path.equals(newPath, path)) {\n            return op;\n          } // If the move happens completely within a single parent the path and\n          // newPath are stable with respect to each other.\n\n\n          if (Path.isSibling(path, newPath)) {\n            return _objectSpread$1({}, op, {\n              path: newPath,\n              newPath: path\n            });\n          } // If the move does not happen within a single parent it is possible\n          // for the move to impact the true path to the location where the node\n          // was removed from and where it was inserted. We have to adjust for this\n          // and find the original path. We can accomplish this (only in non-sibling)\n          // moves by looking at the impact of the move operation on the node\n          // after the original move path.\n\n\n          var inversePath = Path.transform(path, op);\n          var inverseNewPath = Path.transform(Path.next(path), op);\n          return _objectSpread$1({}, op, {\n            path: inversePath,\n            newPath: inverseNewPath\n          });\n        }\n\n      case 'remove_node':\n        {\n          return _objectSpread$1({}, op, {\n            type: 'insert_node'\n          });\n        }\n\n      case 'remove_text':\n        {\n          return _objectSpread$1({}, op, {\n            type: 'insert_text'\n          });\n        }\n\n      case 'set_node':\n        {\n          var {\n            properties,\n            newProperties\n          } = op;\n          return _objectSpread$1({}, op, {\n            properties: newProperties,\n            newProperties: properties\n          });\n        }\n\n      case 'set_selection':\n        {\n          var {\n            properties: _properties,\n            newProperties: _newProperties\n          } = op;\n\n          if (_properties == null) {\n            return _objectSpread$1({}, op, {\n              properties: _newProperties,\n              newProperties: null\n            });\n          } else if (_newProperties == null) {\n            return _objectSpread$1({}, op, {\n              properties: null,\n              newProperties: _properties\n            });\n          } else {\n            return _objectSpread$1({}, op, {\n              properties: _newProperties,\n              newProperties: _properties\n            });\n          }\n        }\n\n      case 'split_node':\n        {\n          return _objectSpread$1({}, op, {\n            type: 'merge_node',\n            path: Path.next(op.path)\n          });\n        }\n    }\n  }\n\n};\nvar Path = {\n  /**\r\n   * Get a list of ancestor paths for a given path.\r\n   *\r\n   * The paths are sorted from deepest to shallowest ancestor. However, if the\r\n   * `reverse: true` option is passed, they are reversed.\r\n   */\n  ancestors(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var paths = Path.levels(path, options);\n\n    if (reverse) {\n      paths = paths.slice(1);\n    } else {\n      paths = paths.slice(0, -1);\n    }\n\n    return paths;\n  },\n\n  /**\r\n   * Get the common ancestor path of two paths.\r\n   */\n  common(path, another) {\n    var common = [];\n\n    for (var i = 0; i < path.length && i < another.length; i++) {\n      var av = path[i];\n      var bv = another[i];\n\n      if (av !== bv) {\n        break;\n      }\n\n      common.push(av);\n    }\n\n    return common;\n  },\n\n  /**\r\n   * Compare a path to another, returning an integer indicating whether the path\r\n   * was before, at, or after the other.\r\n   *\r\n   * Note: Two paths of unequal length can still receive a `0` result if one is\r\n   * directly above or below the other. If you want exact matching, use\r\n   * [[Path.equals]] instead.\r\n   */\n  compare(path, another) {\n    var min = Math.min(path.length, another.length);\n\n    for (var i = 0; i < min; i++) {\n      if (path[i] < another[i]) return -1;\n      if (path[i] > another[i]) return 1;\n    }\n\n    return 0;\n  },\n\n  /**\r\n   * Check if a path ends after one of the indexes in another.\r\n   */\n  endsAfter(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av > bv;\n  },\n\n  /**\r\n   * Check if a path ends at one of the indexes in another.\r\n   */\n  endsAt(path, another) {\n    var i = path.length;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    return Path.equals(as, bs);\n  },\n\n  /**\r\n   * Check if a path ends before one of the indexes in another.\r\n   */\n  endsBefore(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av < bv;\n  },\n\n  /**\r\n   * Check if a path is exactly equal to another.\r\n   */\n  equals(path, another) {\n    return path.length === another.length && path.every((n, i) => n === another[i]);\n  },\n\n  /**\r\n   * Check if a path is after another.\r\n   */\n  isAfter(path, another) {\n    return Path.compare(path, another) === 1;\n  },\n\n  /**\r\n   * Check if a path is an ancestor of another.\r\n   */\n  isAncestor(path, another) {\n    return path.length < another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is before another.\r\n   */\n  isBefore(path, another) {\n    return Path.compare(path, another) === -1;\n  },\n\n  /**\r\n   * Check if a path is a child of another.\r\n   */\n  isChild(path, another) {\n    return path.length === another.length + 1 && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is equal to or an ancestor of another.\r\n   */\n  isCommon(path, another) {\n    return path.length <= another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is a descendant of another.\r\n   */\n  isDescendant(path, another) {\n    return path.length > another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is the parent of another.\r\n   */\n  isParent(path, another) {\n    return path.length + 1 === another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check is a value implements the `Path` interface.\r\n   */\n  isPath(value) {\n    return Array.isArray(value) && (value.length === 0 || typeof value[0] === 'number');\n  },\n\n  /**\r\n   * Check if a path is a sibling of another.\r\n   */\n  isSibling(path, another) {\n    if (path.length !== another.length) {\n      return false;\n    }\n\n    var as = path.slice(0, -1);\n    var bs = another.slice(0, -1);\n    var al = path[path.length - 1];\n    var bl = another[another.length - 1];\n    return al !== bl && Path.equals(as, bs);\n  },\n\n  /**\r\n   * Get a list of paths at every level down to a path. Note: this is the same\r\n   * as `Path.ancestors`, but including the path itself.\r\n   *\r\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\r\n   * true` option is passed, they are reversed.\r\n   */\n  levels(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var list = [];\n\n    for (var i = 0; i <= path.length; i++) {\n      list.push(path.slice(0, i));\n    }\n\n    if (reverse) {\n      list.reverse();\n    }\n\n    return list;\n  },\n\n  /**\r\n   * Given a path, get the path to the next sibling node.\r\n   */\n  next(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the next path of a root path [\".concat(path, \"], because it has no next index.\"));\n    }\n\n    var last = path[path.length - 1];\n    return path.slice(0, -1).concat(last + 1);\n  },\n\n  /**\r\n   * Given a path, return a new path referring to the parent node above it.\r\n   */\n  parent(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the parent path of the root path [\".concat(path, \"].\"));\n    }\n\n    return path.slice(0, -1);\n  },\n\n  /**\r\n   * Given a path, get the path to the previous sibling node.\r\n   */\n  previous(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the previous path of a root path [\".concat(path, \"], because it has no previous index.\"));\n    }\n\n    var last = path[path.length - 1];\n\n    if (last <= 0) {\n      throw new Error(\"Cannot get the previous path of a first child path [\".concat(path, \"] because it would result in a negative index.\"));\n    }\n\n    return path.slice(0, -1).concat(last - 1);\n  },\n\n  /**\r\n   * Get a path relative to an ancestor.\r\n   */\n  relative(path, ancestor) {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\"Cannot get the relative path of [\".concat(path, \"] inside ancestor [\").concat(ancestor, \"], because it is not above or equal to the path.\"));\n    }\n\n    return path.slice(ancestor.length);\n  },\n\n  /**\r\n   * Transform a path by an operation.\r\n   */\n  transform(path, operation) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return produce(path, p => {\n      var {\n        affinity = 'forward'\n      } = options; // PERF: Exit early if the operation is guaranteed not to have an effect.\n\n      if (path.length === 0) {\n        return;\n      }\n\n      switch (operation.type) {\n        case 'insert_node':\n          {\n            var {\n              path: op\n            } = operation;\n\n            if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {\n              p[op.length - 1] += 1;\n            }\n\n            break;\n          }\n\n        case 'remove_node':\n          {\n            var {\n              path: _op\n            } = operation;\n\n            if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {\n              return null;\n            } else if (Path.endsBefore(_op, p)) {\n              p[_op.length - 1] -= 1;\n            }\n\n            break;\n          }\n\n        case 'merge_node':\n          {\n            var {\n              path: _op2,\n              position\n            } = operation;\n\n            if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {\n              p[_op2.length - 1] -= 1;\n            } else if (Path.isAncestor(_op2, p)) {\n              p[_op2.length - 1] -= 1;\n              p[_op2.length] += position;\n            }\n\n            break;\n          }\n\n        case 'split_node':\n          {\n            var {\n              path: _op3,\n              position: _position\n            } = operation;\n\n            if (Path.equals(_op3, p)) {\n              if (affinity === 'forward') {\n                p[p.length - 1] += 1;\n              } else if (affinity === 'backward') ;else {\n                return null;\n              }\n            } else if (Path.endsBefore(_op3, p)) {\n              p[_op3.length - 1] += 1;\n            } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {\n              p[_op3.length - 1] += 1;\n              p[_op3.length] -= _position;\n            }\n\n            break;\n          }\n\n        case 'move_node':\n          {\n            var {\n              path: _op4,\n              newPath: onp\n            } = operation; // If the old and new path are the same, it's a no-op.\n\n            if (Path.equals(_op4, onp)) {\n              return;\n            }\n\n            if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {\n              var copy = onp.slice();\n\n              if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {\n                copy[_op4.length - 1] -= 1;\n              }\n\n              return copy.concat(p.slice(_op4.length));\n            } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {\n              if (Path.endsBefore(_op4, p)) {\n                p[_op4.length - 1] -= 1;\n              } else {\n                p[_op4.length - 1] += 1;\n              }\n            } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {\n              if (Path.endsBefore(_op4, p)) {\n                p[_op4.length - 1] -= 1;\n              }\n\n              p[onp.length - 1] += 1;\n            } else if (Path.endsBefore(_op4, p)) {\n              if (Path.equals(onp, p)) {\n                p[onp.length - 1] += 1;\n              }\n\n              p[_op4.length - 1] -= 1;\n            }\n\n            break;\n          }\n      }\n    });\n  }\n\n};\nvar PathRef = {\n  /**\r\n   * Transform the path ref's current value by an operation.\r\n   */\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n\n    if (current == null) {\n      return;\n    }\n\n    var path = Path.transform(current, op, {\n      affinity\n    });\n    ref.current = path;\n\n    if (path == null) {\n      ref.unref();\n    }\n  }\n\n};\n\nfunction ownKeys$2(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$2(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$2(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar Point = {\n  /**\r\n   * Compare a point to another, returning an integer indicating whether the\r\n   * point was before, at, or after the other.\r\n   */\n  compare(point, another) {\n    var result = Path.compare(point.path, another.path);\n\n    if (result === 0) {\n      if (point.offset < another.offset) return -1;\n      if (point.offset > another.offset) return 1;\n      return 0;\n    }\n\n    return result;\n  },\n\n  /**\r\n   * Check if a point is after another.\r\n   */\n  isAfter(point, another) {\n    return Point.compare(point, another) === 1;\n  },\n\n  /**\r\n   * Check if a point is before another.\r\n   */\n  isBefore(point, another) {\n    return Point.compare(point, another) === -1;\n  },\n\n  /**\r\n   * Check if a point is exactly equal to another.\r\n   */\n  equals(point, another) {\n    // PERF: ensure the offsets are equal first since they are cheaper to check.\n    return point.offset === another.offset && Path.equals(point.path, another.path);\n  },\n\n  /**\r\n   * Check if a value implements the `Point` interface.\r\n   */\n  isPoint(value) {\n    return isPlainObject(value) && typeof value.offset === 'number' && Path.isPath(value.path);\n  },\n\n  /**\r\n   * Transform a point by an operation.\r\n   */\n  transform(point, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return produce(point, p => {\n      var {\n        affinity = 'forward'\n      } = options;\n      var {\n        path,\n        offset\n      } = p;\n\n      switch (op.type) {\n        case 'insert_node':\n        case 'move_node':\n          {\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'insert_text':\n          {\n            if (Path.equals(op.path, path) && op.offset <= offset) {\n              p.offset += op.text.length;\n            }\n\n            break;\n          }\n\n        case 'merge_node':\n          {\n            if (Path.equals(op.path, path)) {\n              p.offset += op.position;\n            }\n\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'remove_text':\n          {\n            if (Path.equals(op.path, path) && op.offset <= offset) {\n              p.offset -= Math.min(offset - op.offset, op.text.length);\n            }\n\n            break;\n          }\n\n        case 'remove_node':\n          {\n            if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n              return null;\n            }\n\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'split_node':\n          {\n            if (Path.equals(op.path, path)) {\n              if (op.position === offset && affinity == null) {\n                return null;\n              } else if (op.position < offset || op.position === offset && affinity === 'forward') {\n                p.offset -= op.position;\n                p.path = Path.transform(path, op, _objectSpread$2({}, options, {\n                  affinity: 'forward'\n                }));\n              }\n            } else {\n              p.path = Path.transform(path, op, options);\n            }\n\n            break;\n          }\n      }\n    });\n  }\n\n};\nvar PointRef = {\n  /**\r\n   * Transform the point ref's current value by an operation.\r\n   */\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n\n    if (current == null) {\n      return;\n    }\n\n    var point = Point.transform(current, op, {\n      affinity\n    });\n    ref.current = point;\n\n    if (point == null) {\n      ref.unref();\n    }\n  }\n\n};\n\nfunction ownKeys$3(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$3(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$3(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$3(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar Range = {\n  /**\r\n   * Get the start and end points of a range, in the order in which they appear\r\n   * in the document.\r\n   */\n  edges(range) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var {\n      anchor,\n      focus\n    } = range;\n    return Range.isBackward(range) === reverse ? [anchor, focus] : [focus, anchor];\n  },\n\n  /**\r\n   * Get the end point of a range.\r\n   */\n  end(range) {\n    var [, end] = Range.edges(range);\n    return end;\n  },\n\n  /**\r\n   * Check if a range is exactly equal to another.\r\n   */\n  equals(range, another) {\n    return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);\n  },\n\n  /**\r\n   * Check if a range includes a path, a point or part of another range.\r\n   */\n  includes(range, target) {\n    if (Range.isRange(target)) {\n      if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {\n        return true;\n      }\n\n      var [rs, re] = Range.edges(range);\n      var [ts, te] = Range.edges(target);\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te);\n    }\n\n    var [start, end] = Range.edges(range);\n    var isAfterStart = false;\n    var isBeforeEnd = false;\n\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start) >= 0;\n      isBeforeEnd = Point.compare(target, end) <= 0;\n    } else {\n      isAfterStart = Path.compare(target, start.path) >= 0;\n      isBeforeEnd = Path.compare(target, end.path) <= 0;\n    }\n\n    return isAfterStart && isBeforeEnd;\n  },\n\n  /**\r\n   * Get the intersection of a range with another.\r\n   */\n  intersection(range, another) {\n    var rest = _objectWithoutProperties(range, [\"anchor\", \"focus\"]);\n\n    var [s1, e1] = Range.edges(range);\n    var [s2, e2] = Range.edges(another);\n    var start = Point.isBefore(s1, s2) ? s2 : s1;\n    var end = Point.isBefore(e1, e2) ? e1 : e2;\n\n    if (Point.isBefore(end, start)) {\n      return null;\n    } else {\n      return _objectSpread$3({\n        anchor: start,\n        focus: end\n      }, rest);\n    }\n  },\n\n  /**\r\n   * Check if a range is backward, meaning that its anchor point appears in the\r\n   * document _after_ its focus point.\r\n   */\n  isBackward(range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    return Point.isAfter(anchor, focus);\n  },\n\n  /**\r\n   * Check if a range is collapsed, meaning that both its anchor and focus\r\n   * points refer to the exact same position in the document.\r\n   */\n  isCollapsed(range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    return Point.equals(anchor, focus);\n  },\n\n  /**\r\n   * Check if a range is expanded.\r\n   *\r\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\r\n   */\n  isExpanded(range) {\n    return !Range.isCollapsed(range);\n  },\n\n  /**\r\n   * Check if a range is forward.\r\n   *\r\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\r\n   */\n  isForward(range) {\n    return !Range.isBackward(range);\n  },\n\n  /**\r\n   * Check if a value implements the [[Range]] interface.\r\n   */\n  isRange(value) {\n    return isPlainObject(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);\n  },\n\n  /**\r\n   * Iterate through all of the point entries in a range.\r\n   */\n  *points(range) {\n    yield [range.anchor, 'anchor'];\n    yield [range.focus, 'focus'];\n  },\n\n  /**\r\n   * Get the start point of a range.\r\n   */\n  start(range) {\n    var [start] = Range.edges(range);\n    return start;\n  },\n\n  /**\r\n   * Transform a range by an operation.\r\n   */\n  transform(range, op, options) {\n    var {\n      affinity = 'inward'\n    } = options;\n    var affinityAnchor;\n    var affinityFocus;\n\n    if (affinity === 'inward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'forward';\n        affinityFocus = 'backward';\n      } else {\n        affinityAnchor = 'backward';\n        affinityFocus = 'forward';\n      }\n    } else if (affinity === 'outward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'backward';\n        affinityFocus = 'forward';\n      } else {\n        affinityAnchor = 'forward';\n        affinityFocus = 'backward';\n      }\n    } else {\n      affinityAnchor = affinity;\n      affinityFocus = affinity;\n    }\n\n    return produce(range, r => {\n      var anchor = Point.transform(r.anchor, op, {\n        affinity: affinityAnchor\n      });\n      var focus = Point.transform(r.focus, op, {\n        affinity: affinityFocus\n      });\n\n      if (!anchor || !focus) {\n        return null;\n      }\n\n      r.anchor = anchor;\n      r.focus = focus;\n    });\n  }\n\n};\nvar RangeRef = {\n  /**\r\n   * Transform the range ref's current value by an operation.\r\n   */\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n\n    if (current == null) {\n      return;\n    }\n\n    var path = Range.transform(current, op, {\n      affinity\n    });\n    ref.current = path;\n\n    if (path == null) {\n      ref.unref();\n    }\n  }\n\n};\n\nfunction ownKeys$4(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$4(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$4(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$4(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar Text = {\n  /**\r\n   * Check if two text nodes are equal.\r\n   */\n  equals(text, another) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      loose = false\n    } = options;\n\n    for (var key in text) {\n      if (loose && key === 'text') {\n        continue;\n      }\n\n      if (text[key] !== another[key]) {\n        return false;\n      }\n    }\n\n    for (var _key in another) {\n      if (loose && _key === 'text') {\n        continue;\n      }\n\n      if (text[_key] !== another[_key]) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Check if a value implements the `Text` interface.\r\n   */\n  isText(value) {\n    return isPlainObject(value) && typeof value.text === 'string';\n  },\n\n  /**\r\n   * Check if a value is a list of `Text` objects.\r\n   */\n  isTextList(value) {\n    return Array.isArray(value) && (value.length === 0 || Text.isText(value[0]));\n  },\n\n  /**\r\n   * Check if an text matches set of properties.\r\n   *\r\n   * Note: this is for matching custom properties, and it does not ensure that\r\n   * the `text` property are two nodes equal.\r\n   */\n  matches(text, props) {\n    for (var key in props) {\n      if (key === 'text') {\n        continue;\n      }\n\n      if (text[key] !== props[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Get the leaves for a text node given decorations.\r\n   */\n  decorations(node, decorations) {\n    var leaves = [_objectSpread$4({}, node)];\n\n    for (var dec of decorations) {\n      var rest = _objectWithoutProperties(dec, [\"anchor\", \"focus\"]);\n\n      var [start, end] = Range.edges(dec);\n      var next = [];\n      var o = 0;\n\n      for (var leaf of leaves) {\n        var {\n          length\n        } = leaf.text;\n        var offset = o;\n        o += length; // If the range encompases the entire leaf, add the range.\n\n        if (start.offset <= offset && end.offset >= offset + length) {\n          Object.assign(leaf, rest);\n          next.push(leaf);\n          continue;\n        } // If the range starts after the leaf, or ends before it, continue.\n\n\n        if (start.offset > offset + length || end.offset < offset || end.offset === offset && offset !== 0) {\n          next.push(leaf);\n          continue;\n        } // Otherwise we need to split the leaf, at the start, end, or both,\n        // and add the range to the middle intersecting section. Do the end\n        // split first since we don't need to update the offset that way.\n\n\n        var middle = leaf;\n        var before = void 0;\n        var after = void 0;\n\n        if (end.offset < offset + length) {\n          var off = end.offset - offset;\n          after = _objectSpread$4({}, middle, {\n            text: middle.text.slice(off)\n          });\n          middle = _objectSpread$4({}, middle, {\n            text: middle.text.slice(0, off)\n          });\n        }\n\n        if (start.offset > offset) {\n          var _off = start.offset - offset;\n\n          before = _objectSpread$4({}, middle, {\n            text: middle.text.slice(0, _off)\n          });\n          middle = _objectSpread$4({}, middle, {\n            text: middle.text.slice(_off)\n          });\n        }\n\n        Object.assign(middle, rest);\n\n        if (before) {\n          next.push(before);\n        }\n\n        next.push(middle);\n\n        if (after) {\n          next.push(after);\n        }\n      }\n\n      leaves = next;\n    }\n\n    return leaves;\n  }\n\n};\n\nfunction ownKeys$5(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$5(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$5(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$5(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar GeneralTransforms = {\n  /**\r\n   * Transform the editor by an operation.\r\n   */\n  transform(editor, op) {\n    editor.children = createDraft(editor.children);\n    var selection = editor.selection && createDraft(editor.selection);\n\n    switch (op.type) {\n      case 'insert_node':\n        {\n          var {\n            path,\n            node\n          } = op;\n          var parent = Node.parent(editor, path);\n          var index = path[path.length - 1];\n          parent.children.splice(index, 0, node);\n\n          if (selection) {\n            for (var [point, key] of Range.points(selection)) {\n              selection[key] = Point.transform(point, op);\n            }\n          }\n\n          break;\n        }\n\n      case 'insert_text':\n        {\n          var {\n            path: _path,\n            offset,\n            text\n          } = op;\n\n          var _node = Node.leaf(editor, _path);\n\n          var before = _node.text.slice(0, offset);\n\n          var after = _node.text.slice(offset);\n\n          _node.text = before + text + after;\n\n          if (selection) {\n            for (var [_point, _key] of Range.points(selection)) {\n              selection[_key] = Point.transform(_point, op);\n            }\n          }\n\n          break;\n        }\n\n      case 'merge_node':\n        {\n          var {\n            path: _path2\n          } = op;\n\n          var _node2 = Node.get(editor, _path2);\n\n          var prevPath = Path.previous(_path2);\n          var prev = Node.get(editor, prevPath);\n\n          var _parent = Node.parent(editor, _path2);\n\n          var _index = _path2[_path2.length - 1];\n\n          if (Text.isText(_node2) && Text.isText(prev)) {\n            prev.text += _node2.text;\n          } else if (!Text.isText(_node2) && !Text.isText(prev)) {\n            prev.children.push(..._node2.children);\n          } else {\n            throw new Error(\"Cannot apply a \\\"merge_node\\\" operation at path [\".concat(_path2, \"] to nodes of different interaces: \").concat(_node2, \" \").concat(prev));\n          }\n\n          _parent.children.splice(_index, 1);\n\n          if (selection) {\n            for (var [_point2, _key2] of Range.points(selection)) {\n              selection[_key2] = Point.transform(_point2, op);\n            }\n          }\n\n          break;\n        }\n\n      case 'move_node':\n        {\n          var {\n            path: _path3,\n            newPath\n          } = op;\n\n          if (Path.isAncestor(_path3, newPath)) {\n            throw new Error(\"Cannot move a path [\".concat(_path3, \"] to new path [\").concat(newPath, \"] because the destination is inside itself.\"));\n          }\n\n          var _node3 = Node.get(editor, _path3);\n\n          var _parent2 = Node.parent(editor, _path3);\n\n          var _index2 = _path3[_path3.length - 1]; // This is tricky, but since the `path` and `newPath` both refer to\n          // the same snapshot in time, there's a mismatch. After either\n          // removing the original position, the second step's path can be out\n          // of date. So instead of using the `op.newPath` directly, we\n          // transform `op.path` to ascertain what the `newPath` would be after\n          // the operation was applied.\n\n          _parent2.children.splice(_index2, 1);\n\n          var truePath = Path.transform(_path3, op);\n          var newParent = Node.get(editor, Path.parent(truePath));\n          var newIndex = truePath[truePath.length - 1];\n          newParent.children.splice(newIndex, 0, _node3);\n\n          if (selection) {\n            for (var [_point3, _key3] of Range.points(selection)) {\n              selection[_key3] = Point.transform(_point3, op);\n            }\n          }\n\n          break;\n        }\n\n      case 'remove_node':\n        {\n          var {\n            path: _path4\n          } = op;\n          var _index3 = _path4[_path4.length - 1];\n\n          var _parent3 = Node.parent(editor, _path4);\n\n          _parent3.children.splice(_index3, 1); // Transform all of the points in the value, but if the point was in the\n          // node that was removed we need to update the range or remove it.\n\n\n          if (selection) {\n            for (var [_point4, _key4] of Range.points(selection)) {\n              var result = Point.transform(_point4, op);\n\n              if (selection != null && result != null) {\n                selection[_key4] = result;\n              } else {\n                var _prev = void 0;\n\n                var next = void 0;\n\n                for (var [n, p] of Node.texts(editor)) {\n                  if (Path.compare(p, _path4) === -1) {\n                    _prev = [n, p];\n                  } else {\n                    next = [n, p];\n                    break;\n                  }\n                }\n\n                if (_prev) {\n                  _point4.path = _prev[1];\n                  _point4.offset = _prev[0].text.length;\n                } else if (next) {\n                  _point4.path = next[1];\n                  _point4.offset = 0;\n                } else {\n                  selection = null;\n                }\n              }\n            }\n          }\n\n          break;\n        }\n\n      case 'remove_text':\n        {\n          var {\n            path: _path5,\n            offset: _offset,\n            text: _text\n          } = op;\n\n          var _node4 = Node.leaf(editor, _path5);\n\n          var _before = _node4.text.slice(0, _offset);\n\n          var _after = _node4.text.slice(_offset + _text.length);\n\n          _node4.text = _before + _after;\n\n          if (selection) {\n            for (var [_point5, _key5] of Range.points(selection)) {\n              selection[_key5] = Point.transform(_point5, op);\n            }\n          }\n\n          break;\n        }\n\n      case 'set_node':\n        {\n          var {\n            path: _path6,\n            newProperties\n          } = op;\n\n          if (_path6.length === 0) {\n            throw new Error(\"Cannot set properties on the root node!\");\n          }\n\n          var _node5 = Node.get(editor, _path6);\n\n          for (var _key6 in newProperties) {\n            if (_key6 === 'children' || _key6 === 'text') {\n              throw new Error(\"Cannot set the \\\"\".concat(_key6, \"\\\" property of nodes!\"));\n            }\n\n            var value = newProperties[_key6];\n\n            if (value == null) {\n              delete _node5[_key6];\n            } else {\n              _node5[_key6] = value;\n            }\n          }\n\n          break;\n        }\n\n      case 'set_selection':\n        {\n          var {\n            newProperties: _newProperties\n          } = op;\n\n          if (_newProperties == null) {\n            selection = _newProperties;\n          } else if (selection == null) {\n            if (!Range.isRange(_newProperties)) {\n              throw new Error(\"Cannot apply an incomplete \\\"set_selection\\\" operation properties \".concat(JSON.stringify(_newProperties), \" when there is no current selection.\"));\n            }\n\n            selection = _newProperties;\n          } else {\n            Object.assign(selection, _newProperties);\n          }\n\n          break;\n        }\n\n      case 'split_node':\n        {\n          var {\n            path: _path7,\n            position,\n            properties\n          } = op;\n\n          if (_path7.length === 0) {\n            throw new Error(\"Cannot apply a \\\"split_node\\\" operation at path [\".concat(_path7, \"] because the root node cannot be split.\"));\n          }\n\n          var _node6 = Node.get(editor, _path7);\n\n          var _parent4 = Node.parent(editor, _path7);\n\n          var _index4 = _path7[_path7.length - 1];\n          var newNode;\n\n          if (Text.isText(_node6)) {\n            var _before2 = _node6.text.slice(0, position);\n\n            var _after2 = _node6.text.slice(position);\n\n            _node6.text = _before2;\n            newNode = _objectSpread$5({}, _node6, {}, properties, {\n              text: _after2\n            });\n          } else {\n            var _before3 = _node6.children.slice(0, position);\n\n            var _after3 = _node6.children.slice(position);\n\n            _node6.children = _before3;\n            newNode = _objectSpread$5({}, _node6, {}, properties, {\n              children: _after3\n            });\n          }\n\n          _parent4.children.splice(_index4 + 1, 0, newNode);\n\n          if (selection) {\n            for (var [_point6, _key7] of Range.points(selection)) {\n              selection[_key7] = Point.transform(_point6, op);\n            }\n          }\n\n          break;\n        }\n    }\n\n    editor.children = finishDraft(editor.children);\n\n    if (selection) {\n      editor.selection = isDraft(selection) ? finishDraft(selection) : selection;\n    } else {\n      editor.selection = null;\n    }\n  }\n\n};\n\nfunction ownKeys$6(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$6(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$6(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$6(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar NodeTransforms = {\n  /**\r\n   * Insert nodes at a specific location in the Editor.\r\n   */\n  insertNodes(editor, nodes) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        hanging = false,\n        voids = false,\n        mode = 'lowest'\n      } = options;\n      var {\n        at,\n        match,\n        select\n      } = options;\n\n      if (Node.isNode(nodes)) {\n        nodes = [nodes];\n      }\n\n      if (nodes.length === 0) {\n        return;\n      }\n\n      var [node] = nodes; // By default, use the selection as the target location. But if there is\n      // no selection, insert at the end of the document since that is such a\n      // common use case when inserting from a non-selected state.\n\n      if (!at) {\n        if (editor.selection) {\n          at = editor.selection;\n        } else if (editor.children.length > 0) {\n          at = Editor.end(editor, []);\n        } else {\n          at = [0];\n        }\n\n        select = true;\n      }\n\n      if (select == null) {\n        select = false;\n      }\n\n      if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at);\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var [, end] = Range.edges(at);\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at\n          });\n          at = pointRef.unref();\n        }\n      }\n\n      if (Point.isPoint(at)) {\n        if (match == null) {\n          if (Text.isText(node)) {\n            match = n => Text.isText(n);\n          } else if (editor.isInline(node)) {\n            match = n => Text.isText(n) || Editor.isInline(editor, n);\n          } else {\n            match = n => Editor.isBlock(editor, n);\n          }\n        }\n\n        var [entry] = Editor.nodes(editor, {\n          at: at.path,\n          match,\n          mode,\n          voids\n        });\n\n        if (entry) {\n          var [, _matchPath] = entry;\n          var pathRef = Editor.pathRef(editor, _matchPath);\n          var isAtEnd = Editor.isEnd(editor, at, _matchPath);\n          Transforms.splitNodes(editor, {\n            at,\n            match,\n            mode,\n            voids\n          });\n          var path = pathRef.unref();\n          at = isAtEnd ? Path.next(path) : path;\n        } else {\n          return;\n        }\n      }\n\n      var parentPath = Path.parent(at);\n      var index = at[at.length - 1];\n\n      if (!voids && Editor.void(editor, {\n        at: parentPath\n      })) {\n        return;\n      }\n\n      for (var _node of nodes) {\n        var _path = parentPath.concat(index);\n\n        index++;\n        editor.apply({\n          type: 'insert_node',\n          path: _path,\n          node: _node\n        });\n      }\n\n      if (select) {\n        var point = Editor.end(editor, at);\n\n        if (point) {\n          Transforms.select(editor, point);\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Lift nodes at a specific location upwards in the document tree, splitting\r\n   * their parent in two if necessary.\r\n   */\n  liftNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        at = editor.selection,\n        mode = 'lowest',\n        voids = false\n      } = options;\n      var {\n        match\n      } = options;\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);\n      }\n\n      if (!at) {\n        return;\n      }\n\n      var matches = Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      });\n      var pathRefs = Array.from(matches, _ref => {\n        var [, p] = _ref;\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var pathRef of pathRefs) {\n        var path = pathRef.unref();\n\n        if (path.length < 2) {\n          throw new Error(\"Cannot lift node at a path [\".concat(path, \"] because it has a depth of less than `2`.\"));\n        }\n\n        var parentNodeEntry = Editor.node(editor, Path.parent(path));\n        var [parent, parentPath] = parentNodeEntry;\n        var index = path[path.length - 1];\n        var {\n          length\n        } = parent.children;\n\n        if (length === 1) {\n          var toPath = Path.next(parentPath);\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: toPath,\n            voids\n          });\n          Transforms.removeNodes(editor, {\n            at: parentPath,\n            voids\n          });\n        } else if (index === 0) {\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: parentPath,\n            voids\n          });\n        } else if (index === length - 1) {\n          var _toPath = Path.next(parentPath);\n\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: _toPath,\n            voids\n          });\n        } else {\n          var splitPath = Path.next(path);\n\n          var _toPath2 = Path.next(parentPath);\n\n          Transforms.splitNodes(editor, {\n            at: splitPath,\n            voids\n          });\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: _toPath2,\n            voids\n          });\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Merge a node at a location with the previous node of the same depth,\r\n   * removing any empty containing nodes after the merge if necessary.\r\n   */\n  mergeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        match,\n        at = editor.selection\n      } = options;\n      var {\n        hanging = false,\n        voids = false,\n        mode = 'lowest'\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          var [parent] = Editor.parent(editor, at);\n\n          match = n => parent.children.includes(n);\n        } else {\n          match = n => Editor.isBlock(editor, n);\n        }\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at);\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var [, end] = Range.edges(at);\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at\n          });\n          at = pointRef.unref();\n\n          if (options.at == null) {\n            Transforms.select(editor, at);\n          }\n        }\n      }\n\n      var [current] = Editor.nodes(editor, {\n        at,\n        match,\n        voids,\n        mode\n      });\n      var prev = Editor.previous(editor, {\n        at,\n        match,\n        voids,\n        mode\n      });\n\n      if (!current || !prev) {\n        return;\n      }\n\n      var [node, path] = current;\n      var [prevNode, prevPath] = prev;\n\n      if (path.length === 0 || prevPath.length === 0) {\n        return;\n      }\n\n      var newPath = Path.next(prevPath);\n      var commonPath = Path.common(path, prevPath);\n      var isPreviousSibling = Path.isSibling(path, prevPath);\n      var levels = Array.from(Editor.levels(editor, {\n        at: path\n      }), _ref2 => {\n        var [n] = _ref2;\n        return n;\n      }).slice(commonPath.length).slice(0, -1); // Determine if the merge will leave an ancestor of the path empty as a\n      // result, in which case we'll want to remove it after merging.\n\n      var emptyAncestor = Editor.above(editor, {\n        at: path,\n        mode: 'highest',\n        match: n => levels.includes(n) && Element.isElement(n) && n.children.length === 1\n      });\n      var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);\n      var properties;\n      var position; // Ensure that the nodes are equivalent, and figure out what the position\n      // and extra properties of the merge will be.\n\n      if (Text.isText(node) && Text.isText(prevNode)) {\n        var rest = _objectWithoutProperties(node, [\"text\"]);\n\n        position = prevNode.text.length;\n        properties = rest;\n      } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n        var rest = _objectWithoutProperties(node, [\"children\"]);\n\n        position = prevNode.children.length;\n        properties = rest;\n      } else {\n        throw new Error(\"Cannot merge the node at path [\".concat(path, \"] with the previous sibling because it is not the same kind: \").concat(JSON.stringify(node), \" \").concat(JSON.stringify(prevNode)));\n      } // If the node isn't already the next sibling of the previous node, move\n      // it so that it is before merging.\n\n\n      if (!isPreviousSibling) {\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: newPath,\n          voids\n        });\n      } // If there was going to be an empty ancestor of the node that was merged,\n      // we remove it from the tree.\n\n\n      if (emptyRef) {\n        Transforms.removeNodes(editor, {\n          at: emptyRef.current,\n          voids\n        });\n      } // If the target node that we're merging with is empty, remove it instead\n      // of merging the two. This is a common rich text editor behavior to\n      // prevent losing formatting when deleting entire nodes when you have a\n      // hanging selection.\n\n\n      if (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === '') {\n        Transforms.removeNodes(editor, {\n          at: prevPath,\n          voids\n        });\n      } else {\n        editor.apply({\n          type: 'merge_node',\n          path: newPath,\n          position,\n          properties\n        });\n      }\n\n      if (emptyRef) {\n        emptyRef.unref();\n      }\n    });\n  },\n\n  /**\r\n   * Move the nodes at a location to a new location.\r\n   */\n  moveNodes(editor, options) {\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        to,\n        at = editor.selection,\n        mode = 'lowest',\n        voids = false\n      } = options;\n      var {\n        match\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);\n      }\n\n      var toRef = Editor.pathRef(editor, to);\n      var targets = Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      });\n      var pathRefs = Array.from(targets, _ref3 => {\n        var [, p] = _ref3;\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var pathRef of pathRefs) {\n        var path = pathRef.unref();\n        var newPath = toRef.current;\n\n        if (path.length !== 0) {\n          editor.apply({\n            type: 'move_node',\n            path,\n            newPath\n          });\n        }\n      }\n\n      toRef.unref();\n    });\n  },\n\n  /**\r\n   * Remove the nodes at a specific location in the document.\r\n   */\n  removeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        hanging = false,\n        voids = false,\n        mode = 'lowest'\n      } = options;\n      var {\n        at = editor.selection,\n        match\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at);\n      }\n\n      var depths = Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      });\n      var pathRefs = Array.from(depths, _ref4 => {\n        var [, p] = _ref4;\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var pathRef of pathRefs) {\n        var path = pathRef.unref();\n\n        if (path) {\n          var [node] = Editor.node(editor, path);\n          editor.apply({\n            type: 'remove_node',\n            path,\n            node\n          });\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Set new properties on the nodes at a location.\r\n   */\n  setNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        match,\n        at = editor.selection\n      } = options;\n      var {\n        hanging = false,\n        mode = 'lowest',\n        split = false,\n        voids = false\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at);\n      }\n\n      if (split && Range.isRange(at)) {\n        var rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward'\n        });\n        var [start, end] = Range.edges(at);\n        var splitMode = mode === 'lowest' ? 'lowest' : 'highest';\n        Transforms.splitNodes(editor, {\n          at: end,\n          match,\n          mode: splitMode,\n          voids\n        });\n        Transforms.splitNodes(editor, {\n          at: start,\n          match,\n          mode: splitMode,\n          voids\n        });\n        at = rangeRef.unref();\n\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n\n      for (var [node, path] of Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      })) {\n        var properties = {};\n        var newProperties = {}; // You can't set properties on the editor node.\n\n        if (path.length === 0) {\n          continue;\n        }\n\n        for (var k in props) {\n          if (k === 'children' || k === 'text') {\n            continue;\n          }\n\n          if (props[k] !== node[k]) {\n            properties[k] = node[k];\n            newProperties[k] = props[k];\n          }\n        }\n\n        if (Object.keys(newProperties).length !== 0) {\n          editor.apply({\n            type: 'set_node',\n            path,\n            properties,\n            newProperties\n          });\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Split the nodes at a specific location.\r\n   */\n  splitNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        mode = 'lowest',\n        voids = false\n      } = options;\n      var {\n        match,\n        at = editor.selection,\n        height = 0,\n        always = false\n      } = options;\n\n      if (match == null) {\n        match = n => Editor.isBlock(editor, n);\n      }\n\n      if (Range.isRange(at)) {\n        at = deleteRange(editor, at);\n      } // If the target is a path, the default height-skipping and position\n      // counters need to account for us potentially splitting at a non-leaf.\n\n\n      if (Path.isPath(at)) {\n        var path = at;\n        var point = Editor.point(editor, path);\n        var [parent] = Editor.parent(editor, path);\n\n        match = n => n === parent;\n\n        height = point.path.length - path.length + 1;\n        at = point;\n        always = true;\n      }\n\n      if (!at) {\n        return;\n      }\n\n      var beforeRef = Editor.pointRef(editor, at, {\n        affinity: 'backward'\n      });\n      var [highest] = Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      });\n\n      if (!highest) {\n        return;\n      }\n\n      var voidMatch = Editor.void(editor, {\n        at,\n        mode: 'highest'\n      });\n      var nudge = 0;\n\n      if (!voids && voidMatch) {\n        var [voidNode, voidPath] = voidMatch;\n\n        if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n          var after = Editor.after(editor, voidPath);\n\n          if (!after) {\n            var text = {\n              text: ''\n            };\n            var afterPath = Path.next(voidPath);\n            Transforms.insertNodes(editor, text, {\n              at: afterPath,\n              voids\n            });\n            after = Editor.point(editor, afterPath);\n          }\n\n          at = after;\n          always = true;\n        }\n\n        var siblingHeight = at.path.length - voidPath.length;\n        height = siblingHeight + 1;\n        always = true;\n      }\n\n      var afterRef = Editor.pointRef(editor, at);\n      var depth = at.path.length - height;\n      var [, highestPath] = highest;\n      var lowestPath = at.path.slice(0, depth);\n      var position = height === 0 ? at.offset : at.path[depth] + nudge;\n\n      for (var [node, _path2] of Editor.levels(editor, {\n        at: lowestPath,\n        reverse: true,\n        voids\n      })) {\n        var split = false;\n\n        if (_path2.length < highestPath.length || _path2.length === 0 || !voids && Editor.isVoid(editor, node)) {\n          break;\n        }\n\n        var _point = beforeRef.current;\n        var isEnd = Editor.isEnd(editor, _point, _path2);\n\n        if (always || !beforeRef || !Editor.isEdge(editor, _point, _path2)) {\n          split = true;\n\n          var properties = _objectWithoutProperties(node, [\"text\", \"children\"]);\n\n          editor.apply({\n            type: 'split_node',\n            path: _path2,\n            position,\n            properties\n          });\n        }\n\n        position = _path2[_path2.length - 1] + (split || isEnd ? 1 : 0);\n      }\n\n      if (options.at == null) {\n        var _point2 = afterRef.current || Editor.end(editor, []);\n\n        Transforms.select(editor, _point2);\n      }\n\n      beforeRef.unref();\n      afterRef.unref();\n    });\n  },\n\n  /**\r\n   * Unset properties on the nodes at a location.\r\n   */\n  unsetNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (!Array.isArray(props)) {\n      props = [props];\n    }\n\n    var obj = {};\n\n    for (var key of props) {\n      obj[key] = null;\n    }\n\n    Transforms.setNodes(editor, obj, options);\n  },\n\n  /**\r\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\r\n   * necessary to ensure that only the content in the range is unwrapped.\r\n   */\n  unwrapNodes(editor, options) {\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        mode = 'lowest',\n        split = false,\n        voids = false\n      } = options;\n      var {\n        at = editor.selection,\n        match\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n\n      var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;\n      var matches = Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      });\n      var pathRefs = Array.from(matches, _ref5 => {\n        var [, p] = _ref5;\n        return Editor.pathRef(editor, p);\n      });\n\n      var _loop = function _loop(pathRef) {\n        var path = pathRef.unref();\n        var [node] = Editor.node(editor, path);\n        var range = Editor.range(editor, path);\n\n        if (split && rangeRef) {\n          range = Range.intersection(rangeRef.current, range);\n        }\n\n        Transforms.liftNodes(editor, {\n          at: range,\n          match: n => node.children.includes(n),\n          voids\n        });\n      };\n\n      for (var pathRef of pathRefs) {\n        _loop(pathRef);\n      }\n\n      if (rangeRef) {\n        rangeRef.unref();\n      }\n    });\n  },\n\n  /**\r\n   * Wrap the nodes at a location in a new container node, splitting the edges\r\n   * of the range first to ensure that only the content in the range is wrapped.\r\n   */\n  wrapNodes(editor, element) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        mode = 'lowest',\n        split = false,\n        voids = false\n      } = options;\n      var {\n        match,\n        at = editor.selection\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          match = matchPath(editor, at);\n        } else if (editor.isInline(element)) {\n          match = n => Editor.isInline(editor, n) || Text.isText(n);\n        } else {\n          match = n => Editor.isBlock(editor, n);\n        }\n      }\n\n      if (split && Range.isRange(at)) {\n        var [start, end] = Range.edges(at);\n        var rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward'\n        });\n        Transforms.splitNodes(editor, {\n          at: end,\n          match,\n          voids\n        });\n        Transforms.splitNodes(editor, {\n          at: start,\n          match,\n          voids\n        });\n        at = rangeRef.unref();\n\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n\n      var roots = Array.from(Editor.nodes(editor, {\n        at,\n        match: editor.isInline(element) ? n => Editor.isBlock(editor, n) : n => Editor.isEditor(n),\n        mode: 'lowest',\n        voids\n      }));\n\n      for (var [, rootPath] of roots) {\n        var a = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;\n\n        if (!a) {\n          continue;\n        }\n\n        var matches = Array.from(Editor.nodes(editor, {\n          at: a,\n          match,\n          mode,\n          voids\n        }));\n\n        if (matches.length > 0) {\n          (function () {\n            var [first] = matches;\n            var last = matches[matches.length - 1];\n            var [, firstPath] = first;\n            var [, lastPath] = last;\n            var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);\n            var range = Editor.range(editor, firstPath, lastPath);\n            var commonNodeEntry = Editor.node(editor, commonPath);\n            var [commonNode] = commonNodeEntry;\n            var depth = commonPath.length + 1;\n            var wrapperPath = Path.next(lastPath.slice(0, depth));\n\n            var wrapper = _objectSpread$6({}, element, {\n              children: []\n            });\n\n            Transforms.insertNodes(editor, wrapper, {\n              at: wrapperPath,\n              voids\n            });\n            Transforms.moveNodes(editor, {\n              at: range,\n              match: n => commonNode.children.includes(n),\n              to: wrapperPath.concat(0),\n              voids\n            });\n          })();\n        }\n      }\n    });\n  }\n\n};\n/**\r\n * Convert a range into a point by deleting it's content.\r\n */\n\nvar deleteRange = (editor, range) => {\n  if (Range.isCollapsed(range)) {\n    return range.anchor;\n  } else {\n    var [, end] = Range.edges(range);\n    var pointRef = Editor.pointRef(editor, end);\n    Transforms.delete(editor, {\n      at: range\n    });\n    return pointRef.unref();\n  }\n};\n\nvar matchPath = (editor, path) => {\n  var [node] = Editor.node(editor, path);\n  return n => n === node;\n};\n\nfunction ownKeys$7(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$7(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$7(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$7(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar SelectionTransforms = {\n  /**\r\n   * Collapse the selection.\r\n   */\n  collapse(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      edge = 'anchor'\n    } = options;\n    var {\n      selection\n    } = editor;\n\n    if (!selection) {\n      return;\n    } else if (edge === 'anchor') {\n      Transforms.select(editor, selection.anchor);\n    } else if (edge === 'focus') {\n      Transforms.select(editor, selection.focus);\n    } else if (edge === 'start') {\n      var [start] = Range.edges(selection);\n      Transforms.select(editor, start);\n    } else if (edge === 'end') {\n      var [, end] = Range.edges(selection);\n      Transforms.select(editor, end);\n    }\n  },\n\n  /**\r\n   * Unset the selection.\r\n   */\n  deselect(editor) {\n    var {\n      selection\n    } = editor;\n\n    if (selection) {\n      editor.apply({\n        type: 'set_selection',\n        properties: selection,\n        newProperties: null\n      });\n    }\n  },\n\n  /**\r\n   * Move the selection's point forward or backward.\r\n   */\n  move(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      selection\n    } = editor;\n    var {\n      distance = 1,\n      unit = 'character',\n      reverse = false\n    } = options;\n    var {\n      edge = null\n    } = options;\n\n    if (!selection) {\n      return;\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n    }\n\n    var {\n      anchor,\n      focus\n    } = selection;\n    var opts = {\n      distance,\n      unit\n    };\n    var props = {};\n\n    if (edge == null || edge === 'anchor') {\n      var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);\n\n      if (point) {\n        props.anchor = point;\n      }\n    }\n\n    if (edge == null || edge === 'focus') {\n      var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);\n\n      if (_point) {\n        props.focus = _point;\n      }\n    }\n\n    Transforms.setSelection(editor, props);\n  },\n\n  /**\r\n   * Set the selection to a new value.\r\n   */\n  select(editor, target) {\n    var {\n      selection\n    } = editor;\n    target = Editor.range(editor, target);\n\n    if (selection) {\n      Transforms.setSelection(editor, target);\n      return;\n    }\n\n    if (!Range.isRange(target)) {\n      throw new Error(\"When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: \".concat(JSON.stringify(target)));\n    }\n\n    editor.apply({\n      type: 'set_selection',\n      properties: selection,\n      newProperties: target\n    });\n  },\n\n  /**\r\n   * Set new properties on one of the selection's points.\r\n   */\n  setPoint(editor, props, options) {\n    var {\n      selection\n    } = editor;\n    var {\n      edge = 'both'\n    } = options;\n\n    if (!selection) {\n      return;\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n    }\n\n    var {\n      anchor,\n      focus\n    } = selection;\n    var point = edge === 'anchor' ? anchor : focus;\n    Transforms.setSelection(editor, {\n      [edge === 'anchor' ? 'anchor' : 'focus']: _objectSpread$7({}, point, {}, props)\n    });\n  },\n\n  /**\r\n   * Set new properties on the selection.\r\n   */\n  setSelection(editor, props) {\n    var {\n      selection\n    } = editor;\n    var oldProps = {};\n    var newProps = {};\n\n    if (!selection) {\n      return;\n    }\n\n    for (var k in props) {\n      if (k === 'anchor' && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === 'focus' && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== 'anchor' && k !== 'focus' && props[k] !== selection[k]) {\n        oldProps[k] = selection[k];\n        newProps[k] = props[k];\n      }\n    }\n\n    if (Object.keys(oldProps).length > 0) {\n      editor.apply({\n        type: 'set_selection',\n        properties: oldProps,\n        newProperties: newProps\n      });\n    }\n  }\n\n};\nvar TextTransforms = {\n  /**\r\n   * Delete content in the editor.\r\n   */\n  delete(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        reverse = false,\n        unit = 'character',\n        distance = 1,\n        voids = false\n      } = options;\n      var {\n        at = editor.selection,\n        hanging = false\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (Range.isRange(at) && Range.isCollapsed(at)) {\n        at = at.anchor;\n      }\n\n      if (Point.isPoint(at)) {\n        var furthestVoid = Editor.void(editor, {\n          at,\n          mode: 'highest'\n        });\n\n        if (!voids && furthestVoid) {\n          var [, voidPath] = furthestVoid;\n          at = voidPath;\n        } else {\n          var opts = {\n            unit,\n            distance\n          };\n          var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);\n          at = {\n            anchor: at,\n            focus: target\n          };\n          hanging = true;\n        }\n      }\n\n      if (Path.isPath(at)) {\n        Transforms.removeNodes(editor, {\n          at,\n          voids\n        });\n        return;\n      }\n\n      if (Range.isCollapsed(at)) {\n        return;\n      }\n\n      if (!hanging) {\n        at = Editor.unhangRange(editor, at, {\n          voids\n        });\n      }\n\n      var [start, end] = Range.edges(at);\n      var startBlock = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: start,\n        voids\n      });\n      var endBlock = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: end,\n        voids\n      });\n      var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n      var isSingleText = Path.equals(start.path, end.path);\n      var startVoid = voids ? null : Editor.void(editor, {\n        at: start,\n        mode: 'highest'\n      });\n      var endVoid = voids ? null : Editor.void(editor, {\n        at: end,\n        mode: 'highest'\n      }); // If the start or end points are inside an inline void, nudge them out.\n\n      if (startVoid) {\n        var before = Editor.before(editor, start);\n\n        if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n          start = before;\n        }\n      }\n\n      if (endVoid) {\n        var after = Editor.after(editor, end);\n\n        if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n          end = after;\n        }\n      } // Get the highest nodes that are completely inside the range, as well as\n      // the start and end nodes.\n\n\n      var matches = [];\n      var lastPath;\n\n      for (var entry of Editor.nodes(editor, {\n        at,\n        voids\n      })) {\n        var [node, path] = entry;\n\n        if (lastPath && Path.compare(path, lastPath) === 0) {\n          continue;\n        }\n\n        if (!voids && Editor.isVoid(editor, node) || !Path.isCommon(path, start.path) && !Path.isCommon(path, end.path)) {\n          matches.push(entry);\n          lastPath = path;\n        }\n      }\n\n      var pathRefs = Array.from(matches, _ref => {\n        var [, p] = _ref;\n        return Editor.pathRef(editor, p);\n      });\n      var startRef = Editor.pointRef(editor, start);\n      var endRef = Editor.pointRef(editor, end);\n\n      if (!isSingleText && !startVoid) {\n        var _point = startRef.current;\n        var [_node] = Editor.leaf(editor, _point);\n        var {\n          path: _path\n        } = _point;\n        var {\n          offset\n        } = start;\n\n        var text = _node.text.slice(offset);\n\n        editor.apply({\n          type: 'remove_text',\n          path: _path,\n          offset,\n          text\n        });\n      }\n\n      for (var pathRef of pathRefs) {\n        var _path2 = pathRef.unref();\n\n        Transforms.removeNodes(editor, {\n          at: _path2,\n          voids\n        });\n      }\n\n      if (!endVoid) {\n        var _point2 = endRef.current;\n        var [_node2] = Editor.leaf(editor, _point2);\n        var {\n          path: _path3\n        } = _point2;\n\n        var _offset = isSingleText ? start.offset : 0;\n\n        var _text = _node2.text.slice(_offset, end.offset);\n\n        editor.apply({\n          type: 'remove_text',\n          path: _path3,\n          offset: _offset,\n          text: _text\n        });\n      }\n\n      if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n        Transforms.mergeNodes(editor, {\n          at: endRef.current,\n          hanging: true,\n          voids\n        });\n      }\n\n      var point = endRef.unref() || startRef.unref();\n\n      if (options.at == null && point) {\n        Transforms.select(editor, point);\n      }\n    });\n  },\n\n  /**\r\n   * Insert a fragment at a specific location in the editor.\r\n   */\n  insertFragment(editor, fragment) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        hanging = false,\n        voids = false\n      } = options;\n      var {\n        at = editor.selection\n      } = options;\n\n      if (!fragment.length) {\n        return;\n      }\n\n      if (!at) {\n        return;\n      } else if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at);\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var [, end] = Range.edges(at);\n\n          if (!voids && Editor.void(editor, {\n            at: end\n          })) {\n            return;\n          }\n\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at\n          });\n          at = pointRef.unref();\n        }\n      } else if (Path.isPath(at)) {\n        at = Editor.start(editor, at);\n      }\n\n      if (!voids && Editor.void(editor, {\n        at\n      })) {\n        return;\n      } // If the insert point is at the edge of an inline node, move it outside\n      // instead since it will need to be split otherwise.\n\n\n      var inlineElementMatch = Editor.above(editor, {\n        at,\n        match: n => Editor.isInline(editor, n),\n        mode: 'highest',\n        voids\n      });\n\n      if (inlineElementMatch) {\n        var [, _inlinePath] = inlineElementMatch;\n\n        if (Editor.isEnd(editor, at, _inlinePath)) {\n          var after = Editor.after(editor, _inlinePath);\n          at = after;\n        } else if (Editor.isStart(editor, at, _inlinePath)) {\n          var before = Editor.before(editor, _inlinePath);\n          at = before;\n        }\n      }\n\n      var blockMatch = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at,\n        voids\n      });\n      var [, blockPath] = blockMatch;\n      var isBlockStart = Editor.isStart(editor, at, blockPath);\n      var isBlockEnd = Editor.isEnd(editor, at, blockPath);\n      var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;\n      var mergeEnd = !isBlockEnd;\n      var [, firstPath] = Node.first({\n        children: fragment\n      }, []);\n      var [, lastPath] = Node.last({\n        children: fragment\n      }, []);\n      var matches = [];\n\n      var matcher = _ref2 => {\n        var [n, p] = _ref2;\n\n        if (mergeStart && Path.isAncestor(p, firstPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n          return false;\n        }\n\n        if (mergeEnd && Path.isAncestor(p, lastPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n          return false;\n        }\n\n        return true;\n      };\n\n      for (var entry of Node.nodes({\n        children: fragment\n      }, {\n        pass: matcher\n      })) {\n        if (entry[1].length > 0 && matcher(entry)) {\n          matches.push(entry);\n        }\n      }\n\n      var starts = [];\n      var middles = [];\n      var ends = [];\n      var starting = true;\n      var hasBlocks = false;\n\n      for (var [node] of matches) {\n        if (Element.isElement(node) && !editor.isInline(node)) {\n          starting = false;\n          hasBlocks = true;\n          middles.push(node);\n        } else if (starting) {\n          starts.push(node);\n        } else {\n          ends.push(node);\n        }\n      }\n\n      var [inlineMatch] = Editor.nodes(editor, {\n        at,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids\n      });\n      var [, inlinePath] = inlineMatch;\n      var isInlineStart = Editor.isStart(editor, at, inlinePath);\n      var isInlineEnd = Editor.isEnd(editor, at, inlinePath);\n      var middleRef = Editor.pathRef(editor, isBlockEnd ? Path.next(blockPath) : blockPath);\n      var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);\n      Transforms.splitNodes(editor, {\n        at,\n        match: n => hasBlocks ? Editor.isBlock(editor, n) : Text.isText(n) || Editor.isInline(editor, n),\n        mode: hasBlocks ? 'lowest' : 'highest',\n        voids\n      });\n      var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);\n      Transforms.insertNodes(editor, starts, {\n        at: startRef.current,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids\n      });\n      Transforms.insertNodes(editor, middles, {\n        at: middleRef.current,\n        match: n => Editor.isBlock(editor, n),\n        mode: 'lowest',\n        voids\n      });\n      Transforms.insertNodes(editor, ends, {\n        at: endRef.current,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids\n      });\n\n      if (!options.at) {\n        var path;\n\n        if (ends.length > 0) {\n          path = Path.previous(endRef.current);\n        } else if (middles.length > 0) {\n          path = Path.previous(middleRef.current);\n        } else {\n          path = Path.previous(startRef.current);\n        }\n\n        var _end = Editor.end(editor, path);\n\n        Transforms.select(editor, _end);\n      }\n\n      startRef.unref();\n      middleRef.unref();\n      endRef.unref();\n    });\n  },\n\n  /**\r\n   * Insert a string of text in the Editor.\r\n   */\n  insertText(editor, text) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        voids = false\n      } = options;\n      var {\n        at = editor.selection\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var end = Range.end(at);\n\n          if (!voids && Editor.void(editor, {\n            at: end\n          })) {\n            return;\n          }\n\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at,\n            voids\n          });\n          at = pointRef.unref();\n          Transforms.setSelection(editor, {\n            anchor: at,\n            focus: at\n          });\n        }\n      }\n\n      if (!voids && Editor.void(editor, {\n        at\n      })) {\n        return;\n      }\n\n      var {\n        path,\n        offset\n      } = at;\n      editor.apply({\n        type: 'insert_text',\n        path,\n        offset,\n        text\n      });\n    });\n  }\n\n};\n\nfunction ownKeys$8(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$8(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$8(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$8(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar Transforms = _objectSpread$8({}, GeneralTransforms, {}, NodeTransforms, {}, SelectionTransforms, {}, TextTransforms);\n\nfunction ownKeys$9(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$9(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$9(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$9(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n/**\r\n * Create a new Slate `Editor` object.\r\n */\n\n\nvar createEditor = () => {\n  var editor = {\n    children: [],\n    operations: [],\n    selection: null,\n    marks: null,\n    isInline: () => false,\n    isVoid: () => false,\n    onChange: () => {},\n    apply: op => {\n      for (var ref of Editor.pathRefs(editor)) {\n        PathRef.transform(ref, op);\n      }\n\n      for (var _ref of Editor.pointRefs(editor)) {\n        PointRef.transform(_ref, op);\n      }\n\n      for (var _ref2 of Editor.rangeRefs(editor)) {\n        RangeRef.transform(_ref2, op);\n      }\n\n      var set = new Set();\n      var dirtyPaths = [];\n\n      var add = path => {\n        if (path) {\n          var key = path.join(',');\n\n          if (!set.has(key)) {\n            set.add(key);\n            dirtyPaths.push(path);\n          }\n        }\n      };\n\n      var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];\n      var newDirtyPaths = getDirtyPaths(op);\n\n      for (var path of oldDirtyPaths) {\n        var newPath = Path.transform(path, op);\n        add(newPath);\n      }\n\n      for (var _path of newDirtyPaths) {\n        add(_path);\n      }\n\n      DIRTY_PATHS.set(editor, dirtyPaths);\n      Editor.transform(editor, op);\n      editor.operations.push(op);\n      Editor.normalize(editor); // Clear any formats applied to the cursor if the selection changes.\n\n      if (op.type === 'set_selection') {\n        editor.marks = null;\n      }\n\n      if (!FLUSHING.get(editor)) {\n        FLUSHING.set(editor, true);\n        Promise.resolve().then(() => {\n          FLUSHING.set(editor, false);\n          editor.onChange();\n          editor.operations = [];\n        });\n      }\n    },\n    addMark: (key, value) => {\n      var {\n        selection\n      } = editor;\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.setNodes(editor, {\n            [key]: value\n          }, {\n            match: Text.isText,\n            split: true\n          });\n        } else {\n          var marks = _objectSpread$9({}, Editor.marks(editor) || {}, {\n            [key]: value\n          });\n\n          editor.marks = marks;\n          editor.onChange();\n        }\n      }\n    },\n    deleteBackward: unit => {\n      var {\n        selection\n      } = editor;\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, {\n          unit,\n          reverse: true\n        });\n      }\n    },\n    deleteForward: unit => {\n      var {\n        selection\n      } = editor;\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, {\n          unit\n        });\n      }\n    },\n    deleteFragment: () => {\n      var {\n        selection\n      } = editor;\n\n      if (selection && Range.isExpanded(selection)) {\n        Transforms.delete(editor);\n      }\n    },\n    getFragment: () => {\n      var {\n        selection\n      } = editor;\n\n      if (selection) {\n        return Node.fragment(editor, selection);\n      }\n\n      return [];\n    },\n    insertBreak: () => {\n      Transforms.splitNodes(editor, {\n        always: true\n      });\n    },\n    insertFragment: fragment => {\n      Transforms.insertFragment(editor, fragment);\n    },\n    insertNode: node => {\n      Transforms.insertNodes(editor, node);\n    },\n    insertText: text => {\n      var {\n        selection,\n        marks\n      } = editor;\n\n      if (selection) {\n        // If the cursor is at the end of an inline, move it outside of\n        // the inline before inserting\n        if (Range.isCollapsed(selection)) {\n          var inline = Editor.above(editor, {\n            match: n => Editor.isInline(editor, n),\n            mode: 'highest'\n          });\n\n          if (inline) {\n            var [, inlinePath] = inline;\n\n            if (Editor.isEnd(editor, selection.anchor, inlinePath)) {\n              var point = Editor.after(editor, inlinePath);\n              Transforms.setSelection(editor, {\n                anchor: point,\n                focus: point\n              });\n            }\n          }\n        }\n\n        if (marks) {\n          var node = _objectSpread$9({\n            text\n          }, marks);\n\n          Transforms.insertNodes(editor, node);\n        } else {\n          Transforms.insertText(editor, text);\n        }\n\n        editor.marks = null;\n      }\n    },\n    normalizeNode: entry => {\n      var [node, path] = entry; // There are no core normalizations for text nodes.\n\n      if (Text.isText(node)) {\n        return;\n      } // Ensure that block and inline nodes have at least one text child.\n\n\n      if (Element.isElement(node) && node.children.length === 0) {\n        var child = {\n          text: ''\n        };\n        Transforms.insertNodes(editor, child, {\n          at: path.concat(0),\n          voids: true\n        });\n        return;\n      } // Determine whether the node should have block or inline children.\n\n\n      var shouldHaveInlines = Editor.isEditor(node) ? false : Element.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0])); // Since we'll be applying operations while iterating, keep track of an\n      // index that accounts for any added/removed nodes.\n\n      var n = 0;\n\n      for (var i = 0; i < node.children.length; i++, n++) {\n        var _child = node.children[i];\n        var prev = node.children[i - 1];\n        var isLast = i === node.children.length - 1;\n        var isInlineOrText = Text.isText(_child) || Element.isElement(_child) && editor.isInline(_child); // Only allow block nodes in the top-level children and parent blocks\n        // that only contain block nodes. Similarly, only allow inline nodes in\n        // other inline nodes, or parent blocks that only contain inlines and\n        // text.\n\n        if (isInlineOrText !== shouldHaveInlines) {\n          Transforms.removeNodes(editor, {\n            at: path.concat(n),\n            voids: true\n          });\n          n--;\n        } else if (Element.isElement(_child)) {\n          // Ensure that inline nodes are surrounded by text nodes.\n          if (editor.isInline(_child)) {\n            if (prev == null || !Text.isText(prev)) {\n              var newChild = {\n                text: ''\n              };\n              Transforms.insertNodes(editor, newChild, {\n                at: path.concat(n),\n                voids: true\n              });\n              n++;\n            } else if (isLast) {\n              var _newChild = {\n                text: ''\n              };\n              Transforms.insertNodes(editor, _newChild, {\n                at: path.concat(n + 1),\n                voids: true\n              });\n              n++;\n            }\n          }\n        } else {\n          // Merge adjacent text nodes that are empty or match.\n          if (prev != null && Text.isText(prev)) {\n            if (Text.equals(_child, prev, {\n              loose: true\n            })) {\n              Transforms.mergeNodes(editor, {\n                at: path.concat(n),\n                voids: true\n              });\n              n--;\n            } else if (prev.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n - 1),\n                voids: true\n              });\n              n--;\n            } else if (isLast && _child.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n),\n                voids: true\n              });\n              n--;\n            }\n          }\n        }\n      }\n    },\n    removeMark: key => {\n      var {\n        selection\n      } = editor;\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.unsetNodes(editor, key, {\n            match: Text.isText,\n            split: true\n          });\n        } else {\n          var marks = _objectSpread$9({}, Editor.marks(editor) || {});\n\n          delete marks[key];\n          editor.marks = marks;\n          editor.onChange();\n        }\n      }\n    }\n  };\n  return editor;\n};\n/**\r\n * Get the \"dirty\" paths generated from an operation.\r\n */\n\n\nvar getDirtyPaths = op => {\n  switch (op.type) {\n    case 'insert_text':\n    case 'remove_text':\n    case 'set_node':\n      {\n        var {\n          path\n        } = op;\n        return Path.levels(path);\n      }\n\n    case 'insert_node':\n      {\n        var {\n          node,\n          path: _path2\n        } = op;\n        var levels = Path.levels(_path2);\n        var descendants = Text.isText(node) ? [] : Array.from(Node.nodes(node), _ref3 => {\n          var [, p] = _ref3;\n          return _path2.concat(p);\n        });\n        return [...levels, ...descendants];\n      }\n\n    case 'merge_node':\n      {\n        var {\n          path: _path3\n        } = op;\n        var ancestors = Path.ancestors(_path3);\n        var previousPath = Path.previous(_path3);\n        return [...ancestors, previousPath];\n      }\n\n    case 'move_node':\n      {\n        var {\n          path: _path4,\n          newPath\n        } = op;\n\n        if (Path.equals(_path4, newPath)) {\n          return [];\n        }\n\n        var oldAncestors = [];\n        var newAncestors = [];\n\n        for (var ancestor of Path.ancestors(_path4)) {\n          var p = Path.transform(ancestor, op);\n          oldAncestors.push(p);\n        }\n\n        for (var _ancestor of Path.ancestors(newPath)) {\n          var _p = Path.transform(_ancestor, op);\n\n          newAncestors.push(_p);\n        }\n\n        return [...oldAncestors, ...newAncestors];\n      }\n\n    case 'remove_node':\n      {\n        var {\n          path: _path5\n        } = op;\n\n        var _ancestors = Path.ancestors(_path5);\n\n        return [..._ancestors];\n      }\n\n    case 'split_node':\n      {\n        var {\n          path: _path6\n        } = op;\n\n        var _levels = Path.levels(_path6);\n\n        var nextPath = Path.next(_path6);\n        return [..._levels, nextPath];\n      }\n\n    default:\n      {\n        return [];\n      }\n  }\n};\n\nexport { Editor, Element, Location, Node, Operation, Path, PathRef, Point, PointRef, Range, RangeRef, Span, Text, Transforms, createEditor };","map":{"version":3,"sources":["../../../node_modules/@babel/runtime/helpers/esm/defineProperty.js","../../../node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","../../../node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","../src/utils/weak-maps.ts","../src/utils/string.ts","../src/interfaces/editor.ts","../src/interfaces/element.ts","../src/interfaces/location.ts","../src/interfaces/node.ts","../src/interfaces/operation.ts","../src/interfaces/path.ts","../src/interfaces/path-ref.ts","../src/interfaces/point.ts","../src/interfaces/point-ref.ts","../src/interfaces/range.ts","../src/interfaces/range-ref.ts","../src/interfaces/text.ts","../src/transforms/general.ts","../src/transforms/node.ts","../src/transforms/selection.ts","../src/transforms/text.ts","../src/transforms/index.ts","../src/create-editor.ts"],"names":["objectWithoutPropertiesLoose","DIRTY_PATHS","FLUSHING","NORMALIZING","PATH_REFS","POINT_REFS","RANGE_REFS","SPACE","PUNCTUATION","CHAMELEON","SURROGATE_START","SURROGATE_END","ZERO_WIDTH_JOINER","getCharacterDistance","text","offset","prev","charCode","isSurrogate","modifier","isModifier","isBMPEmoji","isVariationSelector","getWordDistance","length","i","started","char","l","rest","isWordCharacter","next","remaining","code","Editor","above","options","voids","mode","at","editor","match","path","reverse","Text","Path","addMark","after","anchor","edge","focus","range","distance","d","target","before","deleteBackward","unit","deleteForward","deleteFragment","edges","end","first","fragment","Node","hasBlocks","element","n","hasInlines","hasTexts","insertBreak","insertFragment","insertNode","insertText","isBlock","Element","isEditor","isPlainObject","value","Range","Operation","isEnd","Point","isEdge","isEmpty","children","isInline","isNormalizing","isStart","point","start","isVoid","last","leaf","node","levels","marks","selection","isText","block","span","parent","universal","Span","from","to","iterable","pass","matches","isLower","hit","emit","normalize","force","getDirtyPaths","allPaths","max","m","entry","parentPath","depth","pathRef","affinity","ref","current","unref","pathRefs","refs","pointRef","pointRefs","string","available","isNewBlock","advance","e","s","reverseText","isFirst","previous","rangeRef","rangeRefs","removeMark","t","transform","createDraft","op","index","prevPath","newPath","truePath","newParent","newIndex","result","newProperties","key","JSON","Object","properties","newNode","finishDraft","isDraft","unhangRange","endBlock","blockPath","skip","void","withoutNormalizing","fn","isElement","isElementList","Array","props","Location","isLocation","isSpan","ancestor","child","c","root","childPath","common","p","descendant","newRoot","produce","r","get","has","isNode","isNodeList","visited","nextIndex","isNodeOperation","isOperation","isOperationList","isSelectionOperation","isTextOperation","inverse","type","inversePath","inverseNewPath","ancestors","paths","another","av","bv","compare","min","Math","endsAfter","as","bs","endsAt","endsBefore","equals","isAfter","isAncestor","isBefore","isChild","isCommon","isDescendant","isParent","isPath","isSibling","al","bl","list","relative","operation","position","onp","copy","PathRef","isPoint","PointRef","includes","isAfterStart","isBeforeEnd","intersection","isBackward","isCollapsed","isExpanded","isForward","isRange","affinityAnchor","affinityFocus","RangeRef","loose","isTextList","decorations","leaves","o","middle","off","GeneralTransforms","NodeTransforms","insertNodes","hanging","select","nodes","Transforms","isAtEnd","liftNodes","matchPath","parentNodeEntry","toPath","splitPath","mergeNodes","commonPath","isPreviousSibling","emptyAncestor","emptyRef","prevNode","moveNodes","toRef","targets","removeNodes","depths","setNodes","split","splitMode","k","splitNodes","height","always","deleteRange","beforeRef","voidMatch","nudge","afterPath","siblingHeight","voidPath","afterRef","lowestPath","highestPath","unsetNodes","obj","unwrapNodes","wrapNodes","roots","a","commonNodeEntry","wrapperPath","lastPath","wrapper","commonNode","SelectionTransforms","collapse","deselect","move","opts","setPoint","setSelection","oldProps","newProps","TextTransforms","delete","furthestVoid","startBlock","isAcrossBlocks","isSingleText","startVoid","endVoid","startRef","endRef","inlineElementMatch","blockMatch","isBlockStart","isBlockEnd","mergeStart","mergeEnd","matcher","starts","middles","ends","starting","isInlineStart","isInlineEnd","middleRef","createEditor","operations","onChange","apply","set","dirtyPaths","add","oldDirtyPaths","newDirtyPaths","Promise","getFragment","inline","normalizeNode","shouldHaveInlines","isLast","isInlineOrText","newChild","descendants","previousPath","oldAncestors","newAncestors","nextPath"],"mappings":"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","sourcesContent":["export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}","import objectWithoutPropertiesLoose from \"./objectWithoutPropertiesLoose\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}","import { Editor, Path, PathRef, PointRef, RangeRef } from '..'\n\nexport const DIRTY_PATHS: WeakMap<Editor, Path[]> = new WeakMap()\nexport const FLUSHING: WeakMap<Editor, boolean> = new WeakMap()\nexport const NORMALIZING: WeakMap<Editor, boolean> = new WeakMap()\nexport const PATH_REFS: WeakMap<Editor, Set<PathRef>> = new WeakMap()\nexport const POINT_REFS: WeakMap<Editor, Set<PointRef>> = new WeakMap()\nexport const RANGE_REFS: WeakMap<Editor, Set<RangeRef>> = new WeakMap()\n","/**\n * Constants for string distance checking.\n */\n\nconst SPACE = /\\s/\nconst PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\nconst CHAMELEON = /['\\u2018\\u2019]/\nconst SURROGATE_START = 0xd800\nconst SURROGATE_END = 0xdfff\nconst ZERO_WIDTH_JOINER = 0x200d\n\n/**\n * Get the distance to the end of the first character in a string of text.\n */\n\nexport const getCharacterDistance = (text: string): number => {\n  let offset = 0\n  // prev types:\n  // SURR: surrogate pair\n  // MOD: modifier (technically also surrogate pair)\n  // ZWJ: zero width joiner\n  // VAR: variation selector\n  // BMP: sequenceable character from basic multilingual plane\n  let prev: 'SURR' | 'MOD' | 'ZWJ' | 'VAR' | 'BMP' | null = null\n  let charCode = text.charCodeAt(0)\n\n  while (charCode) {\n    if (isSurrogate(charCode)) {\n      const modifier = isModifier(charCode, text, offset)\n\n      // Early returns are the heart of this function, where we decide if previous and current\n      // codepoints should form a single character (in terms of how many of them should selection\n      // jump over).\n      if (prev === 'SURR' || prev === 'BMP') {\n        break\n      }\n\n      offset += 2\n      prev = modifier ? 'MOD' : 'SURR'\n      charCode = text.charCodeAt(offset)\n      // Absolutely fine to `continue` without any checks because if `charCode` is NaN (which\n      // is the case when out of `text` range), next `while` loop won\"t execute and we\"re done.\n      continue\n    }\n\n    if (charCode === ZERO_WIDTH_JOINER) {\n      offset += 1\n      prev = 'ZWJ'\n      charCode = text.charCodeAt(offset)\n\n      continue\n    }\n\n    if (isBMPEmoji(charCode)) {\n      if (prev && prev !== 'ZWJ' && prev !== 'VAR') {\n        break\n      }\n      offset += 1\n      prev = 'BMP'\n      charCode = text.charCodeAt(offset)\n\n      continue\n    }\n\n    if (isVariationSelector(charCode)) {\n      if (prev && prev !== 'ZWJ') {\n        break\n      }\n      offset += 1\n      prev = 'VAR'\n      charCode = text.charCodeAt(offset)\n      continue\n    }\n\n    // Modifier 'groups up' with what ever character is before that (even whitespace), need to\n    // look ahead.\n    if (prev === 'MOD') {\n      offset += 1\n      break\n    }\n\n    // If while loop ever gets here, we're done (e.g latin chars).\n    break\n  }\n\n  return offset || 1\n}\n\n/**\n * Get the distance to the end of the first word in a string of text.\n */\n\nexport const getWordDistance = (text: string): number => {\n  let length = 0\n  let i = 0\n  let started = false\n  let char\n\n  while ((char = text.charAt(i))) {\n    const l = getCharacterDistance(char)\n    char = text.slice(i, i + l)\n    const rest = text.slice(i + l)\n\n    if (isWordCharacter(char, rest)) {\n      started = true\n      length += l\n    } else if (!started) {\n      length += l\n    } else {\n      break\n    }\n\n    i += l\n  }\n\n  return length\n}\n\n/**\n * Check if a character is a word character. The `remaining` argument is used\n * because sometimes you must read subsequent characters to truly determine it.\n */\n\nconst isWordCharacter = (char: string, remaining: string): boolean => {\n  if (SPACE.test(char)) {\n    return false\n  }\n\n  // Chameleons count as word characters as long as they're in a word, so\n  // recurse to see if the next one is a word character or not.\n  if (CHAMELEON.test(char)) {\n    let next = remaining.charAt(0)\n    const length = getCharacterDistance(next)\n    next = remaining.slice(0, length)\n    const rest = remaining.slice(length)\n\n    if (isWordCharacter(next, rest)) {\n      return true\n    }\n  }\n\n  if (PUNCTUATION.test(char)) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Determines if `code` is a surrogate\n */\n\nconst isSurrogate = (code: number): boolean =>\n  SURROGATE_START <= code && code <= SURROGATE_END\n\n/**\n * Does `code` form Modifier with next one.\n *\n * https://emojipedia.org/modifiers/\n */\n\nconst isModifier = (code: number, text: string, offset: number): boolean => {\n  if (code === 0xd83c) {\n    const next = text.charCodeAt(offset + 1)\n    return next <= 0xdfff && next >= 0xdffb\n  }\n  return false\n}\n\n/**\n * Is `code` a Variation Selector.\n *\n * https://codepoints.net/variation_selectors\n */\n\nconst isVariationSelector = (code: number): boolean => {\n  return code <= 0xfe0f && code >= 0xfe00\n}\n\n/**\n * Is `code` one of the BMP codes used in emoji sequences.\n *\n * https://emojipedia.org/emoji-zwj-sequences/\n */\n\nconst isBMPEmoji = (code: number): boolean => {\n  // This requires tiny bit of maintanance, better ideas?\n  // Fortunately it only happens if new Unicode Standard\n  // is released. Fails gracefully if upkeep lags behind,\n  // same way Slate previously behaved with all emojis.\n  return (\n    code === 0x2764 || // heart (❤)\n    code === 0x2642 || // male (♂)\n    code === 0x2640 || // female (♀)\n    code === 0x2620 || // scull (☠)\n    code === 0x2695 || // medical (⚕)\n    code === 0x2708 || // plane (✈️)\n    code === 0x25ef // large circle (◯)\n  )\n}\n","import isPlainObject from 'is-plain-object'\nimport { createDraft, finishDraft, isDraft } from 'immer'\nimport { reverse as reverseText } from 'esrever'\n\nimport {\n  Ancestor,\n  Descendant,\n  Element,\n  Location,\n  Node,\n  NodeEntry,\n  Operation,\n  Path,\n  PathRef,\n  Point,\n  PointRef,\n  Range,\n  RangeRef,\n  Span,\n  Text,\n} from '..'\nimport {\n  DIRTY_PATHS,\n  NORMALIZING,\n  PATH_REFS,\n  POINT_REFS,\n  RANGE_REFS,\n} from '../utils/weak-maps'\nimport { getWordDistance, getCharacterDistance } from '../utils/string'\n\n/**\n * The `Editor` interface stores all the state of a Slate editor. It is extended\n * by plugins that wish to add their own helpers and implement new behaviors.\n */\n\nexport interface Editor {\n  children: Node[]\n  selection: Range | null\n  operations: Operation[]\n  marks: Record<string, any> | null\n  [key: string]: unknown\n\n  // Schema-specific node behaviors.\n  isInline: (element: Element) => boolean\n  isVoid: (element: Element) => boolean\n  normalizeNode: (entry: NodeEntry) => void\n  onChange: () => void\n\n  // Overrideable core actions.\n  addMark: (key: string, value: any) => void\n  apply: (operation: Operation) => void\n  deleteBackward: (unit: 'character' | 'word' | 'line' | 'block') => void\n  deleteForward: (unit: 'character' | 'word' | 'line' | 'block') => void\n  deleteFragment: () => void\n  getFragment: () => Descendant[]\n  insertBreak: () => void\n  insertFragment: (fragment: Node[]) => void\n  insertNode: (node: Node) => void\n  insertText: (text: string) => void\n  removeMark: (key: string) => void\n}\n\nexport const Editor = {\n  /**\n   * Get the ancestor above a location in the document.\n   */\n\n  above<T extends Ancestor>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<T> | undefined {\n    const {\n      voids = false,\n      mode = 'lowest',\n      at = editor.selection,\n      match,\n    } = options\n\n    if (!at) {\n      return\n    }\n\n    const path = Editor.path(editor, at)\n    const reverse = mode === 'lowest'\n\n    for (const [n, p] of Editor.levels(editor, {\n      at: path,\n      voids,\n      match,\n      reverse,\n    })) {\n      if (!Text.isText(n) && !Path.equals(path, p)) {\n        return [n, p]\n      }\n    }\n  },\n\n  /**\n   * Add a custom property to the leaf text nodes in the current selection.\n   *\n   * If the selection is currently collapsed, the marks will be added to the\n   * `editor.marks` property instead, and applied when text is inserted next.\n   */\n\n  addMark(editor: Editor, key: string, value: any): void {\n    editor.addMark(key, value)\n  },\n\n  /**\n   * Get the point after a location.\n   */\n\n  after(\n    editor: Editor,\n    at: Location,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n    } = {}\n  ): Point | undefined {\n    const anchor = Editor.point(editor, at, { edge: 'end' })\n    const focus = Editor.end(editor, [])\n    const range = { anchor, focus }\n    const { distance = 1 } = options\n    let d = 0\n    let target\n\n    for (const p of Editor.positions(editor, { ...options, at: range })) {\n      if (d > distance) {\n        break\n      }\n\n      if (d !== 0) {\n        target = p\n      }\n\n      d++\n    }\n\n    return target\n  },\n\n  /**\n   * Get the point before a location.\n   */\n\n  before(\n    editor: Editor,\n    at: Location,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n    } = {}\n  ): Point | undefined {\n    const anchor = Editor.start(editor, [])\n    const focus = Editor.point(editor, at, { edge: 'start' })\n    const range = { anchor, focus }\n    const { distance = 1 } = options\n    let d = 0\n    let target\n\n    for (const p of Editor.positions(editor, {\n      ...options,\n      at: range,\n      reverse: true,\n    })) {\n      if (d > distance) {\n        break\n      }\n\n      if (d !== 0) {\n        target = p\n      }\n\n      d++\n    }\n\n    return target\n  },\n\n  /**\n   * Delete content in the editor backward from the current selection.\n   */\n\n  deleteBackward(\n    editor: Editor,\n    options: {\n      unit?: 'character' | 'word' | 'line' | 'block'\n    } = {}\n  ): void {\n    const { unit = 'character' } = options\n    editor.deleteBackward(unit)\n  },\n\n  /**\n   * Delete content in the editor forward from the current selection.\n   */\n\n  deleteForward(\n    editor: Editor,\n    options: {\n      unit?: 'character' | 'word' | 'line' | 'block'\n    } = {}\n  ): void {\n    const { unit = 'character' } = options\n    editor.deleteForward(unit)\n  },\n\n  /**\n   * Delete the content in the current selection.\n   */\n\n  deleteFragment(editor: Editor): void {\n    editor.deleteFragment()\n  },\n\n  /**\n   * Get the start and end points of a location.\n   */\n\n  edges(editor: Editor, at: Location): [Point, Point] {\n    return [Editor.start(editor, at), Editor.end(editor, at)]\n  },\n\n  /**\n   * Get the end point of a location.\n   */\n\n  end(editor: Editor, at: Location): Point {\n    return Editor.point(editor, at, { edge: 'end' })\n  },\n\n  /**\n   * Get the first node at a location.\n   */\n\n  first(editor: Editor, at: Location): NodeEntry {\n    const path = Editor.path(editor, at, { edge: 'start' })\n    return Editor.node(editor, path)\n  },\n\n  /**\n   * Get the fragment at a location.\n   */\n\n  fragment(editor: Editor, at: Location): Descendant[] {\n    const range = Editor.range(editor, at)\n    const fragment = Node.fragment(editor, range)\n    return fragment\n  },\n  /**\n   * Check if a node has block children.\n   */\n\n  hasBlocks(editor: Editor, element: Element): boolean {\n    return element.children.some(n => Editor.isBlock(editor, n))\n  },\n\n  /**\n   * Check if a node has inline and text children.\n   */\n\n  hasInlines(editor: Editor, element: Element): boolean {\n    return element.children.some(\n      n => Text.isText(n) || Editor.isInline(editor, n)\n    )\n  },\n\n  /**\n   * Check if a node has text children.\n   */\n\n  hasTexts(editor: Editor, element: Element): boolean {\n    return element.children.every(n => Text.isText(n))\n  },\n\n  /**\n   * Insert a block break at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertBreak(editor: Editor): void {\n    editor.insertBreak()\n  },\n\n  /**\n   * Insert a fragment at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertFragment(editor: Editor, fragment: Node[]): void {\n    editor.insertFragment(fragment)\n  },\n\n  /**\n   * Insert a node at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertNode(editor: Editor, node: Node): void {\n    editor.insertNode(node)\n  },\n\n  /**\n   * Insert text at the current selection.\n   *\n   * If the selection is currently expanded, it will be deleted first.\n   */\n\n  insertText(editor: Editor, text: string): void {\n    editor.insertText(text)\n  },\n\n  /**\n   * Check if a value is a block `Element` object.\n   */\n\n  isBlock(editor: Editor, value: any): value is Element {\n    return Element.isElement(value) && !editor.isInline(value)\n  },\n\n  /**\n   * Check if a value is an `Editor` object.\n   */\n\n  isEditor(value: any): value is Editor {\n    return (\n      isPlainObject(value) &&\n      typeof value.addMark === 'function' &&\n      typeof value.apply === 'function' &&\n      typeof value.deleteBackward === 'function' &&\n      typeof value.deleteForward === 'function' &&\n      typeof value.deleteFragment === 'function' &&\n      typeof value.insertBreak === 'function' &&\n      typeof value.insertFragment === 'function' &&\n      typeof value.insertNode === 'function' &&\n      typeof value.insertText === 'function' &&\n      typeof value.isInline === 'function' &&\n      typeof value.isVoid === 'function' &&\n      typeof value.normalizeNode === 'function' &&\n      typeof value.onChange === 'function' &&\n      typeof value.removeMark === 'function' &&\n      (value.marks === null || isPlainObject(value.marks)) &&\n      (value.selection === null || Range.isRange(value.selection)) &&\n      Node.isNodeList(value.children) &&\n      Operation.isOperationList(value.operations)\n    )\n  },\n\n  /**\n   * Check if a point is the end point of a location.\n   */\n\n  isEnd(editor: Editor, point: Point, at: Location): boolean {\n    const end = Editor.end(editor, at)\n    return Point.equals(point, end)\n  },\n\n  /**\n   * Check if a point is an edge of a location.\n   */\n\n  isEdge(editor: Editor, point: Point, at: Location): boolean {\n    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at)\n  },\n\n  /**\n   * Check if an element is empty, accounting for void nodes.\n   */\n\n  isEmpty(editor: Editor, element: Element): boolean {\n    const { children } = element\n    const [first] = children\n    return (\n      children.length === 0 ||\n      (children.length === 1 &&\n        Text.isText(first) &&\n        first.text === '' &&\n        !editor.isVoid(element))\n    )\n  },\n\n  /**\n   * Check if a value is an inline `Element` object.\n   */\n\n  isInline(editor: Editor, value: any): value is Element {\n    return Element.isElement(value) && editor.isInline(value)\n  },\n\n  /**\n   * Check if the editor is currently normalizing after each operation.\n   */\n\n  isNormalizing(editor: Editor): boolean {\n    const isNormalizing = NORMALIZING.get(editor)\n    return isNormalizing === undefined ? true : isNormalizing\n  },\n\n  /**\n   * Check if a point is the start point of a location.\n   */\n\n  isStart(editor: Editor, point: Point, at: Location): boolean {\n    // PERF: If the offset isn't `0` we know it's not the start.\n    if (point.offset !== 0) {\n      return false\n    }\n\n    const start = Editor.start(editor, at)\n    return Point.equals(point, start)\n  },\n\n  /**\n   * Check if a value is a void `Element` object.\n   */\n\n  isVoid(editor: Editor, value: any): value is Element {\n    return Element.isElement(value) && editor.isVoid(value)\n  },\n\n  /**\n   * Get the last node at a location.\n   */\n\n  last(editor: Editor, at: Location): NodeEntry {\n    const path = Editor.path(editor, at, { edge: 'end' })\n    return Editor.node(editor, path)\n  },\n\n  /**\n   * Get the leaf text node at a location.\n   */\n\n  leaf(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): NodeEntry<Text> {\n    const path = Editor.path(editor, at, options)\n    const node = Node.leaf(editor, path)\n    return [node, path]\n  },\n\n  /**\n   * Iterate through all of the levels at a location.\n   */\n\n  *levels<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      reverse?: boolean\n      voids?: boolean\n    } = {}\n  ): Iterable<NodeEntry<T>> {\n    const { at = editor.selection, reverse = false, voids = false } = options\n    let { match } = options\n\n    if (match == null) {\n      match = () => true\n    }\n\n    if (!at) {\n      return\n    }\n\n    const levels: NodeEntry<T>[] = []\n    const path = Editor.path(editor, at)\n\n    for (const [n, p] of Node.levels(editor, path)) {\n      if (!match(n)) {\n        continue\n      }\n\n      levels.push([n, p])\n\n      if (!voids && Editor.isVoid(editor, n)) {\n        break\n      }\n    }\n\n    if (reverse) {\n      levels.reverse()\n    }\n\n    yield* levels\n  },\n\n  /**\n   * Get the marks that would be added to text at the current selection.\n   */\n\n  marks(editor: Editor): Record<string, any> | null {\n    const { marks, selection } = editor\n\n    if (!selection) {\n      return null\n    }\n\n    if (marks) {\n      return marks\n    }\n\n    if (Range.isExpanded(selection)) {\n      const [match] = Editor.nodes(editor, { match: Text.isText })\n\n      if (match) {\n        const [node] = match as NodeEntry<Text>\n        const { text, ...rest } = node\n        return rest\n      } else {\n        return {}\n      }\n    }\n\n    const { anchor } = selection\n    const { path } = anchor\n    let [node] = Editor.leaf(editor, path)\n\n    if (anchor.offset === 0) {\n      const prev = Editor.previous(editor, { at: path, match: Text.isText })\n      const block = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n      })\n\n      if (prev && block) {\n        const [prevNode, prevPath] = prev\n        const [, blockPath] = block\n\n        if (Path.isAncestor(blockPath, prevPath)) {\n          node = prevNode as Text\n        }\n      }\n    }\n\n    const { text, ...rest } = node\n    return rest\n  },\n\n  /**\n   * Get the matching node in the branch of the document after a location.\n   */\n\n  next<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<T> | undefined {\n    const { mode = 'lowest', voids = false } = options\n    let { match, at = editor.selection } = options\n\n    if (!at) {\n      return\n    }\n\n    const [, from] = Editor.last(editor, at)\n    const [, to] = Editor.last(editor, [])\n    const span: Span = [from, to]\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(`Cannot get the next node from the root node!`)\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        const [parent] = Editor.parent(editor, at)\n        match = n => parent.children.includes(n)\n      } else {\n        match = () => true\n      }\n    }\n\n    const [, next] = Editor.nodes(editor, { at: span, match, mode, voids })\n    return next\n  },\n\n  /**\n   * Get the node at a location.\n   */\n\n  node(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): NodeEntry {\n    const path = Editor.path(editor, at, options)\n    const node = Node.get(editor, path)\n    return [node, path]\n  },\n\n  /**\n   * Iterate through all of the nodes in the Editor.\n   */\n\n  *nodes<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location | Span\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      universal?: boolean\n      reverse?: boolean\n      voids?: boolean\n    } = {}\n  ): Iterable<NodeEntry<T>> {\n    const {\n      at = editor.selection,\n      mode = 'all',\n      universal = false,\n      reverse = false,\n      voids = false,\n    } = options\n    let { match } = options\n\n    if (!match) {\n      match = () => true\n    }\n\n    if (!at) {\n      return\n    }\n\n    let from\n    let to\n\n    if (Span.isSpan(at)) {\n      from = at[0]\n      to = at[1]\n    } else {\n      const first = Editor.path(editor, at, { edge: 'start' })\n      const last = Editor.path(editor, at, { edge: 'end' })\n      from = reverse ? last : first\n      to = reverse ? first : last\n    }\n\n    const iterable = Node.nodes(editor, {\n      reverse,\n      from,\n      to,\n      pass: ([n]) => (voids ? false : Editor.isVoid(editor, n)),\n    })\n\n    const matches: NodeEntry<T>[] = []\n    let hit: NodeEntry<T> | undefined\n\n    for (const [node, path] of iterable) {\n      const isLower = hit && Path.compare(path, hit[1]) === 0\n\n      // In highest mode any node lower than the last hit is not a match.\n      if (mode === 'highest' && isLower) {\n        continue\n      }\n\n      if (!match(node)) {\n        // If we've arrived at a leaf text node that is not lower than the last\n        // hit, then we've found a branch that doesn't include a match, which\n        // means the match is not universal.\n        if (universal && !isLower && Text.isText(node)) {\n          return\n        } else {\n          continue\n        }\n      }\n\n      // If there's a match and it's lower than the last, update the hit.\n      if (mode === 'lowest' && isLower) {\n        hit = [node, path]\n        continue\n      }\n\n      // In lowest mode we emit the last hit, once it's guaranteed lowest.\n      const emit: NodeEntry<T> | undefined =\n        mode === 'lowest' ? hit : [node, path]\n\n      if (emit) {\n        if (universal) {\n          matches.push(emit)\n        } else {\n          yield emit\n        }\n      }\n\n      hit = [node, path]\n    }\n\n    // Since lowest is always emitting one behind, catch up at the end.\n    if (mode === 'lowest' && hit) {\n      if (universal) {\n        matches.push(hit)\n      } else {\n        yield hit\n      }\n    }\n\n    // Universal defers to ensure that the match occurs in every branch, so we\n    // yield all of the matches after iterating.\n    if (universal) {\n      yield* matches\n    }\n  },\n  /**\n   * Normalize any dirty objects in the editor.\n   */\n\n  normalize(\n    editor: Editor,\n    options: {\n      force?: boolean\n    } = {}\n  ) {\n    const { force = false } = options\n    const getDirtyPaths = (editor: Editor) => {\n      return DIRTY_PATHS.get(editor) || []\n    }\n\n    if (!Editor.isNormalizing(editor)) {\n      return\n    }\n\n    if (force) {\n      const allPaths = Array.from(Node.nodes(editor), ([, p]) => p)\n      DIRTY_PATHS.set(editor, allPaths)\n    }\n\n    if (getDirtyPaths(editor).length === 0) {\n      return\n    }\n\n    Editor.withoutNormalizing(editor, () => {\n      const max = getDirtyPaths(editor).length * 42 // HACK: better way?\n      let m = 0\n\n      while (getDirtyPaths(editor).length !== 0) {\n        if (m > max) {\n          throw new Error(`\n            Could not completely normalize the editor after ${max} iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\n          `)\n        }\n\n        const path = getDirtyPaths(editor).pop()!\n        const entry = Editor.node(editor, path)\n        editor.normalizeNode(entry)\n        m++\n      }\n    })\n  },\n\n  /**\n   * Get the parent node of a location.\n   */\n\n  parent(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): NodeEntry<Ancestor> {\n    const path = Editor.path(editor, at, options)\n    const parentPath = Path.parent(path)\n    const entry = Editor.node(editor, parentPath)\n    return entry as NodeEntry<Ancestor>\n  },\n\n  /**\n   * Get the path of a location.\n   */\n\n  path(\n    editor: Editor,\n    at: Location,\n    options: {\n      depth?: number\n      edge?: 'start' | 'end'\n    } = {}\n  ): Path {\n    const { depth, edge } = options\n\n    if (Path.isPath(at)) {\n      if (edge === 'start') {\n        const [, firstPath] = Node.first(editor, at)\n        at = firstPath\n      } else if (edge === 'end') {\n        const [, lastPath] = Node.last(editor, at)\n        at = lastPath\n      }\n    }\n\n    if (Range.isRange(at)) {\n      if (edge === 'start') {\n        at = Range.start(at)\n      } else if (edge === 'end') {\n        at = Range.end(at)\n      } else {\n        at = Path.common(at.anchor.path, at.focus.path)\n      }\n    }\n\n    if (Point.isPoint(at)) {\n      at = at.path\n    }\n\n    if (depth != null) {\n      at = at.slice(0, depth)\n    }\n\n    return at\n  },\n\n  /**\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n\n  pathRef(\n    editor: Editor,\n    path: Path,\n    options: {\n      affinity?: 'backward' | 'forward' | null\n    } = {}\n  ): PathRef {\n    const { affinity = 'forward' } = options\n    const ref: PathRef = {\n      current: path,\n      affinity,\n      unref() {\n        const { current } = ref\n        const pathRefs = Editor.pathRefs(editor)\n        pathRefs.delete(ref)\n        ref.current = null\n        return current\n      },\n    }\n\n    const refs = Editor.pathRefs(editor)\n    refs.add(ref)\n    return ref\n  },\n\n  /**\n   * Get the set of currently tracked path refs of the editor.\n   */\n\n  pathRefs(editor: Editor): Set<PathRef> {\n    let refs = PATH_REFS.get(editor)\n\n    if (!refs) {\n      refs = new Set()\n      PATH_REFS.set(editor, refs)\n    }\n\n    return refs\n  },\n\n  /**\n   * Get the start or end point of a location.\n   */\n\n  point(\n    editor: Editor,\n    at: Location,\n    options: {\n      edge?: 'start' | 'end'\n    } = {}\n  ): Point {\n    const { edge = 'start' } = options\n\n    if (Path.isPath(at)) {\n      let path\n\n      if (edge === 'end') {\n        const [, lastPath] = Node.last(editor, at)\n        path = lastPath\n      } else {\n        const [, firstPath] = Node.first(editor, at)\n        path = firstPath\n      }\n\n      const node = Node.get(editor, path)\n\n      if (!Text.isText(node)) {\n        throw new Error(\n          `Cannot get the ${edge} point in the node at path [${at}] because it has no ${edge} text node.`\n        )\n      }\n\n      return { path, offset: edge === 'end' ? node.text.length : 0 }\n    }\n\n    if (Range.isRange(at)) {\n      const [start, end] = Range.edges(at)\n      return edge === 'start' ? start : end\n    }\n\n    return at\n  },\n\n  /**\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n\n  pointRef(\n    editor: Editor,\n    point: Point,\n    options: {\n      affinity?: 'backward' | 'forward' | null\n    } = {}\n  ): PointRef {\n    const { affinity = 'forward' } = options\n    const ref: PointRef = {\n      current: point,\n      affinity,\n      unref() {\n        const { current } = ref\n        const pointRefs = Editor.pointRefs(editor)\n        pointRefs.delete(ref)\n        ref.current = null\n        return current\n      },\n    }\n\n    const refs = Editor.pointRefs(editor)\n    refs.add(ref)\n    return ref\n  },\n\n  /**\n   * Get the set of currently tracked point refs of the editor.\n   */\n\n  pointRefs(editor: Editor): Set<PointRef> {\n    let refs = POINT_REFS.get(editor)\n\n    if (!refs) {\n      refs = new Set()\n      POINT_REFS.set(editor, refs)\n    }\n\n    return refs\n  },\n\n  /**\n   * Iterate through all of the positions in the document where a `Point` can be\n   * placed.\n   *\n   * By default it will move forward by individual offsets at a time,  but you\n   * can pass the `unit: 'character'` option to moved forward one character, word,\n   * or line at at time.\n   *\n   * Note: void nodes are treated as a single point, and iteration will not\n   * happen inside their content.\n   */\n\n  *positions(\n    editor: Editor,\n    options: {\n      at?: Location\n      unit?: 'offset' | 'character' | 'word' | 'line' | 'block'\n      reverse?: boolean\n    } = {}\n  ): Iterable<Point> {\n    const { at = editor.selection, unit = 'offset', reverse = false } = options\n\n    if (!at) {\n      return\n    }\n\n    const range = Editor.range(editor, at)\n    const [start, end] = Range.edges(range)\n    const first = reverse ? end : start\n    let string = ''\n    let available = 0\n    let offset = 0\n    let distance: number | null = null\n    let isNewBlock = false\n\n    const advance = () => {\n      if (distance == null) {\n        if (unit === 'character') {\n          distance = getCharacterDistance(string)\n        } else if (unit === 'word') {\n          distance = getWordDistance(string)\n        } else if (unit === 'line' || unit === 'block') {\n          distance = string.length\n        } else {\n          distance = 1\n        }\n\n        string = string.slice(distance)\n      }\n\n      // Add or substract the offset.\n      offset = reverse ? offset - distance : offset + distance\n      // Subtract the distance traveled from the available text.\n      available = available - distance!\n      // If the available had room to spare, reset the distance so that it will\n      // advance again next time. Otherwise, set it to the overflow amount.\n      distance = available >= 0 ? null : 0 - available\n    }\n\n    for (const [node, path] of Editor.nodes(editor, { at, reverse })) {\n      if (Element.isElement(node)) {\n        // Void nodes are a special case, since we don't want to iterate over\n        // their content. We instead always just yield their first point.\n        if (editor.isVoid(node)) {\n          yield Editor.start(editor, path)\n          continue\n        }\n\n        if (editor.isInline(node)) {\n          continue\n        }\n\n        if (Editor.hasInlines(editor, node)) {\n          const e = Path.isAncestor(path, end.path)\n            ? end\n            : Editor.end(editor, path)\n          const s = Path.isAncestor(path, start.path)\n            ? start\n            : Editor.start(editor, path)\n\n          const text = Editor.string(editor, { anchor: s, focus: e })\n          string = reverse ? reverseText(text) : text\n          isNewBlock = true\n        }\n      }\n\n      if (Text.isText(node)) {\n        const isFirst = Path.equals(path, first.path)\n        available = node.text.length\n        offset = reverse ? available : 0\n\n        if (isFirst) {\n          available = reverse ? first.offset : available - first.offset\n          offset = first.offset\n        }\n\n        if (isFirst || isNewBlock || unit === 'offset') {\n          yield { path, offset }\n        }\n\n        while (true) {\n          // If there's no more string, continue to the next block.\n          if (string === '') {\n            break\n          } else {\n            advance()\n          }\n\n          // If the available space hasn't overflow, we have another point to\n          // yield in the current text node.\n          if (available >= 0) {\n            yield { path, offset }\n          } else {\n            break\n          }\n        }\n\n        isNewBlock = false\n      }\n    }\n  },\n\n  /**\n   * Get the matching node in the branch of the document before a location.\n   */\n\n  previous<T extends Node>(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: NodeMatch<T>\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<T> | undefined {\n    const { mode = 'lowest', voids = false } = options\n    let { match, at = editor.selection } = options\n\n    if (!at) {\n      return\n    }\n\n    const [, from] = Editor.first(editor, at)\n    const [, to] = Editor.first(editor, [])\n    const span: Span = [from, to]\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(`Cannot get the previous node from the root node!`)\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        const [parent] = Editor.parent(editor, at)\n        match = n => parent.children.includes(n)\n      } else {\n        match = () => true\n      }\n    }\n\n    const [, previous] = Editor.nodes(editor, {\n      reverse: true,\n      at: span,\n      match,\n      mode,\n      voids,\n    })\n\n    return previous\n  },\n\n  /**\n   * Get a range of a location.\n   */\n\n  range(editor: Editor, at: Location, to?: Location): Range {\n    if (Range.isRange(at) && !to) {\n      return at\n    }\n\n    const start = Editor.start(editor, at)\n    const end = Editor.end(editor, to || at)\n    return { anchor: start, focus: end }\n  },\n\n  /**\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\n   * operations are applied to the editor.\n   */\n\n  rangeRef(\n    editor: Editor,\n    range: Range,\n    options: {\n      affinity?: 'backward' | 'forward' | 'outward' | 'inward' | null\n    } = {}\n  ): RangeRef {\n    const { affinity = 'forward' } = options\n    const ref: RangeRef = {\n      current: range,\n      affinity,\n      unref() {\n        const { current } = ref\n        const rangeRefs = Editor.rangeRefs(editor)\n        rangeRefs.delete(ref)\n        ref.current = null\n        return current\n      },\n    }\n\n    const refs = Editor.rangeRefs(editor)\n    refs.add(ref)\n    return ref\n  },\n\n  /**\n   * Get the set of currently tracked range refs of the editor.\n   */\n\n  rangeRefs(editor: Editor): Set<RangeRef> {\n    let refs = RANGE_REFS.get(editor)\n\n    if (!refs) {\n      refs = new Set()\n      RANGE_REFS.set(editor, refs)\n    }\n\n    return refs\n  },\n\n  /**\n   * Remove a custom property from all of the leaf text nodes in the current\n   * selection.\n   *\n   * If the selection is currently collapsed, the removal will be stored on\n   * `editor.marks` and applied to the text inserted next.\n   */\n\n  removeMark(editor: Editor, key: string): void {\n    editor.removeMark(key)\n  },\n\n  /**\n   * Get the start point of a location.\n   */\n\n  start(editor: Editor, at: Location): Point {\n    return Editor.point(editor, at, { edge: 'start' })\n  },\n\n  /**\n   * Get the text string content of a location.\n   *\n   * Note: the text of void nodes is presumed to be an empty string, regardless\n   * of what their actual content is.\n   */\n\n  string(editor: Editor, at: Location): string {\n    const range = Editor.range(editor, at)\n    const [start, end] = Range.edges(range)\n    let text = ''\n\n    for (const [node, path] of Editor.nodes(editor, {\n      at: range,\n      match: Text.isText,\n    })) {\n      let t = node.text\n\n      if (Path.equals(path, end.path)) {\n        t = t.slice(0, end.offset)\n      }\n\n      if (Path.equals(path, start.path)) {\n        t = t.slice(start.offset)\n      }\n\n      text += t\n    }\n\n    return text\n  },\n\n  /**\n   * Transform the editor by an operation.\n   */\n\n  transform(editor: Editor, op: Operation) {\n    editor.children = createDraft(editor.children)\n    let selection = editor.selection && createDraft(editor.selection)\n\n    switch (op.type) {\n      case 'insert_node': {\n        const { path, node } = op\n        const parent = Node.parent(editor, path)\n        const index = path[path.length - 1]\n        parent.children.splice(index, 0, node)\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'insert_text': {\n        const { path, offset, text } = op\n        const node = Node.leaf(editor, path)\n        const before = node.text.slice(0, offset)\n        const after = node.text.slice(offset)\n        node.text = before + text + after\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'merge_node': {\n        const { path } = op\n        const node = Node.get(editor, path)\n        const prevPath = Path.previous(path)\n        const prev = Node.get(editor, prevPath)\n        const parent = Node.parent(editor, path)\n        const index = path[path.length - 1]\n\n        if (Text.isText(node) && Text.isText(prev)) {\n          prev.text += node.text\n        } else if (!Text.isText(node) && !Text.isText(prev)) {\n          prev.children.push(...node.children)\n        } else {\n          throw new Error(\n            `Cannot apply a \"merge_node\" operation at path [${path}] to nodes of different interaces: ${node} ${prev}`\n          )\n        }\n\n        parent.children.splice(index, 1)\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'move_node': {\n        const { path, newPath } = op\n\n        if (Path.isAncestor(path, newPath)) {\n          throw new Error(\n            `Cannot move a path [${path}] to new path [${newPath}] because the destination is inside itself.`\n          )\n        }\n\n        const node = Node.get(editor, path)\n        const parent = Node.parent(editor, path)\n        const index = path[path.length - 1]\n\n        // This is tricky, but since the `path` and `newPath` both refer to\n        // the same snapshot in time, there's a mismatch. After either\n        // removing the original position, the second step's path can be out\n        // of date. So instead of using the `op.newPath` directly, we\n        // transform `op.path` to ascertain what the `newPath` would be after\n        // the operation was applied.\n        parent.children.splice(index, 1)\n        const truePath = Path.transform(path, op)!\n        const newParent = Node.get(editor, Path.parent(truePath)) as Ancestor\n        const newIndex = truePath[truePath.length - 1]\n\n        newParent.children.splice(newIndex, 0, node)\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'remove_node': {\n        const { path } = op\n        const index = path[path.length - 1]\n        const parent = Node.parent(editor, path)\n        parent.children.splice(index, 1)\n\n        // Transform all of the points in the value, but if the point was in the\n        // node that was removed we need to update the range or remove it.\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            const result = Point.transform(point, op)\n\n            if (selection != null && result != null) {\n              selection[key] = result\n            } else {\n              let prev: NodeEntry<Text> | undefined\n              let next: NodeEntry<Text> | undefined\n\n              for (const [n, p] of Node.texts(editor)) {\n                if (Path.compare(p, path) === -1) {\n                  prev = [n, p]\n                } else {\n                  next = [n, p]\n                  break\n                }\n              }\n\n              if (prev) {\n                point.path = prev[1]\n                point.offset = prev[0].text.length\n              } else if (next) {\n                point.path = next[1]\n                point.offset = 0\n              } else {\n                selection = null\n              }\n            }\n          }\n        }\n\n        break\n      }\n\n      case 'remove_text': {\n        const { path, offset, text } = op\n        const node = Node.leaf(editor, path)\n        const before = node.text.slice(0, offset)\n        const after = node.text.slice(offset + text.length)\n        node.text = before + after\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'set_node': {\n        const { path, newProperties } = op\n\n        if (path.length === 0) {\n          throw new Error(`Cannot set properties on the root node!`)\n        }\n\n        const node = Node.get(editor, path)\n\n        for (const key in newProperties) {\n          if (key === 'children' || key === 'text') {\n            throw new Error(`Cannot set the \"${key}\" property of nodes!`)\n          }\n\n          const value = newProperties[key]\n\n          if (value == null) {\n            delete node[key]\n          } else {\n            node[key] = value\n          }\n        }\n\n        break\n      }\n\n      case 'set_selection': {\n        const { newProperties } = op\n\n        if (newProperties == null) {\n          selection = newProperties\n        } else if (selection == null) {\n          if (!Range.isRange(newProperties)) {\n            throw new Error(\n              `Cannot apply an incomplete \"set_selection\" operation properties ${JSON.stringify(\n                newProperties\n              )} when there is no current selection.`\n            )\n          }\n\n          selection = newProperties\n        } else {\n          Object.assign(selection, newProperties)\n        }\n\n        break\n      }\n\n      case 'split_node': {\n        const { path, position, properties } = op\n\n        if (path.length === 0) {\n          throw new Error(\n            `Cannot apply a \"split_node\" operation at path [${path}] because the root node cannot be split.`\n          )\n        }\n\n        const node = Node.get(editor, path)\n        const parent = Node.parent(editor, path)\n        const index = path[path.length - 1]\n        let newNode: Descendant\n\n        if (Text.isText(node)) {\n          const before = node.text.slice(0, position)\n          const after = node.text.slice(position)\n          node.text = before\n          newNode = {\n            ...node,\n            ...(properties as Partial<Text>),\n            text: after,\n          }\n        } else {\n          const before = node.children.slice(0, position)\n          const after = node.children.slice(position)\n          node.children = before\n\n          newNode = {\n            ...node,\n            ...(properties as Partial<Element>),\n            children: after,\n          }\n        }\n\n        parent.children.splice(index + 1, 0, newNode)\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n    }\n\n    editor.children = finishDraft(editor.children) as Node[]\n\n    if (selection) {\n      editor.selection = isDraft(selection)\n        ? (finishDraft(selection) as Range)\n        : selection\n    } else {\n      editor.selection = null\n    }\n  },\n\n  /**\n   * Convert a range into a non-hanging one.\n   */\n\n  unhangRange(\n    editor: Editor,\n    range: Range,\n    options: {\n      voids?: boolean\n    } = {}\n  ): Range {\n    const { voids = false } = options\n    let [start, end] = Range.edges(range)\n\n    // PERF: exit early if we can guarantee that the range isn't hanging.\n    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range)) {\n      return range\n    }\n\n    const endBlock = Editor.above(editor, {\n      at: end,\n      match: n => Editor.isBlock(editor, n),\n    })\n    const blockPath = endBlock ? endBlock[1] : []\n    const first = Editor.start(editor, [])\n    const before = { anchor: first, focus: end }\n    let skip = true\n\n    for (const [node, path] of Editor.nodes(editor, {\n      at: before,\n      match: Text.isText,\n      reverse: true,\n      voids,\n    })) {\n      if (skip) {\n        skip = false\n        continue\n      }\n\n      if (node.text !== '' || Path.isBefore(path, blockPath)) {\n        end = { path, offset: node.text.length }\n        break\n      }\n    }\n\n    return { anchor: start, focus: end }\n  },\n\n  /**\n   * Match a void node in the current branch of the editor.\n   */\n\n  void(\n    editor: Editor,\n    options: {\n      at?: Location\n      mode?: 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ): NodeEntry<Element> | undefined {\n    return Editor.above(editor, {\n      ...options,\n      match: n => Editor.isVoid(editor, n),\n    })\n  },\n\n  /**\n   * Call a function, deferring normalization until after it completes.\n   */\n\n  withoutNormalizing(editor: Editor, fn: () => void): void {\n    const value = Editor.isNormalizing(editor)\n    NORMALIZING.set(editor, false)\n    fn()\n    NORMALIZING.set(editor, value)\n    Editor.normalize(editor)\n  },\n}\n\n/**\n * A helper type for narrowing matched nodes with a predicate.\n */\n\ntype NodeMatch<T extends Node> =\n  | ((node: Node) => node is T)\n  | ((node: Node) => boolean)\n","import isPlainObject from 'is-plain-object'\nimport { Editor, Node, Path } from '..'\n\n/**\n * `Element` objects are a type of node in a Slate document that contain other\n * element nodes or text nodes. They can be either \"blocks\" or \"inlines\"\n * depending on the Slate editor's configuration.\n */\n\nexport interface Element {\n  children: Node[]\n  [key: string]: unknown\n}\n\nexport const Element = {\n  /**\n   * Check if a value implements the `Element` interface.\n   */\n\n  isElement(value: any): value is Element {\n    return (\n      isPlainObject(value) &&\n      Node.isNodeList(value.children) &&\n      !Editor.isEditor(value)\n    )\n  },\n\n  /**\n   * Check if a value is an array of `Element` objects.\n   */\n\n  isElementList(value: any): value is Element[] {\n    return (\n      Array.isArray(value) &&\n      (value.length === 0 || Element.isElement(value[0]))\n    )\n  },\n\n  /**\n   * Check if an element matches set of properties.\n   *\n   * Note: this checks custom properties, and it does not ensure that any\n   * children are equivalent.\n   */\n\n  matches(element: Element, props: Partial<Element>): boolean {\n    for (const key in props) {\n      if (key === 'children') {\n        continue\n      }\n\n      if (element[key] !== props[key]) {\n        return false\n      }\n    }\n\n    return true\n  },\n}\n\n/**\n * `ElementEntry` objects refer to an `Element` and the `Path` where it can be\n * found inside a root node.\n */\n\nexport type ElementEntry = [Element, Path]\n","import { Path, Point, Range } from '..'\n\n/**\n * The `Location` interface is a union of the ways to refer to a specific\n * location in a Slate document: paths, points or ranges.\n *\n * Methods will often accept a `Location` instead of requiring only a `Path`,\n * `Point` or `Range`. This eliminates the need for developers to manage\n * converting between the different interfaces in their own code base.\n */\n\nexport type Location = Path | Point | Range\n\nexport const Location = {\n  /**\n   * Check if a value implements the `Location` interface.\n   */\n\n  isLocation(value: any): value is Location {\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value)\n  },\n}\n\n/**\n * The `Span` interface is a low-level way to refer to locations in nodes\n * without using `Point` which requires leaf text nodes to be present.\n */\n\nexport type Span = [Path, Path]\n\nexport const Span = {\n  /**\n   * Check if a value implements the `Span` interface.\n   */\n\n  isSpan(value: any): value is Span {\n    return (\n      Array.isArray(value) && value.length === 2 && value.every(Path.isPath)\n    )\n  },\n}\n","import { produce } from 'immer'\nimport { Editor, Element, ElementEntry, Path, Range, Text } from '..'\n\n/**\n * The `Node` union type represents all of the different types of nodes that\n * occur in a Slate document tree.\n */\n\nexport type Node = Editor | Element | Text\n\nexport const Node = {\n  /**\n   * Get the node at a specific path, asserting that it's an ancestor node.\n   */\n\n  ancestor(root: Node, path: Path): Ancestor {\n    const node = Node.get(root, path)\n\n    if (Text.isText(node)) {\n      throw new Error(\n        `Cannot get the ancestor node at path [${path}] because it refers to a text node instead: ${node}`\n      )\n    }\n\n    return node\n  },\n\n  /**\n   * Return an iterable of all the ancestor nodes above a specific path.\n   *\n   * By default the order is bottom-up, from lowest to highest ancestor in\n   * the tree, but you can pass the `reverse: true` option to go top-down.\n   */\n\n  *ancestors(\n    root: Node,\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Iterable<NodeEntry<Ancestor>> {\n    for (const p of Path.ancestors(path, options)) {\n      const n = Node.ancestor(root, p)\n      const entry: NodeEntry<Ancestor> = [n, p]\n      yield entry\n    }\n  },\n\n  /**\n   * Get the child of a node at a specific index.\n   */\n\n  child(root: Node, index: number): Descendant {\n    if (Text.isText(root)) {\n      throw new Error(\n        `Cannot get the child of a text node: ${JSON.stringify(root)}`\n      )\n    }\n\n    const c = root.children[index] as Descendant\n\n    if (c == null) {\n      throw new Error(\n        `Cannot get child at index \\`${index}\\` in node: ${JSON.stringify(\n          root\n        )}`\n      )\n    }\n\n    return c\n  },\n\n  /**\n   * Iterate over the children of a node at a specific path.\n   */\n\n  *children(\n    root: Node,\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Iterable<NodeEntry<Descendant>> {\n    const { reverse = false } = options\n    const ancestor = Node.ancestor(root, path)\n    const { children } = ancestor\n    let index = reverse ? children.length - 1 : 0\n\n    while (reverse ? index >= 0 : index < children.length) {\n      const child = Node.child(ancestor, index)\n      const childPath = path.concat(index)\n      yield [child, childPath]\n      index = reverse ? index - 1 : index + 1\n    }\n  },\n\n  /**\n   * Get an entry for the common ancesetor node of two paths.\n   */\n\n  common(root: Node, path: Path, another: Path): NodeEntry {\n    const p = Path.common(path, another)\n    const n = Node.get(root, p)\n    return [n, p]\n  },\n\n  /**\n   * Get the node at a specific path, asserting that it's a descendant node.\n   */\n\n  descendant(root: Node, path: Path): Descendant {\n    const node = Node.get(root, path)\n\n    if (Editor.isEditor(node)) {\n      throw new Error(\n        `Cannot get the descendant node at path [${path}] because it refers to the root editor node instead: ${node}`\n      )\n    }\n\n    return node\n  },\n\n  /**\n   * Return an iterable of all the descendant node entries inside a root node.\n   */\n\n  *descendants(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Iterable<NodeEntry<Descendant>> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (path.length !== 0) {\n        // NOTE: we have to coerce here because checking the path's length does\n        // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n        yield [node, path] as NodeEntry<Descendant>\n      }\n    }\n  },\n\n  /**\n   * Return an iterable of all the element nodes inside a root node. Each iteration\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\n   * root node is an element it will be included in the iteration as well.\n   */\n\n  *elements(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Iterable<ElementEntry> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (Element.isElement(node)) {\n        yield [node, path]\n      }\n    }\n  },\n\n  /**\n   * Get the first node entry in a root node from a path.\n   */\n\n  first(root: Node, path: Path): NodeEntry {\n    const p = path.slice()\n    let n = Node.get(root, p)\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break\n      } else {\n        n = n.children[0]\n        p.push(0)\n      }\n    }\n\n    return [n, p]\n  },\n\n  /**\n   * Get the sliced fragment represented by a range inside a root node.\n   */\n\n  fragment(root: Node, range: Range): Descendant[] {\n    if (Text.isText(root)) {\n      throw new Error(\n        `Cannot get a fragment starting from a root text node: ${JSON.stringify(\n          root\n        )}`\n      )\n    }\n\n    const newRoot = produce(root, r => {\n      const [start, end] = Range.edges(range)\n      const iterable = Node.nodes(r, {\n        reverse: true,\n        pass: ([, path]) => !Range.includes(range, path),\n      })\n\n      for (const [, path] of iterable) {\n        if (!Range.includes(range, path)) {\n          const parent = Node.parent(r, path)\n          const index = path[path.length - 1]\n          parent.children.splice(index, 1)\n        }\n\n        if (Path.equals(path, end.path)) {\n          const leaf = Node.leaf(r, path)\n          leaf.text = leaf.text.slice(0, end.offset)\n        }\n\n        if (Path.equals(path, start.path)) {\n          const leaf = Node.leaf(r, path)\n          leaf.text = leaf.text.slice(start.offset)\n        }\n      }\n\n      delete r.selection\n    })\n\n    return newRoot.children\n  },\n\n  /**\n   * Get the descendant node referred to by a specific path. If the path is an\n   * empty array, it refers to the root node itself.\n   */\n\n  get(root: Node, path: Path): Node {\n    let node = root\n\n    for (let i = 0; i < path.length; i++) {\n      const p = path[i]\n\n      if (Text.isText(node) || !node.children[p]) {\n        throw new Error(\n          `Cannot find a descendant at path [${path}] in node: ${JSON.stringify(\n            root\n          )}`\n        )\n      }\n\n      node = node.children[p]\n    }\n\n    return node\n  },\n\n  /**\n   * Check if a descendant node exists at a specific path.\n   */\n\n  has(root: Node, path: Path): boolean {\n    let node = root\n\n    for (let i = 0; i < path.length; i++) {\n      const p = path[i]\n\n      if (Text.isText(node) || !node.children[p]) {\n        return false\n      }\n\n      node = node.children[p]\n    }\n\n    return true\n  },\n\n  /**\n   * Check if a value implements the `Node` interface.\n   */\n\n  isNode(value: any): value is Node {\n    return (\n      Text.isText(value) || Element.isElement(value) || Editor.isEditor(value)\n    )\n  },\n\n  /**\n   * Check if a value is a list of `Node` objects.\n   */\n\n  isNodeList(value: any): value is Node[] {\n    return Array.isArray(value) && (value.length === 0 || Node.isNode(value[0]))\n  },\n\n  /**\n   * Get the lash node entry in a root node from a path.\n   */\n\n  last(root: Node, path: Path): NodeEntry {\n    const p = path.slice()\n    let n = Node.get(root, p)\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break\n      } else {\n        const i = n.children.length - 1\n        n = n.children[i]\n        p.push(i)\n      }\n    }\n\n    return [n, p]\n  },\n\n  /**\n   * Get the node at a specific path, ensuring it's a leaf text node.\n   */\n\n  leaf(root: Node, path: Path): Text {\n    const node = Node.get(root, path)\n\n    if (!Text.isText(node)) {\n      throw new Error(\n        `Cannot get the leaf node at path [${path}] because it refers to a non-leaf node: ${node}`\n      )\n    }\n\n    return node\n  },\n\n  /**\n   * Return an iterable of the in a branch of the tree, from a specific path.\n   *\n   * By default the order is top-down, from lowest to highest node in the tree,\n   * but you can pass the `reverse: true` option to go bottom-up.\n   */\n\n  *levels(\n    root: Node,\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Iterable<NodeEntry> {\n    for (const p of Path.levels(path, options)) {\n      const n = Node.get(root, p)\n      yield [n, p]\n    }\n  },\n\n  /**\n   * Check if a node matches a set of props.\n   */\n\n  matches(node: Node, props: Partial<Node>): boolean {\n    return (\n      (Element.isElement(node) && Element.matches(node, props)) ||\n      (Text.isText(node) && Text.matches(node, props))\n    )\n  },\n\n  /**\n   * Return an iterable of all the node entries of a root node. Each entry is\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\n   * position inside the root node.\n   */\n\n  *nodes(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (entry: NodeEntry) => boolean\n    } = {}\n  ): Iterable<NodeEntry> {\n    const { pass, reverse = false } = options\n    const { from = [], to } = options\n    const visited = new Set()\n    let p: Path = []\n    let n = root\n\n    while (true) {\n      if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n        break\n      }\n\n      if (!visited.has(n)) {\n        yield [n, p]\n      }\n\n      // If we're allowed to go downward and we haven't decsended yet, do.\n      if (\n        !visited.has(n) &&\n        !Text.isText(n) &&\n        n.children.length !== 0 &&\n        (pass == null || pass([n, p]) === false)\n      ) {\n        visited.add(n)\n        let nextIndex = reverse ? n.children.length - 1 : 0\n\n        if (Path.isAncestor(p, from)) {\n          nextIndex = from[p.length]\n        }\n\n        p = p.concat(nextIndex)\n        n = Node.get(root, p)\n        continue\n      }\n\n      // If we're at the root and we can't go down, we're done.\n      if (p.length === 0) {\n        break\n      }\n\n      // If we're going forward...\n      if (!reverse) {\n        const newPath = Path.next(p)\n\n        if (Node.has(root, newPath)) {\n          p = newPath\n          n = Node.get(root, p)\n          continue\n        }\n      }\n\n      // If we're going backward...\n      if (reverse && p[p.length - 1] !== 0) {\n        const newPath = Path.previous(p)\n        p = newPath\n        n = Node.get(root, p)\n        continue\n      }\n\n      // Otherwise we're going upward...\n      p = Path.parent(p)\n      n = Node.get(root, p)\n      visited.add(n)\n    }\n  },\n\n  /**\n   * Get the parent of a node at a specific path.\n   */\n\n  parent(root: Node, path: Path): Ancestor {\n    const parentPath = Path.parent(path)\n    const p = Node.get(root, parentPath)\n\n    if (Text.isText(p)) {\n      throw new Error(\n        `Cannot get the parent of path [${path}] because it does not exist in the root.`\n      )\n    }\n\n    return p\n  },\n\n  /**\n   * Get the concatenated text string of a node's content.\n   *\n   * Note that this will not include spaces or line breaks between block nodes.\n   * It is not a user-facing string, but a string for performing offset-related\n   * computations for a node.\n   */\n\n  string(node: Node): string {\n    if (Text.isText(node)) {\n      return node.text\n    } else {\n      return node.children.map(Node.string).join('')\n    }\n  },\n\n  /**\n   * Return an iterable of all leaf text nodes in a root node.\n   */\n\n  *texts(\n    root: Node,\n    options: {\n      from?: Path\n      to?: Path\n      reverse?: boolean\n      pass?: (node: NodeEntry) => boolean\n    } = {}\n  ): Iterable<NodeEntry<Text>> {\n    for (const [node, path] of Node.nodes(root, options)) {\n      if (Text.isText(node)) {\n        yield [node, path]\n      }\n    }\n  },\n}\n\n/**\n * The `Descendant` union type represents nodes that are descendants in the\n * tree. It is returned as a convenience in certain cases to narrow a value\n * further than the more generic `Node` union.\n */\n\nexport type Descendant = Element | Text\n\n/**\n * The `Ancestor` union type represents nodes that are ancestors in the tree.\n * It is returned as a convenience in certain cases to narrow a value further\n * than the more generic `Node` union.\n */\n\nexport type Ancestor = Editor | Element\n\n/**\n * `NodeEntry` objects are returned when iterating over the nodes in a Slate\n * document tree. They consist of the node and its `Path` relative to the root\n * node in the document.\n */\n\nexport type NodeEntry<T extends Node = Node> = [T, Path]\n","import { Node, Path, Range } from '..'\nimport isPlainObject from 'is-plain-object'\n\nexport type InsertNodeOperation = {\n  type: 'insert_node'\n  path: Path\n  node: Node\n  [key: string]: unknown\n}\n\nexport type InsertTextOperation = {\n  type: 'insert_text'\n  path: Path\n  offset: number\n  text: string\n  [key: string]: unknown\n}\n\nexport type MergeNodeOperation = {\n  type: 'merge_node'\n  path: Path\n  position: number\n  properties: Partial<Node>\n  [key: string]: unknown\n}\n\nexport type MoveNodeOperation = {\n  type: 'move_node'\n  path: Path\n  newPath: Path\n  [key: string]: unknown\n}\n\nexport type RemoveNodeOperation = {\n  type: 'remove_node'\n  path: Path\n  node: Node\n  [key: string]: unknown\n}\n\nexport type RemoveTextOperation = {\n  type: 'remove_text'\n  path: Path\n  offset: number\n  text: string\n  [key: string]: unknown\n}\n\nexport type SetNodeOperation = {\n  type: 'set_node'\n  path: Path\n  properties: Partial<Node>\n  newProperties: Partial<Node>\n  [key: string]: unknown\n}\n\nexport type SetSelectionOperation =\n  | {\n      type: 'set_selection'\n      [key: string]: unknown\n      properties: null\n      newProperties: Range\n    }\n  | {\n      type: 'set_selection'\n      [key: string]: unknown\n      properties: Partial<Range>\n      newProperties: Partial<Range>\n    }\n  | {\n      type: 'set_selection'\n      [key: string]: unknown\n      properties: Range\n      newProperties: null\n    }\n\nexport type SplitNodeOperation = {\n  type: 'split_node'\n  path: Path\n  position: number\n  properties: Partial<Node>\n  [key: string]: unknown\n}\n\nexport type NodeOperation =\n  | InsertNodeOperation\n  | MergeNodeOperation\n  | MoveNodeOperation\n  | RemoveNodeOperation\n  | SetNodeOperation\n  | SplitNodeOperation\n\nexport type SelectionOperation = SetSelectionOperation\n\nexport type TextOperation = InsertTextOperation | RemoveTextOperation\n\n/**\n * `Operation` objects define the low-level instructions that Slate editors use\n * to apply changes to their internal state. Representing all changes as\n * operations is what allows Slate editors to easily implement history,\n * collaboration, and other features.\n */\n\nexport type Operation = NodeOperation | SelectionOperation | TextOperation\n\nexport const Operation = {\n  /**\n   * Check of a value is a `NodeOperation` object.\n   */\n\n  isNodeOperation(value: any): value is NodeOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_node')\n  },\n\n  /**\n   * Check of a value is an `Operation` object.\n   */\n\n  isOperation(value: any): value is Operation {\n    if (!isPlainObject(value)) {\n      return false\n    }\n\n    switch (value.type) {\n      case 'insert_node':\n        return Path.isPath(value.path) && Node.isNode(value.node)\n      case 'insert_text':\n        return (\n          typeof value.offset === 'number' &&\n          typeof value.text === 'string' &&\n          Path.isPath(value.path)\n        )\n      case 'merge_node':\n        return (\n          typeof value.position === 'number' &&\n          Path.isPath(value.path) &&\n          isPlainObject(value.properties)\n        )\n      case 'move_node':\n        return Path.isPath(value.path) && Path.isPath(value.newPath)\n      case 'remove_node':\n        return Path.isPath(value.path) && Node.isNode(value.node)\n      case 'remove_text':\n        return (\n          typeof value.offset === 'number' &&\n          typeof value.text === 'string' &&\n          Path.isPath(value.path)\n        )\n      case 'set_node':\n        return (\n          Path.isPath(value.path) &&\n          isPlainObject(value.properties) &&\n          isPlainObject(value.newProperties)\n        )\n      case 'set_selection':\n        return (\n          (value.properties === null && Range.isRange(value.newProperties)) ||\n          (value.newProperties === null && Range.isRange(value.properties)) ||\n          (isPlainObject(value.properties) &&\n            isPlainObject(value.newProperties))\n        )\n      case 'split_node':\n        return (\n          Path.isPath(value.path) &&\n          typeof value.position === 'number' &&\n          isPlainObject(value.properties)\n        )\n      default:\n        return false\n    }\n  },\n\n  /**\n   * Check if a value is a list of `Operation` objects.\n   */\n\n  isOperationList(value: any): value is Operation[] {\n    return (\n      Array.isArray(value) &&\n      (value.length === 0 || Operation.isOperation(value[0]))\n    )\n  },\n\n  /**\n   * Check of a value is a `SelectionOperation` object.\n   */\n\n  isSelectionOperation(value: any): value is SelectionOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_selection')\n  },\n\n  /**\n   * Check of a value is a `TextOperation` object.\n   */\n\n  isTextOperation(value: any): value is TextOperation {\n    return Operation.isOperation(value) && value.type.endsWith('_text')\n  },\n\n  /**\n   * Invert an operation, returning a new operation that will exactly undo the\n   * original when applied.\n   */\n\n  inverse(op: Operation): Operation {\n    switch (op.type) {\n      case 'insert_node': {\n        return { ...op, type: 'remove_node' }\n      }\n\n      case 'insert_text': {\n        return { ...op, type: 'remove_text' }\n      }\n\n      case 'merge_node': {\n        return { ...op, type: 'split_node', path: Path.previous(op.path) }\n      }\n\n      case 'move_node': {\n        const { newPath, path } = op\n\n        // PERF: in this case the move operation is a no-op anyways.\n        if (Path.equals(newPath, path)) {\n          return op\n        }\n\n        // If the move happens completely within a single parent the path and\n        // newPath are stable with respect to each other.\n        if (Path.isSibling(path, newPath)) {\n          return { ...op, path: newPath, newPath: path }\n        }\n\n        // If the move does not happen within a single parent it is possible\n        // for the move to impact the true path to the location where the node\n        // was removed from and where it was inserted. We have to adjust for this\n        // and find the original path. We can accomplish this (only in non-sibling)\n        // moves by looking at the impact of the move operation on the node\n        // after the original move path.\n        const inversePath = Path.transform(path, op)!\n        const inverseNewPath = Path.transform(Path.next(path), op)!\n        return { ...op, path: inversePath, newPath: inverseNewPath }\n      }\n\n      case 'remove_node': {\n        return { ...op, type: 'insert_node' }\n      }\n\n      case 'remove_text': {\n        return { ...op, type: 'insert_text' }\n      }\n\n      case 'set_node': {\n        const { properties, newProperties } = op\n        return { ...op, properties: newProperties, newProperties: properties }\n      }\n\n      case 'set_selection': {\n        const { properties, newProperties } = op\n\n        if (properties == null) {\n          return {\n            ...op,\n            properties: newProperties as Range,\n            newProperties: null,\n          }\n        } else if (newProperties == null) {\n          return {\n            ...op,\n            properties: null,\n            newProperties: properties as Range,\n          }\n        } else {\n          return { ...op, properties: newProperties, newProperties: properties }\n        }\n      }\n\n      case 'split_node': {\n        return { ...op, type: 'merge_node', path: Path.next(op.path) }\n      }\n    }\n  },\n}\n","import { produce } from 'immer'\nimport { Operation } from '..'\n\n/**\n * `Path` arrays are a list of indexes that describe a node's exact position in\n * a Slate node tree. Although they are usually relative to the root `Editor`\n * object, they can be relative to any `Node` object.\n */\n\nexport type Path = number[]\n\nexport const Path = {\n  /**\n   * Get a list of ancestor paths for a given path.\n   *\n   * The paths are sorted from deepest to shallowest ancestor. However, if the\n   * `reverse: true` option is passed, they are reversed.\n   */\n\n  ancestors(path: Path, options: { reverse?: boolean } = {}): Path[] {\n    const { reverse = false } = options\n    let paths = Path.levels(path, options)\n\n    if (reverse) {\n      paths = paths.slice(1)\n    } else {\n      paths = paths.slice(0, -1)\n    }\n\n    return paths\n  },\n\n  /**\n   * Get the common ancestor path of two paths.\n   */\n\n  common(path: Path, another: Path): Path {\n    const common: Path = []\n\n    for (let i = 0; i < path.length && i < another.length; i++) {\n      const av = path[i]\n      const bv = another[i]\n\n      if (av !== bv) {\n        break\n      }\n\n      common.push(av)\n    }\n\n    return common\n  },\n\n  /**\n   * Compare a path to another, returning an integer indicating whether the path\n   * was before, at, or after the other.\n   *\n   * Note: Two paths of unequal length can still receive a `0` result if one is\n   * directly above or below the other. If you want exact matching, use\n   * [[Path.equals]] instead.\n   */\n\n  compare(path: Path, another: Path): -1 | 0 | 1 {\n    const min = Math.min(path.length, another.length)\n\n    for (let i = 0; i < min; i++) {\n      if (path[i] < another[i]) return -1\n      if (path[i] > another[i]) return 1\n    }\n\n    return 0\n  },\n\n  /**\n   * Check if a path ends after one of the indexes in another.\n   */\n\n  endsAfter(path: Path, another: Path): boolean {\n    const i = path.length - 1\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    const av = path[i]\n    const bv = another[i]\n    return Path.equals(as, bs) && av > bv\n  },\n\n  /**\n   * Check if a path ends at one of the indexes in another.\n   */\n\n  endsAt(path: Path, another: Path): boolean {\n    const i = path.length\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    return Path.equals(as, bs)\n  },\n\n  /**\n   * Check if a path ends before one of the indexes in another.\n   */\n\n  endsBefore(path: Path, another: Path): boolean {\n    const i = path.length - 1\n    const as = path.slice(0, i)\n    const bs = another.slice(0, i)\n    const av = path[i]\n    const bv = another[i]\n    return Path.equals(as, bs) && av < bv\n  },\n\n  /**\n   * Check if a path is exactly equal to another.\n   */\n\n  equals(path: Path, another: Path): boolean {\n    return (\n      path.length === another.length && path.every((n, i) => n === another[i])\n    )\n  },\n\n  /**\n   * Check if a path is after another.\n   */\n\n  isAfter(path: Path, another: Path): boolean {\n    return Path.compare(path, another) === 1\n  },\n\n  /**\n   * Check if a path is an ancestor of another.\n   */\n\n  isAncestor(path: Path, another: Path): boolean {\n    return path.length < another.length && Path.compare(path, another) === 0\n  },\n\n  /**\n   * Check if a path is before another.\n   */\n\n  isBefore(path: Path, another: Path): boolean {\n    return Path.compare(path, another) === -1\n  },\n\n  /**\n   * Check if a path is a child of another.\n   */\n\n  isChild(path: Path, another: Path): boolean {\n    return (\n      path.length === another.length + 1 && Path.compare(path, another) === 0\n    )\n  },\n\n  /**\n   * Check if a path is equal to or an ancestor of another.\n   */\n\n  isCommon(path: Path, another: Path): boolean {\n    return path.length <= another.length && Path.compare(path, another) === 0\n  },\n\n  /**\n   * Check if a path is a descendant of another.\n   */\n\n  isDescendant(path: Path, another: Path): boolean {\n    return path.length > another.length && Path.compare(path, another) === 0\n  },\n\n  /**\n   * Check if a path is the parent of another.\n   */\n\n  isParent(path: Path, another: Path): boolean {\n    return (\n      path.length + 1 === another.length && Path.compare(path, another) === 0\n    )\n  },\n\n  /**\n   * Check is a value implements the `Path` interface.\n   */\n\n  isPath(value: any): value is Path {\n    return (\n      Array.isArray(value) &&\n      (value.length === 0 || typeof value[0] === 'number')\n    )\n  },\n\n  /**\n   * Check if a path is a sibling of another.\n   */\n\n  isSibling(path: Path, another: Path): boolean {\n    if (path.length !== another.length) {\n      return false\n    }\n\n    const as = path.slice(0, -1)\n    const bs = another.slice(0, -1)\n    const al = path[path.length - 1]\n    const bl = another[another.length - 1]\n    return al !== bl && Path.equals(as, bs)\n  },\n\n  /**\n   * Get a list of paths at every level down to a path. Note: this is the same\n   * as `Path.ancestors`, but including the path itself.\n   *\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\n   * true` option is passed, they are reversed.\n   */\n\n  levels(\n    path: Path,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): Path[] {\n    const { reverse = false } = options\n    const list: Path[] = []\n\n    for (let i = 0; i <= path.length; i++) {\n      list.push(path.slice(0, i))\n    }\n\n    if (reverse) {\n      list.reverse()\n    }\n\n    return list\n  },\n\n  /**\n   * Given a path, get the path to the next sibling node.\n   */\n\n  next(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(\n        `Cannot get the next path of a root path [${path}], because it has no next index.`\n      )\n    }\n\n    const last = path[path.length - 1]\n    return path.slice(0, -1).concat(last + 1)\n  },\n\n  /**\n   * Given a path, return a new path referring to the parent node above it.\n   */\n\n  parent(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(`Cannot get the parent path of the root path [${path}].`)\n    }\n\n    return path.slice(0, -1)\n  },\n\n  /**\n   * Given a path, get the path to the previous sibling node.\n   */\n\n  previous(path: Path): Path {\n    if (path.length === 0) {\n      throw new Error(\n        `Cannot get the previous path of a root path [${path}], because it has no previous index.`\n      )\n    }\n\n    const last = path[path.length - 1]\n\n    if (last <= 0) {\n      throw new Error(\n        `Cannot get the previous path of a first child path [${path}] because it would result in a negative index.`\n      )\n    }\n\n    return path.slice(0, -1).concat(last - 1)\n  },\n\n  /**\n   * Get a path relative to an ancestor.\n   */\n\n  relative(path: Path, ancestor: Path): Path {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\n        `Cannot get the relative path of [${path}] inside ancestor [${ancestor}], because it is not above or equal to the path.`\n      )\n    }\n\n    return path.slice(ancestor.length)\n  },\n\n  /**\n   * Transform a path by an operation.\n   */\n\n  transform(\n    path: Path,\n    operation: Operation,\n    options: { affinity?: 'forward' | 'backward' | null } = {}\n  ): Path | null {\n    return produce(path, p => {\n      const { affinity = 'forward' } = options\n\n      // PERF: Exit early if the operation is guaranteed not to have an effect.\n      if (path.length === 0) {\n        return\n      }\n\n      switch (operation.type) {\n        case 'insert_node': {\n          const { path: op } = operation\n\n          if (\n            Path.equals(op, p) ||\n            Path.endsBefore(op, p) ||\n            Path.isAncestor(op, p)\n          ) {\n            p[op.length - 1] += 1\n          }\n\n          break\n        }\n\n        case 'remove_node': {\n          const { path: op } = operation\n\n          if (Path.equals(op, p) || Path.isAncestor(op, p)) {\n            return null\n          } else if (Path.endsBefore(op, p)) {\n            p[op.length - 1] -= 1\n          }\n\n          break\n        }\n\n        case 'merge_node': {\n          const { path: op, position } = operation\n\n          if (Path.equals(op, p) || Path.endsBefore(op, p)) {\n            p[op.length - 1] -= 1\n          } else if (Path.isAncestor(op, p)) {\n            p[op.length - 1] -= 1\n            p[op.length] += position\n          }\n\n          break\n        }\n\n        case 'split_node': {\n          const { path: op, position } = operation\n\n          if (Path.equals(op, p)) {\n            if (affinity === 'forward') {\n              p[p.length - 1] += 1\n            } else if (affinity === 'backward') {\n              // Nothing, because it still refers to the right path.\n            } else {\n              return null\n            }\n          } else if (Path.endsBefore(op, p)) {\n            p[op.length - 1] += 1\n          } else if (Path.isAncestor(op, p) && path[op.length] >= position) {\n            p[op.length - 1] += 1\n            p[op.length] -= position\n          }\n\n          break\n        }\n\n        case 'move_node': {\n          const { path: op, newPath: onp } = operation\n\n          // If the old and new path are the same, it's a no-op.\n          if (Path.equals(op, onp)) {\n            return\n          }\n\n          if (Path.isAncestor(op, p) || Path.equals(op, p)) {\n            const copy = onp.slice()\n\n            if (Path.endsBefore(op, onp) && op.length < onp.length) {\n              copy[op.length - 1] -= 1\n            }\n\n            return copy.concat(p.slice(op.length))\n          } else if (\n            Path.isSibling(op, onp) &&\n            (Path.isAncestor(onp, p) || Path.equals(onp, p))\n          ) {\n            if (Path.endsBefore(op, p)) {\n              p[op.length - 1] -= 1\n            } else {\n              p[op.length - 1] += 1\n            }\n          } else if (\n            Path.endsBefore(onp, p) ||\n            Path.equals(onp, p) ||\n            Path.isAncestor(onp, p)\n          ) {\n            if (Path.endsBefore(op, p)) {\n              p[op.length - 1] -= 1\n            }\n\n            p[onp.length - 1] += 1\n          } else if (Path.endsBefore(op, p)) {\n            if (Path.equals(onp, p)) {\n              p[onp.length - 1] += 1\n            }\n\n            p[op.length - 1] -= 1\n          }\n\n          break\n        }\n      }\n    })\n  },\n}\n","import { Operation, Path } from '..'\n\n/**\n * `PathRef` objects keep a specific path in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date path value.\n */\n\nexport interface PathRef {\n  current: Path | null\n  affinity: 'forward' | 'backward' | null\n  unref(): Path | null\n}\n\nexport const PathRef = {\n  /**\n   * Transform the path ref's current value by an operation.\n   */\n\n  transform(ref: PathRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const path = Path.transform(current, op, { affinity })\n    ref.current = path\n\n    if (path == null) {\n      ref.unref()\n    }\n  },\n}\n","import isPlainObject from 'is-plain-object'\nimport { produce } from 'immer'\nimport { Operation, Path } from '..'\n\n/**\n * `Point` objects refer to a specific location in a text node in a Slate\n * document. Its path refers to the location of the node in the tree, and its\n * offset refers to the distance into the node's string of text. Points can\n * only refer to `Text` nodes.\n */\n\nexport interface Point {\n  path: Path\n  offset: number\n  [key: string]: unknown\n}\n\nexport const Point = {\n  /**\n   * Compare a point to another, returning an integer indicating whether the\n   * point was before, at, or after the other.\n   */\n\n  compare(point: Point, another: Point): -1 | 0 | 1 {\n    const result = Path.compare(point.path, another.path)\n\n    if (result === 0) {\n      if (point.offset < another.offset) return -1\n      if (point.offset > another.offset) return 1\n      return 0\n    }\n\n    return result\n  },\n\n  /**\n   * Check if a point is after another.\n   */\n\n  isAfter(point: Point, another: Point): boolean {\n    return Point.compare(point, another) === 1\n  },\n\n  /**\n   * Check if a point is before another.\n   */\n\n  isBefore(point: Point, another: Point): boolean {\n    return Point.compare(point, another) === -1\n  },\n\n  /**\n   * Check if a point is exactly equal to another.\n   */\n\n  equals(point: Point, another: Point): boolean {\n    // PERF: ensure the offsets are equal first since they are cheaper to check.\n    return (\n      point.offset === another.offset && Path.equals(point.path, another.path)\n    )\n  },\n\n  /**\n   * Check if a value implements the `Point` interface.\n   */\n\n  isPoint(value: any): value is Point {\n    return (\n      isPlainObject(value) &&\n      typeof value.offset === 'number' &&\n      Path.isPath(value.path)\n    )\n  },\n\n  /**\n   * Transform a point by an operation.\n   */\n\n  transform(\n    point: Point,\n    op: Operation,\n    options: { affinity?: 'forward' | 'backward' | null } = {}\n  ): Point | null {\n    return produce(point, p => {\n      const { affinity = 'forward' } = options\n      const { path, offset } = p\n\n      switch (op.type) {\n        case 'insert_node':\n        case 'move_node': {\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'insert_text': {\n          if (Path.equals(op.path, path) && op.offset <= offset) {\n            p.offset += op.text.length\n          }\n\n          break\n        }\n\n        case 'merge_node': {\n          if (Path.equals(op.path, path)) {\n            p.offset += op.position\n          }\n\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'remove_text': {\n          if (Path.equals(op.path, path) && op.offset <= offset) {\n            p.offset -= Math.min(offset - op.offset, op.text.length)\n          }\n\n          break\n        }\n\n        case 'remove_node': {\n          if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n            return null\n          }\n\n          p.path = Path.transform(path, op, options)!\n          break\n        }\n\n        case 'split_node': {\n          if (Path.equals(op.path, path)) {\n            if (op.position === offset && affinity == null) {\n              return null\n            } else if (\n              op.position < offset ||\n              (op.position === offset && affinity === 'forward')\n            ) {\n              p.offset -= op.position\n\n              p.path = Path.transform(path, op, {\n                ...options,\n                affinity: 'forward',\n              })!\n            }\n          } else {\n            p.path = Path.transform(path, op, options)!\n          }\n\n          break\n        }\n      }\n    })\n  },\n}\n\n/**\n * `PointEntry` objects are returned when iterating over `Point` objects that\n * belong to a range.\n */\n\nexport type PointEntry = [Point, 'anchor' | 'focus']\n","import { Operation, Point } from '..'\n\n/**\n * `PointRef` objects keep a specific point in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date point value.\n */\n\nexport interface PointRef {\n  current: Point | null\n  affinity: 'forward' | 'backward' | null\n  unref(): Point | null\n}\n\nexport const PointRef = {\n  /**\n   * Transform the point ref's current value by an operation.\n   */\n\n  transform(ref: PointRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const point = Point.transform(current, op, { affinity })\n    ref.current = point\n\n    if (point == null) {\n      ref.unref()\n    }\n  },\n}\n","import { produce } from 'immer'\nimport isPlainObject from 'is-plain-object'\nimport { Operation, Path, Point, PointEntry } from '..'\n\n/**\n * `Range` objects are a set of points that refer to a specific span of a Slate\n * document. They can define a span inside a single node or a can span across\n * multiple nodes.\n */\n\nexport interface Range {\n  anchor: Point\n  focus: Point\n  [key: string]: unknown\n}\n\nexport const Range = {\n  /**\n   * Get the start and end points of a range, in the order in which they appear\n   * in the document.\n   */\n\n  edges(\n    range: Range,\n    options: {\n      reverse?: boolean\n    } = {}\n  ): [Point, Point] {\n    const { reverse = false } = options\n    const { anchor, focus } = range\n    return Range.isBackward(range) === reverse\n      ? [anchor, focus]\n      : [focus, anchor]\n  },\n\n  /**\n   * Get the end point of a range.\n   */\n\n  end(range: Range): Point {\n    const [, end] = Range.edges(range)\n    return end\n  },\n\n  /**\n   * Check if a range is exactly equal to another.\n   */\n\n  equals(range: Range, another: Range): boolean {\n    return (\n      Point.equals(range.anchor, another.anchor) &&\n      Point.equals(range.focus, another.focus)\n    )\n  },\n\n  /**\n   * Check if a range includes a path, a point or part of another range.\n   */\n\n  includes(range: Range, target: Path | Point | Range): boolean {\n    if (Range.isRange(target)) {\n      if (\n        Range.includes(range, target.anchor) ||\n        Range.includes(range, target.focus)\n      ) {\n        return true\n      }\n\n      const [rs, re] = Range.edges(range)\n      const [ts, te] = Range.edges(target)\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te)\n    }\n\n    const [start, end] = Range.edges(range)\n    let isAfterStart = false\n    let isBeforeEnd = false\n\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start) >= 0\n      isBeforeEnd = Point.compare(target, end) <= 0\n    } else {\n      isAfterStart = Path.compare(target, start.path) >= 0\n      isBeforeEnd = Path.compare(target, end.path) <= 0\n    }\n\n    return isAfterStart && isBeforeEnd\n  },\n\n  /**\n   * Get the intersection of a range with another.\n   */\n\n  intersection(range: Range, another: Range): Range | null {\n    const { anchor, focus, ...rest } = range\n    const [s1, e1] = Range.edges(range)\n    const [s2, e2] = Range.edges(another)\n    const start = Point.isBefore(s1, s2) ? s2 : s1\n    const end = Point.isBefore(e1, e2) ? e1 : e2\n\n    if (Point.isBefore(end, start)) {\n      return null\n    } else {\n      return { anchor: start, focus: end, ...rest }\n    }\n  },\n\n  /**\n   * Check if a range is backward, meaning that its anchor point appears in the\n   * document _after_ its focus point.\n   */\n\n  isBackward(range: Range): boolean {\n    const { anchor, focus } = range\n    return Point.isAfter(anchor, focus)\n  },\n\n  /**\n   * Check if a range is collapsed, meaning that both its anchor and focus\n   * points refer to the exact same position in the document.\n   */\n\n  isCollapsed(range: Range): boolean {\n    const { anchor, focus } = range\n    return Point.equals(anchor, focus)\n  },\n\n  /**\n   * Check if a range is expanded.\n   *\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\n   */\n\n  isExpanded(range: Range): boolean {\n    return !Range.isCollapsed(range)\n  },\n\n  /**\n   * Check if a range is forward.\n   *\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\n   */\n\n  isForward(range: Range): boolean {\n    return !Range.isBackward(range)\n  },\n\n  /**\n   * Check if a value implements the [[Range]] interface.\n   */\n\n  isRange(value: any): value is Range {\n    return (\n      isPlainObject(value) &&\n      Point.isPoint(value.anchor) &&\n      Point.isPoint(value.focus)\n    )\n  },\n\n  /**\n   * Iterate through all of the point entries in a range.\n   */\n\n  *points(range: Range): Iterable<PointEntry> {\n    yield [range.anchor, 'anchor']\n    yield [range.focus, 'focus']\n  },\n\n  /**\n   * Get the start point of a range.\n   */\n\n  start(range: Range): Point {\n    const [start] = Range.edges(range)\n    return start\n  },\n\n  /**\n   * Transform a range by an operation.\n   */\n\n  transform(\n    range: Range,\n    op: Operation,\n    options: { affinity: 'forward' | 'backward' | 'outward' | 'inward' | null }\n  ): Range | null {\n    const { affinity = 'inward' } = options\n    let affinityAnchor: 'forward' | 'backward' | null\n    let affinityFocus: 'forward' | 'backward' | null\n\n    if (affinity === 'inward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'forward'\n        affinityFocus = 'backward'\n      } else {\n        affinityAnchor = 'backward'\n        affinityFocus = 'forward'\n      }\n    } else if (affinity === 'outward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'backward'\n        affinityFocus = 'forward'\n      } else {\n        affinityAnchor = 'forward'\n        affinityFocus = 'backward'\n      }\n    } else {\n      affinityAnchor = affinity\n      affinityFocus = affinity\n    }\n\n    return produce(range, r => {\n      const anchor = Point.transform(r.anchor, op, { affinity: affinityAnchor })\n      const focus = Point.transform(r.focus, op, { affinity: affinityFocus })\n\n      if (!anchor || !focus) {\n        return null\n      }\n\n      r.anchor = anchor\n      r.focus = focus\n    })\n  },\n}\n","import { Operation, Range } from '..'\n\n/**\n * `RangeRef` objects keep a specific range in a document synced over time as new\n * operations are applied to the editor. You can access their `current` property\n * at any time for the up-to-date range value.\n */\n\nexport interface RangeRef {\n  current: Range | null\n  affinity: 'forward' | 'backward' | 'outward' | 'inward' | null\n  unref(): Range | null\n}\n\nexport const RangeRef = {\n  /**\n   * Transform the range ref's current value by an operation.\n   */\n\n  transform(ref: RangeRef, op: Operation): void {\n    const { current, affinity } = ref\n\n    if (current == null) {\n      return\n    }\n\n    const path = Range.transform(current, op, { affinity })\n    ref.current = path\n\n    if (path == null) {\n      ref.unref()\n    }\n  },\n}\n","import isPlainObject from 'is-plain-object'\nimport { Range } from '..'\n\n/**\n * `Text` objects represent the nodes that contain the actual text content of a\n * Slate document along with any formatting properties. They are always leaf\n * nodes in the document tree as they cannot contain any children.\n */\n\nexport interface Text {\n  text: string\n  [key: string]: unknown\n}\n\nexport const Text = {\n  /**\n   * Check if two text nodes are equal.\n   */\n\n  equals(\n    text: Text,\n    another: Text,\n    options: { loose?: boolean } = {}\n  ): boolean {\n    const { loose = false } = options\n\n    for (const key in text) {\n      if (loose && key === 'text') {\n        continue\n      }\n\n      if (text[key] !== another[key]) {\n        return false\n      }\n    }\n\n    for (const key in another) {\n      if (loose && key === 'text') {\n        continue\n      }\n\n      if (text[key] !== another[key]) {\n        return false\n      }\n    }\n\n    return true\n  },\n\n  /**\n   * Check if a value implements the `Text` interface.\n   */\n\n  isText(value: any): value is Text {\n    return isPlainObject(value) && typeof value.text === 'string'\n  },\n\n  /**\n   * Check if a value is a list of `Text` objects.\n   */\n\n  isTextList(value: any): value is Text[] {\n    return Array.isArray(value) && (value.length === 0 || Text.isText(value[0]))\n  },\n\n  /**\n   * Check if an text matches set of properties.\n   *\n   * Note: this is for matching custom properties, and it does not ensure that\n   * the `text` property are two nodes equal.\n   */\n\n  matches(text: Text, props: Partial<Text>): boolean {\n    for (const key in props) {\n      if (key === 'text') {\n        continue\n      }\n\n      if (text[key] !== props[key]) {\n        return false\n      }\n    }\n\n    return true\n  },\n\n  /**\n   * Get the leaves for a text node given decorations.\n   */\n\n  decorations(node: Text, decorations: Range[]): Text[] {\n    let leaves: Text[] = [{ ...node }]\n\n    for (const dec of decorations) {\n      const { anchor, focus, ...rest } = dec\n      const [start, end] = Range.edges(dec)\n      const next = []\n      let o = 0\n\n      for (const leaf of leaves) {\n        const { length } = leaf.text\n        const offset = o\n        o += length\n\n        // If the range encompases the entire leaf, add the range.\n        if (start.offset <= offset && end.offset >= offset + length) {\n          Object.assign(leaf, rest)\n          next.push(leaf)\n          continue\n        }\n\n        // If the range starts after the leaf, or ends before it, continue.\n        if (\n          start.offset > offset + length ||\n          end.offset < offset ||\n          (end.offset === offset && offset !== 0)\n        ) {\n          next.push(leaf)\n          continue\n        }\n\n        // Otherwise we need to split the leaf, at the start, end, or both,\n        // and add the range to the middle intersecting section. Do the end\n        // split first since we don't need to update the offset that way.\n        let middle = leaf\n        let before\n        let after\n\n        if (end.offset < offset + length) {\n          const off = end.offset - offset\n          after = { ...middle, text: middle.text.slice(off) }\n          middle = { ...middle, text: middle.text.slice(0, off) }\n        }\n\n        if (start.offset > offset) {\n          const off = start.offset - offset\n          before = { ...middle, text: middle.text.slice(0, off) }\n          middle = { ...middle, text: middle.text.slice(off) }\n        }\n\n        Object.assign(middle, rest)\n\n        if (before) {\n          next.push(before)\n        }\n\n        next.push(middle)\n\n        if (after) {\n          next.push(after)\n        }\n      }\n\n      leaves = next\n    }\n\n    return leaves\n  },\n}\n","import { createDraft, finishDraft, isDraft } from 'immer'\nimport {\n  Node,\n  Editor,\n  Range,\n  Point,\n  Text,\n  Element,\n  Operation,\n  Descendant,\n  NodeEntry,\n  Path,\n  Ancestor,\n} from '..'\n\nexport const GeneralTransforms = {\n  /**\n   * Transform the editor by an operation.\n   */\n\n  transform(editor: Editor, op: Operation) {\n    editor.children = createDraft(editor.children)\n    let selection = editor.selection && createDraft(editor.selection)\n\n    switch (op.type) {\n      case 'insert_node': {\n        const { path, node } = op\n        const parent = Node.parent(editor, path)\n        const index = path[path.length - 1]\n        parent.children.splice(index, 0, node)\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'insert_text': {\n        const { path, offset, text } = op\n        const node = Node.leaf(editor, path)\n        const before = node.text.slice(0, offset)\n        const after = node.text.slice(offset)\n        node.text = before + text + after\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'merge_node': {\n        const { path } = op\n        const node = Node.get(editor, path)\n        const prevPath = Path.previous(path)\n        const prev = Node.get(editor, prevPath)\n        const parent = Node.parent(editor, path)\n        const index = path[path.length - 1]\n\n        if (Text.isText(node) && Text.isText(prev)) {\n          prev.text += node.text\n        } else if (!Text.isText(node) && !Text.isText(prev)) {\n          prev.children.push(...node.children)\n        } else {\n          throw new Error(\n            `Cannot apply a \"merge_node\" operation at path [${path}] to nodes of different interaces: ${node} ${prev}`\n          )\n        }\n\n        parent.children.splice(index, 1)\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'move_node': {\n        const { path, newPath } = op\n\n        if (Path.isAncestor(path, newPath)) {\n          throw new Error(\n            `Cannot move a path [${path}] to new path [${newPath}] because the destination is inside itself.`\n          )\n        }\n\n        const node = Node.get(editor, path)\n        const parent = Node.parent(editor, path)\n        const index = path[path.length - 1]\n\n        // This is tricky, but since the `path` and `newPath` both refer to\n        // the same snapshot in time, there's a mismatch. After either\n        // removing the original position, the second step's path can be out\n        // of date. So instead of using the `op.newPath` directly, we\n        // transform `op.path` to ascertain what the `newPath` would be after\n        // the operation was applied.\n        parent.children.splice(index, 1)\n        const truePath = Path.transform(path, op)!\n        const newParent = Node.get(editor, Path.parent(truePath)) as Ancestor\n        const newIndex = truePath[truePath.length - 1]\n\n        newParent.children.splice(newIndex, 0, node)\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'remove_node': {\n        const { path } = op\n        const index = path[path.length - 1]\n        const parent = Node.parent(editor, path)\n        parent.children.splice(index, 1)\n\n        // Transform all of the points in the value, but if the point was in the\n        // node that was removed we need to update the range or remove it.\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            const result = Point.transform(point, op)\n\n            if (selection != null && result != null) {\n              selection[key] = result\n            } else {\n              let prev: NodeEntry<Text> | undefined\n              let next: NodeEntry<Text> | undefined\n\n              for (const [n, p] of Node.texts(editor)) {\n                if (Path.compare(p, path) === -1) {\n                  prev = [n, p]\n                } else {\n                  next = [n, p]\n                  break\n                }\n              }\n\n              if (prev) {\n                point.path = prev[1]\n                point.offset = prev[0].text.length\n              } else if (next) {\n                point.path = next[1]\n                point.offset = 0\n              } else {\n                selection = null\n              }\n            }\n          }\n        }\n\n        break\n      }\n\n      case 'remove_text': {\n        const { path, offset, text } = op\n        const node = Node.leaf(editor, path)\n        const before = node.text.slice(0, offset)\n        const after = node.text.slice(offset + text.length)\n        node.text = before + after\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n\n      case 'set_node': {\n        const { path, newProperties } = op\n\n        if (path.length === 0) {\n          throw new Error(`Cannot set properties on the root node!`)\n        }\n\n        const node = Node.get(editor, path)\n\n        for (const key in newProperties) {\n          if (key === 'children' || key === 'text') {\n            throw new Error(`Cannot set the \"${key}\" property of nodes!`)\n          }\n\n          const value = newProperties[key]\n\n          if (value == null) {\n            delete node[key]\n          } else {\n            node[key] = value\n          }\n        }\n\n        break\n      }\n\n      case 'set_selection': {\n        const { newProperties } = op\n\n        if (newProperties == null) {\n          selection = newProperties\n        } else if (selection == null) {\n          if (!Range.isRange(newProperties)) {\n            throw new Error(\n              `Cannot apply an incomplete \"set_selection\" operation properties ${JSON.stringify(\n                newProperties\n              )} when there is no current selection.`\n            )\n          }\n\n          selection = newProperties\n        } else {\n          Object.assign(selection, newProperties)\n        }\n\n        break\n      }\n\n      case 'split_node': {\n        const { path, position, properties } = op\n\n        if (path.length === 0) {\n          throw new Error(\n            `Cannot apply a \"split_node\" operation at path [${path}] because the root node cannot be split.`\n          )\n        }\n\n        const node = Node.get(editor, path)\n        const parent = Node.parent(editor, path)\n        const index = path[path.length - 1]\n        let newNode: Descendant\n\n        if (Text.isText(node)) {\n          const before = node.text.slice(0, position)\n          const after = node.text.slice(position)\n          node.text = before\n          newNode = {\n            ...node,\n            ...(properties as Partial<Text>),\n            text: after,\n          }\n        } else {\n          const before = node.children.slice(0, position)\n          const after = node.children.slice(position)\n          node.children = before\n\n          newNode = {\n            ...node,\n            ...(properties as Partial<Element>),\n            children: after,\n          }\n        }\n\n        parent.children.splice(index + 1, 0, newNode)\n\n        if (selection) {\n          for (const [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op)!\n          }\n        }\n\n        break\n      }\n    }\n\n    editor.children = finishDraft(editor.children) as Node[]\n\n    if (selection) {\n      editor.selection = isDraft(selection)\n        ? (finishDraft(selection) as Range)\n        : selection\n    } else {\n      editor.selection = null\n    }\n  },\n}\n","import {\n  Editor,\n  Element,\n  Location,\n  Node,\n  Path,\n  Point,\n  Range,\n  Text,\n  Transforms,\n  NodeEntry,\n  Ancestor,\n} from '..'\n\nexport const NodeTransforms = {\n  /**\n   * Insert nodes at a specific location in the Editor.\n   */\n\n  insertNodes(\n    editor: Editor,\n    nodes: Node | Node[],\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      select?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { hanging = false, voids = false, mode = 'lowest' } = options\n      let { at, match, select } = options\n\n      if (Node.isNode(nodes)) {\n        nodes = [nodes]\n      }\n\n      if (nodes.length === 0) {\n        return\n      }\n\n      const [node] = nodes\n\n      // By default, use the selection as the target location. But if there is\n      // no selection, insert at the end of the document since that is such a\n      // common use case when inserting from a non-selected state.\n      if (!at) {\n        if (editor.selection) {\n          at = editor.selection\n        } else if (editor.children.length > 0) {\n          at = Editor.end(editor, [])\n        } else {\n          at = [0]\n        }\n\n        select = true\n      }\n\n      if (select == null) {\n        select = false\n      }\n\n      if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at)\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at })\n          at = pointRef.unref()!\n        }\n      }\n\n      if (Point.isPoint(at)) {\n        if (match == null) {\n          if (Text.isText(node)) {\n            match = n => Text.isText(n)\n          } else if (editor.isInline(node)) {\n            match = n => Text.isText(n) || Editor.isInline(editor, n)\n          } else {\n            match = n => Editor.isBlock(editor, n)\n          }\n        }\n\n        const [entry] = Editor.nodes(editor, {\n          at: at.path,\n          match,\n          mode,\n          voids,\n        })\n\n        if (entry) {\n          const [, matchPath] = entry\n          const pathRef = Editor.pathRef(editor, matchPath)\n          const isAtEnd = Editor.isEnd(editor, at, matchPath)\n          Transforms.splitNodes(editor, { at, match, mode, voids })\n          const path = pathRef.unref()!\n          at = isAtEnd ? Path.next(path) : path\n        } else {\n          return\n        }\n      }\n\n      const parentPath = Path.parent(at)\n      let index = at[at.length - 1]\n\n      if (!voids && Editor.void(editor, { at: parentPath })) {\n        return\n      }\n\n      for (const node of nodes) {\n        const path = parentPath.concat(index)\n        index++\n        editor.apply({ type: 'insert_node', path, node })\n      }\n\n      if (select) {\n        const point = Editor.end(editor, at)\n\n        if (point) {\n          Transforms.select(editor, point)\n        }\n      }\n    })\n  },\n\n  /**\n   * Lift nodes at a specific location upwards in the document tree, splitting\n   * their parent in two if necessary.\n   */\n\n  liftNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'all' | 'highest' | 'lowest'\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { at = editor.selection, mode = 'lowest', voids = false } = options\n      let { match } = options\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (!at) {\n        return\n      }\n\n      const matches = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n\n        if (path.length < 2) {\n          throw new Error(\n            `Cannot lift node at a path [${path}] because it has a depth of less than \\`2\\`.`\n          )\n        }\n\n        const parentNodeEntry = Editor.node(editor, Path.parent(path))\n        const [parent, parentPath] = parentNodeEntry as NodeEntry<Ancestor>\n        const index = path[path.length - 1]\n        const { length } = parent.children\n\n        if (length === 1) {\n          const toPath = Path.next(parentPath)\n          Transforms.moveNodes(editor, { at: path, to: toPath, voids })\n          Transforms.removeNodes(editor, { at: parentPath, voids })\n        } else if (index === 0) {\n          Transforms.moveNodes(editor, { at: path, to: parentPath, voids })\n        } else if (index === length - 1) {\n          const toPath = Path.next(parentPath)\n          Transforms.moveNodes(editor, { at: path, to: toPath, voids })\n        } else {\n          const splitPath = Path.next(path)\n          const toPath = Path.next(parentPath)\n          Transforms.splitNodes(editor, { at: splitPath, voids })\n          Transforms.moveNodes(editor, { at: path, to: toPath, voids })\n        }\n      }\n    })\n  },\n\n  /**\n   * Merge a node at a location with the previous node of the same depth,\n   * removing any empty containing nodes after the merge if necessary.\n   */\n\n  mergeNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      let { match, at = editor.selection } = options\n      const { hanging = false, voids = false, mode = 'lowest' } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          const [parent] = Editor.parent(editor, at)\n          match = n => parent.children.includes(n)\n        } else {\n          match = n => Editor.isBlock(editor, n)\n        }\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at)\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at })\n          at = pointRef.unref()!\n\n          if (options.at == null) {\n            Transforms.select(editor, at)\n          }\n        }\n      }\n\n      const [current] = Editor.nodes(editor, { at, match, voids, mode })\n      const prev = Editor.previous(editor, { at, match, voids, mode })\n\n      if (!current || !prev) {\n        return\n      }\n\n      const [node, path] = current\n      const [prevNode, prevPath] = prev\n\n      if (path.length === 0 || prevPath.length === 0) {\n        return\n      }\n\n      const newPath = Path.next(prevPath)\n      const commonPath = Path.common(path, prevPath)\n      const isPreviousSibling = Path.isSibling(path, prevPath)\n      const levels = Array.from(Editor.levels(editor, { at: path }), ([n]) => n)\n        .slice(commonPath.length)\n        .slice(0, -1)\n\n      // Determine if the merge will leave an ancestor of the path empty as a\n      // result, in which case we'll want to remove it after merging.\n      const emptyAncestor = Editor.above(editor, {\n        at: path,\n        mode: 'highest',\n        match: n =>\n          levels.includes(n) && Element.isElement(n) && n.children.length === 1,\n      })\n\n      const emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1])\n      let properties\n      let position\n\n      // Ensure that the nodes are equivalent, and figure out what the position\n      // and extra properties of the merge will be.\n      if (Text.isText(node) && Text.isText(prevNode)) {\n        const { text, ...rest } = node\n        position = prevNode.text.length\n        properties = rest as Partial<Text>\n      } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n        const { children, ...rest } = node\n        position = prevNode.children.length\n        properties = rest as Partial<Element>\n      } else {\n        throw new Error(\n          `Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(\n            node\n          )} ${JSON.stringify(prevNode)}`\n        )\n      }\n\n      // If the node isn't already the next sibling of the previous node, move\n      // it so that it is before merging.\n      if (!isPreviousSibling) {\n        Transforms.moveNodes(editor, { at: path, to: newPath, voids })\n      }\n\n      // If there was going to be an empty ancestor of the node that was merged,\n      // we remove it from the tree.\n      if (emptyRef) {\n        Transforms.removeNodes(editor, { at: emptyRef.current!, voids })\n      }\n\n      // If the target node that we're merging with is empty, remove it instead\n      // of merging the two. This is a common rich text editor behavior to\n      // prevent losing formatting when deleting entire nodes when you have a\n      // hanging selection.\n      if (\n        (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode)) ||\n        (Text.isText(prevNode) && prevNode.text === '')\n      ) {\n        Transforms.removeNodes(editor, { at: prevPath, voids })\n      } else {\n        editor.apply({\n          type: 'merge_node',\n          path: newPath,\n          position,\n          properties,\n        })\n      }\n\n      if (emptyRef) {\n        emptyRef.unref()\n      }\n    })\n  },\n\n  /**\n   * Move the nodes at a location to a new location.\n   */\n\n  moveNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'all' | 'highest' | 'lowest'\n      to: Path\n      voids?: boolean\n    }\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const {\n        to,\n        at = editor.selection,\n        mode = 'lowest',\n        voids = false,\n      } = options\n      let { match } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      const toRef = Editor.pathRef(editor, to)\n      const targets = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(targets, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        const newPath = toRef.current!\n\n        if (path.length !== 0) {\n          editor.apply({ type: 'move_node', path, newPath })\n        }\n      }\n\n      toRef.unref()\n    })\n  },\n\n  /**\n   * Remove the nodes at a specific location in the document.\n   */\n\n  removeNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'highest' | 'lowest'\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { hanging = false, voids = false, mode = 'lowest' } = options\n      let { at = editor.selection, match } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at)\n      }\n\n      const depths = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(depths, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n\n        if (path) {\n          const [node] = Editor.node(editor, path)\n          editor.apply({ type: 'remove_node', path, node })\n        }\n      }\n    })\n  },\n\n  /**\n   * Set new properties on the nodes at a location.\n   */\n\n  setNodes(\n    editor: Editor,\n    props: Partial<Node>,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'all' | 'highest' | 'lowest'\n      hanging?: boolean\n      split?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      let { match, at = editor.selection } = options\n      const {\n        hanging = false,\n        mode = 'lowest',\n        split = false,\n        voids = false,\n      } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at)\n      }\n\n      if (split && Range.isRange(at)) {\n        const rangeRef = Editor.rangeRef(editor, at, { affinity: 'inward' })\n        const [start, end] = Range.edges(at)\n        const splitMode = mode === 'lowest' ? 'lowest' : 'highest'\n        Transforms.splitNodes(editor, {\n          at: end,\n          match,\n          mode: splitMode,\n          voids,\n        })\n        Transforms.splitNodes(editor, {\n          at: start,\n          match,\n          mode: splitMode,\n          voids,\n        })\n        at = rangeRef.unref()!\n\n        if (options.at == null) {\n          Transforms.select(editor, at)\n        }\n      }\n\n      for (const [node, path] of Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids,\n      })) {\n        const properties: Partial<Node> = {}\n        const newProperties: Partial<Node> = {}\n\n        // You can't set properties on the editor node.\n        if (path.length === 0) {\n          continue\n        }\n\n        for (const k in props) {\n          if (k === 'children' || k === 'text') {\n            continue\n          }\n\n          if (props[k] !== node[k]) {\n            properties[k] = node[k]\n            newProperties[k] = props[k]\n          }\n        }\n\n        if (Object.keys(newProperties).length !== 0) {\n          editor.apply({\n            type: 'set_node',\n            path,\n            properties,\n            newProperties,\n          })\n        }\n      }\n    })\n  },\n\n  /**\n   * Split the nodes at a specific location.\n   */\n\n  splitNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'highest' | 'lowest'\n      always?: boolean\n      height?: number\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { mode = 'lowest', voids = false } = options\n      let { match, at = editor.selection, height = 0, always = false } = options\n\n      if (match == null) {\n        match = n => Editor.isBlock(editor, n)\n      }\n\n      if (Range.isRange(at)) {\n        at = deleteRange(editor, at)\n      }\n\n      // If the target is a path, the default height-skipping and position\n      // counters need to account for us potentially splitting at a non-leaf.\n      if (Path.isPath(at)) {\n        const path = at\n        const point = Editor.point(editor, path)\n        const [parent] = Editor.parent(editor, path)\n        match = n => n === parent\n        height = point.path.length - path.length + 1\n        at = point\n        always = true\n      }\n\n      if (!at) {\n        return\n      }\n\n      const beforeRef = Editor.pointRef(editor, at, {\n        affinity: 'backward',\n      })\n      const [highest] = Editor.nodes(editor, { at, match, mode, voids })\n\n      if (!highest) {\n        return\n      }\n\n      const voidMatch = Editor.void(editor, { at, mode: 'highest' })\n      const nudge = 0\n\n      if (!voids && voidMatch) {\n        const [voidNode, voidPath] = voidMatch\n\n        if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n          let after = Editor.after(editor, voidPath)\n\n          if (!after) {\n            const text = { text: '' }\n            const afterPath = Path.next(voidPath)\n            Transforms.insertNodes(editor, text, { at: afterPath, voids })\n            after = Editor.point(editor, afterPath)!\n          }\n\n          at = after\n          always = true\n        }\n\n        const siblingHeight = at.path.length - voidPath.length\n        height = siblingHeight + 1\n        always = true\n      }\n\n      const afterRef = Editor.pointRef(editor, at)\n      const depth = at.path.length - height\n      const [, highestPath] = highest\n      const lowestPath = at.path.slice(0, depth)\n      let position = height === 0 ? at.offset : at.path[depth] + nudge\n\n      for (const [node, path] of Editor.levels(editor, {\n        at: lowestPath,\n        reverse: true,\n        voids,\n      })) {\n        let split = false\n\n        if (\n          path.length < highestPath.length ||\n          path.length === 0 ||\n          (!voids && Editor.isVoid(editor, node))\n        ) {\n          break\n        }\n\n        const point = beforeRef.current!\n        const isEnd = Editor.isEnd(editor, point, path)\n\n        if (always || !beforeRef || !Editor.isEdge(editor, point, path)) {\n          split = true\n          const { text, children, ...properties } = node\n          editor.apply({\n            type: 'split_node',\n            path,\n            position,\n            properties,\n          })\n        }\n\n        position = path[path.length - 1] + (split || isEnd ? 1 : 0)\n      }\n\n      if (options.at == null) {\n        const point = afterRef.current || Editor.end(editor, [])\n        Transforms.select(editor, point)\n      }\n\n      beforeRef.unref()\n      afterRef.unref()\n    })\n  },\n\n  /**\n   * Unset properties on the nodes at a location.\n   */\n\n  unsetNodes(\n    editor: Editor,\n    props: string | string[],\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    if (!Array.isArray(props)) {\n      props = [props]\n    }\n\n    const obj = {}\n\n    for (const key of props) {\n      obj[key] = null\n    }\n\n    Transforms.setNodes(editor, obj, options)\n  },\n\n  /**\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\n   * necessary to ensure that only the content in the range is unwrapped.\n   */\n\n  unwrapNodes(\n    editor: Editor,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    }\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { mode = 'lowest', split = false, voids = false } = options\n      let { at = editor.selection, match } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        match = Path.isPath(at)\n          ? matchPath(editor, at)\n          : n => Editor.isBlock(editor, n)\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at)\n      }\n\n      const rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null\n      const matches = Editor.nodes(editor, { at, match, mode, voids })\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        const [node] = Editor.node(editor, path) as NodeEntry<Ancestor>\n        let range = Editor.range(editor, path)\n\n        if (split && rangeRef) {\n          range = Range.intersection(rangeRef.current!, range)!\n        }\n\n        Transforms.liftNodes(editor, {\n          at: range,\n          match: n => node.children.includes(n),\n          voids,\n        })\n      }\n\n      if (rangeRef) {\n        rangeRef.unref()\n      }\n    })\n  },\n\n  /**\n   * Wrap the nodes at a location in a new container node, splitting the edges\n   * of the range first to ensure that only the content in the range is wrapped.\n   */\n\n  wrapNodes(\n    editor: Editor,\n    element: Element,\n    options: {\n      at?: Location\n      match?: (node: Node) => boolean\n      mode?: 'all' | 'highest' | 'lowest'\n      split?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { mode = 'lowest', split = false, voids = false } = options\n      let { match, at = editor.selection } = options\n\n      if (!at) {\n        return\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          match = matchPath(editor, at)\n        } else if (editor.isInline(element)) {\n          match = n => Editor.isInline(editor, n) || Text.isText(n)\n        } else {\n          match = n => Editor.isBlock(editor, n)\n        }\n      }\n\n      if (split && Range.isRange(at)) {\n        const [start, end] = Range.edges(at)\n        const rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward',\n        })\n        Transforms.splitNodes(editor, { at: end, match, voids })\n        Transforms.splitNodes(editor, { at: start, match, voids })\n        at = rangeRef.unref()!\n\n        if (options.at == null) {\n          Transforms.select(editor, at)\n        }\n      }\n\n      const roots = Array.from(\n        Editor.nodes(editor, {\n          at,\n          match: editor.isInline(element)\n            ? n => Editor.isBlock(editor, n)\n            : n => Editor.isEditor(n),\n          mode: 'lowest',\n          voids,\n        })\n      )\n\n      for (const [, rootPath] of roots) {\n        const a = Range.isRange(at)\n          ? Range.intersection(at, Editor.range(editor, rootPath))\n          : at\n\n        if (!a) {\n          continue\n        }\n\n        const matches = Array.from(\n          Editor.nodes(editor, { at: a, match, mode, voids })\n        )\n\n        if (matches.length > 0) {\n          const [first] = matches\n          const last = matches[matches.length - 1]\n          const [, firstPath] = first\n          const [, lastPath] = last\n          const commonPath = Path.equals(firstPath, lastPath)\n            ? Path.parent(firstPath)\n            : Path.common(firstPath, lastPath)\n\n          const range = Editor.range(editor, firstPath, lastPath)\n          const commonNodeEntry = Editor.node(editor, commonPath)\n          const [commonNode] = commonNodeEntry as NodeEntry<Ancestor>\n          const depth = commonPath.length + 1\n          const wrapperPath = Path.next(lastPath.slice(0, depth))\n          const wrapper = { ...element, children: [] }\n          Transforms.insertNodes(editor, wrapper, { at: wrapperPath, voids })\n\n          Transforms.moveNodes(editor, {\n            at: range,\n            match: n => commonNode.children.includes(n),\n            to: wrapperPath.concat(0),\n            voids,\n          })\n        }\n      }\n    })\n  },\n}\n\n/**\n * Convert a range into a point by deleting it's content.\n */\n\nconst deleteRange = (editor: Editor, range: Range): Point | null => {\n  if (Range.isCollapsed(range)) {\n    return range.anchor\n  } else {\n    const [, end] = Range.edges(range)\n    const pointRef = Editor.pointRef(editor, end)\n    Transforms.delete(editor, { at: range })\n    return pointRef.unref()\n  }\n}\n\nconst matchPath = (editor: Editor, path: Path): ((node: Node) => boolean) => {\n  const [node] = Editor.node(editor, path)\n  return n => n === node\n}\n","import { Editor, Location, Point, Range, Transforms } from '..'\n\nexport const SelectionTransforms = {\n  /**\n   * Collapse the selection.\n   */\n\n  collapse(\n    editor: Editor,\n    options: {\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    } = {}\n  ) {\n    const { edge = 'anchor' } = options\n    const { selection } = editor\n\n    if (!selection) {\n      return\n    } else if (edge === 'anchor') {\n      Transforms.select(editor, selection.anchor)\n    } else if (edge === 'focus') {\n      Transforms.select(editor, selection.focus)\n    } else if (edge === 'start') {\n      const [start] = Range.edges(selection)\n      Transforms.select(editor, start)\n    } else if (edge === 'end') {\n      const [, end] = Range.edges(selection)\n      Transforms.select(editor, end)\n    }\n  },\n\n  /**\n   * Unset the selection.\n   */\n\n  deselect(editor: Editor) {\n    const { selection } = editor\n\n    if (selection) {\n      editor.apply({\n        type: 'set_selection',\n        properties: selection,\n        newProperties: null,\n      })\n    }\n  },\n\n  /**\n   * Move the selection's point forward or backward.\n   */\n\n  move(\n    editor: Editor,\n    options: {\n      distance?: number\n      unit?: 'offset' | 'character' | 'word' | 'line'\n      reverse?: boolean\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    } = {}\n  ) {\n    const { selection } = editor\n    const { distance = 1, unit = 'character', reverse = false } = options\n    let { edge = null } = options\n\n    if (!selection) {\n      return\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor'\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus'\n    }\n\n    const { anchor, focus } = selection\n    const opts = { distance, unit }\n    const props: Partial<Range> = {}\n\n    if (edge == null || edge === 'anchor') {\n      const point = reverse\n        ? Editor.before(editor, anchor, opts)\n        : Editor.after(editor, anchor, opts)\n\n      if (point) {\n        props.anchor = point\n      }\n    }\n\n    if (edge == null || edge === 'focus') {\n      const point = reverse\n        ? Editor.before(editor, focus, opts)\n        : Editor.after(editor, focus, opts)\n\n      if (point) {\n        props.focus = point\n      }\n    }\n\n    Transforms.setSelection(editor, props)\n  },\n\n  /**\n   * Set the selection to a new value.\n   */\n\n  select(editor: Editor, target: Location) {\n    const { selection } = editor\n    target = Editor.range(editor, target)\n\n    if (selection) {\n      Transforms.setSelection(editor, target)\n      return\n    }\n\n    if (!Range.isRange(target)) {\n      throw new Error(\n        `When setting the selection and the current selection is \\`null\\` you must provide at least an \\`anchor\\` and \\`focus\\`, but you passed: ${JSON.stringify(\n          target\n        )}`\n      )\n    }\n\n    editor.apply({\n      type: 'set_selection',\n      properties: selection,\n      newProperties: target,\n    })\n  },\n\n  /**\n   * Set new properties on one of the selection's points.\n   */\n\n  setPoint(\n    editor: Editor,\n    props: Partial<Point>,\n    options: {\n      edge?: 'anchor' | 'focus' | 'start' | 'end'\n    }\n  ) {\n    const { selection } = editor\n    let { edge = 'both' } = options\n\n    if (!selection) {\n      return\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor'\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus'\n    }\n\n    const { anchor, focus } = selection\n    const point = edge === 'anchor' ? anchor : focus\n\n    Transforms.setSelection(editor, {\n      [edge === 'anchor' ? 'anchor' : 'focus']: { ...point, ...props },\n    })\n  },\n\n  /**\n   * Set new properties on the selection.\n   */\n\n  setSelection(editor: Editor, props: Partial<Range>) {\n    const { selection } = editor\n    const oldProps: Partial<Range> | null = {}\n    const newProps: Partial<Range> = {}\n\n    if (!selection) {\n      return\n    }\n\n    for (const k in props) {\n      if (\n        (k === 'anchor' &&\n          props.anchor != null &&\n          !Point.equals(props.anchor, selection.anchor)) ||\n        (k === 'focus' &&\n          props.focus != null &&\n          !Point.equals(props.focus, selection.focus)) ||\n        (k !== 'anchor' && k !== 'focus' && props[k] !== selection[k])\n      ) {\n        oldProps[k] = selection[k]\n        newProps[k] = props[k]\n      }\n    }\n\n    if (Object.keys(oldProps).length > 0) {\n      editor.apply({\n        type: 'set_selection',\n        properties: oldProps,\n        newProperties: newProps,\n      })\n    }\n  },\n}\n","import {\n  Editor,\n  Element,\n  Location,\n  Node,\n  NodeEntry,\n  Path,\n  Text,\n  Point,\n  Range,\n  Transforms,\n} from '..'\n\nexport const TextTransforms = {\n  /**\n   * Delete content in the editor.\n   */\n\n  delete(\n    editor: Editor,\n    options: {\n      at?: Location\n      distance?: number\n      unit?: 'character' | 'word' | 'line' | 'block'\n      reverse?: boolean\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const {\n        reverse = false,\n        unit = 'character',\n        distance = 1,\n        voids = false,\n      } = options\n      let { at = editor.selection, hanging = false } = options\n\n      if (!at) {\n        return\n      }\n\n      if (Range.isRange(at) && Range.isCollapsed(at)) {\n        at = at.anchor\n      }\n\n      if (Point.isPoint(at)) {\n        const furthestVoid = Editor.void(editor, { at, mode: 'highest' })\n\n        if (!voids && furthestVoid) {\n          const [, voidPath] = furthestVoid\n          at = voidPath\n        } else {\n          const opts = { unit, distance }\n          const target = reverse\n            ? Editor.before(editor, at, opts) || Editor.start(editor, [])\n            : Editor.after(editor, at, opts) || Editor.end(editor, [])\n          at = { anchor: at, focus: target }\n          hanging = true\n        }\n      }\n\n      if (Path.isPath(at)) {\n        Transforms.removeNodes(editor, { at, voids })\n        return\n      }\n\n      if (Range.isCollapsed(at)) {\n        return\n      }\n\n      if (!hanging) {\n        at = Editor.unhangRange(editor, at, { voids })\n      }\n\n      let [start, end] = Range.edges(at)\n      const startBlock = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: start,\n        voids,\n      })\n      const endBlock = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: end,\n        voids,\n      })\n      const isAcrossBlocks =\n        startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1])\n      const isSingleText = Path.equals(start.path, end.path)\n      const startVoid = voids\n        ? null\n        : Editor.void(editor, { at: start, mode: 'highest' })\n      const endVoid = voids\n        ? null\n        : Editor.void(editor, { at: end, mode: 'highest' })\n\n      // If the start or end points are inside an inline void, nudge them out.\n      if (startVoid) {\n        const before = Editor.before(editor, start)\n\n        if (\n          before &&\n          startBlock &&\n          Path.isAncestor(startBlock[1], before.path)\n        ) {\n          start = before\n        }\n      }\n\n      if (endVoid) {\n        const after = Editor.after(editor, end)\n\n        if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n          end = after\n        }\n      }\n\n      // Get the highest nodes that are completely inside the range, as well as\n      // the start and end nodes.\n      const matches: NodeEntry[] = []\n      let lastPath: Path | undefined\n\n      for (const entry of Editor.nodes(editor, { at, voids })) {\n        const [node, path] = entry\n\n        if (lastPath && Path.compare(path, lastPath) === 0) {\n          continue\n        }\n\n        if (\n          (!voids && Editor.isVoid(editor, node)) ||\n          (!Path.isCommon(path, start.path) && !Path.isCommon(path, end.path))\n        ) {\n          matches.push(entry)\n          lastPath = path\n        }\n      }\n\n      const pathRefs = Array.from(matches, ([, p]) => Editor.pathRef(editor, p))\n      const startRef = Editor.pointRef(editor, start)\n      const endRef = Editor.pointRef(editor, end)\n\n      if (!isSingleText && !startVoid) {\n        const point = startRef.current!\n        const [node] = Editor.leaf(editor, point)\n        const { path } = point\n        const { offset } = start\n        const text = node.text.slice(offset)\n        editor.apply({ type: 'remove_text', path, offset, text })\n      }\n\n      for (const pathRef of pathRefs) {\n        const path = pathRef.unref()!\n        Transforms.removeNodes(editor, { at: path, voids })\n      }\n\n      if (!endVoid) {\n        const point = endRef.current!\n        const [node] = Editor.leaf(editor, point)\n        const { path } = point\n        const offset = isSingleText ? start.offset : 0\n        const text = node.text.slice(offset, end.offset)\n        editor.apply({ type: 'remove_text', path, offset, text })\n      }\n\n      if (\n        !isSingleText &&\n        isAcrossBlocks &&\n        endRef.current &&\n        startRef.current\n      ) {\n        Transforms.mergeNodes(editor, {\n          at: endRef.current,\n          hanging: true,\n          voids,\n        })\n      }\n\n      const point = endRef.unref() || startRef.unref()\n\n      if (options.at == null && point) {\n        Transforms.select(editor, point)\n      }\n    })\n  },\n\n  /**\n   * Insert a fragment at a specific location in the editor.\n   */\n\n  insertFragment(\n    editor: Editor,\n    fragment: Node[],\n    options: {\n      at?: Location\n      hanging?: boolean\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { hanging = false, voids = false } = options\n      let { at = editor.selection } = options\n\n      if (!fragment.length) {\n        return\n      }\n\n      if (!at) {\n        return\n      } else if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at)\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const [, end] = Range.edges(at)\n\n          if (!voids && Editor.void(editor, { at: end })) {\n            return\n          }\n\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at })\n          at = pointRef.unref()!\n        }\n      } else if (Path.isPath(at)) {\n        at = Editor.start(editor, at)\n      }\n\n      if (!voids && Editor.void(editor, { at })) {\n        return\n      }\n\n      // If the insert point is at the edge of an inline node, move it outside\n      // instead since it will need to be split otherwise.\n      const inlineElementMatch = Editor.above(editor, {\n        at,\n        match: n => Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })\n\n      if (inlineElementMatch) {\n        const [, inlinePath] = inlineElementMatch\n\n        if (Editor.isEnd(editor, at, inlinePath)) {\n          const after = Editor.after(editor, inlinePath)!\n          at = after\n        } else if (Editor.isStart(editor, at, inlinePath)) {\n          const before = Editor.before(editor, inlinePath)!\n          at = before\n        }\n      }\n\n      const blockMatch = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at,\n        voids,\n      })!\n      const [, blockPath] = blockMatch\n      const isBlockStart = Editor.isStart(editor, at, blockPath)\n      const isBlockEnd = Editor.isEnd(editor, at, blockPath)\n      const mergeStart = !isBlockStart || (isBlockStart && isBlockEnd)\n      const mergeEnd = !isBlockEnd\n      const [, firstPath] = Node.first({ children: fragment }, [])\n      const [, lastPath] = Node.last({ children: fragment }, [])\n\n      const matches: NodeEntry[] = []\n      const matcher = ([n, p]: NodeEntry) => {\n        if (\n          mergeStart &&\n          Path.isAncestor(p, firstPath) &&\n          Element.isElement(n) &&\n          !editor.isVoid(n) &&\n          !editor.isInline(n)\n        ) {\n          return false\n        }\n\n        if (\n          mergeEnd &&\n          Path.isAncestor(p, lastPath) &&\n          Element.isElement(n) &&\n          !editor.isVoid(n) &&\n          !editor.isInline(n)\n        ) {\n          return false\n        }\n\n        return true\n      }\n\n      for (const entry of Node.nodes(\n        { children: fragment },\n        { pass: matcher }\n      )) {\n        if (entry[1].length > 0 && matcher(entry)) {\n          matches.push(entry)\n        }\n      }\n\n      const starts = []\n      const middles = []\n      const ends = []\n      let starting = true\n      let hasBlocks = false\n\n      for (const [node] of matches) {\n        if (Element.isElement(node) && !editor.isInline(node)) {\n          starting = false\n          hasBlocks = true\n          middles.push(node)\n        } else if (starting) {\n          starts.push(node)\n        } else {\n          ends.push(node)\n        }\n      }\n\n      const [inlineMatch] = Editor.nodes(editor, {\n        at,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })!\n\n      const [, inlinePath] = inlineMatch\n      const isInlineStart = Editor.isStart(editor, at, inlinePath)\n      const isInlineEnd = Editor.isEnd(editor, at, inlinePath)\n\n      const middleRef = Editor.pathRef(\n        editor,\n        isBlockEnd ? Path.next(blockPath) : blockPath\n      )\n\n      const endRef = Editor.pathRef(\n        editor,\n        isInlineEnd ? Path.next(inlinePath) : inlinePath\n      )\n\n      Transforms.splitNodes(editor, {\n        at,\n        match: n =>\n          hasBlocks\n            ? Editor.isBlock(editor, n)\n            : Text.isText(n) || Editor.isInline(editor, n),\n        mode: hasBlocks ? 'lowest' : 'highest',\n        voids,\n      })\n\n      const startRef = Editor.pathRef(\n        editor,\n        !isInlineStart || (isInlineStart && isInlineEnd)\n          ? Path.next(inlinePath)\n          : inlinePath\n      )\n\n      Transforms.insertNodes(editor, starts, {\n        at: startRef.current!,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })\n\n      Transforms.insertNodes(editor, middles, {\n        at: middleRef.current!,\n        match: n => Editor.isBlock(editor, n),\n        mode: 'lowest',\n        voids,\n      })\n\n      Transforms.insertNodes(editor, ends, {\n        at: endRef.current!,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids,\n      })\n\n      if (!options.at) {\n        let path\n\n        if (ends.length > 0) {\n          path = Path.previous(endRef.current!)\n        } else if (middles.length > 0) {\n          path = Path.previous(middleRef.current!)\n        } else {\n          path = Path.previous(startRef.current!)\n        }\n\n        const end = Editor.end(editor, path)\n        Transforms.select(editor, end)\n      }\n\n      startRef.unref()\n      middleRef.unref()\n      endRef.unref()\n    })\n  },\n\n  /**\n   * Insert a string of text in the Editor.\n   */\n\n  insertText(\n    editor: Editor,\n    text: string,\n    options: {\n      at?: Location\n      voids?: boolean\n    } = {}\n  ) {\n    Editor.withoutNormalizing(editor, () => {\n      const { voids = false } = options\n      let { at = editor.selection } = options\n\n      if (!at) {\n        return\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at)\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor\n        } else {\n          const end = Range.end(at)\n\n          if (!voids && Editor.void(editor, { at: end })) {\n            return\n          }\n\n          const pointRef = Editor.pointRef(editor, end)\n          Transforms.delete(editor, { at, voids })\n          at = pointRef.unref()!\n          Transforms.setSelection(editor, { anchor: at, focus: at })\n        }\n      }\n\n      if (!voids && Editor.void(editor, { at })) {\n        return\n      }\n\n      const { path, offset } = at\n      editor.apply({ type: 'insert_text', path, offset, text })\n    })\n  },\n}\n","import { GeneralTransforms } from './general'\nimport { NodeTransforms } from './node'\nimport { SelectionTransforms } from './selection'\nimport { TextTransforms } from './text'\n\nexport const Transforms = {\n  ...GeneralTransforms,\n  ...NodeTransforms,\n  ...SelectionTransforms,\n  ...TextTransforms,\n}\n","import {\n  Descendant,\n  Editor,\n  Element,\n  Node,\n  NodeEntry,\n  Operation,\n  Path,\n  PathRef,\n  PointRef,\n  Range,\n  RangeRef,\n  Text,\n  Transforms,\n} from './'\nimport { DIRTY_PATHS, FLUSHING } from './utils/weak-maps'\n\n/**\n * Create a new Slate `Editor` object.\n */\n\nexport const createEditor = (): Editor => {\n  const editor: Editor = {\n    children: [],\n    operations: [],\n    selection: null,\n    marks: null,\n    isInline: () => false,\n    isVoid: () => false,\n    onChange: () => {},\n\n    apply: (op: Operation) => {\n      for (const ref of Editor.pathRefs(editor)) {\n        PathRef.transform(ref, op)\n      }\n\n      for (const ref of Editor.pointRefs(editor)) {\n        PointRef.transform(ref, op)\n      }\n\n      for (const ref of Editor.rangeRefs(editor)) {\n        RangeRef.transform(ref, op)\n      }\n\n      const set = new Set()\n      const dirtyPaths: Path[] = []\n\n      const add = (path: Path | null) => {\n        if (path) {\n          const key = path.join(',')\n\n          if (!set.has(key)) {\n            set.add(key)\n            dirtyPaths.push(path)\n          }\n        }\n      }\n\n      const oldDirtyPaths = DIRTY_PATHS.get(editor) || []\n      const newDirtyPaths = getDirtyPaths(op)\n\n      for (const path of oldDirtyPaths) {\n        const newPath = Path.transform(path, op)\n        add(newPath)\n      }\n\n      for (const path of newDirtyPaths) {\n        add(path)\n      }\n\n      DIRTY_PATHS.set(editor, dirtyPaths)\n      Editor.transform(editor, op)\n      editor.operations.push(op)\n      Editor.normalize(editor)\n\n      // Clear any formats applied to the cursor if the selection changes.\n      if (op.type === 'set_selection') {\n        editor.marks = null\n      }\n\n      if (!FLUSHING.get(editor)) {\n        FLUSHING.set(editor, true)\n\n        Promise.resolve().then(() => {\n          FLUSHING.set(editor, false)\n          editor.onChange()\n          editor.operations = []\n        })\n      }\n    },\n\n    addMark: (key: string, value: any) => {\n      const { selection } = editor\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.setNodes(\n            editor,\n            { [key]: value },\n            { match: Text.isText, split: true }\n          )\n        } else {\n          const marks = {\n            ...(Editor.marks(editor) || {}),\n            [key]: value,\n          }\n\n          editor.marks = marks\n          editor.onChange()\n        }\n      }\n    },\n\n    deleteBackward: (unit: 'character' | 'word' | 'line' | 'block') => {\n      const { selection } = editor\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, { unit, reverse: true })\n      }\n    },\n\n    deleteForward: (unit: 'character' | 'word' | 'line' | 'block') => {\n      const { selection } = editor\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, { unit })\n      }\n    },\n\n    deleteFragment: () => {\n      const { selection } = editor\n\n      if (selection && Range.isExpanded(selection)) {\n        Transforms.delete(editor)\n      }\n    },\n\n    getFragment: () => {\n      const { selection } = editor\n\n      if (selection) {\n        return Node.fragment(editor, selection)\n      }\n      return []\n    },\n\n    insertBreak: () => {\n      Transforms.splitNodes(editor, { always: true })\n    },\n\n    insertFragment: (fragment: Node[]) => {\n      Transforms.insertFragment(editor, fragment)\n    },\n\n    insertNode: (node: Node) => {\n      Transforms.insertNodes(editor, node)\n    },\n\n    insertText: (text: string) => {\n      const { selection, marks } = editor\n\n      if (selection) {\n        // If the cursor is at the end of an inline, move it outside of\n        // the inline before inserting\n        if (Range.isCollapsed(selection)) {\n          const inline = Editor.above(editor, {\n            match: n => Editor.isInline(editor, n),\n            mode: 'highest',\n          })\n\n          if (inline) {\n            const [, inlinePath] = inline\n\n            if (Editor.isEnd(editor, selection.anchor, inlinePath)) {\n              const point = Editor.after(editor, inlinePath)!\n              Transforms.setSelection(editor, {\n                anchor: point,\n                focus: point,\n              })\n            }\n          }\n        }\n\n        if (marks) {\n          const node = { text, ...marks }\n          Transforms.insertNodes(editor, node)\n        } else {\n          Transforms.insertText(editor, text)\n        }\n\n        editor.marks = null\n      }\n    },\n\n    normalizeNode: (entry: NodeEntry) => {\n      const [node, path] = entry\n\n      // There are no core normalizations for text nodes.\n      if (Text.isText(node)) {\n        return\n      }\n\n      // Ensure that block and inline nodes have at least one text child.\n      if (Element.isElement(node) && node.children.length === 0) {\n        const child = { text: '' }\n        Transforms.insertNodes(editor, child, {\n          at: path.concat(0),\n          voids: true,\n        })\n        return\n      }\n\n      // Determine whether the node should have block or inline children.\n      const shouldHaveInlines = Editor.isEditor(node)\n        ? false\n        : Element.isElement(node) &&\n          (editor.isInline(node) ||\n            node.children.length === 0 ||\n            Text.isText(node.children[0]) ||\n            editor.isInline(node.children[0]))\n\n      // Since we'll be applying operations while iterating, keep track of an\n      // index that accounts for any added/removed nodes.\n      let n = 0\n\n      for (let i = 0; i < node.children.length; i++, n++) {\n        const child = node.children[i] as Descendant\n        const prev = node.children[i - 1] as Descendant\n        const isLast = i === node.children.length - 1\n        const isInlineOrText =\n          Text.isText(child) ||\n          (Element.isElement(child) && editor.isInline(child))\n\n        // Only allow block nodes in the top-level children and parent blocks\n        // that only contain block nodes. Similarly, only allow inline nodes in\n        // other inline nodes, or parent blocks that only contain inlines and\n        // text.\n        if (isInlineOrText !== shouldHaveInlines) {\n          Transforms.removeNodes(editor, { at: path.concat(n), voids: true })\n          n--\n        } else if (Element.isElement(child)) {\n          // Ensure that inline nodes are surrounded by text nodes.\n          if (editor.isInline(child)) {\n            if (prev == null || !Text.isText(prev)) {\n              const newChild = { text: '' }\n              Transforms.insertNodes(editor, newChild, {\n                at: path.concat(n),\n                voids: true,\n              })\n              n++\n            } else if (isLast) {\n              const newChild = { text: '' }\n              Transforms.insertNodes(editor, newChild, {\n                at: path.concat(n + 1),\n                voids: true,\n              })\n              n++\n            }\n          }\n        } else {\n          // Merge adjacent text nodes that are empty or match.\n          if (prev != null && Text.isText(prev)) {\n            if (Text.equals(child, prev, { loose: true })) {\n              Transforms.mergeNodes(editor, { at: path.concat(n), voids: true })\n              n--\n            } else if (prev.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n - 1),\n                voids: true,\n              })\n              n--\n            } else if (isLast && child.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n),\n                voids: true,\n              })\n              n--\n            }\n          }\n        }\n      }\n    },\n\n    removeMark: (key: string) => {\n      const { selection } = editor\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.unsetNodes(editor, key, {\n            match: Text.isText,\n            split: true,\n          })\n        } else {\n          const marks = { ...(Editor.marks(editor) || {}) }\n          delete marks[key]\n          editor.marks = marks\n          editor.onChange()\n        }\n      }\n    },\n  }\n\n  return editor\n}\n\n/**\n * Get the \"dirty\" paths generated from an operation.\n */\n\nconst getDirtyPaths = (op: Operation) => {\n  switch (op.type) {\n    case 'insert_text':\n    case 'remove_text':\n    case 'set_node': {\n      const { path } = op\n      return Path.levels(path)\n    }\n\n    case 'insert_node': {\n      const { node, path } = op\n      const levels = Path.levels(path)\n      const descendants = Text.isText(node)\n        ? []\n        : Array.from(Node.nodes(node), ([, p]) => path.concat(p))\n\n      return [...levels, ...descendants]\n    }\n\n    case 'merge_node': {\n      const { path } = op\n      const ancestors = Path.ancestors(path)\n      const previousPath = Path.previous(path)\n      return [...ancestors, previousPath]\n    }\n\n    case 'move_node': {\n      const { path, newPath } = op\n\n      if (Path.equals(path, newPath)) {\n        return []\n      }\n\n      const oldAncestors: Path[] = []\n      const newAncestors: Path[] = []\n\n      for (const ancestor of Path.ancestors(path)) {\n        const p = Path.transform(ancestor, op)\n        oldAncestors.push(p!)\n      }\n\n      for (const ancestor of Path.ancestors(newPath)) {\n        const p = Path.transform(ancestor, op)\n        newAncestors.push(p!)\n      }\n\n      return [...oldAncestors, ...newAncestors]\n    }\n\n    case 'remove_node': {\n      const { path } = op\n      const ancestors = Path.ancestors(path)\n      return [...ancestors]\n    }\n\n    case 'split_node': {\n      const { path } = op\n      const levels = Path.levels(path)\n      const nextPath = Path.next(path)\n      return [...levels, nextPath]\n    }\n\n    default: {\n      return []\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}