{"ast":null,"code":"// Should be no imports here!\nvar _a; // SOme things that should be evaluated before all else...\n\n\nvar hasSymbol = typeof Symbol !== \"undefined\";\nvar hasMap = typeof Map !== \"undefined\";\nvar hasSet = typeof Set !== \"undefined\";\n/**\r\n * The sentinel value returned by producers to replace the draft with undefined.\r\n */\n\nvar NOTHING = hasSymbol ? Symbol(\"immer-nothing\") : (_a = {}, _a[\"immer-nothing\"] = true, _a);\n/**\r\n * To let Immer treat your class instances as plain immutable objects\r\n * (albeit with a custom prototype), you must define either an instance property\r\n * or a static property on each of your custom classes.\r\n *\r\n * Otherwise, your class instance will never be drafted, which means it won't be\r\n * safe to mutate in a produce callback.\r\n */\n\nvar DRAFTABLE = hasSymbol ? Symbol(\"immer-draftable\") : \"__$immer_draftable\";\nvar DRAFT_STATE = hasSymbol ? Symbol(\"immer-state\") : \"__$immer_state\";\nvar iteratorSymbol = hasSymbol ? Symbol.iterator : \"@@iterator\";\n/* istanbul ignore next */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) {\n        d[p] = b[p];\n      }\n    }\n  };\n\n  return extendStatics(d, b);\n}; // Ugly hack to resolve #502 and inherit built in Map / Set\n\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = ( // @ts-ignore\n  __.prototype = b.prototype, new __());\n}\n\nvar Archtype;\n\n(function (Archtype) {\n  Archtype[Archtype[\"Object\"] = 0] = \"Object\";\n  Archtype[Archtype[\"Array\"] = 1] = \"Array\";\n  Archtype[Archtype[\"Map\"] = 2] = \"Map\";\n  Archtype[Archtype[\"Set\"] = 3] = \"Set\";\n})(Archtype || (Archtype = {}));\n\nvar ProxyType;\n\n(function (ProxyType) {\n  ProxyType[ProxyType[\"ProxyObject\"] = 0] = \"ProxyObject\";\n  ProxyType[ProxyType[\"ProxyArray\"] = 1] = \"ProxyArray\";\n  ProxyType[ProxyType[\"ES5Object\"] = 2] = \"ES5Object\";\n  ProxyType[ProxyType[\"ES5Array\"] = 3] = \"ES5Array\";\n  ProxyType[ProxyType[\"Map\"] = 4] = \"Map\";\n  ProxyType[ProxyType[\"Set\"] = 5] = \"Set\";\n})(ProxyType || (ProxyType = {}));\n/** Returns true if the given value is an Immer draft */\n\n\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\n/** Returns true if the given value can be drafted by Immer */\n\n\nfunction isDraftable(value) {\n  if (!value) {\n    return false;\n  }\n\n  return isPlainObject(value) || Array.isArray(value) || !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE] || isMap(value) || isSet(value);\n}\n\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n\n  var proto = Object.getPrototypeOf(value);\n  return !proto || proto === Object.prototype;\n}\n\nfunction original(value) {\n  if (value && value[DRAFT_STATE]) {\n    return value[DRAFT_STATE].base;\n  } // otherwise return undefined\n\n}\n\nvar ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== \"undefined\" ? function (obj) {\n  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));\n} :\n/* istanbul ignore next */\nObject.getOwnPropertyNames;\n\nfunction each(obj, iter) {\n  if (getArchtype(obj) === Archtype.Object) {\n    ownKeys(obj).forEach(function (key) {\n      return iter(key, obj[key], obj);\n    });\n  } else {\n    obj.forEach(function (entry, index) {\n      return iter(index, entry, obj);\n    });\n  }\n}\n\nfunction isEnumerable(base, prop) {\n  var desc = Object.getOwnPropertyDescriptor(base, prop);\n  return desc && desc.enumerable ? true : false;\n}\n\nfunction getArchtype(thing) {\n  /* istanbul ignore next */\n  if (!thing) {\n    die();\n  }\n\n  if (thing[DRAFT_STATE]) {\n    switch (thing[DRAFT_STATE].type) {\n      case ProxyType.ES5Object:\n      case ProxyType.ProxyObject:\n        return Archtype.Object;\n\n      case ProxyType.ES5Array:\n      case ProxyType.ProxyArray:\n        return Archtype.Array;\n\n      case ProxyType.Map:\n        return Archtype.Map;\n\n      case ProxyType.Set:\n        return Archtype.Set;\n    }\n  }\n\n  return Array.isArray(thing) ? Archtype.Array : isMap(thing) ? Archtype.Map : isSet(thing) ? Archtype.Set : Archtype.Object;\n}\n\nfunction has(thing, prop) {\n  return getArchtype(thing) === Archtype.Map ? thing.has(prop) : Object.prototype.hasOwnProperty.call(thing, prop);\n}\n\nfunction get(thing, prop) {\n  // @ts-ignore\n  return getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop];\n}\n\nfunction set(thing, propOrOldValue, value) {\n  switch (getArchtype(thing)) {\n    case Archtype.Map:\n      thing.set(propOrOldValue, value);\n      break;\n\n    case Archtype.Set:\n      thing.delete(propOrOldValue);\n      thing.add(value);\n      break;\n\n    default:\n      thing[propOrOldValue] = value;\n  }\n}\n\nfunction is(x, y) {\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n\nfunction isMap(target) {\n  return hasMap && target instanceof Map;\n}\n\nfunction isSet(target) {\n  return hasSet && target instanceof Set;\n}\n\nfunction latest(state) {\n  return state.copy || state.base;\n}\n\nfunction shallowCopy(base, invokeGetters) {\n  if (invokeGetters === void 0) {\n    invokeGetters = false;\n  }\n\n  if (Array.isArray(base)) {\n    return base.slice();\n  }\n\n  var clone = Object.create(Object.getPrototypeOf(base));\n  ownKeys(base).forEach(function (key) {\n    if (key === DRAFT_STATE) {\n      return; // Never copy over draft state.\n    }\n\n    var desc = Object.getOwnPropertyDescriptor(base, key);\n    var value = desc.value;\n\n    if (desc.get) {\n      if (!invokeGetters) {\n        throw new Error(\"Immer drafts cannot have computed properties\");\n      }\n\n      value = desc.get.call(base);\n    }\n\n    if (desc.enumerable) {\n      clone[key] = value;\n    } else {\n      Object.defineProperty(clone, key, {\n        value: value,\n        writable: true,\n        configurable: true\n      });\n    }\n  });\n  return clone;\n}\n\nfunction freeze(obj, deep) {\n  if (!isDraftable(obj) || isDraft(obj) || Object.isFrozen(obj)) {\n    return;\n  }\n\n  var type = getArchtype(obj);\n\n  if (type === Archtype.Set) {\n    obj.add = obj.clear = obj.delete = dontMutateFrozenCollections;\n  } else if (type === Archtype.Map) {\n    obj.set = obj.clear = obj.delete = dontMutateFrozenCollections;\n  }\n\n  Object.freeze(obj);\n\n  if (deep) {\n    each(obj, function (_, value) {\n      return freeze(value, true);\n    });\n  }\n}\n\nfunction dontMutateFrozenCollections() {\n  throw new Error(\"This object has been frozen and should not be mutated\");\n}\n\nfunction createHiddenProperty(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value: value,\n    enumerable: false,\n    writable: true\n  });\n}\n/* istanbul ignore next */\n\n\nfunction die() {\n  throw new Error(\"Illegal state, please file a bug\");\n}\n/** Each scope represents a `produce` call. */\n\n\nvar ImmerScope =\n/** @class */\nfunction () {\n  function ImmerScope(parent, immer) {\n    this.drafts = [];\n    this.parent = parent;\n    this.immer = immer; // Whenever the modified draft contains a draft from another scope, we\n    // need to prevent auto-freezing so the unowned draft can be finalized.\n\n    this.canAutoFreeze = true;\n  }\n\n  ImmerScope.prototype.usePatches = function (patchListener) {\n    if (patchListener) {\n      this.patches = [];\n      this.inversePatches = [];\n      this.patchListener = patchListener;\n    }\n  };\n\n  ImmerScope.prototype.revoke = function () {\n    this.leave();\n    this.drafts.forEach(revoke); // @ts-ignore\n\n    this.drafts = null;\n  };\n\n  ImmerScope.prototype.leave = function () {\n    if (this === ImmerScope.current) {\n      ImmerScope.current = this.parent;\n    }\n  };\n\n  ImmerScope.enter = function (immer) {\n    var scope = new ImmerScope(ImmerScope.current, immer);\n    ImmerScope.current = scope;\n    return scope;\n  };\n\n  return ImmerScope;\n}();\n\nfunction revoke(draft) {\n  var state = draft[DRAFT_STATE];\n\n  if (state.type === ProxyType.ProxyObject || state.type === ProxyType.ProxyArray) {\n    state.revoke();\n  } else {\n    state.revoked = true;\n  }\n}\n\nfunction processResult(immer, result, scope) {\n  var baseDraft = scope.drafts[0];\n  var isReplaced = result !== undefined && result !== baseDraft;\n  immer.willFinalize(scope, result, isReplaced);\n\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified) {\n      scope.revoke();\n      throw new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"); // prettier-ignore\n    }\n\n    if (isDraftable(result)) {\n      // Finalize the result in case it contains (or is) a subset of the draft.\n      result = finalize(immer, result, scope);\n\n      if (!scope.parent) {\n        maybeFreeze(immer, result);\n      }\n    }\n\n    if (scope.patches) {\n      scope.patches.push({\n        op: \"replace\",\n        path: [],\n        value: result\n      });\n      scope.inversePatches.push({\n        op: \"replace\",\n        path: [],\n        value: baseDraft[DRAFT_STATE].base\n      });\n    }\n  } else {\n    // Finalize the base draft.\n    result = finalize(immer, baseDraft, scope, []);\n  }\n\n  scope.revoke();\n\n  if (scope.patches) {\n    scope.patchListener(scope.patches, scope.inversePatches);\n  }\n\n  return result !== NOTHING ? result : undefined;\n}\n\nfunction finalize(immer, draft, scope, path) {\n  var state = draft[DRAFT_STATE];\n\n  if (!state) {\n    if (Object.isFrozen(draft)) {\n      return draft;\n    }\n\n    return finalizeTree(immer, draft, scope);\n  } // Never finalize drafts owned by another scope.\n\n\n  if (state.scope !== scope) {\n    return draft;\n  }\n\n  if (!state.modified) {\n    maybeFreeze(immer, state.base, true);\n    return state.base;\n  }\n\n  if (!state.finalized) {\n    state.finalized = true;\n    finalizeTree(immer, state.draft, scope, path); // We cannot really delete anything inside of a Set. We can only replace the whole Set.\n\n    if (immer.onDelete && state.type !== ProxyType.Set) {\n      // The `assigned` object is unreliable with ES5 drafts.\n      if (immer.useProxies) {\n        var assigned = state.assigned;\n        each(assigned, function (prop, exists) {\n          if (!exists) {\n            immer.onDelete(state, prop);\n          }\n        });\n      } else {\n        var base = state.base,\n            copy_1 = state.copy;\n        each(base, function (prop) {\n          if (!has(copy_1, prop)) {\n            immer.onDelete(state, prop);\n          }\n        });\n      }\n    }\n\n    if (immer.onCopy) {\n      immer.onCopy(state);\n    } // At this point, all descendants of `state.copy` have been finalized,\n    // so we can be sure that `scope.canAutoFreeze` is accurate.\n\n\n    if (immer.autoFreeze && scope.canAutoFreeze) {\n      freeze(state.copy, false);\n    }\n\n    if (path && scope.patches) {\n      generatePatches(state, path, scope.patches, scope.inversePatches);\n    }\n  }\n\n  return state.copy;\n}\n\nfunction finalizeTree(immer, root, scope, rootPath) {\n  var state = root[DRAFT_STATE];\n\n  if (state) {\n    if (state.type === ProxyType.ES5Object || state.type === ProxyType.ES5Array) {\n      // Create the final copy, with added keys and without deleted keys.\n      state.copy = shallowCopy(state.draft, true);\n    }\n\n    root = state.copy;\n  }\n\n  each(root, function (key, value) {\n    return finalizeProperty(immer, scope, root, state, root, key, value, rootPath);\n  });\n  return root;\n}\n\nfunction finalizeProperty(immer, scope, root, rootState, parentValue, prop, childValue, rootPath) {\n  if (childValue === parentValue) {\n    throw Error(\"Immer forbids circular references\");\n  } // In the `finalizeTree` method, only the `root` object may be a draft.\n\n\n  var isDraftProp = !!rootState && parentValue === root;\n  var isSetMember = isSet(parentValue);\n\n  if (isDraft(childValue)) {\n    var path = rootPath && isDraftProp && !isSetMember && // Set objects are atomic since they have no keys.\n    !has(rootState.assigned, prop) // Skip deep patches for assigned keys.\n    ? rootPath.concat(prop) : undefined; // Drafts owned by `scope` are finalized here.\n\n    childValue = finalize(immer, childValue, scope, path);\n    set(parentValue, prop, childValue); // Drafts from another scope must prevent auto-freezing.\n\n    if (isDraft(childValue)) {\n      scope.canAutoFreeze = false;\n    }\n  } // Unchanged draft properties are ignored.\n  else if (isDraftProp && is(childValue, get(rootState.base, prop))) {\n      return;\n    } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n    // TODO: the recursion over here looks weird, shouldn't non-draft stuff have it's own recursion?\n    // especially the passing on of root and rootState doesn't make sense...\n    else if (isDraftable(childValue)) {\n        each(childValue, function (key, grandChild) {\n          return finalizeProperty(immer, scope, root, rootState, childValue, key, grandChild, rootPath);\n        });\n\n        if (!scope.parent) {\n          maybeFreeze(immer, childValue);\n        }\n      }\n\n  if (isDraftProp && immer.onAssign && !isSetMember) {\n    immer.onAssign(rootState, prop, childValue);\n  }\n}\n\nfunction maybeFreeze(immer, value, deep) {\n  if (deep === void 0) {\n    deep = false;\n  }\n\n  if (immer.autoFreeze && !isDraft(value)) {\n    freeze(value, deep);\n  }\n}\n/**\r\n * Returns a new draft of the `base` object.\r\n *\r\n * The second argument is the parent draft-state (used internally).\r\n */\n\n\nfunction createProxy(base, parent) {\n  var isArray = Array.isArray(base);\n  var state = {\n    type: isArray ? ProxyType.ProxyArray : ProxyType.ProxyObject,\n    // Track which produce call this is associated with.\n    scope: parent ? parent.scope : ImmerScope.current,\n    // True for both shallow and deep changes.\n    modified: false,\n    // Used during finalization.\n    finalized: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned: {},\n    // The parent draft state.\n    parent: parent,\n    // The base state.\n    base: base,\n    // The base proxy.\n    draft: null,\n    // Any property proxies.\n    drafts: {},\n    // The base copy with any updated values.\n    copy: null,\n    // Called by the `produce` function.\n    revoke: null,\n    isManual: false\n  }; // the traps must target something, a bit like the 'real' base.\n  // but also, we need to be able to determine from the target what the relevant state is\n  // (to avoid creating traps per instance to capture the state in closure,\n  // and to avoid creating weird hidden properties as well)\n  // So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n  // Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\n  var target = state;\n  var traps = objectTraps;\n\n  if (isArray) {\n    target = [state];\n    traps = arrayTraps;\n  } // TODO: optimization: might be faster, cheaper if we created a non-revocable proxy\n  // and administrate revoking ourselves\n\n\n  var _a = Proxy.revocable(target, traps),\n      revoke = _a.revoke,\n      proxy = _a.proxy;\n\n  state.draft = proxy;\n  state.revoke = revoke;\n  return proxy;\n}\n/**\r\n * Object drafts\r\n */\n\n\nvar objectTraps = {\n  get: function (state, prop) {\n    if (prop === DRAFT_STATE) {\n      return state;\n    }\n\n    var drafts = state.drafts; // Check for existing draft in unmodified state.\n\n    if (!state.modified && has(drafts, prop)) {\n      return drafts[prop];\n    }\n\n    var value = latest(state)[prop];\n\n    if (state.finalized || !isDraftable(value)) {\n      return value;\n    } // Check for existing draft in modified state.\n\n\n    if (state.modified) {\n      // Assigned values are never drafted. This catches any drafts we created, too.\n      if (value !== peek(state.base, prop)) {\n        return value;\n      } // Store drafts on the copy (when one exists).\n      // @ts-ignore\n\n\n      drafts = state.copy;\n    }\n\n    return drafts[prop] = state.scope.immer.createProxy(value, state);\n  },\n  has: function (state, prop) {\n    return prop in latest(state);\n  },\n  ownKeys: function (state) {\n    return Reflect.ownKeys(latest(state));\n  },\n  set: function (state, prop\n  /* strictly not, but helps TS */\n  , value) {\n    if (!state.modified) {\n      var baseValue = peek(state.base, prop); // Optimize based on value's truthiness. Truthy values are guaranteed to\n      // never be undefined, so we can avoid the `in` operator. Lastly, truthy\n      // values may be drafts, but falsy values are never drafts.\n\n      var isUnchanged = value ? is(baseValue, value) || value === state.drafts[prop] : is(baseValue, value) && prop in state.base;\n\n      if (isUnchanged) {\n        return true;\n      }\n\n      prepareCopy(state);\n      markChanged(state);\n    }\n\n    state.assigned[prop] = true; // @ts-ignore\n\n    state.copy[prop] = value;\n    return true;\n  },\n  deleteProperty: function (state, prop) {\n    // The `undefined` check is a fast path for pre-existing keys.\n    if (peek(state.base, prop) !== undefined || prop in state.base) {\n      state.assigned[prop] = false;\n      prepareCopy(state);\n      markChanged(state);\n    } else if (state.assigned[prop]) {\n      // if an originally not assigned property was deleted\n      delete state.assigned[prop];\n    } // @ts-ignore\n\n\n    if (state.copy) {\n      delete state.copy[prop];\n    }\n\n    return true;\n  },\n  // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n  // the same guarantee in ES5 mode.\n  getOwnPropertyDescriptor: function (state, prop) {\n    var owner = latest(state);\n    var desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n\n    if (desc) {\n      desc.writable = true;\n      desc.configurable = state.type !== ProxyType.ProxyArray || prop !== \"length\";\n    }\n\n    return desc;\n  },\n  defineProperty: function () {\n    throw new Error(\"Object.defineProperty() cannot be used on an Immer draft\"); // prettier-ignore\n  },\n  getPrototypeOf: function (state) {\n    return Object.getPrototypeOf(state.base);\n  },\n  setPrototypeOf: function () {\n    throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\"); // prettier-ignore\n  }\n};\n/**\r\n * Array drafts\r\n */\n\nvar arrayTraps = {};\neach(objectTraps, function (key, fn) {\n  // @ts-ignore\n  arrayTraps[key] = function () {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\n\narrayTraps.deleteProperty = function (state, prop) {\n  if (isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports deleting array indices\"); // prettier-ignore\n  }\n\n  return objectTraps.deleteProperty.call(this, state[0], prop);\n};\n\narrayTraps.set = function (state, prop, value) {\n  if (prop !== \"length\" && isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports setting array indices and the 'length' property\"); // prettier-ignore\n  }\n\n  return objectTraps.set.call(this, state[0], prop, value, state[0]);\n};\n/**\r\n * Map drafts\r\n */\n// Access a property without creating an Immer draft.\n\n\nfunction peek(draft, prop) {\n  var state = draft[DRAFT_STATE];\n  var desc = Reflect.getOwnPropertyDescriptor(state ? latest(state) : draft, prop);\n  return desc && desc.value;\n}\n\nfunction markChanged(state) {\n  if (!state.modified) {\n    state.modified = true;\n\n    if (state.type === ProxyType.ProxyObject || state.type === ProxyType.ProxyArray) {\n      var copy_1 = state.copy = shallowCopy(state.base);\n      each(state.drafts, function (key, value) {\n        // @ts-ignore\n        copy_1[key] = value;\n      });\n      state.drafts = undefined;\n    }\n\n    if (state.parent) {\n      markChanged(state.parent);\n    }\n  }\n}\n\nfunction prepareCopy(state) {\n  if (!state.copy) {\n    state.copy = shallowCopy(state.base);\n  }\n}\n\nfunction willFinalizeES5(scope, result, isReplaced) {\n  scope.drafts.forEach(function (draft) {\n    draft[DRAFT_STATE].finalizing = true;\n  });\n\n  if (!isReplaced) {\n    if (scope.patches) {\n      markChangesRecursively(scope.drafts[0]);\n    } // This is faster when we don't care about which attributes changed.\n\n\n    markChangesSweep(scope.drafts);\n  } // When a child draft is returned, look for changes.\n  else if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\n      markChangesSweep(scope.drafts);\n    }\n}\n\nfunction createES5Proxy(base, parent) {\n  var isArray = Array.isArray(base);\n  var draft = clonePotentialDraft(base);\n  each(draft, function (prop) {\n    proxyProperty(draft, prop, isArray || isEnumerable(base, prop));\n  });\n  var state = {\n    type: isArray ? ProxyType.ES5Array : ProxyType.ES5Object,\n    scope: parent ? parent.scope : ImmerScope.current,\n    modified: false,\n    finalizing: false,\n    finalized: false,\n    assigned: {},\n    parent: parent,\n    base: base,\n    draft: draft,\n    copy: null,\n    revoked: false,\n    isManual: false\n  };\n  createHiddenProperty(draft, DRAFT_STATE, state);\n  return draft;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek$1(draft, prop) {\n  var state = draft[DRAFT_STATE];\n\n  if (state && !state.finalizing) {\n    state.finalizing = true;\n    var value = draft[prop];\n    state.finalizing = false;\n    return value;\n  }\n\n  return draft[prop];\n}\n\nfunction get$1(state, prop) {\n  assertUnrevoked(state);\n  var value = peek$1(latest(state), prop);\n\n  if (state.finalizing) {\n    return value;\n  } // Create a draft if the value is unmodified.\n\n\n  if (value === peek$1(state.base, prop) && isDraftable(value)) {\n    prepareCopy$1(state); // @ts-ignore\n\n    return state.copy[prop] = state.scope.immer.createProxy(value, state);\n  }\n\n  return value;\n}\n\nfunction set$1(state, prop, value) {\n  assertUnrevoked(state);\n  state.assigned[prop] = true;\n\n  if (!state.modified) {\n    if (is(value, peek$1(latest(state), prop))) {\n      return;\n    }\n\n    markChangedES5(state);\n    prepareCopy$1(state);\n  } // @ts-ignore\n\n\n  state.copy[prop] = value;\n}\n\nfunction markChangedES5(state) {\n  if (!state.modified) {\n    state.modified = true;\n\n    if (state.parent) {\n      markChangedES5(state.parent);\n    }\n  }\n}\n\nfunction prepareCopy$1(state) {\n  if (!state.copy) {\n    state.copy = clonePotentialDraft(state.base);\n  }\n}\n\nfunction clonePotentialDraft(base) {\n  var state = base && base[DRAFT_STATE];\n\n  if (state) {\n    state.finalizing = true;\n    var draft = shallowCopy(state.draft, true);\n    state.finalizing = false;\n    return draft;\n  }\n\n  return shallowCopy(base);\n} // property descriptors are recycled to make sure we don't create a get and set closure per property,\n// but share them all instead\n\n\nvar descriptors = {};\n\nfunction proxyProperty(draft, prop, enumerable) {\n  var desc = descriptors[prop];\n\n  if (desc) {\n    desc.enumerable = enumerable;\n  } else {\n    descriptors[prop] = desc = {\n      configurable: true,\n      enumerable: enumerable,\n      get: function () {\n        return get$1(this[DRAFT_STATE], prop);\n      },\n      set: function (value) {\n        set$1(this[DRAFT_STATE], prop, value);\n      }\n    };\n  }\n\n  Object.defineProperty(draft, prop, desc);\n}\n\nfunction assertUnrevoked(state) {\n  if (state.revoked === true) {\n    throw new Error(\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + JSON.stringify(latest(state)));\n  }\n} // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\n\nfunction markChangesSweep(drafts) {\n  // The natural order of drafts in the `scope` array is based on when they\n  // were accessed. By processing drafts in reverse natural order, we have a\n  // better chance of processing leaf nodes first. When a leaf node is known to\n  // have changed, we can avoid any traversal of its ancestor nodes.\n  for (var i = drafts.length - 1; i >= 0; i--) {\n    var state = drafts[i][DRAFT_STATE];\n\n    if (!state.modified) {\n      switch (state.type) {\n        case ProxyType.ES5Array:\n          if (hasArrayChanges(state)) {\n            markChangedES5(state);\n          }\n\n          break;\n\n        case ProxyType.ES5Object:\n          if (hasObjectChanges(state)) {\n            markChangedES5(state);\n          }\n\n          break;\n      }\n    }\n  }\n}\n\nfunction markChangesRecursively(object) {\n  if (!object || typeof object !== \"object\") {\n    return;\n  }\n\n  var state = object[DRAFT_STATE];\n\n  if (!state) {\n    return;\n  }\n\n  var base = state.base,\n      draft = state.draft,\n      assigned = state.assigned,\n      type = state.type;\n\n  if (type === ProxyType.ES5Object) {\n    // Look for added keys.\n    // TODO: looks quite duplicate to hasObjectChanges,\n    // probably there is a faster way to detect changes, as sweep + recurse seems to do some\n    // unnecessary work.\n    // also: probably we can store the information we detect here, to speed up tree finalization!\n    each(draft, function (key) {\n      if (key === DRAFT_STATE) {\n        return;\n      } // The `undefined` check is a fast path for pre-existing keys.\n\n\n      if (base[key] === undefined && !has(base, key)) {\n        assigned[key] = true;\n        markChangedES5(state);\n      } else if (!assigned[key]) {\n        // Only untouched properties trigger recursion.\n        markChangesRecursively(draft[key]);\n      }\n    }); // Look for removed keys.\n\n    each(base, function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (draft[key] === undefined && !has(draft, key)) {\n        assigned[key] = false;\n        markChangedES5(state);\n      }\n    });\n  } else if (type === ProxyType.ES5Array) {\n    if (hasArrayChanges(state)) {\n      markChangedES5(state);\n      assigned.length = true;\n    }\n\n    if (draft.length < base.length) {\n      for (var i = draft.length; i < base.length; i++) {\n        assigned[i] = false;\n      }\n    } else {\n      for (var i = base.length; i < draft.length; i++) {\n        assigned[i] = true;\n      }\n    } // Minimum count is enough, the other parts has been processed.\n\n\n    var min = Math.min(draft.length, base.length);\n\n    for (var i = 0; i < min; i++) {\n      // Only untouched indices trigger recursion.\n      if (assigned[i] === undefined) {\n        markChangesRecursively(draft[i]);\n      }\n    }\n  }\n}\n\nfunction hasObjectChanges(state) {\n  var base = state.base,\n      draft = state.draft; // Search for added keys and changed keys. Start at the back, because\n  // non-numeric keys are ordered by time of definition on the object.\n\n  var keys = Object.keys(draft);\n\n  for (var i = keys.length - 1; i >= 0; i--) {\n    var key = keys[i];\n    var baseValue = base[key]; // The `undefined` check is a fast path for pre-existing keys.\n\n    if (baseValue === undefined && !has(base, key)) {\n      return true;\n    } // Once a base key is deleted, future changes go undetected, because its\n    // descriptor is erased. This branch detects any missed changes.\n    else {\n        var value = draft[key];\n        var state_1 = value && value[DRAFT_STATE];\n\n        if (state_1 ? state_1.base !== baseValue : !is(value, baseValue)) {\n          return true;\n        }\n      }\n  } // At this point, no keys were added or changed.\n  // Compare key count to determine if keys were deleted.\n\n\n  return keys.length !== Object.keys(base).length;\n}\n\nfunction hasArrayChanges(state) {\n  var draft = state.draft;\n\n  if (draft.length !== state.base.length) {\n    return true;\n  } // See #116\n  // If we first shorten the length, our array interceptors will be removed.\n  // If after that new items are added, result in the same original length,\n  // those last items will have no intercepting property.\n  // So if there is no own descriptor on the last position, we know that items were removed and added\n  // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n  // the last one\n\n\n  var descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\n  if (descriptor && !descriptor.get) {\n    return true;\n  } // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\n\n  return false;\n}\n\nvar DraftMap = function (_super) {\n  if (!_super) {\n    /* istanbul ignore next */\n    throw new Error(\"Map is not polyfilled\");\n  }\n\n  __extends(DraftMap, _super); // Create class manually, cause #502\n\n\n  function DraftMap(target, parent) {\n    this[DRAFT_STATE] = {\n      type: ProxyType.Map,\n      parent: parent,\n      scope: parent ? parent.scope : ImmerScope.current,\n      modified: false,\n      finalized: false,\n      copy: undefined,\n      assigned: undefined,\n      base: target,\n      draft: this,\n      isManual: false,\n      revoked: false\n    };\n    return this;\n  }\n\n  var p = DraftMap.prototype; // TODO: smaller build size if we create a util for Object.defineProperty\n\n  Object.defineProperty(p, \"size\", {\n    get: function () {\n      return latest(this[DRAFT_STATE]).size;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  p.has = function (key) {\n    return latest(this[DRAFT_STATE]).has(key);\n  };\n\n  p.set = function (key, value) {\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state);\n\n    if (latest(state).get(key) !== value) {\n      prepareCopy$2(state);\n      state.scope.immer.markChanged(state);\n      state.assigned.set(key, true);\n      state.copy.set(key, value);\n      state.assigned.set(key, true);\n    }\n\n    return this;\n  };\n\n  p.delete = function (key) {\n    if (!this.has(key)) {\n      return false;\n    }\n\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state);\n    prepareCopy$2(state);\n    state.scope.immer.markChanged(state);\n    state.assigned.set(key, false);\n    state.copy.delete(key);\n    return true;\n  };\n\n  p.clear = function () {\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state);\n    prepareCopy$2(state);\n    state.scope.immer.markChanged(state);\n    state.assigned = new Map();\n    return state.copy.clear();\n  };\n\n  p.forEach = function (cb, thisArg) {\n    var _this = this;\n\n    var state = this[DRAFT_STATE];\n    latest(state).forEach(function (_value, key, _map) {\n      cb.call(thisArg, _this.get(key), key, _this);\n    });\n  };\n\n  p.get = function (key) {\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state);\n    var value = latest(state).get(key);\n\n    if (state.finalized || !isDraftable(value)) {\n      return value;\n    }\n\n    if (value !== state.base.get(key)) {\n      return value; // either already drafted or reassigned\n    } // despite what it looks, this creates a draft only once, see above condition\n\n\n    var draft = state.scope.immer.createProxy(value, state);\n    prepareCopy$2(state);\n    state.copy.set(key, draft);\n    return draft;\n  };\n\n  p.keys = function () {\n    return latest(this[DRAFT_STATE]).keys();\n  };\n\n  p.values = function () {\n    var _a;\n\n    var _this = this;\n\n    var iterator = this.keys();\n    return _a = {}, _a[iteratorSymbol] = function () {\n      return _this.values();\n    }, _a.next = function () {\n      var r = iterator.next();\n      /* istanbul ignore next */\n\n      if (r.done) {\n        return r;\n      }\n\n      var value = _this.get(r.value);\n\n      return {\n        done: false,\n        value: value\n      };\n    }, _a;\n  };\n\n  p.entries = function () {\n    var _a;\n\n    var _this = this;\n\n    var iterator = this.keys();\n    return _a = {}, _a[iteratorSymbol] = function () {\n      return _this.entries();\n    }, _a.next = function () {\n      var r = iterator.next();\n      /* istanbul ignore next */\n\n      if (r.done) {\n        return r;\n      }\n\n      var value = _this.get(r.value);\n\n      return {\n        done: false,\n        value: [r.value, value]\n      };\n    }, _a;\n  };\n\n  p[iteratorSymbol] = function () {\n    return this.entries();\n  };\n\n  return DraftMap;\n}(Map);\n\nfunction proxyMap(target, parent) {\n  // @ts-ignore\n  return new DraftMap(target, parent);\n}\n\nfunction prepareCopy$2(state) {\n  if (!state.copy) {\n    state.assigned = new Map();\n    state.copy = new Map(state.base);\n  }\n}\n\nvar DraftSet = function (_super) {\n  if (!_super) {\n    /* istanbul ignore next */\n    throw new Error(\"Set is not polyfilled\");\n  }\n\n  __extends(DraftSet, _super); // Create class manually, cause #502\n\n\n  function DraftSet(target, parent) {\n    this[DRAFT_STATE] = {\n      type: ProxyType.Set,\n      parent: parent,\n      scope: parent ? parent.scope : ImmerScope.current,\n      modified: false,\n      finalized: false,\n      copy: undefined,\n      base: target,\n      draft: this,\n      drafts: new Map(),\n      revoked: false,\n      isManual: false\n    };\n    return this;\n  }\n\n  var p = DraftSet.prototype;\n  Object.defineProperty(p, \"size\", {\n    get: function () {\n      return latest(this[DRAFT_STATE]).size;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  p.has = function (value) {\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state); // bit of trickery here, to be able to recognize both the value, and the draft of its value\n\n    if (!state.copy) {\n      return state.base.has(value);\n    }\n\n    if (state.copy.has(value)) {\n      return true;\n    }\n\n    if (state.drafts.has(value) && state.copy.has(state.drafts.get(value))) {\n      return true;\n    }\n\n    return false;\n  };\n\n  p.add = function (value) {\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state);\n\n    if (state.copy) {\n      state.copy.add(value);\n    } else if (!state.base.has(value)) {\n      prepareCopy$3(state);\n      state.scope.immer.markChanged(state);\n      state.copy.add(value);\n    }\n\n    return this;\n  };\n\n  p.delete = function (value) {\n    if (!this.has(value)) {\n      return false;\n    }\n\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state);\n    prepareCopy$3(state);\n    state.scope.immer.markChanged(state);\n    return state.copy.delete(value) || (state.drafts.has(value) ? state.copy.delete(state.drafts.get(value)) :\n    /* istanbul ignore next */\n    false);\n  };\n\n  p.clear = function () {\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state);\n    prepareCopy$3(state);\n    state.scope.immer.markChanged(state);\n    return state.copy.clear();\n  };\n\n  p.values = function () {\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state);\n    prepareCopy$3(state);\n    return state.copy.values();\n  };\n\n  p.entries = function entries() {\n    var state = this[DRAFT_STATE];\n    assertUnrevoked(state);\n    prepareCopy$3(state);\n    return state.copy.entries();\n  };\n\n  p.keys = function () {\n    return this.values();\n  };\n\n  p[iteratorSymbol] = function () {\n    return this.values();\n  };\n\n  p.forEach = function forEach(cb, thisArg) {\n    var iterator = this.values();\n    var result = iterator.next();\n\n    while (!result.done) {\n      cb.call(thisArg, result.value, result.value, this);\n      result = iterator.next();\n    }\n  };\n\n  return DraftSet;\n}(Set);\n\nfunction proxySet(target, parent) {\n  // @ts-ignore\n  return new DraftSet(target, parent);\n}\n\nfunction prepareCopy$3(state) {\n  if (!state.copy) {\n    // create drafts for all entries to preserve insertion order\n    state.copy = new Set();\n    state.base.forEach(function (value) {\n      if (isDraftable(value)) {\n        var draft = state.scope.immer.createProxy(value, state);\n        state.drafts.set(value, draft);\n        state.copy.add(draft);\n      } else {\n        state.copy.add(value);\n      }\n    });\n  }\n}\n\nfunction generatePatches(state, basePath, patches, inversePatches) {\n  switch (state.type) {\n    case ProxyType.ProxyObject:\n    case ProxyType.ES5Object:\n    case ProxyType.Map:\n      return generatePatchesFromAssigned(state, basePath, patches, inversePatches);\n\n    case ProxyType.ES5Array:\n    case ProxyType.ProxyArray:\n      return generateArrayPatches(state, basePath, patches, inversePatches);\n\n    case ProxyType.Set:\n      return generateSetPatches(state, basePath, patches, inversePatches);\n  }\n}\n\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\n  var _a, _b;\n\n  var base = state.base,\n      assigned = state.assigned,\n      copy = state.copy;\n  /* istanbul ignore next */\n\n  if (!copy) {\n    die();\n  } // Reduce complexity by ensuring `base` is never longer.\n\n\n  if (copy.length < base.length) {\n    _a = [copy, base], base = _a[0], copy = _a[1];\n    _b = [inversePatches, patches], patches = _b[0], inversePatches = _b[1];\n  }\n\n  var delta = copy.length - base.length; // Find the first replaced index.\n\n  var start = 0;\n\n  while (base[start] === copy[start] && start < base.length) {\n    ++start;\n  } // Find the last replaced index. Search from the end to optimize splice patches.\n\n\n  var end = base.length;\n\n  while (end > start && base[end - 1] === copy[end + delta - 1]) {\n    --end;\n  } // Process replaced indices.\n\n\n  for (var i = start; i < end; ++i) {\n    if (assigned[i] && copy[i] !== base[i]) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"replace\",\n        path: path,\n        value: copy[i]\n      });\n      inversePatches.push({\n        op: \"replace\",\n        path: path,\n        value: base[i]\n      });\n    }\n  }\n\n  var replaceCount = patches.length; // Process added indices.\n\n  for (var i = end + delta - 1; i >= end; --i) {\n    var path = basePath.concat([i]);\n    patches[replaceCount + i - end] = {\n      op: \"add\",\n      path: path,\n      value: copy[i]\n    };\n    inversePatches.push({\n      op: \"remove\",\n      path: path\n    });\n  }\n} // This is used for both Map objects and normal objects.\n\n\nfunction generatePatchesFromAssigned(state, basePath, patches, inversePatches) {\n  var base = state.base,\n      copy = state.copy;\n  each(state.assigned, function (key, assignedValue) {\n    var origValue = get(base, key);\n    var value = get(copy, key);\n    var op = !assignedValue ? \"remove\" : has(base, key) ? \"replace\" : \"add\";\n\n    if (origValue === value && op === \"replace\") {\n      return;\n    }\n\n    var path = basePath.concat(key);\n    patches.push(op === \"remove\" ? {\n      op: op,\n      path: path\n    } : {\n      op: op,\n      path: path,\n      value: value\n    });\n    inversePatches.push(op === \"add\" ? {\n      op: \"remove\",\n      path: path\n    } : op === \"remove\" ? {\n      op: \"add\",\n      path: path,\n      value: origValue\n    } : {\n      op: \"replace\",\n      path: path,\n      value: origValue\n    });\n  });\n}\n\nfunction generateSetPatches(state, basePath, patches, inversePatches) {\n  var base = state.base,\n      copy = state.copy;\n  var i = 0;\n  base.forEach(function (value) {\n    if (!copy.has(value)) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"remove\",\n        path: path,\n        value: value\n      });\n      inversePatches.unshift({\n        op: \"add\",\n        path: path,\n        value: value\n      });\n    }\n\n    i++;\n  });\n  i = 0;\n  copy.forEach(function (value) {\n    if (!base.has(value)) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"add\",\n        path: path,\n        value: value\n      });\n      inversePatches.unshift({\n        op: \"remove\",\n        path: path,\n        value: value\n      });\n    }\n\n    i++;\n  });\n}\n\nfunction applyPatches(draft, patches) {\n  patches.forEach(function (patch) {\n    var path = patch.path,\n        op = patch.op;\n    /* istanbul ignore next */\n\n    if (!path.length) {\n      die();\n    }\n\n    var base = draft;\n\n    for (var i = 0; i < path.length - 1; i++) {\n      base = get(base, path[i]);\n\n      if (!base || typeof base !== \"object\") {\n        throw new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\"));\n      } // prettier-ignore\n\n    }\n\n    var type = getArchtype(base);\n    var value = deepClonePatchValue(patch.value); // used to clone patch to ensure original patch is not modified, see #411\n\n    var key = path[path.length - 1];\n\n    switch (op) {\n      case \"replace\":\n        switch (type) {\n          case Archtype.Map:\n            return base.set(key, value);\n\n          /* istanbul ignore next */\n\n          case Archtype.Set:\n            throw new Error('Sets cannot have \"replace\" patches.');\n\n          default:\n            // if value is an object, then it's assigned by reference\n            // in the following add or remove ops, the value field inside the patch will also be modifyed\n            // so we use value from the cloned patch\n            // @ts-ignore\n            return base[key] = value;\n        }\n\n      case \"add\":\n        switch (type) {\n          case Archtype.Array:\n            return base.splice(key, 0, value);\n\n          case Archtype.Map:\n            return base.set(key, value);\n\n          case Archtype.Set:\n            return base.add(value);\n\n          default:\n            return base[key] = value;\n        }\n\n      case \"remove\":\n        switch (type) {\n          case Archtype.Array:\n            return base.splice(key, 1);\n\n          case Archtype.Map:\n            return base.delete(key);\n\n          case Archtype.Set:\n            return base.delete(patch.value);\n\n          default:\n            return delete base[key];\n        }\n\n      default:\n        throw new Error(\"Unsupported patch operation: \" + op);\n    }\n  });\n  return draft;\n}\n\nfunction deepClonePatchValue(obj) {\n  if (!obj || typeof obj !== \"object\") {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(deepClonePatchValue);\n  }\n\n  if (isMap(obj)) {\n    return new Map(Array.from(obj.entries()).map(function (_a) {\n      var k = _a[0],\n          v = _a[1];\n      return [k, deepClonePatchValue(v)];\n    }));\n  }\n\n  if (isSet(obj)) {\n    return new Set(Array.from(obj).map(deepClonePatchValue));\n  }\n\n  var cloned = Object.create(Object.getPrototypeOf(obj));\n\n  for (var key in obj) {\n    cloned[key] = deepClonePatchValue(obj[key]);\n  }\n\n  return cloned;\n}\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n}\n/* istanbul ignore next */\n\n\nfunction verifyMinified() {}\n\nvar configDefaults = {\n  useProxies: typeof Proxy !== \"undefined\" && typeof Proxy.revocable !== \"undefined\" && typeof Reflect !== \"undefined\",\n  autoFreeze: typeof process !== \"undefined\" ? process.env.NODE_ENV !== \"production\" :\n  /* istanbul ignore next */\n  verifyMinified.name === \"verifyMinified\",\n  onAssign: null,\n  onDelete: null,\n  onCopy: null\n};\n\nvar Immer =\n/** @class */\nfunction () {\n  function Immer(config) {\n    var _this = this;\n\n    this.useProxies = false;\n    this.autoFreeze = false;\n    each(configDefaults, function (key, value) {\n      var _a, _b; // @ts-ignore\n\n\n      _this[key] = (_b = (_a = config) === null || _a === void 0 ? void 0 : _a[key], _b !== null && _b !== void 0 ? _b : value);\n    });\n    this.setUseProxies(this.useProxies);\n    this.produce = this.produce.bind(this);\n    this.produceWithPatches = this.produceWithPatches.bind(this);\n  }\n  /**\r\n   * The `produce` function takes a value and a \"recipe function\" (whose\r\n   * return value often depends on the base state). The recipe function is\r\n   * free to mutate its first argument however it wants. All mutations are\r\n   * only ever applied to a __copy__ of the base state.\r\n   *\r\n   * Pass only a function to create a \"curried producer\" which relieves you\r\n   * from passing the recipe function every time.\r\n   *\r\n   * Only plain objects and arrays are made mutable. All other objects are\r\n   * considered uncopyable.\r\n   *\r\n   * Note: This function is __bound__ to its `Immer` instance.\r\n   *\r\n   * @param {any} base - the initial state\r\n   * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\r\n   * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n   * @returns {any} a new state, or the initial state if nothing was modified\r\n   */\n\n\n  Immer.prototype.produce = function (base, recipe, patchListener) {\n    var _this = this; // curried invocation\n\n\n    if (typeof base === \"function\" && typeof recipe !== \"function\") {\n      var defaultBase_1 = recipe;\n      recipe = base;\n      var self_1 = this;\n      return function curriedProduce(base) {\n        var arguments$1 = arguments;\n\n        var _this = this;\n\n        if (base === void 0) {\n          base = defaultBase_1;\n        }\n\n        var args = [];\n\n        for (var _i = 1; _i < arguments.length; _i++) {\n          args[_i - 1] = arguments$1[_i];\n        }\n\n        return self_1.produce(base, function (draft) {\n          return recipe.call.apply(recipe, __spreadArrays([_this, draft], args));\n        }); // prettier-ignore\n      };\n    } // prettier-ignore\n\n\n    {\n      if (typeof recipe !== \"function\") {\n        throw new Error(\"The first or second argument to `produce` must be a function\");\n      }\n\n      if (patchListener !== undefined && typeof patchListener !== \"function\") {\n        throw new Error(\"The third argument to `produce` must be a function or undefined\");\n      }\n    }\n    var result; // Only plain objects, arrays, and \"immerable classes\" are drafted.\n\n    if (isDraftable(base)) {\n      var scope_1 = ImmerScope.enter(this);\n      var proxy = this.createProxy(base, undefined);\n      var hasError = true;\n\n      try {\n        result = recipe(proxy);\n        hasError = false;\n      } finally {\n        // finally instead of catch + rethrow better preserves original stack\n        if (hasError) {\n          scope_1.revoke();\n        } else {\n          scope_1.leave();\n        }\n      }\n\n      if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n        return result.then(function (result) {\n          scope_1.usePatches(patchListener);\n          return processResult(_this, result, scope_1);\n        }, function (error) {\n          scope_1.revoke();\n          throw error;\n        });\n      }\n\n      scope_1.usePatches(patchListener);\n      return processResult(this, result, scope_1);\n    } else {\n      result = recipe(base);\n\n      if (result === NOTHING) {\n        return undefined;\n      }\n\n      if (result === undefined) {\n        result = base;\n      }\n\n      maybeFreeze(this, result, true);\n      return result;\n    }\n  };\n\n  Immer.prototype.produceWithPatches = function (arg1, arg2, arg3) {\n    var _this = this;\n\n    if (typeof arg1 === \"function\") {\n      return function (state) {\n        var arguments$1 = arguments;\n        var args = [];\n\n        for (var _i = 1; _i < arguments.length; _i++) {\n          args[_i - 1] = arguments$1[_i];\n        }\n\n        return _this.produceWithPatches(state, function (draft) {\n          return arg1.apply(void 0, __spreadArrays([draft], args));\n        });\n      };\n    } // non-curried form\n\n    /* istanbul ignore next */\n\n\n    if (arg3) {\n      die();\n    }\n\n    var patches, inversePatches;\n    var nextState = this.produce(arg1, arg2, function (p, ip) {\n      patches = p;\n      inversePatches = ip;\n    });\n    return [nextState, patches, inversePatches];\n  };\n\n  Immer.prototype.createDraft = function (base) {\n    if (!isDraftable(base)) {\n      throw new Error(\"First argument to `createDraft` must be a plain object, an array, or an immerable object\"); // prettier-ignore\n    }\n\n    var scope = ImmerScope.enter(this);\n    var proxy = this.createProxy(base, undefined);\n    proxy[DRAFT_STATE].isManual = true;\n    scope.leave();\n    return proxy;\n  };\n\n  Immer.prototype.finishDraft = function (draft, patchListener) {\n    var state = draft && draft[DRAFT_STATE];\n\n    if (!state || !state.isManual) {\n      throw new Error(\"First argument to `finishDraft` must be a draft returned by `createDraft`\"); // prettier-ignore\n    }\n\n    if (state.finalized) {\n      throw new Error(\"The given draft is already finalized\"); // prettier-ignore\n    }\n\n    var scope = state.scope;\n    scope.usePatches(patchListener);\n    return processResult(this, undefined, scope);\n  };\n  /**\r\n   * Pass true to automatically freeze all copies created by Immer.\r\n   *\r\n   * By default, auto-freezing is disabled in production.\r\n   */\n\n\n  Immer.prototype.setAutoFreeze = function (value) {\n    this.autoFreeze = value;\n  };\n  /**\r\n   * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n   * always faster than using ES5 proxies.\r\n   *\r\n   * By default, feature detection is used, so calling this is rarely necessary.\r\n   */\n\n\n  Immer.prototype.setUseProxies = function (value) {\n    this.useProxies = value;\n  };\n\n  Immer.prototype.applyPatches = function (base, patches) {\n    // If a patch replaces the entire state, take that replacement as base\n    // before applying patches\n    var i;\n\n    for (i = patches.length - 1; i >= 0; i--) {\n      var patch = patches[i];\n\n      if (patch.path.length === 0 && patch.op === \"replace\") {\n        base = patch.value;\n        break;\n      }\n    }\n\n    if (isDraft(base)) {\n      // N.B: never hits if some patch a replacement, patches are never drafts\n      return applyPatches(base, patches);\n    } // Otherwise, produce a copy of the base state.\n\n\n    return this.produce(base, function (draft) {\n      return applyPatches(draft, patches.slice(i + 1));\n    });\n  };\n\n  Immer.prototype.createProxy = function (value, parent) {\n    // precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n    var draft = isMap(value) ? proxyMap(value, parent) : isSet(value) ? proxySet(value, parent) : this.useProxies ? createProxy(value, parent) : createES5Proxy(value, parent);\n    var scope = parent ? parent.scope : ImmerScope.current;\n    scope.drafts.push(draft);\n    return draft;\n  };\n\n  Immer.prototype.willFinalize = function (scope, thing, isReplaced) {\n    if (!this.useProxies) {\n      willFinalizeES5(scope, thing, isReplaced);\n    }\n  };\n\n  Immer.prototype.markChanged = function (state) {\n    if (this.useProxies) {\n      markChanged(state);\n    } else {\n      markChangedES5(state);\n    }\n  };\n\n  return Immer;\n}();\n\nvar immer = new Immer();\n/**\r\n * The `produce` function takes a value and a \"recipe function\" (whose\r\n * return value often depends on the base state). The recipe function is\r\n * free to mutate its first argument however it wants. All mutations are\r\n * only ever applied to a __copy__ of the base state.\r\n *\r\n * Pass only a function to create a \"curried producer\" which relieves you\r\n * from passing the recipe function every time.\r\n *\r\n * Only plain objects and arrays are made mutable. All other objects are\r\n * considered uncopyable.\r\n *\r\n * Note: This function is __bound__ to its `Immer` instance.\r\n *\r\n * @param {any} base - the initial state\r\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\r\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\r\n * @returns {any} a new state, or the initial state if nothing was modified\r\n */\n\nvar produce = immer.produce;\n/**\r\n * Like `produce`, but `produceWithPatches` always returns a tuple\r\n * [nextState, patches, inversePatches] (instead of just the next state)\r\n */\n\nvar produceWithPatches = immer.produceWithPatches.bind(immer);\n/**\r\n * Pass true to automatically freeze all copies created by Immer.\r\n *\r\n * By default, auto-freezing is disabled in production.\r\n */\n\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\n/**\r\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\r\n * always faster than using ES5 proxies.\r\n *\r\n * By default, feature detection is used, so calling this is rarely necessary.\r\n */\n\nvar setUseProxies = immer.setUseProxies.bind(immer);\n/**\r\n * Apply an array of Immer patches to the first argument.\r\n *\r\n * This function is a producer, which means copy-on-write is in effect.\r\n */\n\nvar applyPatches$1 = immer.applyPatches.bind(immer);\n/**\r\n * Create an Immer draft from the given base state, which may be a draft itself.\r\n * The draft can be modified until you finalize it with the `finishDraft` function.\r\n */\n\nvar createDraft = immer.createDraft.bind(immer);\n/**\r\n * Finalize an Immer draft from a `createDraft` call, returning the base state\r\n * (if no changes were made) or a modified copy. The draft must *not* be\r\n * mutated afterwards.\r\n *\r\n * Pass a function as the 2nd argument to generate Immer patches based on the\r\n * changes that were made.\r\n */\n\nvar finishDraft = immer.finishDraft.bind(immer);\n/**\r\n * This function is actually a no-op, but can be used to cast an immutable type\r\n * to an draft type and make TypeScript happy\r\n *\r\n * @param value\r\n */\n\nfunction castDraft(value) {\n  return value;\n}\n/**\r\n * This function is actually a no-op, but can be used to cast a mutable type\r\n * to an immutable type and make TypeScript happy\r\n * @param value\r\n */\n\n\nfunction castImmutable(value) {\n  return value;\n}\n\nexport default produce;\nexport { Immer, applyPatches$1 as applyPatches, castDraft, castImmutable, createDraft, finishDraft, DRAFTABLE as immerable, isDraft, isDraftable, NOTHING as nothing, original, produce, produceWithPatches, setAutoFreeze, setUseProxies };","map":{"version":3,"sources":["../src/env.ts","../src/extends.ts","../src/types-internal.ts","../src/common.ts","../src/scope.ts","../src/finalize.ts","../src/proxy.ts","../src/es5.ts","../src/map.ts","../src/set.ts","../src/patches.ts","../node_modules/tslib/tslib.es6.js","../src/immer.ts","../src/index.ts"],"names":["hasSymbol","hasMap","hasSet","NOTHING","Symbol","_a","DRAFTABLE","DRAFT_STATE","iteratorSymbol","extendStatics","__proto__","d","b","__extends","__","Archtype","ProxyType","isDraft","value","isDraftable","isPlainObject","Array","isMap","isSet","proto","Object","original","ownKeys","Reflect","each","obj","iter","getArchtype","isEnumerable","base","prop","desc","thing","die","has","get","set","propOrOldValue","is","x","y","target","latest","state","shallowCopy","invokeGetters","clone","key","writable","configurable","freeze","deep","type","createHiddenProperty","enumerable","ImmerScope","scope","draft","processResult","immer","result","baseDraft","isReplaced","finalize","maybeFreeze","op","path","finalizeTree","assigned","copy_1","generatePatches","root","finalizeProperty","childValue","Error","isDraftProp","parentValue","isSetMember","rootPath","rootState","createProxy","parent","isArray","modified","finalized","drafts","copy","revoke","isManual","traps","proxy","objectTraps","peek","baseValue","isUnchanged","prepareCopy","markChanged","deleteProperty","getOwnPropertyDescriptor","owner","defineProperty","getPrototypeOf","setPrototypeOf","arrayTraps","arguments","fn","isNaN","parseInt","willFinalizeES5","markChangesRecursively","markChangesSweep","createES5Proxy","clonePotentialDraft","proxyProperty","finalizing","revoked","assertUnrevoked","markChangedES5","descriptors","JSON","i","hasArrayChanges","hasObjectChanges","object","min","Math","keys","state_1","descriptor","DraftMap","p","cb","_this","iterator","r","done","proxyMap","DraftSet","proxySet","basePath","patches","inversePatches","generatePatchesFromAssigned","generateArrayPatches","generateSetPatches","_b","delta","start","end","replaceCount","origValue","applyPatches","deepClonePatchValue","patch","k","v","cloned","configDefaults","useProxies","Proxy","autoFreeze","process","verifyMinified","onAssign","onDelete","onCopy","config","Immer","defaultBase_1","recipe","self_1","args","patchListener","scope_1","hasError","arg1","nextState","produce","produceWithPatches","setAutoFreeze","setUseProxies","createDraft","finishDraft","castDraft","castImmutable"],"mappings":"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","sourcesContent":["// Should be no imports here!\n\n// SOme things that should be evaluated before all else...\nconst hasSymbol = typeof Symbol !== \"undefined\"\nexport const hasMap = typeof Map !== \"undefined\"\nexport const hasSet = typeof Set !== \"undefined\"\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: Nothing = hasSymbol\n\t? Symbol(\"immer-nothing\")\n\t: ({[\"immer-nothing\"]: true} as any)\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = hasSymbol\n\t? Symbol(\"immer-draftable\")\n\t: (\"__$immer_draftable\" as any)\n\nexport const DRAFT_STATE: unique symbol = hasSymbol\n\t? Symbol(\"immer-state\")\n\t: (\"__$immer_state\" as any)\n\nexport const iteratorSymbol: typeof Symbol.iterator = hasSymbol\n\t? Symbol.iterator\n\t: (\"@@iterator\" as any)\n\n/** Use a class type for `nothing` so its type is unique */\nexport class Nothing {\n\t// This lets us do `Exclude<T, Nothing>`\n\t// @ts-ignore\n\tprivate _!: unique symbol\n}\n","/* istanbul ignore next */\nvar extendStatics = function(d: any, b: any): any {\n\textendStatics =\n\t\tObject.setPrototypeOf ||\n\t\t({__proto__: []} instanceof Array &&\n\t\t\tfunction(d, b) {\n\t\t\t\td.__proto__ = b\n\t\t\t}) ||\n\t\tfunction(d, b) {\n\t\t\tfor (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]\n\t\t}\n\treturn extendStatics(d, b)\n}\n\n// Ugly hack to resolve #502 and inherit built in Map / Set\nexport function __extends(d: any, b: any): any {\n\textendStatics(d, b)\n\tfunction __(this: any): any {\n\t\tthis.constructor = d\n\t}\n\td.prototype =\n\t\t// @ts-ignore\n\t\t((__.prototype = b.prototype), new __())\n}\n","import {\n\tSetState,\n\tImmerScope,\n\tProxyObjectState,\n\tProxyArrayState,\n\tES5ObjectState,\n\tES5ArrayState,\n\tMapState,\n\tDRAFT_STATE\n} from \"./internal\"\n\nexport type Objectish = AnyObject | AnyArray | AnyMap | AnySet\nexport type ObjectishNoSet = AnyObject | AnyArray | AnyMap\n\nexport type AnyObject = {[key: string]: any}\nexport type AnyArray = Array<any>\nexport type AnySet = Set<any>\nexport type AnyMap = Map<any, any>\nexport enum Archtype {\n\tObject,\n\tArray,\n\tMap,\n\tSet\n}\n\nexport enum ProxyType {\n\tProxyObject,\n\tProxyArray,\n\tES5Object,\n\tES5Array,\n\tMap,\n\tSet\n}\n\nexport interface ImmerBaseState {\n\tparent?: ImmerState\n\tscope: ImmerScope\n\tmodified: boolean\n\tfinalized: boolean\n\tisManual: boolean\n}\n\nexport type ImmerState =\n\t| ProxyObjectState\n\t| ProxyArrayState\n\t| ES5ObjectState\n\t| ES5ArrayState\n\t| MapState\n\t| SetState\n\n// The _internal_ type used for drafts (not to be confused with Draft, which is public facing)\nexport type Drafted<Base = any, T extends ImmerState = ImmerState> = {\n\t[DRAFT_STATE]: T\n} & Base\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\thasSet,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\tProxyType,\n\tArchtype,\n\thasMap\n} from \"./internal\"\n\n/** Returns true if the given value is an Immer draft */\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = Object.getPrototypeOf(value)\n\treturn !proto || proto === Object.prototype\n}\n\n/** Get the underlying object that is represented by the given draft */\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (value && value[DRAFT_STATE]) {\n\t\treturn value[DRAFT_STATE].base as any\n\t}\n\t// otherwise return undefined\n}\n\nexport const ownKeys: (target: AnyObject) => PropertyKey[] =\n\ttypeof Reflect !== \"undefined\" && Reflect.ownKeys\n\t\t? Reflect.ownKeys\n\t\t: typeof Object.getOwnPropertySymbols !== \"undefined\"\n\t\t? obj =>\n\t\t\t\tObject.getOwnPropertyNames(obj).concat(\n\t\t\t\t\tObject.getOwnPropertySymbols(obj) as any\n\t\t\t\t)\n\t\t: /* istanbul ignore next */ Object.getOwnPropertyNames\n\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void\n): void\nexport function each(obj: any, iter: any) {\n\tif (getArchtype(obj) === Archtype.Object) {\n\t\townKeys(obj).forEach(key => iter(key, obj[key], obj))\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\nexport function isEnumerable(base: AnyObject, prop: PropertyKey): boolean {\n\tconst desc = Object.getOwnPropertyDescriptor(base, prop)\n\treturn desc && desc.enumerable ? true : false\n}\n\nexport function getArchtype(thing: any): Archtype {\n\t/* istanbul ignore next */\n\tif (!thing) die()\n\tif (thing[DRAFT_STATE]) {\n\t\tswitch ((thing as Drafted)[DRAFT_STATE].type) {\n\t\t\tcase ProxyType.ES5Object:\n\t\t\tcase ProxyType.ProxyObject:\n\t\t\t\treturn Archtype.Object\n\t\t\tcase ProxyType.ES5Array:\n\t\t\tcase ProxyType.ProxyArray:\n\t\t\t\treturn Archtype.Array\n\t\t\tcase ProxyType.Map:\n\t\t\t\treturn Archtype.Map\n\t\t\tcase ProxyType.Set:\n\t\t\t\treturn Archtype.Set\n\t\t}\n\t}\n\treturn Array.isArray(thing)\n\t\t? Archtype.Array\n\t\t: isMap(thing)\n\t\t? Archtype.Map\n\t\t: isSet(thing)\n\t\t? Archtype.Set\n\t\t: Archtype.Object\n}\n\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === Archtype.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === Archtype.Map ? thing.get(prop) : thing[prop]\n}\n\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tswitch (getArchtype(thing)) {\n\t\tcase Archtype.Map:\n\t\t\tthing.set(propOrOldValue, value)\n\t\t\tbreak\n\t\tcase Archtype.Set:\n\t\t\tthing.delete(propOrOldValue)\n\t\t\tthing.add(value)\n\t\t\tbreak\n\t\tdefault:\n\t\t\tthing[propOrOldValue] = value\n\t}\n}\n\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\nexport function isMap(target: any): target is AnyMap {\n\treturn hasMap && target instanceof Map\n}\n\nexport function isSet(target: any): target is AnySet {\n\treturn hasSet && target instanceof Set\n}\n\nexport function latest(state: ImmerState): any {\n\treturn state.copy || state.base\n}\n\nexport function shallowCopy<T extends AnyObject | AnyArray>(\n\tbase: T,\n\tinvokeGetters?: boolean\n): T\nexport function shallowCopy(base: any, invokeGetters = false) {\n\tif (Array.isArray(base)) return base.slice()\n\tconst clone = Object.create(Object.getPrototypeOf(base))\n\townKeys(base).forEach(key => {\n\t\tif (key === DRAFT_STATE) {\n\t\t\treturn // Never copy over draft state.\n\t\t}\n\t\tconst desc = Object.getOwnPropertyDescriptor(base, key)!\n\t\tlet {value} = desc\n\t\tif (desc.get) {\n\t\t\tif (!invokeGetters) {\n\t\t\t\tthrow new Error(\"Immer drafts cannot have computed properties\")\n\t\t\t}\n\t\t\tvalue = desc.get.call(base)\n\t\t}\n\t\tif (desc.enumerable) {\n\t\t\tclone[key] = value\n\t\t} else {\n\t\t\tObject.defineProperty(clone, key, {\n\t\t\t\tvalue,\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true\n\t\t\t})\n\t\t}\n\t})\n\treturn clone\n}\n\nexport function freeze(obj: any, deep: boolean): void {\n\tif (!isDraftable(obj) || isDraft(obj) || Object.isFrozen(obj)) return\n\tconst type = getArchtype(obj)\n\tif (type === Archtype.Set) {\n\t\tobj.add = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t} else if (type === Archtype.Map) {\n\t\tobj.set = obj.clear = obj.delete = dontMutateFrozenCollections as any\n\t}\n\tObject.freeze(obj)\n\tif (deep) each(obj, (_, value) => freeze(value, true))\n}\n\nfunction dontMutateFrozenCollections() {\n\tthrow new Error(\"This object has been frozen and should not be mutated\")\n}\n\nexport function createHiddenProperty(\n\ttarget: AnyObject,\n\tprop: PropertyKey,\n\tvalue: any\n) {\n\tObject.defineProperty(target, prop, {\n\t\tvalue: value,\n\t\tenumerable: false,\n\t\twritable: true\n\t})\n}\n\n/* istanbul ignore next */\nexport function die(): never {\n\tthrow new Error(\"Illegal state, please file a bug\")\n}\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tProxyType,\n\tImmer,\n\tDRAFT_STATE\n} from \"./internal\"\n\n/** Each scope represents a `produce` call. */\nexport class ImmerScope {\n\tstatic current?: ImmerScope\n\n\tpatches?: Patch[]\n\tinversePatches?: Patch[]\n\tcanAutoFreeze: boolean\n\tdrafts: any[]\n\tparent?: ImmerScope\n\tpatchListener?: PatchListener\n\timmer: Immer\n\n\tconstructor(parent: ImmerScope | undefined, immer: Immer) {\n\t\tthis.drafts = []\n\t\tthis.parent = parent\n\t\tthis.immer = immer\n\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tthis.canAutoFreeze = true\n\t}\n\n\tusePatches(patchListener?: PatchListener) {\n\t\tif (patchListener) {\n\t\t\tthis.patches = []\n\t\t\tthis.inversePatches = []\n\t\t\tthis.patchListener = patchListener\n\t\t}\n\t}\n\n\trevoke() {\n\t\tthis.leave()\n\t\tthis.drafts.forEach(revoke)\n\t\t// @ts-ignore\n\t\tthis.drafts = null\n\t}\n\n\tleave() {\n\t\tif (this === ImmerScope.current) {\n\t\t\tImmerScope.current = this.parent\n\t\t}\n\t}\n\n\tstatic enter(immer: Immer) {\n\t\tconst scope = new ImmerScope(ImmerScope.current, immer)\n\t\tImmerScope.current = scope\n\t\treturn scope\n\t}\n}\n\nfunction revoke(draft: Drafted) {\n\tconst state = draft[DRAFT_STATE]\n\tif (\n\t\tstate.type === ProxyType.ProxyObject ||\n\t\tstate.type === ProxyType.ProxyArray\n\t)\n\t\tstate.revoke()\n\telse state.revoked = true\n}\n","import {\n\tImmer,\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tDrafted,\n\tPatchPath,\n\tProxyType,\n\teach,\n\thas,\n\tfreeze,\n\tgeneratePatches,\n\tshallowCopy,\n\tImmerState,\n\tisSet,\n\tisDraft,\n\tSetState,\n\tset,\n\tis,\n\tget\n} from \"./internal\"\n\nexport function processResult(immer: Immer, result: any, scope: ImmerScope) {\n\tconst baseDraft = scope.drafts![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\timmer.willFinalize(scope, result, isReplaced)\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified) {\n\t\t\tscope.revoke()\n\t\t\tthrow new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\") // prettier-ignore\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(immer, result, scope)\n\t\t\tif (!scope.parent) maybeFreeze(immer, result)\n\t\t}\n\t\tif (scope.patches) {\n\t\t\tscope.patches.push({\n\t\t\t\top: \"replace\",\n\t\t\t\tpath: [],\n\t\t\t\tvalue: result\n\t\t\t})\n\t\t\tscope.inversePatches!.push({\n\t\t\t\top: \"replace\",\n\t\t\t\tpath: [],\n\t\t\t\tvalue: baseDraft[DRAFT_STATE].base\n\t\t\t})\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(immer, baseDraft, scope, [])\n\t}\n\tscope.revoke()\n\tif (scope.patches) {\n\t\tscope.patchListener!(scope.patches, scope.inversePatches!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(\n\timmer: Immer,\n\tdraft: Drafted,\n\tscope: ImmerScope,\n\tpath?: PatchPath\n) {\n\tconst state = draft[DRAFT_STATE]\n\tif (!state) {\n\t\tif (Object.isFrozen(draft)) return draft\n\t\treturn finalizeTree(immer, draft, scope)\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope !== scope) {\n\t\treturn draft\n\t}\n\tif (!state.modified) {\n\t\tmaybeFreeze(immer, state.base, true)\n\t\treturn state.base\n\t}\n\tif (!state.finalized) {\n\t\tstate.finalized = true\n\t\tfinalizeTree(immer, state.draft, scope, path)\n\n\t\t// We cannot really delete anything inside of a Set. We can only replace the whole Set.\n\t\tif (immer.onDelete && state.type !== ProxyType.Set) {\n\t\t\t// The `assigned` object is unreliable with ES5 drafts.\n\t\t\tif (immer.useProxies) {\n\t\t\t\tconst {assigned} = state\n\t\t\t\teach(assigned, (prop, exists) => {\n\t\t\t\t\tif (!exists) immer.onDelete!(state, prop as any)\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tconst {base, copy} = state\n\t\t\t\teach(base, prop => {\n\t\t\t\t\tif (!has(copy, prop)) immer.onDelete!(state, prop as any)\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tif (immer.onCopy) {\n\t\t\timmer.onCopy(state)\n\t\t}\n\n\t\t// At this point, all descendants of `state.copy` have been finalized,\n\t\t// so we can be sure that `scope.canAutoFreeze` is accurate.\n\t\tif (immer.autoFreeze && scope.canAutoFreeze) {\n\t\t\tfreeze(state.copy, false)\n\t\t}\n\n\t\tif (path && scope.patches) {\n\t\t\tgeneratePatches(state, path, scope.patches, scope.inversePatches!)\n\t\t}\n\t}\n\treturn state.copy\n}\n\nfunction finalizeTree(\n\timmer: Immer,\n\troot: Drafted,\n\tscope: ImmerScope,\n\trootPath?: PatchPath\n) {\n\tconst state = root[DRAFT_STATE]\n\tif (state) {\n\t\tif (\n\t\t\tstate.type === ProxyType.ES5Object ||\n\t\t\tstate.type === ProxyType.ES5Array\n\t\t) {\n\t\t\t// Create the final copy, with added keys and without deleted keys.\n\t\t\tstate.copy = shallowCopy(state.draft, true)\n\t\t}\n\t\troot = state.copy\n\t}\n\teach(root, (key, value) =>\n\t\tfinalizeProperty(immer, scope, root, state, root, key, value, rootPath)\n\t)\n\treturn root\n}\n\nfunction finalizeProperty(\n\timmer: Immer,\n\tscope: ImmerScope,\n\troot: Drafted,\n\trootState: ImmerState,\n\tparentValue: Drafted,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath\n) {\n\tif (childValue === parentValue) {\n\t\tthrow Error(\"Immer forbids circular references\")\n\t}\n\n\t// In the `finalizeTree` method, only the `root` object may be a draft.\n\tconst isDraftProp = !!rootState && parentValue === root\n\tconst isSetMember = isSet(parentValue)\n\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tisDraftProp &&\n\t\t\t!isSetMember && // Set objects are atomic since they have no keys.\n\t\t\t!has((rootState as Exclude<ImmerState, SetState>).assigned!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tchildValue = finalize(immer, childValue, scope, path)\n\t\tset(parentValue, prop, childValue)\n\n\t\t// Drafts from another scope must prevent auto-freezing.\n\t\tif (isDraft(childValue)) {\n\t\t\tscope.canAutoFreeze = false\n\t\t}\n\t}\n\t// Unchanged draft properties are ignored.\n\telse if (isDraftProp && is(childValue, get(rootState.base, prop))) {\n\t\treturn\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\t// TODO: the recursion over here looks weird, shouldn't non-draft stuff have it's own recursion?\n\t// especially the passing on of root and rootState doesn't make sense...\n\telse if (isDraftable(childValue)) {\n\t\teach(childValue, (key, grandChild) =>\n\t\t\tfinalizeProperty(\n\t\t\t\timmer,\n\t\t\t\tscope,\n\t\t\t\troot,\n\t\t\t\trootState,\n\t\t\t\tchildValue,\n\t\t\t\tkey,\n\t\t\t\tgrandChild,\n\t\t\t\trootPath\n\t\t\t)\n\t\t)\n\t\tif (!scope.parent) maybeFreeze(immer, childValue)\n\t}\n\n\tif (isDraftProp && immer.onAssign && !isSetMember) {\n\t\timmer.onAssign(rootState, prop, childValue)\n\t}\n}\n\nexport function maybeFreeze(immer: Immer, value: any, deep = false) {\n\tif (immer.autoFreeze && !isDraft(value)) {\n\t\tfreeze(value, deep)\n\t}\n}\n","\"use strict\"\nimport {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tProxyType,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tImmerScope,\n\tDRAFT_STATE\n} from \"./internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned: {\n\t\t[property: string]: boolean\n\t}\n\tparent?: ImmerState\n\tdrafts?: {\n\t\t[property: string]: Drafted<any, any>\n\t}\n\trevoke(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype: ProxyType.ProxyObject\n\tbase: AnyObject\n\tcopy: AnyObject | null\n\tdraft: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype: ProxyType.ProxyArray\n\tbase: AnyArray\n\tcopy: AnyArray | null\n\tdraft: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype: isArray ? ProxyType.ProxyArray : (ProxyType.ProxyObject as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope: parent ? parent.scope : ImmerScope.current!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified: false,\n\t\t// Used during finalization.\n\t\tfinalized: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned: {},\n\t\t// The parent draft state.\n\t\tparent,\n\t\t// The base state.\n\t\tbase,\n\t\t// The base proxy.\n\t\tdraft: null as any, // set below\n\t\t// Any property proxies.\n\t\tdrafts: {},\n\t\t// The base copy with any updated values.\n\t\tcopy: null,\n\t\t// Called by the `produce` function.\n\t\trevoke: null as any,\n\t\tisManual: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\t// TODO: optimization: might be faster, cheaper if we created a non-revocable proxy\n\t// and administrate revoking ourselves\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft = proxy as any\n\tstate.revoke = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nconst objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\t\tlet {drafts} = state\n\n\t\t// Check for existing draft in unmodified state.\n\t\tif (!state.modified && has(drafts, prop)) {\n\t\t\treturn drafts![prop as any]\n\t\t}\n\n\t\tconst value = latest(state)[prop]\n\t\tif (state.finalized || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\n\t\t// Check for existing draft in modified state.\n\t\tif (state.modified) {\n\t\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\t\tif (value !== peek(state.base, prop)) return value\n\t\t\t// Store drafts on the copy (when one exists).\n\t\t\t// @ts-ignore\n\t\t\tdrafts = state.copy\n\t\t}\n\n\t\treturn (drafts![prop as any] = state.scope.immer.createProxy(value, state))\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(state, prop: string /* strictly not, but helps TS */, value) {\n\t\tif (!state.modified) {\n\t\t\tconst baseValue = peek(state.base, prop)\n\t\t\t// Optimize based on value's truthiness. Truthy values are guaranteed to\n\t\t\t// never be undefined, so we can avoid the `in` operator. Lastly, truthy\n\t\t\t// values may be drafts, but falsy values are never drafts.\n\t\t\tconst isUnchanged = value\n\t\t\t\t? is(baseValue, value) || value === state.drafts![prop]\n\t\t\t\t: is(baseValue, value) && prop in state.base\n\t\t\tif (isUnchanged) return true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\t\tstate.assigned[prop] = true\n\t\t// @ts-ignore\n\t\tstate.copy![prop] = value\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base, prop) !== undefined || prop in state.base) {\n\t\t\tstate.assigned[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else if (state.assigned[prop]) {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned[prop]\n\t\t}\n\t\t// @ts-ignore\n\t\tif (state.copy) delete state.copy[prop]\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (desc) {\n\t\t\tdesc.writable = true\n\t\t\tdesc.configurable =\n\t\t\t\tstate.type !== ProxyType.ProxyArray || prop !== \"length\"\n\t\t}\n\t\treturn desc\n\t},\n\tdefineProperty() {\n\t\tthrow new Error(\"Object.defineProperty() cannot be used on an Immer draft\") // prettier-ignore\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn Object.getPrototypeOf(state.base)\n\t},\n\tsetPrototypeOf() {\n\t\tthrow new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\") // prettier-ignore\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (isNaN(parseInt(prop as any))) {\n\t\tthrow new Error(\"Immer only supports deleting array indices\") // prettier-ignore\n\t}\n\treturn objectTraps.deleteProperty!.call(this, state[0], prop)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (prop !== \"length\" && isNaN(parseInt(prop as any))) {\n\t\tthrow new Error(\"Immer only supports setting array indices and the 'length' property\") // prettier-ignore\n\t}\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n/**\n * Map drafts\n */\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey): any {\n\tconst state = draft[DRAFT_STATE]\n\tconst desc = Reflect.getOwnPropertyDescriptor(\n\t\tstate ? latest(state) : draft,\n\t\tprop\n\t)\n\treturn desc && desc.value\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified) {\n\t\tstate.modified = true\n\t\tif (\n\t\t\tstate.type === ProxyType.ProxyObject ||\n\t\t\tstate.type === ProxyType.ProxyArray\n\t\t) {\n\t\t\tconst copy = (state.copy = shallowCopy(state.base))\n\t\t\teach(state.drafts!, (key, value) => {\n\t\t\t\t// @ts-ignore\n\t\t\t\tcopy[key] = value\n\t\t\t})\n\t\t\tstate.drafts = undefined\n\t\t}\n\n\t\tif (state.parent) {\n\t\t\tmarkChanged(state.parent)\n\t\t}\n\t}\n}\n\nfunction prepareCopy(state: ProxyState) {\n\tif (!state.copy) {\n\t\tstate.copy = shallowCopy(state.base)\n\t}\n}\n","\"use strict\"\nimport {\n\teach,\n\thas,\n\tis,\n\tisDraft,\n\tisDraftable,\n\tisEnumerable,\n\tshallowCopy,\n\tlatest,\n\tcreateHiddenProperty,\n\tImmerScope,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tObjectish,\n\tImmerBaseState,\n\tAnyArray,\n\tProxyType,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE\n} from \"./internal\"\n\ninterface ES5BaseState extends ImmerBaseState {\n\tfinalizing: boolean\n\tassigned: {[key: string]: any}\n\tparent?: ImmerState\n\trevoked: boolean\n}\n\nexport interface ES5ObjectState extends ES5BaseState {\n\ttype: ProxyType.ES5Object\n\tdraft: Drafted<AnyObject, ES5ObjectState>\n\tbase: AnyObject\n\tcopy: AnyObject | null\n}\n\nexport interface ES5ArrayState extends ES5BaseState {\n\ttype: ProxyType.ES5Array\n\tdraft: Drafted<AnyObject, ES5ArrayState>\n\tbase: AnyArray\n\tcopy: AnyArray | null\n}\n\ntype ES5State = ES5ArrayState | ES5ObjectState\n\nexport function willFinalizeES5(\n\tscope: ImmerScope,\n\tresult: any,\n\tisReplaced: boolean\n) {\n\tscope.drafts!.forEach(draft => {\n\t\tdraft[DRAFT_STATE].finalizing = true\n\t})\n\tif (!isReplaced) {\n\t\tif (scope.patches) {\n\t\t\tmarkChangesRecursively(scope.drafts![0])\n\t\t}\n\t\t// This is faster when we don't care about which attributes changed.\n\t\tmarkChangesSweep(scope.drafts)\n\t}\n\t// When a child draft is returned, look for changes.\n\telse if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\n\t\tmarkChangesSweep(scope.drafts)\n\t}\n}\n\nexport function createES5Proxy<T>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ES5ObjectState | ES5ArrayState> {\n\tconst isArray = Array.isArray(base)\n\tconst draft = clonePotentialDraft(base)\n\n\teach(draft, prop => {\n\t\tproxyProperty(draft, prop, isArray || isEnumerable(base, prop))\n\t})\n\n\tconst state: ES5ObjectState | ES5ArrayState = {\n\t\ttype: isArray ? ProxyType.ES5Array : (ProxyType.ES5Object as any),\n\t\tscope: parent ? parent.scope : ImmerScope.current!,\n\t\tmodified: false,\n\t\tfinalizing: false,\n\t\tfinalized: false,\n\t\tassigned: {},\n\t\tparent,\n\t\tbase,\n\t\tdraft,\n\t\tcopy: null,\n\t\trevoked: false,\n\t\tisManual: false\n\t}\n\n\tcreateHiddenProperty(draft, DRAFT_STATE, state)\n\treturn draft\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tif (state && !state.finalizing) {\n\t\tstate.finalizing = true\n\t\tconst value = draft[prop]\n\t\tstate.finalizing = false\n\t\treturn value\n\t}\n\treturn draft[prop]\n}\n\nfunction get(state: ES5State, prop: string | number) {\n\tassertUnrevoked(state)\n\tconst value = peek(latest(state), prop)\n\tif (state.finalizing) return value\n\t// Create a draft if the value is unmodified.\n\tif (value === peek(state.base, prop) && isDraftable(value)) {\n\t\tprepareCopy(state)\n\t\t// @ts-ignore\n\t\treturn (state.copy![prop] = state.scope.immer.createProxy(value, state))\n\t}\n\treturn value\n}\n\nfunction set(state: ES5State, prop: string | number, value: any) {\n\tassertUnrevoked(state)\n\tstate.assigned[prop] = true\n\tif (!state.modified) {\n\t\tif (is(value, peek(latest(state), prop))) return\n\t\tmarkChangedES5(state)\n\t\tprepareCopy(state)\n\t}\n\t// @ts-ignore\n\tstate.copy![prop] = value\n}\n\nexport function markChangedES5(state: ImmerState) {\n\tif (!state.modified) {\n\t\tstate.modified = true\n\t\tif (state.parent) markChangedES5(state.parent)\n\t}\n}\n\nfunction prepareCopy(state: ES5State) {\n\tif (!state.copy) state.copy = clonePotentialDraft(state.base)\n}\n\nfunction clonePotentialDraft(base: Objectish) {\n\tconst state = base && (base as any)[DRAFT_STATE]\n\tif (state) {\n\t\tstate.finalizing = true\n\t\tconst draft = shallowCopy(state.draft, true)\n\t\tstate.finalizing = false\n\t\treturn draft\n\t}\n\treturn shallowCopy(base)\n}\n\n// property descriptors are recycled to make sure we don't create a get and set closure per property,\n// but share them all instead\nconst descriptors: {[prop: string]: PropertyDescriptor} = {}\n\nfunction proxyProperty(\n\tdraft: Drafted<any, ES5State>,\n\tprop: string | number,\n\tenumerable: boolean\n) {\n\tlet desc = descriptors[prop]\n\tif (desc) {\n\t\tdesc.enumerable = enumerable\n\t} else {\n\t\tdescriptors[prop] = desc = {\n\t\t\tconfigurable: true,\n\t\t\tenumerable,\n\t\t\tget(this: any) {\n\t\t\t\treturn get(this[DRAFT_STATE], prop)\n\t\t\t},\n\t\t\tset(this: any, value) {\n\t\t\t\tset(this[DRAFT_STATE], prop, value)\n\t\t\t}\n\t\t}\n\t}\n\tObject.defineProperty(draft, prop, desc)\n}\n\nexport function assertUnrevoked(state: ES5State | MapState | SetState) {\n\tif (state.revoked === true)\n\t\tthrow new Error(\n\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\t\tJSON.stringify(latest(state))\n\t\t)\n}\n\n// This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\nfunction markChangesSweep(drafts: Drafted<any, ImmerState>[]) {\n\t// The natural order of drafts in the `scope` array is based on when they\n\t// were accessed. By processing drafts in reverse natural order, we have a\n\t// better chance of processing leaf nodes first. When a leaf node is known to\n\t// have changed, we can avoid any traversal of its ancestor nodes.\n\tfor (let i = drafts.length - 1; i >= 0; i--) {\n\t\tconst state = drafts[i][DRAFT_STATE]\n\t\tif (!state.modified) {\n\t\t\tswitch (state.type) {\n\t\t\t\tcase ProxyType.ES5Array:\n\t\t\t\t\tif (hasArrayChanges(state)) markChangedES5(state)\n\t\t\t\t\tbreak\n\t\t\t\tcase ProxyType.ES5Object:\n\t\t\t\t\tif (hasObjectChanges(state)) markChangedES5(state)\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction markChangesRecursively(object: any) {\n\tif (!object || typeof object !== \"object\") return\n\tconst state = object[DRAFT_STATE]\n\tif (!state) return\n\tconst {base, draft, assigned, type} = state\n\tif (type === ProxyType.ES5Object) {\n\t\t// Look for added keys.\n\t\t// TODO: looks quite duplicate to hasObjectChanges,\n\t\t// probably there is a faster way to detect changes, as sweep + recurse seems to do some\n\t\t// unnecessary work.\n\t\t// also: probably we can store the information we detect here, to speed up tree finalization!\n\t\teach(draft, key => {\n\t\t\tif ((key as any) === DRAFT_STATE) return\n\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\tif (base[key] === undefined && !has(base, key)) {\n\t\t\t\tassigned[key] = true\n\t\t\t\tmarkChangedES5(state)\n\t\t\t} else if (!assigned[key]) {\n\t\t\t\t// Only untouched properties trigger recursion.\n\t\t\t\tmarkChangesRecursively(draft[key])\n\t\t\t}\n\t\t})\n\t\t// Look for removed keys.\n\t\teach(base, key => {\n\t\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\t\tif (draft[key] === undefined && !has(draft, key)) {\n\t\t\t\tassigned[key] = false\n\t\t\t\tmarkChangedES5(state)\n\t\t\t}\n\t\t})\n\t} else if (type === ProxyType.ES5Array) {\n\t\tif (hasArrayChanges(state)) {\n\t\t\tmarkChangedES5(state)\n\t\t\tassigned.length = true\n\t\t}\n\n\t\tif (draft.length < base.length) {\n\t\t\tfor (let i = draft.length; i < base.length; i++) assigned[i] = false\n\t\t} else {\n\t\t\tfor (let i = base.length; i < draft.length; i++) assigned[i] = true\n\t\t}\n\n\t\t// Minimum count is enough, the other parts has been processed.\n\t\tconst min = Math.min(draft.length, base.length)\n\n\t\tfor (let i = 0; i < min; i++) {\n\t\t\t// Only untouched indices trigger recursion.\n\t\t\tif (assigned[i] === undefined) markChangesRecursively(draft[i])\n\t\t}\n\t}\n}\n\nfunction hasObjectChanges(state: ES5ObjectState) {\n\tconst {base, draft} = state\n\n\t// Search for added keys and changed keys. Start at the back, because\n\t// non-numeric keys are ordered by time of definition on the object.\n\tconst keys = Object.keys(draft)\n\tfor (let i = keys.length - 1; i >= 0; i--) {\n\t\tconst key = keys[i]\n\t\tconst baseValue = base[key]\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (baseValue === undefined && !has(base, key)) {\n\t\t\treturn true\n\t\t}\n\t\t// Once a base key is deleted, future changes go undetected, because its\n\t\t// descriptor is erased. This branch detects any missed changes.\n\t\telse {\n\t\t\tconst value = draft[key]\n\t\t\tconst state = value && value[DRAFT_STATE]\n\t\t\tif (state ? state.base !== baseValue : !is(value, baseValue)) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\n\t// At this point, no keys were added or changed.\n\t// Compare key count to determine if keys were deleted.\n\treturn keys.length !== Object.keys(base).length\n}\n\nfunction hasArrayChanges(state: ES5ArrayState) {\n\tconst {draft} = state\n\tif (draft.length !== state.base.length) return true\n\t// See #116\n\t// If we first shorten the length, our array interceptors will be removed.\n\t// If after that new items are added, result in the same original length,\n\t// those last items will have no intercepting property.\n\t// So if there is no own descriptor on the last position, we know that items were removed and added\n\t// N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n\t// the last one\n\tconst descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1)\n\t// descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\tif (descriptor && !descriptor.get) return true\n\t// For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\treturn false\n}\n","import {\n\t__extends,\n\tImmerBaseState,\n\tProxyType,\n\tAnyMap,\n\tDrafted,\n\tImmerState,\n\tDRAFT_STATE,\n\tImmerScope,\n\tlatest,\n\tassertUnrevoked,\n\tisDraftable,\n\titeratorSymbol\n} from \"./internal\"\n\nexport interface MapState extends ImmerBaseState {\n\ttype: ProxyType.Map\n\tcopy: AnyMap | undefined\n\tassigned: Map<any, boolean> | undefined\n\tbase: AnyMap\n\trevoked: boolean\n\tdraft: Drafted<AnyMap, MapState>\n}\n\nconst DraftMap = (function(_super) {\n\tif (!_super) {\n\t\t/* istanbul ignore next */\n\t\tthrow new Error(\"Map is not polyfilled\")\n\t}\n\t__extends(DraftMap, _super)\n\t// Create class manually, cause #502\n\tfunction DraftMap(this: any, target: AnyMap, parent?: ImmerState): any {\n\t\tthis[DRAFT_STATE] = {\n\t\t\ttype: ProxyType.Map,\n\t\t\tparent,\n\t\t\tscope: parent ? parent.scope : ImmerScope.current!,\n\t\t\tmodified: false,\n\t\t\tfinalized: false,\n\t\t\tcopy: undefined,\n\t\t\tassigned: undefined,\n\t\t\tbase: target,\n\t\t\tdraft: this as any,\n\t\t\tisManual: false,\n\t\t\trevoked: false\n\t\t}\n\t\treturn this\n\t}\n\tconst p = DraftMap.prototype\n\n\t// TODO: smaller build size if we create a util for Object.defineProperty\n\tObject.defineProperty(p, \"size\", {\n\t\tget: function() {\n\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t},\n\t\tenumerable: true,\n\t\tconfigurable: true\n\t})\n\n\tp.has = function(key: any): boolean {\n\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t}\n\n\tp.set = function(key: any, value: any) {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tif (latest(state).get(key) !== value) {\n\t\t\tprepareCopy(state)\n\t\t\tstate.scope.immer.markChanged(state)\n\t\t\tstate.assigned!.set(key, true)\n\t\t\tstate.copy!.set(key, value)\n\t\t\tstate.assigned!.set(key, true)\n\t\t}\n\t\treturn this\n\t}\n\n\tp.delete = function(key: any): boolean {\n\t\tif (!this.has(key)) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tprepareCopy(state)\n\t\tstate.scope.immer.markChanged(state)\n\t\tstate.assigned!.set(key, false)\n\t\tstate.copy!.delete(key)\n\t\treturn true\n\t}\n\n\tp.clear = function() {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tprepareCopy(state)\n\t\tstate.scope.immer.markChanged(state)\n\t\tstate.assigned = new Map()\n\t\treturn state.copy!.clear()\n\t}\n\n\tp.forEach = function(\n\t\tcb: (value: any, key: any, self: any) => void,\n\t\tthisArg?: any\n\t) {\n\t\tconst state = this[DRAFT_STATE]\n\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t})\n\t}\n\n\tp.get = function(key: any): any {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tconst value = latest(state).get(key)\n\t\tif (state.finalized || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\tif (value !== state.base.get(key)) {\n\t\t\treturn value // either already drafted or reassigned\n\t\t}\n\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\tconst draft = state.scope.immer.createProxy(value, state)\n\t\tprepareCopy(state)\n\t\tstate.copy!.set(key, draft)\n\t\treturn draft\n\t}\n\n\tp.keys = function(): IterableIterator<any> {\n\t\treturn latest(this[DRAFT_STATE]).keys()\n\t}\n\n\tp.values = function(): IterableIterator<any> {\n\t\tconst iterator = this.keys()\n\t\treturn {\n\t\t\t[iteratorSymbol]: () => this.values(),\n\t\t\tnext: () => {\n\t\t\t\tconst r = iterator.next()\n\t\t\t\t/* istanbul ignore next */\n\t\t\t\tif (r.done) return r\n\t\t\t\tconst value = this.get(r.value)\n\t\t\t\treturn {\n\t\t\t\t\tdone: false,\n\t\t\t\t\tvalue\n\t\t\t\t}\n\t\t\t}\n\t\t} as any\n\t}\n\n\tp.entries = function(): IterableIterator<[any, any]> {\n\t\tconst iterator = this.keys()\n\t\treturn {\n\t\t\t[iteratorSymbol]: () => this.entries(),\n\t\t\tnext: () => {\n\t\t\t\tconst r = iterator.next()\n\t\t\t\t/* istanbul ignore next */\n\t\t\t\tif (r.done) return r\n\t\t\t\tconst value = this.get(r.value)\n\t\t\t\treturn {\n\t\t\t\t\tdone: false,\n\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t}\n\t\t\t}\n\t\t} as any\n\t}\n\n\tp[iteratorSymbol] = function() {\n\t\treturn this.entries()\n\t}\n\n\treturn DraftMap\n})(Map)\n\nexport function proxyMap<T extends AnyMap>(\n\ttarget: T,\n\tparent?: ImmerState\n): T & {[DRAFT_STATE]: MapState} {\n\t// @ts-ignore\n\treturn new DraftMap(target, parent)\n}\n\nfunction prepareCopy(state: MapState) {\n\tif (!state.copy) {\n\t\tstate.assigned = new Map()\n\t\tstate.copy = new Map(state.base)\n\t}\n}\n","import {\n\t__extends,\n\tImmerBaseState,\n\tProxyType,\n\tAnySet,\n\tDrafted,\n\tImmerState,\n\tDRAFT_STATE,\n\tImmerScope,\n\tlatest,\n\tassertUnrevoked,\n\titeratorSymbol,\n\tisDraftable\n} from \"./internal\"\n\nexport interface SetState extends ImmerBaseState {\n\ttype: ProxyType.Set\n\tcopy: AnySet | undefined\n\tbase: AnySet\n\tdrafts: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked: boolean\n\tdraft: Drafted<AnySet, SetState>\n}\n\nconst DraftSet = (function(_super) {\n\tif (!_super) {\n\t\t/* istanbul ignore next */\n\t\tthrow new Error(\"Set is not polyfilled\")\n\t}\n\t__extends(DraftSet, _super)\n\t// Create class manually, cause #502\n\tfunction DraftSet(this: any, target: AnySet, parent?: ImmerState) {\n\t\tthis[DRAFT_STATE] = {\n\t\t\ttype: ProxyType.Set,\n\t\t\tparent,\n\t\t\tscope: parent ? parent.scope : ImmerScope.current!,\n\t\t\tmodified: false,\n\t\t\tfinalized: false,\n\t\t\tcopy: undefined,\n\t\t\tbase: target,\n\t\t\tdraft: this,\n\t\t\tdrafts: new Map(),\n\t\t\trevoked: false,\n\t\t\tisManual: false\n\t\t}\n\t\treturn this\n\t}\n\tconst p = DraftSet.prototype\n\n\tObject.defineProperty(p, \"size\", {\n\t\tget: function() {\n\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t},\n\t\tenumerable: true,\n\t\tconfigurable: true\n\t})\n\n\tp.has = function(value: any): boolean {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\tif (!state.copy) {\n\t\t\treturn state.base.has(value)\n\t\t}\n\t\tif (state.copy.has(value)) return true\n\t\tif (state.drafts.has(value) && state.copy.has(state.drafts.get(value)))\n\t\t\treturn true\n\t\treturn false\n\t}\n\n\tp.add = function(value: any): any {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tif (state.copy) {\n\t\t\tstate.copy.add(value)\n\t\t} else if (!state.base.has(value)) {\n\t\t\tprepareCopy(state)\n\t\t\tstate.scope.immer.markChanged(state)\n\t\t\tstate.copy!.add(value)\n\t\t}\n\t\treturn this\n\t}\n\n\tp.delete = function(value: any): any {\n\t\tif (!this.has(value)) {\n\t\t\treturn false\n\t\t}\n\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tprepareCopy(state)\n\t\tstate.scope.immer.markChanged(state)\n\t\treturn (\n\t\t\tstate.copy!.delete(value) ||\n\t\t\t(state.drafts.has(value)\n\t\t\t\t? state.copy!.delete(state.drafts.get(value))\n\t\t\t\t: /* istanbul ignore next */ false)\n\t\t)\n\t}\n\n\tp.clear = function() {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tprepareCopy(state)\n\t\tstate.scope.immer.markChanged(state)\n\t\treturn state.copy!.clear()\n\t}\n\n\tp.values = function(): IterableIterator<any> {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tprepareCopy(state)\n\t\treturn state.copy!.values()\n\t}\n\n\tp.entries = function entries(): IterableIterator<[any, any]> {\n\t\tconst state = this[DRAFT_STATE]\n\t\tassertUnrevoked(state)\n\t\tprepareCopy(state)\n\t\treturn state.copy!.entries()\n\t}\n\n\tp.keys = function(): IterableIterator<any> {\n\t\treturn this.values()\n\t}\n\n\tp[iteratorSymbol] = function() {\n\t\treturn this.values()\n\t}\n\n\tp.forEach = function forEach(cb: any, thisArg?: any) {\n\t\tconst iterator = this.values()\n\t\tlet result = iterator.next()\n\t\twhile (!result.done) {\n\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\tresult = iterator.next()\n\t\t}\n\t}\n\n\treturn DraftSet\n})(Set)\n\nexport function proxySet<T extends AnySet>(\n\ttarget: T,\n\tparent?: ImmerState\n): T & {[DRAFT_STATE]: SetState} {\n\t// @ts-ignore\n\treturn new DraftSet(target, parent)\n}\n\nfunction prepareCopy(state: SetState) {\n\tif (!state.copy) {\n\t\t// create drafts for all entries to preserve insertion order\n\t\tstate.copy = new Set()\n\t\tstate.base.forEach(value => {\n\t\t\tif (isDraftable(value)) {\n\t\t\t\tconst draft = state.scope.immer.createProxy(value, state)\n\t\t\t\tstate.drafts.set(value, draft)\n\t\t\t\tstate.copy!.add(draft)\n\t\t\t} else {\n\t\t\t\tstate.copy!.add(value)\n\t\t\t}\n\t\t})\n\t}\n}\n","import {\n\tget,\n\teach,\n\thas,\n\tdie,\n\tgetArchtype,\n\tImmerState,\n\tPatch,\n\tProxyType,\n\tSetState,\n\tES5ArrayState,\n\tProxyArrayState,\n\tMapState,\n\tES5ObjectState,\n\tProxyObjectState,\n\tArchtype,\n\tisMap,\n\tisSet\n} from \"./internal\"\n\nexport type PatchPath = (string | number)[]\n\nexport function generatePatches(\n\tstate: ImmerState,\n\tbasePath: PatchPath,\n\tpatches: Patch[],\n\tinversePatches: Patch[]\n): void {\n\tswitch (state.type) {\n\t\tcase ProxyType.ProxyObject:\n\t\tcase ProxyType.ES5Object:\n\t\tcase ProxyType.Map:\n\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\tstate,\n\t\t\t\tbasePath,\n\t\t\t\tpatches,\n\t\t\t\tinversePatches\n\t\t\t)\n\t\tcase ProxyType.ES5Array:\n\t\tcase ProxyType.ProxyArray:\n\t\t\treturn generateArrayPatches(state, basePath, patches, inversePatches)\n\t\tcase ProxyType.Set:\n\t\t\treturn generateSetPatches(\n\t\t\t\t(state as any) as SetState,\n\t\t\t\tbasePath,\n\t\t\t\tpatches,\n\t\t\t\tinversePatches\n\t\t\t)\n\t}\n}\n\nfunction generateArrayPatches(\n\tstate: ES5ArrayState | ProxyArrayState,\n\tbasePath: PatchPath,\n\tpatches: Patch[],\n\tinversePatches: Patch[]\n) {\n\tlet {base, assigned, copy} = state\n\t/* istanbul ignore next */\n\tif (!copy) die()\n\n\t// Reduce complexity by ensuring `base` is never longer.\n\tif (copy.length < base.length) {\n\t\t// @ts-ignore\n\t\t;[base, copy] = [copy, base]\n\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t}\n\n\tconst delta = copy.length - base.length\n\n\t// Find the first replaced index.\n\tlet start = 0\n\twhile (base[start] === copy[start] && start < base.length) {\n\t\t++start\n\t}\n\n\t// Find the last replaced index. Search from the end to optimize splice patches.\n\tlet end = base.length\n\twhile (end > start && base[end - 1] === copy[end + delta - 1]) {\n\t\t--end\n\t}\n\n\t// Process replaced indices.\n\tfor (let i = start; i < end; ++i) {\n\t\tif (assigned[i] && copy[i] !== base[i]) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: \"replace\",\n\t\t\t\tpath,\n\t\t\t\tvalue: copy[i]\n\t\t\t})\n\t\t\tinversePatches.push({\n\t\t\t\top: \"replace\",\n\t\t\t\tpath,\n\t\t\t\tvalue: base[i]\n\t\t\t})\n\t\t}\n\t}\n\n\tconst replaceCount = patches.length\n\n\t// Process added indices.\n\tfor (let i = end + delta - 1; i >= end; --i) {\n\t\tconst path = basePath.concat([i])\n\t\tpatches[replaceCount + i - end] = {\n\t\t\top: \"add\",\n\t\t\tpath,\n\t\t\tvalue: copy[i]\n\t\t}\n\t\tinversePatches.push({\n\t\t\top: \"remove\",\n\t\t\tpath\n\t\t})\n\t}\n}\n\n// This is used for both Map objects and normal objects.\nfunction generatePatchesFromAssigned(\n\tstate: MapState | ES5ObjectState | ProxyObjectState,\n\tbasePath: PatchPath,\n\tpatches: Patch[],\n\tinversePatches: Patch[]\n) {\n\tconst {base, copy} = state\n\teach(state.assigned!, (key, assignedValue) => {\n\t\tconst origValue = get(base, key)\n\t\tconst value = get(copy!, key)\n\t\tconst op = !assignedValue ? \"remove\" : has(base, key) ? \"replace\" : \"add\"\n\t\tif (origValue === value && op === \"replace\") return\n\t\tconst path = basePath.concat(key as any)\n\t\tpatches.push(op === \"remove\" ? {op, path} : {op, path, value})\n\t\tinversePatches.push(\n\t\t\top === \"add\"\n\t\t\t\t? {op: \"remove\", path}\n\t\t\t\t: op === \"remove\"\n\t\t\t\t? {op: \"add\", path, value: origValue}\n\t\t\t\t: {op: \"replace\", path, value: origValue}\n\t\t)\n\t})\n}\n\nfunction generateSetPatches(\n\tstate: SetState,\n\tbasePath: PatchPath,\n\tpatches: Patch[],\n\tinversePatches: Patch[]\n) {\n\tlet {base, copy} = state\n\n\tlet i = 0\n\tbase.forEach(value => {\n\t\tif (!copy!.has(value)) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: \"remove\",\n\t\t\t\tpath,\n\t\t\t\tvalue\n\t\t\t})\n\t\t\tinversePatches.unshift({\n\t\t\t\top: \"add\",\n\t\t\t\tpath,\n\t\t\t\tvalue\n\t\t\t})\n\t\t}\n\t\ti++\n\t})\n\ti = 0\n\tcopy!.forEach(value => {\n\t\tif (!base.has(value)) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: \"add\",\n\t\t\t\tpath,\n\t\t\t\tvalue\n\t\t\t})\n\t\t\tinversePatches.unshift({\n\t\t\t\top: \"remove\",\n\t\t\t\tpath,\n\t\t\t\tvalue\n\t\t\t})\n\t\t}\n\t\ti++\n\t})\n}\n\nexport function applyPatches<T>(draft: T, patches: Patch[]): T {\n\tpatches.forEach(patch => {\n\t\tconst {path, op} = patch\n\n\t\t/* istanbul ignore next */\n\t\tif (!path.length) die()\n\n\t\tlet base: any = draft\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tbase = get(base, path[i])\n\t\t\tif (!base || typeof base !== \"object\")\n\t\t\t\tthrow new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\")) // prettier-ignore\n\t\t}\n\n\t\tconst type = getArchtype(base)\n\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\tconst key = path[path.length - 1]\n\t\tswitch (op) {\n\t\t\tcase \"replace\":\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\tthrow new Error('Sets cannot have \"replace\" patches.')\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t}\n\t\t\tcase \"add\":\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\treturn base.splice(key as any, 0, value)\n\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t}\n\t\t\tcase \"remove\":\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase Archtype.Array:\n\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\tcase Archtype.Map:\n\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\tcase Archtype.Set:\n\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Unsupported patch operation: \" + op)\n\t\t}\n\t})\n\n\treturn draft\n}\n\n// TODO: optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n// E.g. auto-draft when new objects from outside are assigned and modified?\n// (See failing test when deepClone just returns obj)\nfunction deepClonePatchValue<T>(obj: T): T\nfunction deepClonePatchValue(obj: any) {\n\tif (!obj || typeof obj !== \"object\") return obj\n\tif (Array.isArray(obj)) return obj.map(deepClonePatchValue)\n\tif (isMap(obj))\n\t\treturn new Map(\n\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t)\n\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\tconst cloned = Object.create(Object.getPrototypeOf(obj))\n\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\treturn cloned\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import {\n\tcreateES5Proxy,\n\twillFinalizeES5,\n\tmarkChangedES5,\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\teach,\n\tDrafted,\n\tisDraftable,\n\tImmerScope,\n\tprocessResult,\n\tNOTHING,\n\tmaybeFreeze,\n\tdie,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tapplyPatches,\n\tisMap,\n\tproxyMap,\n\tisSet,\n\tproxySet,\n\tcreateProxy,\n\tmarkChanged\n} from \"./internal\"\n\n/* istanbul ignore next */\nfunction verifyMinified() {}\n\nconst configDefaults = {\n\tuseProxies:\n\t\ttypeof Proxy !== \"undefined\" &&\n\t\ttypeof Proxy.revocable !== \"undefined\" &&\n\t\ttypeof Reflect !== \"undefined\",\n\tautoFreeze:\n\t\ttypeof process !== \"undefined\"\n\t\t\t? process.env.NODE_ENV !== \"production\"\n\t\t\t: /* istanbul ignore next */\n\t\t\t  verifyMinified.name === \"verifyMinified\",\n\tonAssign: null,\n\tonDelete: null,\n\tonCopy: null\n} as const\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport class Immer implements ProducersFns {\n\tuseProxies: boolean = false\n\tautoFreeze: boolean = false\n\tonAssign?: (state: ImmerState, prop: string | number, value: unknown) => void\n\tonDelete?: (state: ImmerState, prop: string | number) => void\n\tonCopy?: (state: ImmerState) => void\n\n\tconstructor(config?: {\n\t\tuseProxies?: boolean\n\t\tautoFreeze?: boolean\n\t\tonAssign?: (\n\t\t\tstate: ImmerState,\n\t\t\tprop: string | number,\n\t\t\tvalue: unknown\n\t\t) => void\n\t\tonDelete?: (state: ImmerState, prop: string | number) => void\n\t\tonCopy?: (state: ImmerState) => void\n\t}) {\n\t\teach(configDefaults, (key, value) => {\n\t\t\t// @ts-ignore\n\t\t\tthis[key] = config?.[key] ?? value\n\t\t})\n\t\tthis.setUseProxies(this.useProxies)\n\t\tthis.produce = this.produce.bind(this)\n\t\tthis.produceWithPatches = this.produceWithPatches.bind(this)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce(base: any, recipe?: any, patchListener?: any) {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\t// prettier-ignore\n\t\t{\n\t\t\tif (typeof recipe !== \"function\") {\n\t\t\t\tthrow new Error(\"The first or second argument to `produce` must be a function\")\n\t\t\t}\n\t\t\tif (patchListener !== undefined && typeof patchListener !== \"function\") {\n\t\t\t\tthrow new Error(\"The third argument to `produce` must be a function or undefined\")\n\t\t\t}\n\t\t}\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = ImmerScope.enter(this)\n\t\t\tconst proxy = this.createProxy(base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) scope.revoke()\n\t\t\t\telse scope.leave()\n\t\t\t}\n\t\t\tif (typeof Promise !== \"undefined\" && result instanceof Promise) {\n\t\t\t\treturn result.then(\n\t\t\t\t\tresult => {\n\t\t\t\t\t\tscope.usePatches(patchListener)\n\t\t\t\t\t\treturn processResult(this, result, scope)\n\t\t\t\t\t},\n\t\t\t\t\terror => {\n\t\t\t\t\t\tscope.revoke()\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t}\n\t\t\tscope.usePatches(patchListener)\n\t\t\treturn processResult(this, result, scope)\n\t\t} else {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === NOTHING) return undefined\n\t\t\tif (result === undefined) result = base\n\t\t\tmaybeFreeze(this, result, true)\n\t\t\treturn result\n\t\t}\n\t}\n\n\tproduceWithPatches(arg1: any, arg2?: any, arg3?: any): any {\n\t\tif (typeof arg1 === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => arg1(draft, ...args))\n\t\t}\n\t\t// non-curried form\n\t\t/* istanbul ignore next */\n\t\tif (arg3) die()\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst nextState = this.produce(arg1, arg2, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\t\treturn [nextState, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) {\n\t\t\tthrow new Error(\"First argument to `createDraft` must be a plain object, an array, or an immerable object\") // prettier-ignore\n\t\t}\n\t\tconst scope = ImmerScope.enter(this)\n\t\tconst proxy = this.createProxy(base, undefined)\n\t\tproxy[DRAFT_STATE].isManual = true\n\t\tscope.leave()\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && draft[DRAFT_STATE]\n\t\tif (!state || !state.isManual) {\n\t\t\tthrow new Error(\"First argument to `finishDraft` must be a draft returned by `createDraft`\") // prettier-ignore\n\t\t}\n\t\tif (state.finalized) {\n\t\t\tthrow new Error(\"The given draft is already finalized\") // prettier-ignore\n\t\t}\n\t\tconst {scope} = state\n\t\tscope.usePatches(patchListener)\n\t\treturn processResult(this, undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is disabled in production.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze = value\n\t}\n\n\t/**\n\t * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n\t * always faster than using ES5 proxies.\n\t *\n\t * By default, feature detection is used, so calling this is rarely necessary.\n\t */\n\tsetUseProxies(value: boolean) {\n\t\tthis.useProxies = value\n\t}\n\n\tapplyPatches(base: Objectish, patches: Patch[]) {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatches(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatches(draft, patches.slice(i + 1))\n\t\t)\n\t}\n\n\tcreateProxy<T extends Objectish>(\n\t\tvalue: T,\n\t\tparent?: ImmerState\n\t): Drafted<T, ImmerState> {\n\t\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\t\tconst draft: Drafted = isMap(value)\n\t\t\t? proxyMap(value, parent)\n\t\t\t: isSet(value)\n\t\t\t? proxySet(value, parent)\n\t\t\t: this.useProxies\n\t\t\t? createProxy(value, parent)\n\t\t\t: createES5Proxy(value, parent)\n\n\t\tconst scope = parent ? parent.scope : ImmerScope.current!\n\t\tscope.drafts.push(draft)\n\t\treturn draft\n\t}\n\n\twillFinalize(scope: ImmerScope, thing: any, isReplaced: boolean) {\n\t\tif (!this.useProxies) willFinalizeES5(scope, thing, isReplaced)\n\t}\n\n\tmarkChanged(state: ImmerState) {\n\t\tif (this.useProxies) {\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\tmarkChangedES5(state)\n\t\t}\n\t}\n}\n","import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\toriginal,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = immer.produce\nexport default produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\nexport const setAutoFreeze = immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\nexport const setUseProxies = immer.setUseProxies.bind(immer)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n"]},"metadata":{},"sourceType":"module"}