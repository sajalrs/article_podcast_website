{"ast":null,"code":"import React from 'react';\nimport Types from 'prop-types';\nimport SlateTypes from 'slate-prop-types';\nimport ImmutableTypes from 'react-immutable-proptypes';\nimport Debug from 'debug';\nimport warning from 'tiny-warning';\nimport { PathUtils, Value, Editor, Node } from 'slate';\nimport getWindow from 'get-window';\nimport isBackward from 'selection-is-backward';\nimport { IS_SAFARI, IS_IOS, IS_IE, IS_ANDROID, IS_FIREFOX, HAS_INPUT_EVENTS_LEVEL_2, IS_EDGE } from 'slate-dev-environment';\nimport throttle from 'lodash/throttle';\nimport omit from 'lodash/omit';\nimport { List } from 'immutable';\nimport Hotkeys from 'slate-hotkeys';\nimport ReactDOM from 'react-dom';\nimport Base64 from 'slate-base64-serializer';\nimport Plain from 'slate-plain-serializer';\nimport invariant from 'tiny-invariant';\nimport PlaceholderPlugin from 'slate-react-placeholder';\nimport memoizeOne from 'memoize-one';\n/**\n * Event handlers used by Slate plugins.\n *\n * @type {Array}\n */\n\nvar EVENT_HANDLERS = ['onBeforeInput', 'onBlur', 'onClick', 'onContextMenu', 'onCompositionEnd', 'onCompositionStart', 'onCopy', 'onCut', 'onDragEnd', 'onDragEnter', 'onDragExit', 'onDragLeave', 'onDragOver', 'onDragStart', 'onDrop', 'onInput', 'onFocus', 'onKeyDown', 'onKeyUp', 'onMouseDown', 'onMouseUp', 'onPaste', 'onSelect'];\n/**\n * Other handlers used by Slate plugins.\n *\n * @type {Array}\n */\n\nvar OTHER_HANDLERS = ['decorateNode', 'renderAnnotation', 'renderBlock', 'renderDecoration', 'renderDocument', 'renderEditor', 'renderInline', 'renderMark'];\n/**\n * DOM data attribute strings that refer to Slate concepts.\n *\n * @type {String}\n */\n\nvar DATA_ATTRS = {\n  EDITOR: 'data-slate-editor',\n  FRAGMENT: 'data-slate-fragment',\n  KEY: 'data-key',\n  LEAF: 'data-slate-leaf',\n  LENGTH: 'data-slate-length',\n  OBJECT: 'data-slate-object',\n  OFFSET_KEY: 'data-offset-key',\n  SPACER: 'data-slate-spacer',\n  STRING: 'data-slate-string',\n  TEXT: 'data-slate-object',\n  VOID: 'data-slate-void',\n  ZERO_WIDTH: 'data-slate-zero-width'\n};\n/**\n * DOM selector strings that refer to Slate concepts.\n *\n * @type {String}\n */\n\nvar SELECTORS = {\n  BLOCK: '[' + DATA_ATTRS.OBJECT + '=\"block\"]',\n  EDITOR: '[' + DATA_ATTRS.EDITOR + ']',\n  INLINE: '[' + DATA_ATTRS.OBJECT + '=\"inline\"]',\n  KEY: '[' + DATA_ATTRS.KEY + ']',\n  LEAF: '[' + DATA_ATTRS.LEAF + ']',\n  OBJECT: '[' + DATA_ATTRS.OBJECT + ']',\n  STRING: '[' + DATA_ATTRS.STRING + ']',\n  TEXT: '[' + DATA_ATTRS.OBJECT + '=\"text\"]',\n  VOID: '[' + DATA_ATTRS.VOID + ']',\n  ZERO_WIDTH: '[' + DATA_ATTRS.ZERO_WIDTH + ']'\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n/**\n * Offset key parser regex.\n *\n * @type {RegExp}\n */\n\n\nvar PARSER = /^([\\w-]+)(?::(\\d+))?$/;\n/**\n * Parse an offset key `string`.\n *\n * @param {String} string\n * @return {Object}\n */\n\nfunction parse(string) {\n  var matches = PARSER.exec(string);\n\n  if (!matches) {\n    throw new Error(\"Invalid offset key string \\\"\" + string + \"\\\".\");\n  }\n\n  var _matches = slicedToArray(matches, 3),\n      original = _matches[0],\n      key = _matches[1],\n      index = _matches[2]; // eslint-disable-line no-unused-vars\n\n\n  return {\n    key: key,\n    index: parseInt(index, 10)\n  };\n}\n/**\n * Stringify an offset key `object`.\n *\n * @param {Object} object\n *   @property {String} key\n *   @property {Number} index\n * @return {String}\n */\n\n\nfunction stringify(object) {\n  return object.key + \":\" + object.index;\n}\n/**\n * Export.\n *\n * @type {Object}\n */\n\n\nvar OffsetKey = {\n  parse: parse,\n  stringify: stringify\n};\n/**\n * Leaf strings with text in them.\n *\n * @type {Component}\n */\n\nvar TextString = function TextString(_ref) {\n  var _ref$text = _ref.text,\n      text = _ref$text === undefined ? '' : _ref$text,\n      _ref$isTrailing = _ref.isTrailing,\n      isTrailing = _ref$isTrailing === undefined ? false : _ref$isTrailing;\n  return React.createElement('span', defineProperty({}, DATA_ATTRS.STRING, true), text, isTrailing ? '\\n' : null);\n};\n/**\n * Leaf strings without text, render as zero-width strings.\n *\n * @type {Component}\n */\n\n\nvar ZeroWidthString = function ZeroWidthString(_ref3) {\n  var _ref4;\n\n  var _ref3$length = _ref3.length,\n      length = _ref3$length === undefined ? 0 : _ref3$length,\n      _ref3$isLineBreak = _ref3.isLineBreak,\n      isLineBreak = _ref3$isLineBreak === undefined ? false : _ref3$isLineBreak;\n  return React.createElement('span', (_ref4 = {}, defineProperty(_ref4, DATA_ATTRS.ZERO_WIDTH, isLineBreak ? 'n' : 'z'), defineProperty(_ref4, DATA_ATTRS.LENGTH, length), _ref4), '\\uFEFF', isLineBreak ? React.createElement('br', null) : null);\n};\n/**\n * Individual leaves in a text node with unique formatting.\n *\n * @type {Component}\n */\n\n\nvar Leaf = function Leaf(props) {\n  var _attrs;\n\n  var marks = props.marks,\n      annotations = props.annotations,\n      decorations = props.decorations,\n      node = props.node,\n      index = props.index,\n      offset = props.offset,\n      text = props.text,\n      editor = props.editor,\n      parent = props.parent,\n      block = props.block,\n      leaves = props.leaves;\n  var offsetKey = OffsetKey.stringify({\n    key: node.key,\n    index: index\n  });\n  var children = void 0;\n\n  if (editor.query('isVoid', parent)) {\n    // COMPAT: Render text inside void nodes with a zero-width space.\n    // So the node can contain selection but the text is not visible.\n    children = React.createElement(ZeroWidthString, {\n      length: parent.text.length\n    });\n  } else if (text === '' && parent.object === 'block' && parent.text === '' && parent.nodes.last() === node) {\n    // COMPAT: If this is the last text node in an empty block, render a zero-\n    // width space that will convert into a line break when copying and pasting\n    // to support expected plain text.\n    children = React.createElement(ZeroWidthString, {\n      isLineBreak: true\n    });\n  } else if (text === '') {\n    // COMPAT: If the text is empty, it's because it's on the edge of an inline\n    // node, so we render a zero-width space so that the selection can be\n    // inserted next to it still.\n    children = React.createElement(ZeroWidthString, null);\n  } else {\n    // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n    // so we need to add an extra trailing new lines to prevent that.\n    var lastText = block.getLastText();\n    var lastChar = text.charAt(text.length - 1);\n    var isLastText = node === lastText;\n    var isLastLeaf = index === leaves.size - 1;\n\n    if (isLastText && isLastLeaf && lastChar === '\\n') {\n      children = React.createElement(TextString, {\n        isTrailing: true,\n        text: text\n      });\n    } else {\n      children = React.createElement(TextString, {\n        text: text\n      });\n    }\n  }\n\n  var renderProps = {\n    editor: editor,\n    marks: marks,\n    annotations: annotations,\n    decorations: decorations,\n    node: node,\n    offset: offset,\n    text: text // COMPAT: Having the `data-` attributes on these leaf elements ensures that\n    // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\n    // contenteditable behaviors. (2019/05/08)\n\n  };\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = marks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var mark = _step.value;\n      var ret = editor.run('renderMark', _extends({}, renderProps, {\n        mark: mark,\n        children: children,\n        attributes: defineProperty({}, DATA_ATTRS.OBJECT, 'mark')\n      }));\n\n      if (ret) {\n        children = ret;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = decorations[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var decoration = _step2.value;\n      var ret = editor.run('renderDecoration', _extends({}, renderProps, {\n        decoration: decoration,\n        children: children,\n        attributes: defineProperty({}, DATA_ATTRS.OBJECT, 'decoration')\n      }));\n\n      if (ret) {\n        children = ret;\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = annotations[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var annotation = _step3.value;\n      var ret = editor.run('renderAnnotation', _extends({}, renderProps, {\n        annotation: annotation,\n        children: children,\n        attributes: defineProperty({}, DATA_ATTRS.OBJECT, 'annotation')\n      }));\n\n      if (ret) {\n        children = ret;\n      }\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  var attrs = (_attrs = {}, defineProperty(_attrs, DATA_ATTRS.LEAF, true), defineProperty(_attrs, DATA_ATTRS.OFFSET_KEY, offsetKey), _attrs);\n  return React.createElement('span', attrs, children);\n};\n/**\n * Prop types.\n *\n * @type {Object}\n */\n\n\nLeaf.propTypes = {\n  annotations: ImmutableTypes.list.isRequired,\n  block: SlateTypes.block.isRequired,\n  decorations: ImmutableTypes.list.isRequired,\n  editor: Types.object.isRequired,\n  index: Types.number.isRequired,\n  leaves: Types.object.isRequired,\n  marks: SlateTypes.marks.isRequired,\n  node: SlateTypes.node.isRequired,\n  offset: Types.number.isRequired,\n  parent: SlateTypes.node.isRequired,\n  text: Types.string.isRequired\n  /**\n   * A memoized version of `Leaf` that updates less frequently.\n   *\n   * @type {Component}\n   */\n\n};\nvar MemoizedLeaf = React.memo(Leaf, function (prev, next) {\n  return next.block === prev.block && next.index === prev.index && next.marks === prev.marks && next.parent === prev.parent && next.text === prev.text && next.annotations.equals(prev.annotations) && next.decorations.equals(prev.decorations);\n});\n/**\n * Text node.\n *\n * @type {Component}\n */\n\nvar Text = React.forwardRef(function (props, ref) {\n  var _ref;\n\n  var annotations = props.annotations,\n      block = props.block,\n      decorations = props.decorations,\n      node = props.node,\n      parent = props.parent,\n      editor = props.editor,\n      style = props.style;\n  var key = node.key;\n  var leaves = node.getLeaves(annotations, decorations);\n  var at = 0;\n  return React.createElement('span', _extends({\n    ref: ref,\n    style: style\n  }, (_ref = {}, defineProperty(_ref, DATA_ATTRS.OBJECT, node.object), defineProperty(_ref, DATA_ATTRS.KEY, key), _ref)), leaves.map(function (leaf, index) {\n    var text = leaf.text;\n    var offset = at;\n    at += text.length;\n    return React.createElement(MemoizedLeaf, {\n      key: node.key + '-' + index,\n      block: block,\n      editor: editor,\n      index: index,\n      annotations: leaf.annotations,\n      decorations: leaf.decorations,\n      marks: leaf.marks,\n      node: node,\n      offset: offset,\n      parent: parent,\n      leaves: leaves,\n      text: text\n    });\n  }));\n});\n/**\n * Prop types.\n *\n * @type {Object}\n */\n\nText.propTypes = {\n  annotations: ImmutableTypes.map.isRequired,\n  block: SlateTypes.block,\n  decorations: ImmutableTypes.list.isRequired,\n  editor: Types.object.isRequired,\n  node: SlateTypes.node.isRequired,\n  parent: SlateTypes.node.isRequired,\n  style: Types.object\n  /**\n   * A memoized version of `Text` that updates less frequently.\n   *\n   * @type {Component}\n   */\n\n};\nvar MemoizedText = React.memo(Text, function (prev, next) {\n  return (// PERF: There are cases where it will have\n    // changed, but it's properties will be exactly the same (eg. copy-paste)\n    // which this won't catch. But that's rare and not a drag on performance, so\n    // for simplicity we just let them through.\n    next.node === prev.node && // If the node parent is a block node, and it was the last child of the\n    // block, re-render to cleanup extra `\\n`.\n    next.parent.object === 'block' && prev.parent.nodes.last() === prev.node && next.parent.nodes.last() !== next.node && // The formatting hasn't changed.\n    next.annotations.equals(prev.annotations) && next.decorations.equals(prev.decorations)\n  );\n});\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug = Debug('slate:void');\n/**\n * Void.\n *\n * @type {Component}\n */\n\nvar Void = function (_React$Component) {\n  inherits(Void, _React$Component);\n\n  function Void() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, Void);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Void.__proto__ || Object.getPrototypeOf(Void)).call.apply(_ref, [this].concat(args))), _this), _initialiseProps.call(_this), _temp), possibleConstructorReturn(_this, _ret);\n  }\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n\n  createClass(Void, [{\n    key: 'render',\n\n    /**\n     * Render.\n     *\n     * @return {Element}\n     */\n    value: function render() {\n      var _attrs;\n\n      var props = this.props;\n      var children = props.children,\n          node = props.node,\n          readOnly = props.readOnly;\n      var Tag = node.object === 'block' ? 'div' : 'span';\n      var style = {\n        height: '0',\n        color: 'transparent',\n        outline: 'none',\n        position: 'absolute'\n      };\n      var spacerAttrs = defineProperty({}, DATA_ATTRS.SPACER, true);\n      var spacer = React.createElement(Tag, _extends({\n        style: style\n      }, spacerAttrs), this.renderText());\n      var content = React.createElement(Tag, {\n        contentEditable: readOnly ? null : false\n      }, children);\n      this.debug('render', {\n        props: props\n      });\n      var attrs = (_attrs = {}, defineProperty(_attrs, DATA_ATTRS.VOID, true), defineProperty(_attrs, DATA_ATTRS.KEY, node.key), _attrs);\n      return React.createElement(Tag, _extends({\n        contentEditable: readOnly || node.object === 'block' ? null : false\n      }, attrs), readOnly ? null : spacer, content);\n    }\n    /**\n     * Render the void node's text node, which will catch the cursor when it the\n     * void node is navigated to with the arrow keys.\n     *\n     * Having this text node there means the browser continues to manage the\n     * selection natively, so it keeps track of the right offset when moving\n     * across the block.\n     *\n     * @return {Element}\n     */\n\n  }]);\n  return Void;\n}(React.Component);\n/**\n * Export.\n *\n * @type {Component}\n */\n\n\nVoid.propTypes = {\n  block: SlateTypes.block,\n  children: Types.any.isRequired,\n  editor: Types.object.isRequired,\n  node: SlateTypes.node.isRequired,\n  parent: SlateTypes.node.isRequired,\n  readOnly: Types.bool.isRequired\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this2 = this;\n\n  this.debug = function (message) {\n    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    var node = _this2.props.node;\n    var key = node.key,\n        type = node.type;\n    var id = key + ' (' + type + ')';\n    debug.apply(undefined, [message, '' + id].concat(args));\n  };\n\n  this.renderText = function () {\n    var _props = _this2.props,\n        annotations = _props.annotations,\n        block = _props.block,\n        decorations = _props.decorations,\n        node = _props.node,\n        readOnly = _props.readOnly,\n        editor = _props.editor,\n        textRef = _props.textRef;\n    var child = node.getFirstText();\n    return React.createElement(MemoizedText, {\n      ref: textRef,\n      annotations: annotations,\n      block: node.object === 'block' ? node : block,\n      decorations: decorations,\n      editor: editor,\n      key: child.key,\n      node: child,\n      parent: node,\n      readOnly: readOnly\n    });\n  };\n};\n/**\n * Debug.\n *\n * @type {Function}\n */\n\n\nvar debug$1 = Debug('slate:node');\n/**\n * Node.\n *\n * @type {Component}\n */\n\nvar Node$1 = function (_React$Component) {\n  inherits(Node$$1, _React$Component);\n\n  function Node$$1() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, Node$$1);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Node$$1.__proto__ || Object.getPrototypeOf(Node$$1)).call.apply(_ref, [this].concat(args))), _this), _initialiseProps$1.call(_this), _temp), possibleConstructorReturn(_this, _ret);\n  }\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Temporary values.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * A ref for the contenteditable DOM node.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n\n  createClass(Node$$1, [{\n    key: 'shouldComponentUpdate',\n\n    /**\n     * Should the node update?\n     *\n     * @param {Object} nextProps\n     * @param {Object} value\n     * @return {Boolean}\n     */\n    value: function shouldComponentUpdate(nextProps) {\n      var props = this.props;\n      var editor = props.editor;\n      var shouldUpdate = editor.run('shouldNodeComponentUpdate', props, nextProps);\n      var n = nextProps;\n      var p = props; // If the `Component` has a custom logic to determine whether the component\n      // needs to be updated or not, return true if it returns true. If it returns\n      // false, we need to ignore it, because it shouldn't be allowed it.\n\n      if (shouldUpdate != null) {\n        warning(false, 'As of slate-react@0.22 the `shouldNodeComponentUpdate` middleware is deprecated. You can pass specific values down the tree using React\\'s built-in \"context\" construct instead.');\n\n        if (shouldUpdate) {\n          return true;\n        }\n\n        warning(shouldUpdate !== false, \"Returning false in `shouldNodeComponentUpdate` does not disable Slate's internal `shouldComponentUpdate` logic. If you want to prevent updates, use React's `shouldComponentUpdate` instead.\");\n      } // If the `readOnly` status has changed, re-render in case there is any\n      // user-land logic that depends on it, like nested editable contents.\n\n\n      if (n.readOnly !== p.readOnly) {\n        return true;\n      } // If the node has changed, update. PERF: There are cases where it will have\n      // changed, but it's properties will be exactly the same (eg. copy-paste)\n      // which this won't catch. But that's rare and not a drag on performance, so\n      // for simplicity we just let them through.\n\n\n      if (n.node !== p.node) {\n        return true;\n      } // If the selection value of the node or of some of its children has changed,\n      // re-render in case there is any user-land logic depends on it to render.\n      // if the node is selected update it, even if it was already selected: the\n      // selection value of some of its children could have been changed and they\n      // need to be rendered again.\n\n\n      if (!n.selection && p.selection || n.selection && !p.selection || n.selection && p.selection && !n.selection.equals(p.selection)) {\n        return true;\n      } // If the annotations have changed, update.\n\n\n      if (!n.annotations.equals(p.annotations)) {\n        return true;\n      } // If the decorations have changed, update.\n\n\n      if (!n.decorations.equals(p.decorations)) {\n        return true;\n      } // Otherwise, don't update.\n\n\n      return false;\n    }\n    /**\n     * Render.\n     *\n     * @return {Element}\n     */\n\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this,\n          _attributes;\n\n      this.debug('render', this);\n      var _props = this.props,\n          annotations = _props.annotations,\n          block = _props.block,\n          decorations = _props.decorations,\n          editor = _props.editor,\n          node = _props.node,\n          parent = _props.parent,\n          readOnly = _props.readOnly,\n          selection = _props.selection;\n      var newDecorations = node.getDecorations(editor);\n      var children = node.nodes.toArray().map(function (child, i) {\n        var Component = child.object === 'text' ? MemoizedText : Node$$1;\n        var sel = selection && getRelativeRange(node, i, selection);\n        var decs = newDecorations.concat(decorations).map(function (d) {\n          return getRelativeRange(node, i, d);\n        }).filter(function (d) {\n          return d;\n        });\n        var anns = annotations.map(function (a) {\n          return getRelativeRange(node, i, a);\n        }).filter(function (a) {\n          return a;\n        });\n        return React.createElement(Component, {\n          block: node.object === 'block' ? node : block,\n          editor: editor,\n          annotations: anns,\n          decorations: decs,\n          selection: sel,\n          key: child.key,\n          node: child,\n          parent: node,\n          readOnly: readOnly // COMPAT: We use this map of refs to lookup a DOM node down the\n          // tree of components by path.\n          ,\n          ref: function ref(_ref2) {\n            if (_ref2) {\n              _this2.tmp.nodeRefs[i] = _ref2;\n            } else {\n              delete _this2.tmp.nodeRefs[i];\n            }\n          }\n        });\n      }); // Attributes that the developer must mix into the element in their\n      // custom node renderer component.\n\n      var attributes = (_attributes = {}, defineProperty(_attributes, DATA_ATTRS.OBJECT, node.object), defineProperty(_attributes, DATA_ATTRS.KEY, node.key), defineProperty(_attributes, 'ref', this.ref), _attributes); // If it's a block node with inline children, add the proper `dir` attribute\n      // for text direction.\n\n      if (node.isLeafBlock()) {\n        var direction = node.getTextDirection();\n        if (direction === 'rtl') attributes.dir = 'rtl';\n      }\n\n      var render = void 0;\n\n      if (node.object === 'block') {\n        render = 'renderBlock';\n      } else if (node.object === 'document') {\n        render = 'renderDocument';\n      } else if (node.object === 'inline') {\n        render = 'renderInline';\n      }\n\n      var element = editor.run(render, {\n        attributes: attributes,\n        children: children,\n        editor: editor,\n        isFocused: !!selection && selection.isFocused,\n        isSelected: !!selection,\n        node: node,\n        parent: parent,\n        readOnly: readOnly\n      });\n      return editor.isVoid(node) ? React.createElement(Void, _extends({}, this.props, {\n        textRef: function textRef(ref) {\n          if (ref) {\n            _this2.tmp.nodeRefs[0] = ref;\n          } else {\n            delete _this2.tmp.nodeRefs[0];\n          }\n        }\n      }), element) : element;\n    }\n  }]);\n  return Node$$1;\n}(React.Component);\n/**\n * Return a `range` relative to a child at `index`.\n *\n * @param {Range} range\n * @param {Number} index\n * @return {Range}\n */\n\n\nNode$1.propTypes = {\n  annotations: ImmutableTypes.map.isRequired,\n  block: SlateTypes.block,\n  decorations: ImmutableTypes.list.isRequired,\n  editor: Types.object.isRequired,\n  node: SlateTypes.node.isRequired,\n  parent: SlateTypes.node,\n  readOnly: Types.bool.isRequired,\n  selection: SlateTypes.selection\n};\n\nvar _initialiseProps$1 = function _initialiseProps() {\n  var _this3 = this;\n\n  this.tmp = {\n    nodeRefs: {}\n  };\n  this.ref = React.createRef();\n\n  this.debug = function (message) {\n    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    var node = _this3.props.node;\n    var key = node.key,\n        type = node.type;\n    debug$1.apply(undefined, [message, key + ' (' + type + ')'].concat(args));\n  };\n};\n\nfunction getRelativeRange(node, index, range) {\n  if (range.isUnset) {\n    return null;\n  }\n\n  var child = node.nodes.get(index);\n  var _range = range,\n      start = _range.start,\n      end = _range.end;\n  var _start = start,\n      startPath = _start.path;\n  var _end = end,\n      endPath = _end.path;\n  var startIndex = startPath.first();\n  var endIndex = endPath.first();\n\n  if (startIndex === index) {\n    start = start.setPath(startPath.rest());\n  } else if (startIndex < index && index <= endIndex) {\n    if (child.object === 'text') {\n      start = start.moveTo(PathUtils.create([index]), 0).setKey(child.key);\n    } else {\n      var _child$texts = child.texts(),\n          _child$texts2 = slicedToArray(_child$texts, 1),\n          first = _child$texts2[0];\n\n      var _first = slicedToArray(first, 2),\n          firstNode = _first[0],\n          firstPath = _first[1];\n\n      start = start.moveTo(firstPath, 0).setKey(firstNode.key);\n    }\n  } else {\n    start = null;\n  }\n\n  if (endIndex === index) {\n    end = end.setPath(endPath.rest());\n  } else if (startIndex <= index && index < endIndex) {\n    if (child.object === 'text') {\n      var length = child.text.length;\n      end = end.moveTo(PathUtils.create([index]), length).setKey(child.key);\n    } else {\n      var _child$texts3 = child.texts({\n        direction: 'backward'\n      }),\n          _child$texts4 = slicedToArray(_child$texts3, 1),\n          last = _child$texts4[0];\n\n      var _last = slicedToArray(last, 2),\n          lastNode = _last[0],\n          lastPath = _last[1];\n\n      end = end.moveTo(lastPath, lastNode.text.length).setKey(lastNode.key);\n    }\n  } else {\n    end = null;\n  }\n\n  if (!start || !end) {\n    return null;\n  }\n\n  range = range.setAnchor(start);\n  range = range.setFocus(end);\n  return range;\n}\n/**\n * CSS overflow values that would cause scrolling.\n *\n * @type {Array}\n */\n\n\nvar OVERFLOWS = ['auto', 'overlay', 'scroll'];\n/**\n * Detect whether we are running IOS version 11\n */\n\nvar IS_IOS_11 = IS_IOS && !!window.navigator.userAgent.match(/os 11_/i);\n/**\n * Find the nearest parent with scrolling, or window.\n *\n * @param {el} Element\n */\n\nfunction findScrollContainer(el, window) {\n  var parent = el.parentNode;\n  var scroller = void 0;\n\n  while (!scroller) {\n    if (!parent.parentNode) break;\n    var style = window.getComputedStyle(parent);\n    var overflowY = style.overflowY;\n\n    if (OVERFLOWS.includes(overflowY)) {\n      scroller = parent;\n      break;\n    }\n\n    parent = parent.parentNode;\n  } // COMPAT: Because Chrome does not allow doucment.body.scrollTop, we're\n  // assuming that window.scrollTo() should be used if the scrollable element\n  // turns out to be document.body or document.documentElement. This will work\n  // unless body is intentionally set to scrollable by restricting its height\n  // (e.g. height: 100vh).\n\n\n  if (!scroller) {\n    return window.document.body;\n  }\n\n  return scroller;\n}\n/**\n * Scroll the current selection's focus point into view if needed.\n *\n * @param {Selection} selection\n */\n\n\nfunction scrollToSelection(selection) {\n  if (IS_IOS_11) return;\n  if (!selection.anchorNode) return;\n  var window = getWindow(selection.anchorNode);\n  var scroller = findScrollContainer(selection.anchorNode, window);\n  var isWindow = scroller === window.document.body || scroller === window.document.documentElement;\n  var backward = isBackward(selection);\n  var range = selection.getRangeAt(0).cloneRange();\n  range.collapse(backward);\n  var cursorRect = range.getBoundingClientRect(); // COMPAT: range.getBoundingClientRect() returns 0s in Safari when range is\n  // collapsed. Expanding the range by 1 is a relatively effective workaround\n  // for vertical scroll, although horizontal may be off by 1 character.\n  // https://bugs.webkit.org/show_bug.cgi?id=138949\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=435438\n\n  if (IS_SAFARI) {\n    if (range.collapsed && cursorRect.top === 0 && cursorRect.height === 0) {\n      if (range.startOffset === 0) {\n        range.setEnd(range.endContainer, 1);\n      } else {\n        range.setStart(range.startContainer, range.startOffset - 1);\n      }\n\n      cursorRect = range.getBoundingClientRect();\n\n      if (cursorRect.top === 0 && cursorRect.height === 0) {\n        if (range.getClientRects().length) {\n          cursorRect = range.getClientRects()[0];\n        }\n      }\n    }\n  }\n\n  var width = void 0;\n  var height = void 0;\n  var yOffset = void 0;\n  var xOffset = void 0;\n  var scrollerTop = 0;\n  var scrollerLeft = 0;\n  var scrollerBordersY = 0;\n  var scrollerBordersX = 0;\n  var scrollerPaddingTop = 0;\n  var scrollerPaddingBottom = 0;\n  var scrollerPaddingLeft = 0;\n  var scrollerPaddingRight = 0;\n\n  if (isWindow) {\n    var innerWidth = window.innerWidth,\n        innerHeight = window.innerHeight,\n        pageYOffset = window.pageYOffset,\n        pageXOffset = window.pageXOffset;\n    width = innerWidth;\n    height = innerHeight;\n    yOffset = pageYOffset;\n    xOffset = pageXOffset;\n  } else {\n    var offsetWidth = scroller.offsetWidth,\n        offsetHeight = scroller.offsetHeight,\n        scrollTop = scroller.scrollTop,\n        scrollLeft = scroller.scrollLeft;\n\n    var _window$getComputedSt = window.getComputedStyle(scroller),\n        borderTopWidth = _window$getComputedSt.borderTopWidth,\n        borderBottomWidth = _window$getComputedSt.borderBottomWidth,\n        borderLeftWidth = _window$getComputedSt.borderLeftWidth,\n        borderRightWidth = _window$getComputedSt.borderRightWidth,\n        paddingTop = _window$getComputedSt.paddingTop,\n        paddingBottom = _window$getComputedSt.paddingBottom,\n        paddingLeft = _window$getComputedSt.paddingLeft,\n        paddingRight = _window$getComputedSt.paddingRight;\n\n    var scrollerRect = scroller.getBoundingClientRect();\n    width = offsetWidth;\n    height = offsetHeight;\n    scrollerTop = scrollerRect.top + parseInt(borderTopWidth, 10);\n    scrollerLeft = scrollerRect.left + parseInt(borderLeftWidth, 10);\n    scrollerBordersY = parseInt(borderTopWidth, 10) + parseInt(borderBottomWidth, 10);\n    scrollerBordersX = parseInt(borderLeftWidth, 10) + parseInt(borderRightWidth, 10);\n    scrollerPaddingTop = parseInt(paddingTop, 10);\n    scrollerPaddingBottom = parseInt(paddingBottom, 10);\n    scrollerPaddingLeft = parseInt(paddingLeft, 10);\n    scrollerPaddingRight = parseInt(paddingRight, 10);\n    yOffset = scrollTop;\n    xOffset = scrollLeft;\n  }\n\n  var cursorTop = cursorRect.top + yOffset - scrollerTop;\n  var cursorLeft = cursorRect.left + xOffset - scrollerLeft;\n  var x = xOffset;\n  var y = yOffset;\n\n  if (cursorLeft < xOffset) {\n    // selection to the left of viewport\n    x = cursorLeft - scrollerPaddingLeft;\n  } else if (cursorLeft + cursorRect.width + scrollerBordersX > xOffset + width) {\n    // selection to the right of viewport\n    x = cursorLeft + scrollerBordersX + scrollerPaddingRight - width;\n  }\n\n  if (cursorTop < yOffset) {\n    // selection above viewport\n    y = cursorTop - scrollerPaddingTop;\n  } else if (cursorTop + cursorRect.height + scrollerBordersY > yOffset + height) {\n    // selection below viewport\n    y = cursorTop + scrollerBordersY + scrollerPaddingBottom + cursorRect.height - height;\n  }\n\n  if (isWindow) {\n    window.scrollTo(x, y);\n  } else {\n    scroller.scrollTop = y;\n    scroller.scrollLeft = x;\n  }\n}\n/**\n * Cross-browser remove all ranges from a `domSelection`.\n *\n * @param {Selection} domSelection\n */\n\n\nfunction removeAllRanges(domSelection) {\n  // COMPAT: In IE 11, if the selection contains nested tables, then\n  // `removeAllRanges` will throw an error.\n  if (IS_IE) {\n    var range = window.document.body.createTextRange();\n    range.collapse();\n    range.select();\n  } else {\n    domSelection.removeAllRanges();\n  }\n}\n\nvar FIREFOX_NODE_TYPE_ACCESS_ERROR = /Permission denied to access property \"nodeType\"/;\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug$2 = Debug('slate:content');\n/**\n * Separate debug to easily see when the DOM has updated either by render or\n * changing selection.\n *\n * @type {Function}\n */\n\ndebug$2.update = Debug('slate:update');\n/**\n * Content.\n *\n * @type {Component}\n */\n\nvar Content = function (_React$Component) {\n  inherits(Content, _React$Component);\n\n  function Content() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, Content);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Content.__proto__ || Object.getPrototypeOf(Content)).call.apply(_ref, [this].concat(args))), _this), _this.tmp = {\n      isUpdatingSelection: false,\n      nodeRef: React.createRef(),\n      nodeRefs: {},\n      contentKey: 0,\n      nativeSelection: {} // Native selection object stored to check if `onNativeSelectionChange` has triggered yet\n\n      /**\n       * A ref for the contenteditable DOM node.\n       *\n       * @type {Object}\n       */\n\n    }, _this.ref = React.createRef(), _this.setRef = function (el) {\n      _this.ref.current = el;\n      _this.props.editor.el = el;\n    }, _this.handlers = EVENT_HANDLERS.reduce(function (obj, handler) {\n      obj[handler] = function (event) {\n        return _this.onEvent(handler, event);\n      };\n\n      return obj;\n    }, {}), _this.updateSelection = function () {\n      var editor = _this.props.editor;\n      var value = editor.value;\n      var selection = value.selection;\n      var isBackward$$1 = selection.isBackward;\n      var window = getWindow(_this.ref.current);\n      var native = window.getSelection();\n      var activeElement = window.document.activeElement;\n\n      if (debug$2.update.enabled) {\n        debug$2.update('updateSelection', {\n          selection: selection.toJSON()\n        });\n      } // COMPAT: In Firefox, there's a but where `getSelection` can return `null`.\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=827585 (2018/11/07)\n\n\n      if (!native) {\n        return;\n      }\n\n      var rangeCount = native.rangeCount,\n          anchorNode = native.anchorNode;\n      var updated = false; // If the Slate selection is blurred, but the DOM's active element is still\n      // the editor, we need to blur it.\n\n      if (selection.isBlurred && activeElement === _this.ref.current) {\n        _this.ref.current.blur();\n\n        updated = true;\n      } // If the Slate selection is unset, but the DOM selection has a range\n      // selected in the editor, we need to remove the range.\n      // However we should _not_ remove the range if the selection as\n      // reported by `getSelection` is not equal to `this.tmp.nativeSelection`\n      // as this suggests `onNativeSelectionChange` has not triggered yet (which can occur in Firefox)\n      // See: https://github.com/ianstormtaylor/slate/pull/2995\n\n\n      var propsToCompare = ['anchorNode', 'anchorOffset', 'focusNode', 'focusOffset', 'isCollapsed', 'rangeCount', 'type'];\n      var selectionsEqual = true;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = propsToCompare[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var prop = _step.value;\n\n          if (_this.tmp.nativeSelection[prop] !== native[prop]) {\n            selectionsEqual = false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (selection.isUnset && rangeCount && _this.isInEditor(anchorNode) && selectionsEqual) {\n        removeAllRanges(native);\n        updated = true;\n      } // If the Slate selection is focused, but the DOM's active element is not\n      // the editor, we need to focus it. We prevent scrolling because we handle\n      // scrolling to the correct selection.\n\n\n      if (selection.isFocused && activeElement !== _this.ref.current) {\n        _this.ref.current.focus({\n          preventScroll: true\n        });\n\n        updated = true;\n      } // Otherwise, figure out which DOM nodes should be selected...\n\n\n      if (selection.isFocused && selection.isSet) {\n        var current = !!native.rangeCount && native.getRangeAt(0);\n        var range = editor.findDOMRange(selection);\n\n        if (!range) {\n          warning(false, 'Unable to find a native DOM range from the current selection.');\n          return;\n        }\n\n        var startContainer = range.startContainer,\n            startOffset = range.startOffset,\n            endContainer = range.endContainer,\n            endOffset = range.endOffset; // If the new range matches the current selection, there is nothing to fix.\n        // COMPAT: The native `Range` object always has it's \"start\" first and \"end\"\n        // last in the DOM. It has no concept of \"backwards/forwards\", so we have\n        // to check both orientations here. (2017/10/31)\n\n        if (current) {\n          if (startContainer === current.startContainer && startOffset === current.startOffset && endContainer === current.endContainer && endOffset === current.endOffset || startContainer === current.endContainer && startOffset === current.endOffset && endContainer === current.startContainer && endOffset === current.startOffset) {\n            return;\n          }\n        } // Otherwise, set the `isUpdatingSelection` flag and update the selection.\n\n\n        updated = true;\n        _this.tmp.isUpdatingSelection = true;\n        removeAllRanges(native); // COMPAT: IE 11 does not support `setBaseAndExtent`. (2018/11/07)\n\n        if (native.setBaseAndExtent) {\n          // COMPAT: Since the DOM range has no concept of backwards/forwards\n          // we need to check and do the right thing here.\n          if (isBackward$$1) {\n            native.setBaseAndExtent(range.endContainer, range.endOffset, range.startContainer, range.startOffset);\n          } else {\n            native.setBaseAndExtent(range.startContainer, range.startOffset, range.endContainer, range.endOffset);\n          }\n        } else {\n          native.addRange(range);\n        } // Only scroll to selection when a user action is performed\n\n\n        if (editor.userActionPerformed() === true) {\n          // Scroll to the selection, in case it's out of view.\n          scrollToSelection(native);\n        } // Then unset the `isUpdatingSelection` flag after a delay, to ensure that\n        // it is still set when selection-related events from updating it fire.\n\n\n        setTimeout(function () {\n          // COMPAT: In Firefox, it's not enough to create a range, you also need\n          // to focus the contenteditable element too. (2016/11/16)\n          if (IS_FIREFOX && _this.ref.current) {\n            _this.ref.current.focus();\n          }\n\n          _this.tmp.isUpdatingSelection = false;\n          debug$2.update('updateSelection:setTimeout', {\n            anchorOffset: window.getSelection().anchorOffset\n          });\n        });\n      }\n\n      if (updated && (debug$2.enabled || debug$2.update.enabled)) {\n        debug$2('updateSelection', {\n          selection: selection,\n          native: native,\n          activeElement: activeElement\n        });\n        debug$2.update('updateSelection:applied', {\n          selection: selection.toJSON(),\n          native: {\n            anchorOffset: native.anchorOffset,\n            focusOffset: native.focusOffset\n          }\n        });\n      }\n    }, _this.isInEditor = function (target) {\n      var el = void 0;\n\n      try {\n        // COMPAT: In Firefox, sometimes the node can be comment which doesn't\n        // have .closest and it crashes.\n        if (target.nodeType === 8) {\n          return false;\n        } // COMPAT: Text nodes don't have `isContentEditable` property. So, when\n        // `target` is a text node use its parent node for check.\n\n\n        el = target.nodeType === 3 ? target.parentNode : target;\n      } catch (err) {\n        // COMPAT: In Firefox, `target.nodeType` will throw an error if target is\n        // originating from an internal \"restricted\" element (e.g. a stepper\n        // arrow on a number input)\n        // see github.com/ianstormtaylor/slate/issues/1819\n        if (IS_FIREFOX && FIREFOX_NODE_TYPE_ACCESS_ERROR.test(err.message)) {\n          return false;\n        }\n\n        throw err;\n      }\n\n      return el.isContentEditable && (el === _this.ref.current || el.closest(SELECTORS.EDITOR) === _this.ref.current);\n    }, _this.onNativeSelectionChange = throttle(function (event) {\n      if (_this.props.readOnly) return;\n      var window = getWindow(event.target);\n      var activeElement = window.document.activeElement;\n      var native = window.getSelection();\n      debug$2.update('onNativeSelectionChange', {\n        anchorOffset: native.anchorOffset\n      });\n      if (activeElement !== _this.ref.current) return;\n      _this.tmp.nativeSelection = {\n        anchorNode: native.anchorNode,\n        anchorOffset: native.anchorOffset,\n        focusNode: native.focusNode,\n        focusOffset: native.focusOffset,\n        isCollapsed: native.isCollapsed,\n        rangeCount: native.rangeCount,\n        type: native.type\n      };\n\n      _this.props.onEvent('onSelect', event);\n    }, 100), _temp), possibleConstructorReturn(_this, _ret);\n  }\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n\n  createClass(Content, [{\n    key: 'componentDidCatch',\n\n    /**\n     * An error boundary. If there is a render error, we increment `errorKey`\n     * which is part of the container `key` which forces a re-render from\n     * scratch.\n     *\n     * @param {Error} error\n     * @param {String} info\n     */\n    value: function componentDidCatch(error, info) {\n      debug$2('componentDidCatch', {\n        error: error,\n        info: info\n      }); // The call to `setState` is required despite not setting a value.\n      // Without this call, React will not try to recreate the component tree.\n\n      this.setState({});\n    }\n    /**\n     * Temporary values.\n     *\n     * @type {Object}\n     */\n\n    /**\n     * Set both `this.ref` and `editor.el`\n     *\n     * @type {DOMElement}\n     */\n\n    /**\n     * Create a set of bound event handlers.\n     *\n     * @type {Object}\n     */\n\n  }, {\n    key: 'componentDidMount',\n\n    /**\n     * When the editor first mounts in the DOM we need to:\n     *\n     *   - Add native DOM event listeners.\n     *   - Update the selection, in case it starts focused.\n     */\n    value: function componentDidMount() {\n      var window = getWindow(this.ref.current);\n      window.document.addEventListener('selectionchange', this.onNativeSelectionChange); // COMPAT: Restrict scope of `beforeinput` to clients that support the\n      // Input Events Level 2 spec, since they are preventable events.\n\n      if (HAS_INPUT_EVENTS_LEVEL_2) {\n        this.ref.current.addEventListener('beforeinput', this.handlers.onBeforeInput);\n      }\n\n      this.updateSelection();\n      this.props.onEvent('onComponentDidMount');\n    }\n    /**\n     * When unmounting, remove DOM event listeners.\n     */\n\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      var window = getWindow(this.ref.current);\n\n      if (window) {\n        window.document.removeEventListener('selectionchange', this.onNativeSelectionChange);\n      }\n\n      if (HAS_INPUT_EVENTS_LEVEL_2) {\n        this.ref.current.removeEventListener('beforeinput', this.handlers.onBeforeInput);\n      }\n\n      this.props.onEvent('onComponentWillUnmount');\n    }\n    /**\n     * On update, update the selection.\n     */\n\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate() {\n      debug$2.update('componentDidUpdate');\n      this.updateSelection();\n      this.props.editor.clearUserActionPerformed();\n      this.props.onEvent('onComponentDidUpdate');\n    }\n    /**\n     * Update the native DOM selection to reflect the internal model.\n     */\n\n    /**\n     * Check if an event `target` is fired from within the contenteditable\n     * element. This should be false for edits happening in non-contenteditable\n     * children, such as void nodes and other nested Slate editors.\n     *\n     * @param {Element} target\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'onEvent',\n\n    /**\n     * On `event` with `handler`.\n     *\n     * @param {String} handler\n     * @param {Event} event\n     */\n    value: function onEvent(handler, event) {\n      debug$2('onEvent', handler);\n      var nativeEvent = event.nativeEvent || event;\n      var isUndoRedo = event.type === 'keydown' && (Hotkeys.isUndo(nativeEvent) || Hotkeys.isRedo(nativeEvent)); // Ignore `onBlur`, `onFocus` and `onSelect` events generated\n      // programmatically while updating selection.\n\n      if ((this.tmp.isUpdatingSelection || isUndoRedo) && (handler === 'onSelect' || handler === 'onBlur' || handler === 'onFocus')) {\n        return;\n      } // COMPAT: There are situations where a select event will fire with a new\n      // native selection that resolves to the same internal position. In those\n      // cases we don't need to trigger any changes, since our internal model is\n      // already up to date, but we do want to update the native selection again\n      // to make sure it is in sync. (2017/10/16)\n      //\n      // ANDROID: The updateSelection causes issues in Android when you are\n      // at the end of a block. The selection ends up to the left of the inserted\n      // character instead of to the right. This behavior continues even if\n      // you enter more than one character. (2019/01/03)\n\n\n      if (!IS_ANDROID && handler === 'onSelect') {\n        var editor = this.props.editor;\n        var value = editor.value;\n        var selection = value.selection;\n        var window = getWindow(event.target);\n        var domSelection = window.getSelection();\n        var range = editor.findRange(domSelection);\n\n        if (range && range.equals(selection.toRange())) {\n          this.updateSelection();\n          return;\n        }\n      } // Don't handle drag and drop events coming from embedded editors.\n\n\n      if (handler === 'onDragEnd' || handler === 'onDragEnter' || handler === 'onDragExit' || handler === 'onDragLeave' || handler === 'onDragOver' || handler === 'onDragStart' || handler === 'onDrop') {\n        var closest = event.target.closest(SELECTORS.EDITOR);\n\n        if (closest !== this.ref.current) {\n          return;\n        }\n      } // Some events require being in editable in the editor, so if the event\n      // target isn't, ignore them.\n\n\n      if (handler === 'onBeforeInput' || handler === 'onBlur' || handler === 'onCompositionEnd' || handler === 'onCompositionStart' || handler === 'onCopy' || handler === 'onCut' || handler === 'onFocus' || handler === 'onInput' || handler === 'onKeyDown' || handler === 'onKeyUp' || handler === 'onPaste' || handler === 'onSelect') {\n        if (!this.isInEditor(event.target)) {\n          return;\n        }\n      }\n\n      this.props.onEvent(handler, event);\n    }\n    /**\n     * On native `selectionchange` event, trigger the `onSelect` handler. This is\n     * needed to account for React's `onSelect` being non-standard and not firing\n     * until after a selection has been released. This causes issues in situations\n     * where another change happens while a selection is being made.\n     *\n     * @param {Event} event\n     */\n\n  }, {\n    key: 'render',\n\n    /**\n     * Render the editor content.\n     *\n     * @return {Element}\n     */\n    value: function render() {\n      var _data;\n\n      var props = this.props,\n          handlers = this.handlers;\n      var id = props.id,\n          className = props.className,\n          readOnly = props.readOnly,\n          editor = props.editor,\n          tabIndex = props.tabIndex,\n          role = props.role,\n          tagName = props.tagName,\n          spellCheck = props.spellCheck;\n      var value = editor.value;\n      var Container = tagName;\n      var document = value.document,\n          selection = value.selection;\n\n      var style = _extends({\n        // Prevent the default outline styles.\n        outline: 'none',\n        // Preserve adjacent whitespace and new lines.\n        whiteSpace: 'pre-wrap',\n        // Allow words to break if they are too long.\n        wordWrap: 'break-word'\n      }, readOnly ? {} : {\n        WebkitUserModify: 'read-write-plaintext-only'\n      }, props.style); // console.log('rerender content', this.tmp.contentKey, document.text)\n\n\n      debug$2('render', {\n        props: props\n      });\n      debug$2.update('render', this.tmp.contentKey, document.text);\n      this.props.onEvent('onRender');\n      var data = (_data = {}, defineProperty(_data, DATA_ATTRS.EDITOR, true), defineProperty(_data, DATA_ATTRS.KEY, document.key), _data);\n      var domProps = omit(this.props, Object.keys(Content.propTypes));\n      return React.createElement(Container, _extends({}, domProps, {\n        key: this.tmp.contentKey\n      }, handlers, data, {\n        ref: this.setRef,\n        contentEditable: readOnly ? null : true,\n        suppressContentEditableWarning: true,\n        id: id,\n        className: className,\n        autoCorrect: props.autoCorrect ? 'on' : 'off',\n        spellCheck: spellCheck,\n        style: style,\n        role: readOnly ? null : role || 'textbox',\n        tabIndex: tabIndex // COMPAT: The Grammarly Chrome extension works by changing the DOM out\n        // from under `contenteditable` elements, which leads to weird behaviors\n        // so we have to disable it like this. (2017/04/24)\n        // just the existence of the flag is disabling the extension irrespective of its value\n        ,\n        'data-gramm': domProps['data-gramm'] ? undefined : false\n      }), React.createElement(Node$1, {\n        annotations: value.annotations,\n        block: null,\n        decorations: List(),\n        editor: editor,\n        node: document,\n        parent: null,\n        readOnly: readOnly,\n        selection: selection,\n        ref: this.tmp.nodeRef\n      }));\n    }\n  }]);\n  return Content;\n}(React.Component);\n/**\n * Export.\n *\n * @type {Component}\n */\n\n\nContent.propTypes = {\n  autoCorrect: Types.bool.isRequired,\n  className: Types.string,\n  contentKey: Types.number,\n  editor: Types.object.isRequired,\n  id: Types.string,\n  onEvent: Types.func.isRequired,\n  readOnly: Types.bool.isRequired,\n  role: Types.string,\n  spellCheck: Types.bool.isRequired,\n  style: Types.object,\n  tabIndex: Types.number,\n  tagName: Types.string\n};\nContent.defaultProps = {\n  style: {},\n  tagName: 'div'\n};\n/**\n * Props that can be defined by plugins.\n *\n * @type {Array}\n */\n\nvar PROPS = [].concat(toConsumableArray(EVENT_HANDLERS), ['commands', 'decorateNode', 'queries', 'renderAnnotation', 'renderBlock', 'renderDecoration', 'renderDocument', 'renderEditor', 'renderInline', 'renderMark', 'schema']);\n/**\n * The top-level editor props in a plugin.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction EditorPropsPlugin() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var plugin = PROPS.reduce(function (memo, prop) {\n    if (prop in options) memo[prop] = options[prop];\n    return memo;\n  }, {});\n  return plugin;\n}\n/**\n * The default rendering behavior for the React plugin.\n *\n * @return {Object}\n */\n\n\nfunction Rendering() {\n  return {\n    decorateNode: function decorateNode() {\n      return [];\n    },\n    renderAnnotation: function renderAnnotation(_ref) {\n      var attributes = _ref.attributes,\n          children = _ref.children;\n      return React.createElement('span', attributes, children);\n    },\n    renderBlock: function renderBlock(_ref2) {\n      var attributes = _ref2.attributes,\n          children = _ref2.children;\n      return React.createElement('div', _extends({}, attributes, {\n        style: {\n          position: 'relative'\n        }\n      }), children);\n    },\n    renderDecoration: function renderDecoration(_ref3) {\n      var attributes = _ref3.attributes,\n          children = _ref3.children;\n      return React.createElement('span', attributes, children);\n    },\n    renderDocument: function renderDocument(_ref4) {\n      var children = _ref4.children;\n      return children;\n    },\n    renderEditor: function renderEditor(_ref5) {\n      var children = _ref5.children;\n      return children;\n    },\n    renderInline: function renderInline(_ref6) {\n      var attributes = _ref6.attributes,\n          children = _ref6.children;\n      return React.createElement('span', _extends({}, attributes, {\n        style: {\n          position: 'relative'\n        }\n      }), children);\n    },\n    renderMark: function renderMark(_ref7) {\n      var attributes = _ref7.attributes,\n          children = _ref7.children;\n      return React.createElement('span', attributes, children);\n    }\n  };\n}\n/**\n * A set of commands for the React plugin.\n *\n * @return {Object}\n */\n\n\nfunction CommandsPlugin() {\n  /**\n   * Takes a `node`, find the matching `domNode` and uses it to set the text\n   * in the `node`.\n   *\n   * @param {Editor} editor\n   * @param {Node} node\n   */\n  function reconcileNode(editor, node) {\n    var value = editor.value;\n    var document = value.document,\n        selection = value.selection;\n    var path = document.getPath(node.key);\n    var domElement = editor.findDOMNode(path);\n    var block = document.getClosestBlock(path); // Get text information\n\n    var text = node.text;\n    var domText = domElement.textContent;\n    var isLastNode = block.nodes.last() === node;\n    var lastChar = domText.charAt(domText.length - 1); // COMPAT: If this is the last leaf, and the DOM text ends in a new line,\n    // we will have added another new line in <Leaf>'s render method to account\n    // for browsers collapsing a single trailing new lines, so remove it.\n\n    if (isLastNode && lastChar === '\\n') {\n      domText = domText.slice(0, -1);\n    } // If the text is no different, abort.\n\n\n    if (text === domText) return;\n    var entire = selection.moveAnchorTo(path, 0).moveFocusTo(path, text.length);\n    entire = document.resolveRange(entire); // Change the current value to have the leaf's text replaced.\n\n    editor.insertTextAtRange(entire, domText, node.marks);\n    return;\n  }\n  /**\n   * Takes text from the `domNode` and uses it to set the text in the matching\n   * `node` in Slate.\n   *\n   * @param {Editor} editor\n   * @param {DOMNode} domNode\n   */\n\n\n  function reconcileDOMNode(editor, domNode) {\n    var domElement = domNode.parentElement.closest('[data-key]');\n    var node = editor.findNode(domElement);\n    editor.reconcileNode(node);\n  }\n\n  return {\n    commands: {\n      reconcileNode: reconcileNode,\n      reconcileDOMNode: reconcileDOMNode\n    }\n  };\n}\n/**\n * A set of queries for the React plugin.\n *\n * @return {Object}\n */\n\n\nfunction QueriesPlugin() {\n  /**\n   * Find the native DOM element for a node at `path`.\n   *\n   * @param {Editor} editor\n   * @param {Array|List} path\n   * @return {DOMNode|Null}\n   */\n  function findDOMNode(editor, path) {\n    path = PathUtils.create(path);\n    var content = editor.tmp.contentRef.current;\n\n    if (!content) {\n      return null;\n    }\n\n    if (!path.size) {\n      return content.ref.current || null;\n    }\n\n    var search = function search(instance, p) {\n      if (!instance) {\n        return null;\n      }\n\n      if (!p.size) {\n        if (instance.ref) {\n          return instance.ref.current || null;\n        } else {\n          return instance || null;\n        }\n      }\n\n      var index = p.first();\n      var rest = p.rest();\n      var ref = instance.tmp.nodeRefs[index];\n      return search(ref, rest);\n    };\n\n    var document = content.tmp.nodeRef.current;\n    var el = search(document, path);\n    return el;\n  }\n  /**\n   * Find a native DOM selection point from a Slate `point`.\n   *\n   * @param {Editor} editor\n   * @param {Point} point\n   * @return {Object|Null}\n   */\n\n\n  function findDOMPoint(editor, point) {\n    var el = editor.findDOMNode(point.path);\n    var start = 0;\n\n    if (!el) {\n      return null;\n    } // For each leaf, we need to isolate its content, which means filtering to its\n    // direct text and zero-width spans. (We have to filter out any other siblings\n    // that may have been rendered alongside them.)\n\n\n    var texts = Array.from(el.querySelectorAll(SELECTORS.STRING + ', ' + SELECTORS.ZERO_WIDTH));\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = texts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var text = _step.value;\n        var node = text.childNodes[0];\n        var domLength = node.textContent.length;\n        var slateLength = domLength;\n\n        if (text.hasAttribute(DATA_ATTRS.LENGTH)) {\n          slateLength = parseInt(text.getAttribute(DATA_ATTRS.LENGTH), 10);\n        }\n\n        var end = start + slateLength;\n\n        if (point.offset <= end) {\n          var offset = Math.min(domLength, Math.max(0, point.offset - start));\n          return {\n            node: node,\n            offset: offset\n          };\n        }\n\n        start = end;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Find a native DOM range from a Slate `range`.\n   *\n   * @param {Editor} editor\n   * @param {Range} range\n   * @return {DOMRange|Null}\n   */\n\n\n  function findDOMRange(editor, range) {\n    var anchor = range.anchor,\n        focus = range.focus,\n        isBackward$$1 = range.isBackward,\n        isCollapsed = range.isCollapsed;\n    var domAnchor = editor.findDOMPoint(anchor);\n    var domFocus = isCollapsed ? domAnchor : editor.findDOMPoint(focus);\n\n    if (!domAnchor || !domFocus) {\n      return null;\n    }\n\n    var window = getWindow(domAnchor.node);\n    var r = window.document.createRange();\n    var start = isBackward$$1 ? domFocus : domAnchor;\n    var end = isBackward$$1 ? domAnchor : domFocus;\n    r.setStart(start.node, start.offset);\n    r.setEnd(end.node, end.offset);\n    return r;\n  }\n  /**\n   * Find a Slate node from a native DOM `element`.\n   *\n   * @param {Editor} editor\n   * @param {Element} element\n   * @return {List|Null}\n   */\n\n\n  function findNode(editor, element) {\n    var path = editor.findPath(element);\n\n    if (!path) {\n      return null;\n    }\n\n    var value = editor.value;\n    var document = value.document;\n    var node = document.getNode(path);\n    return node;\n  }\n  /**\n   * Get the target range from a DOM `event`.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @return {Range}\n   */\n\n\n  function findEventRange(editor, event) {\n    if (event.nativeEvent) {\n      event = event.nativeEvent;\n    }\n\n    var _event = event,\n        x = _event.clientX,\n        y = _event.clientY,\n        target = _event.target;\n    if (x == null || y == null) return null;\n    var value = editor.value;\n    var document = value.document;\n    var path = editor.findPath(event.target);\n    if (!path) return null;\n    var node = document.getNode(path); // If the drop target is inside a void node, move it into either the next or\n    // previous node, depending on which side the `x` and `y` coordinates are\n    // closest to.\n\n    if (editor.isVoid(node)) {\n      var rect = target.getBoundingClientRect();\n      var isPrevious = node.object === 'inline' ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\n\n      var _range = document.createRange();\n\n      var move = isPrevious ? 'moveToEndOfNode' : 'moveToStartOfNode';\n      var entry = document[isPrevious ? 'getPreviousText' : 'getNextText'](path);\n\n      if (entry) {\n        return _range[move](entry);\n      }\n\n      return null;\n    } // Else resolve a range from the caret position where the drop occured.\n\n\n    var window = getWindow(target);\n    var native = void 0; // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n\n    if (window.document.caretRangeFromPoint) {\n      native = window.document.caretRangeFromPoint(x, y);\n    } else if (window.document.caretPositionFromPoint) {\n      var position = window.document.caretPositionFromPoint(x, y);\n      native = window.document.createRange();\n      native.setStart(position.offsetNode, position.offset);\n      native.setEnd(position.offsetNode, position.offset);\n    } else if (window.document.body.createTextRange) {\n      // COMPAT: In IE, `caretRangeFromPoint` and\n      // `caretPositionFromPoint` don't exist. (2018/07/11)\n      native = window.document.body.createTextRange();\n\n      try {\n        native.moveToPoint(x, y);\n      } catch (error) {\n        // IE11 will raise an `unspecified error` if `moveToPoint` is\n        // called during a dropEvent.\n        return null;\n      }\n    } // Resolve a Slate range from the DOM range.\n\n\n    var range = editor.findRange(native);\n    return range;\n  }\n  /**\n   * Find the path of a native DOM `element` by searching React refs.\n   *\n   * @param {Editor} editor\n   * @param {Element} element\n   * @return {List|Null}\n   */\n\n\n  function findPath(editor, element) {\n    var content = editor.tmp.contentRef.current;\n    var nodeElement = element; // If element does not have a key, it is likely a string or\n    // mark, return the closest parent Node that can be looked up.\n\n    if (!nodeElement.hasAttribute(DATA_ATTRS.KEY)) {\n      nodeElement = nodeElement.closest(SELECTORS.KEY);\n    }\n\n    if (!nodeElement || !nodeElement.getAttribute(DATA_ATTRS.KEY)) {\n      return null;\n    }\n\n    if (nodeElement === content.ref.current) {\n      return PathUtils.create([]);\n    }\n\n    var search = function search(instance, p) {\n      if (nodeElement === instance) {\n        return p;\n      }\n\n      if (!instance.ref) {\n        return null;\n      }\n\n      if (nodeElement === instance.ref.current) {\n        return p;\n      } // If there's no `tmp` then we're at a leaf node without success.\n\n\n      if (!instance.tmp) {\n        return null;\n      }\n\n      var nodeRefs = instance.tmp.nodeRefs;\n      var keys = Object.keys(nodeRefs);\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var i = _step2.value;\n          var ref = nodeRefs[i];\n          var n = parseInt(i, 10);\n\n          var _path = search(ref, [].concat(toConsumableArray(p), [n]));\n\n          if (_path) {\n            return _path;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return null;\n    };\n\n    var document = content.tmp.nodeRef.current;\n    var path = search(document, []);\n\n    if (!path) {\n      return null;\n    }\n\n    return PathUtils.create(path);\n  }\n  /**\n   * Find a Slate point from a DOM selection's `nativeNode` and `nativeOffset`.\n   *\n   * @param {Editor} editor\n   * @param {Element} nativeNode\n   * @param {Number} nativeOffset\n   * @return {Point}\n   */\n\n\n  function findPoint(editor, nativeNode, nativeOffset) {\n    var _normalizeNodeAndOffs = normalizeNodeAndOffset(nativeNode, nativeOffset),\n        nearestNode = _normalizeNodeAndOffs.node,\n        nearestOffset = _normalizeNodeAndOffs.offset;\n\n    var window = getWindow(nativeNode);\n    var parentNode = nearestNode.parentNode;\n    var leafNode = parentNode.closest(SELECTORS.LEAF);\n    var textNode = void 0;\n    var offset = void 0;\n    var node = void 0; // Calculate how far into the text node the `nearestNode` is, so that we can\n    // determine what the offset relative to the text node is.\n\n    if (leafNode) {\n      textNode = leafNode.closest(SELECTORS.TEXT);\n      var range = window.document.createRange();\n      range.setStart(textNode, 0);\n      range.setEnd(nearestNode, nearestOffset);\n      var contents = range.cloneContents();\n      var zeroWidths = contents.querySelectorAll(SELECTORS.ZERO_WIDTH);\n      Array.from(zeroWidths).forEach(function (el) {\n        el.parentNode.removeChild(el);\n      }); // COMPAT: Edge has a bug where Range.prototype.toString() will convert \\n\n      // into \\r\\n. The bug causes a loop when slate-react attempts to reposition\n      // its cursor to match the native position. Use textContent.length instead.\n      // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n\n      offset = contents.textContent.length;\n      node = textNode;\n    } else {\n      // For void nodes, the element with the offset key will be a cousin, not an\n      // ancestor, so find it by going down from the nearest void parent.\n      var voidNode = parentNode.closest(SELECTORS.VOID);\n\n      if (!voidNode) {\n        return null;\n      }\n\n      leafNode = voidNode.querySelector(SELECTORS.LEAF);\n\n      if (!leafNode) {\n        return null;\n      }\n\n      textNode = leafNode.closest(SELECTORS.TEXT);\n      node = leafNode;\n      offset = node.textContent.length;\n    } // COMPAT: If the parent node is a Slate zero-width space, this is because the\n    // text node should have no characters. However, during IME composition the\n    // ASCII characters will be prepended to the zero-width space, so subtract 1\n    // from the offset to account for the zero-width space character.\n\n\n    if (offset === node.textContent.length && parentNode.hasAttribute(DATA_ATTRS.ZERO_WIDTH)) {\n      offset--;\n    } // COMPAT: If someone is clicking from one Slate editor into another, the\n    // select event fires twice, once for the old editor's `element` first, and\n    // then afterwards for the correct `element`. (2017/03/03)\n\n\n    var path = editor.findPath(textNode);\n\n    if (!path) {\n      return null;\n    }\n\n    var value = editor.value;\n    var document = value.document;\n    var point = document.createPoint({\n      path: path,\n      offset: offset\n    });\n    return point;\n  }\n  /**\n   * Find a Slate range from a DOM range or selection.\n   *\n   * @param {Editor} editor\n   * @param {Selection} domRange\n   * @return {Range}\n   */\n\n\n  function findRange(editor, domRange) {\n    var el = domRange.anchorNode || domRange.startContainer;\n\n    if (!el) {\n      return null;\n    }\n\n    var window = getWindow(el); // If the `domRange` object is a DOM `Range` or `StaticRange` object, change it\n    // into something that looks like a DOM `Selection` instead.\n\n    if (domRange instanceof window.Range || window.StaticRange && domRange instanceof window.StaticRange) {\n      domRange = {\n        anchorNode: domRange.startContainer,\n        anchorOffset: domRange.startOffset,\n        focusNode: domRange.endContainer,\n        focusOffset: domRange.endOffset\n      };\n    }\n\n    var _domRange = domRange,\n        anchorNode = _domRange.anchorNode,\n        anchorOffset = _domRange.anchorOffset,\n        focusNode = _domRange.focusNode,\n        focusOffset = _domRange.focusOffset,\n        isCollapsed = _domRange.isCollapsed;\n    var value = editor.value;\n    var anchor = editor.findPoint(anchorNode, anchorOffset);\n    var focus = isCollapsed ? anchor : editor.findPoint(focusNode, focusOffset);\n\n    if (!anchor || !focus) {\n      return null;\n    }\n\n    var document = value.document;\n    var range = document.createRange({\n      anchor: anchor,\n      focus: focus\n    });\n    return range;\n  }\n  /**\n   * Find a Slate selection from a DOM selection.\n   *\n   * @param {Editor} editor\n   * @param {Selection} domSelection\n   * @return {Range}\n   */\n\n\n  function findSelection(editor, domSelection) {\n    var value = editor.value;\n    var document = value.document; // If there are no ranges, the editor was blurred natively.\n\n    if (!domSelection.rangeCount) {\n      return null;\n    } // Otherwise, determine the Slate selection from the native one.\n\n\n    var range = editor.findRange(domSelection);\n\n    if (!range) {\n      return null;\n    }\n\n    var _range2 = range,\n        anchor = _range2.anchor,\n        focus = _range2.focus;\n    var anchorText = document.getNode(anchor.path);\n    var focusText = document.getNode(focus.path);\n    var anchorInline = document.getClosestInline(anchor.path);\n    var focusInline = document.getClosestInline(focus.path);\n    var focusBlock = document.getClosestBlock(focus.path);\n    var anchorBlock = document.getClosestBlock(anchor.path); // COMPAT: If the anchor point is at the start of a non-void, and the\n    // focus point is inside a void node with an offset that isn't `0`, set\n    // the focus offset to `0`. This is due to void nodes <span>'s being\n    // positioned off screen, resulting in the offset always being greater\n    // than `0`. Since we can't know what it really should be, and since an\n    // offset of `0` is less destructive because it creates a hanging\n    // selection, go with `0`. (2017/09/07)\n\n    if (anchorBlock && !editor.isVoid(anchorBlock) && anchor.offset === 0 && focusBlock && editor.isVoid(focusBlock) && focus.offset !== 0) {\n      range = range.setFocus(focus.setOffset(0));\n    } // COMPAT: If the selection is at the end of a non-void inline node, and\n    // there is a node after it, put it in the node after instead. This\n    // standardizes the behavior, since it's indistinguishable to the user.\n\n\n    if (anchorInline && !editor.isVoid(anchorInline) && anchor.offset === anchorText.text.length) {\n      var block = document.getClosestBlock(anchor.path);\n      var depth = document.getDepth(block.key);\n      var relativePath = PathUtils.drop(anchor.path, depth);\n\n      var _block$texts = block.texts({\n        path: relativePath\n      }),\n          _block$texts2 = slicedToArray(_block$texts, 1),\n          next = _block$texts2[0];\n\n      if (next) {\n        var _next = slicedToArray(next, 2),\n            nextPath = _next[1];\n\n        var absolutePath = anchor.path.slice(0, depth).concat(nextPath);\n        range = range.moveAnchorTo(absolutePath, 0);\n      }\n    }\n\n    if (focusInline && !editor.isVoid(focusInline) && focus.offset === focusText.text.length) {\n      var _block = document.getClosestBlock(focus.path);\n\n      var _depth = document.getDepth(_block.key);\n\n      var _relativePath = PathUtils.drop(focus.path, _depth);\n\n      var _block$texts3 = _block.texts({\n        path: _relativePath\n      }),\n          _block$texts4 = slicedToArray(_block$texts3, 1),\n          _next2 = _block$texts4[0];\n\n      if (_next2) {\n        var _next3 = slicedToArray(_next2, 2),\n            _nextPath = _next3[1];\n\n        var _absolutePath = focus.path.slice(0, _depth).concat(_nextPath);\n\n        range = range.moveFocusTo(_absolutePath, 0);\n      }\n    }\n\n    var selection = document.createSelection(range); // COMPAT: Ensure that the `isFocused` argument is set.\n\n    selection = selection.setIsFocused(true); // COMPAT: Preserve the marks, since we have no way of knowing what the DOM\n    // selection's marks were. They will be cleared automatically by the\n    // `select` command if the selection moves.\n\n    selection = selection.set('marks', value.selection.marks);\n    return selection;\n  }\n\n  return {\n    queries: {\n      findDOMNode: findDOMNode,\n      findDOMPoint: findDOMPoint,\n      findDOMRange: findDOMRange,\n      findEventRange: findEventRange,\n      findNode: findNode,\n      findPath: findPath,\n      findPoint: findPoint,\n      findRange: findRange,\n      findSelection: findSelection\n    }\n  };\n}\n/**\n * From a DOM selection's `node` and `offset`, normalize so that it always\n * refers to a text node.\n *\n * @param {Element} node\n * @param {Number} offset\n * @return {Object}\n */\n\n\nfunction normalizeNodeAndOffset(node, offset) {\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (node.nodeType === 1 && node.childNodes.length) {\n    var isLast = offset === node.childNodes.length;\n    var direction = isLast ? 'backward' : 'forward';\n    var index = isLast ? offset - 1 : offset;\n    node = getEditableChild(node, index, direction); // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n\n    while (node.nodeType === 1 && node.childNodes.length) {\n      var i = isLast ? node.childNodes.length - 1 : 0;\n      node = getEditableChild(node, i, direction);\n    } // Determine the new offset inside the text node.\n\n\n    offset = isLast ? node.textContent.length : 0;\n  } // Return the node and offset.\n\n\n  return {\n    node: node,\n    offset: offset\n  };\n}\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n *\n * @param {Element} parent\n * @param {Number} index\n * @param {String} direction ('forward' or 'backward')\n * @return {Element|Null}\n */\n\n\nfunction getEditableChild(parent, index, direction) {\n  var childNodes = parent.childNodes;\n  var child = childNodes[index];\n  var i = index;\n  var triedForward = false;\n  var triedBackward = false; // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n\n  while (child.nodeType === 8 || child.nodeType === 1 && child.childNodes.length === 0 || child.nodeType === 1 && child.getAttribute('contenteditable') === 'false') {\n    if (triedForward && triedBackward) break;\n\n    if (i >= childNodes.length) {\n      triedForward = true;\n      i = index - 1;\n      direction = 'backward';\n      continue;\n    }\n\n    if (i < 0) {\n      triedBackward = true;\n      i = index + 1;\n      direction = 'forward';\n      continue;\n    }\n\n    child = childNodes[i];\n    if (direction === 'forward') i++;\n    if (direction === 'backward') i--;\n  }\n\n  return child || null;\n}\n/**\n * Returns the number of characters that are the same at the beginning of the\n * String.\n *\n * @param {String} prev\n * @param {String} next\n */\n\n\nfunction getDiffStart(prev, next) {\n  var length = Math.min(prev.length, next.length);\n\n  for (var i = 0; i < length; i++) {\n    if (prev.charAt(i) !== next.charAt(i)) return i;\n  }\n\n  if (prev.length !== next.length) return length;\n  return null;\n}\n/**\n * Returns the number of characters that are the same at the end of the String\n * up to `max`. Max prevents double-counting characters when there are\n * multiple duplicate characters around the diff area.\n *\n * @param {String} prev\n * @param {String} next\n * @param {Number} max\n */\n\n\nfunction getDiffEnd(prev, next, max) {\n  var prevLength = prev.length;\n  var nextLength = next.length;\n  var length = Math.min(prevLength, nextLength, max);\n\n  for (var i = 0; i < length; i++) {\n    var prevChar = prev.charAt(prevLength - i - 1);\n    var nextChar = next.charAt(nextLength - i - 1);\n    if (prevChar !== nextChar) return i;\n  }\n\n  if (prev.length !== next.length) return length;\n  return null;\n}\n/**\n * Takes two strings and returns an object representing two offsets. The\n * first, `start` represents the number of characters that are the same at\n * the front of the String. The `end` represents the number of characters\n * that are the same at the end of the String.\n *\n * Returns null if they are identical.\n *\n * @param {String} prev\n * @param {String} next\n */\n\n\nfunction getDiffOffsets(prev, next) {\n  if (prev === next) return null;\n  var start = getDiffStart(prev, next);\n  var maxEnd = Math.min(prev.length - start, next.length - start);\n  var end = getDiffEnd(prev, next, maxEnd);\n  return {\n    start: start,\n    end: end,\n    total: start + end\n  };\n}\n/**\n * Takes a text string and returns a slice from the string at the given offses\n *\n * @param {String} text\n * @param {Object} offsets\n */\n\n\nfunction sliceText(text, offsets) {\n  return text.slice(offsets.start, text.length - offsets.end);\n}\n/**\n * Takes two strings and returns a smart diff that can be used to describe the\n * change in a way that can be used as operations like inserting, removing or\n * replacing text.\n *\n * @param {String} prev\n * @param {String} next\n */\n\n\nfunction diff(prev, next) {\n  var offsets = getDiffOffsets(prev, next);\n  if (offsets == null) return null;\n  var insertText = sliceText(next, offsets);\n  var removeText = sliceText(prev, offsets);\n  return {\n    start: offsets.start,\n    end: prev.length - offsets.end,\n    cursor: offsets.start + insertText.length,\n    insertText: insertText,\n    removeText: removeText\n  };\n}\n/**\n * @type {Debug}\n */\n\n\nvar debug$3 = Debug('slate:composition-manager');\n/**\n * Unicode String for a ZERO_WIDTH_SPACE\n *\n * @type {String}\n */\n\nvar ZERO_WIDTH_SPACE = String.fromCharCode(65279);\n/**\n * https://github.com/facebook/draft-js/commit/cda13cb8ff9c896cdb9ff832d1edeaa470d3b871\n */\n\nvar flushControlled = ReactDOM.unstable_flushControlled;\n\nfunction renderSync(editor, fn) {\n  flushControlled(function () {\n    fn();\n    editor.controller.flush();\n  });\n}\n/**\n * Takes text from a dom node and an offset within that text and returns an\n * object with fixed text and fixed offset which removes zero width spaces\n * and adjusts the offset.\n *\n * Optionally, if an `isLastNode` argument is passed in, it will also remove\n * a trailing newline.\n *\n * @param {String} text\n * @param {Number} offset\n * @param {Boolean} isLastNode\n */\n\n\nfunction fixTextAndOffset(prevText) {\n  var prevOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var isLastNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var nextOffset = prevOffset;\n  var nextText = prevText;\n  var index = 0;\n\n  while (index !== -1) {\n    index = nextText.indexOf(ZERO_WIDTH_SPACE, index);\n    if (index === -1) break;\n    if (nextOffset > index) nextOffset--;\n    nextText = '' + nextText.slice(0, index) + nextText.slice(index + 1);\n  } // remove the last newline if we are in the last node of a block\n\n\n  var lastChar = nextText.charAt(nextText.length - 1);\n\n  if (isLastNode && lastChar === '\\n') {\n    nextText = nextText.slice(0, -1);\n  }\n\n  var maxOffset = nextText.length;\n  if (nextOffset > maxOffset) nextOffset = maxOffset;\n  return {\n    text: nextText,\n    offset: nextOffset\n  };\n}\n/**\n * Based loosely on:\n *\n * https://github.com/facebook/draft-js/blob/master/src/component/handlers/composition/DOMObserver.js\n * https://github.com/ProseMirror/prosemirror-view/blob/master/src/domobserver.js\n *\n * But is an analysis mainly for `backspace` and `enter` as we handle\n * compositions as a single operation.\n *\n * @param {} element\n */\n\n\nfunction CompositionManager(editor) {\n  /**\n   * A MutationObserver that flushes to the method `flush`\n   *\n   * @type {MutationObserver}\n   */\n  var observer = new window.MutationObserver(flush);\n  var win = null;\n  /**\n   * Object that keeps track of the most recent state\n   *\n   * @type {Range}\n   */\n\n  var last = {\n    rootEl: null,\n    // root element that MutationObserver is attached to\n    diff: null,\n    // last text node diff between Slate and DOM\n    range: null,\n    // last range selected\n    domNode: null // last DOM node the cursor was in\n\n    /**\n     * Connect the MutationObserver to a specific editor root element\n     */\n\n  };\n\n  function connect() {\n    debug$3('connect', {\n      rootEl: rootEl\n    });\n    var rootEl = editor.findDOMNode([]);\n    if (last.rootEl === rootEl) return;\n    debug$3('connect:run');\n    win = getWindow(rootEl);\n    observer.observe(rootEl, {\n      childList: true,\n      characterData: true,\n      attributes: true,\n      subtree: true,\n      characterDataOldValue: true\n    });\n  }\n\n  function disconnect() {\n    debug$3('disconnect');\n    observer.disconnect();\n    last.rootEl = null;\n  }\n\n  function clearDiff() {\n    debug$3('clearDIff');\n    last.diff = null;\n  }\n  /**\n   * Clear the `last` properties related to an action only\n   */\n\n\n  function clearAction() {\n    debug$3('clearAction');\n    last.diff = null;\n    last.domNode = null;\n  }\n  /**\n   * Apply the last `diff`\n   *\n   * We don't want to apply the `diff` at the time it is created because we\n   * may be in a composition. There are a few things that trigger the applying\n   * of the saved diff. Sometimeson its own and sometimes immediately before\n   * doing something else with the Editor.\n   *\n   * - `onCompositionEnd` event\n   * - `onSelect` event only when the user has moved into a different node\n   * - The user hits `enter`\n   * - The user hits `backspace` and removes an inline node\n   * - The user hits `backspace` and merges two blocks\n   */\n\n\n  function applyDiff() {\n    debug$3('applyDiff');\n    var diff$$1 = last.diff;\n    if (diff$$1 == null) return;\n    debug$3('applyDiff:run');\n    var document = editor.value.document;\n    var entire = editor.value.selection.moveAnchorTo(diff$$1.path, diff$$1.start).moveFocusTo(diff$$1.path, diff$$1.end);\n    entire = document.resolveRange(entire);\n    editor.insertTextAtRange(entire, diff$$1.insertText);\n  }\n  /**\n   * Handle `enter` that splits block\n   */\n\n\n  function splitBlock() {\n    debug$3('splitBlock');\n    renderSync(editor, function () {\n      applyDiff();\n\n      if (last.range) {\n        editor.select(last.range);\n      } else {\n        debug$3('splitBlock:NO-SELECTION');\n      }\n\n      editor.splitBlock().focus().restoreDOM();\n      clearAction();\n    });\n  }\n  /**\n   * Handle `backspace` that merges blocks\n   */\n\n\n  function mergeBlock() {\n    debug$3('mergeBlock');\n    /**\n     * The delay is required because hitting `enter`, `enter` then `backspace`\n     * in a word results in the cursor being one position to the right in\n     * Android 9.\n     *\n     * Slate sets the position to `0` and we even check it immediately after\n     * setting it and it is correct, but somewhere Android moves it to the right.\n     *\n     * This happens only when using the virtual keyboard. Hitting enter on a\n     * hardware keyboard does not trigger this bug.\n     *\n     * The call to `focus` is required because when we switch examples then\n     * merge a block, we lose focus in Android 9 (possibly others).\n     */\n\n    win.requestAnimationFrame(function () {\n      renderSync(editor, function () {\n        applyDiff();\n        editor.select(last.range).deleteBackward().focus().restoreDOM();\n        clearAction();\n      });\n    });\n  }\n  /**\n   * The requestId used to the save selection\n   *\n   * @type {Any}\n   */\n\n\n  var onSelectTimeoutId = null;\n  var bufferedMutations = [];\n  var startActionFrameId = null;\n  var isFlushing = false;\n  /**\n   * Mark the beginning of an action. The action happens when the\n   * `requestAnimationFrame` expires.\n   *\n   * If `startAction` is called again, it pushes the `action` to a new\n   * `requestAnimationFrame` and cancels the old one.\n   */\n\n  function startAction() {\n    if (onSelectTimeoutId) {\n      window.cancelAnimationFrame(onSelectTimeoutId);\n      onSelectTimeoutId = null;\n    }\n\n    isFlushing = true;\n    if (startActionFrameId) window.cancelAnimationFrame(startActionFrameId);\n    startActionFrameId = window.requestAnimationFrame(function () {\n      if (bufferedMutations.length > 0) {\n        flushAction(bufferedMutations);\n      }\n\n      startActionFrameId = null;\n      bufferedMutations = [];\n      isFlushing = false;\n    });\n  }\n  /**\n   * Handle MutationObserver flush\n   *\n   * @param {MutationList} mutations\n   */\n\n\n  function flush(mutations) {\n    var _bufferedMutations;\n\n    debug$3('flush');\n\n    (_bufferedMutations = bufferedMutations).push.apply(_bufferedMutations, toConsumableArray(mutations));\n\n    startAction();\n  }\n  /**\n   * Handle a `requestAnimationFrame` long batch of mutations.\n   *\n   * @param {Array} mutations\n   */\n\n\n  function flushAction(mutations) {\n    debug$3('flushAction', mutations.length, mutations); // If there is an expanded collection, delete it\n\n    if (last.range && !last.range.isCollapsed) {\n      renderSync(editor, function () {\n        editor.select(last.range).deleteBackward().focus().restoreDOM();\n      });\n      return;\n    }\n\n    if (mutations.length > 1) {\n      // check if one of the mutations matches the signature of an `enter`\n      // which we use to signify a `splitBlock`\n      var splitBlockMutation = mutations.find(function (m) {\n        if (m.type !== 'childList') return false;\n        if (m.addedNodes.length === 0) return false;\n        var addedNode = m.addedNodes[0]; // If a text node is created anywhere with a newline in it, it's an\n        // enter\n\n        if (addedNode.nodeType === window.Node.TEXT_NODE && addedNode.textContent === '\\n') return true; // If an element is created with a key that matches a block in our\n        // document, that means the mutation is splitting an existing block\n        // by creating a new element with the same key.\n\n        if (addedNode.nodeType !== window.Node.ELEMENT_NODE) return false;\n        var dataset = addedNode.dataset;\n        var key = dataset.key;\n        if (key == null) return false;\n        var block = editor.value.document.getClosestBlock(key);\n        return !!block;\n      });\n\n      if (splitBlockMutation) {\n        splitBlock();\n        return;\n      }\n    } // If we haven't matched a more specific mutation already, these general\n    // mutation catchers will try and determine what the user was trying to\n    // do.\n\n\n    var firstMutation = mutations[0];\n\n    if (firstMutation.type === 'characterData') {\n      resolveDOMNode(firstMutation.target.parentNode);\n    } else if (firstMutation.type === 'childList') {\n      if (firstMutation.removedNodes.length > 0) {\n        if (mutations.length === 1) {\n          removeNode(firstMutation.removedNodes[0]);\n        } else {\n          mergeBlock();\n        }\n      } else if (firstMutation.addedNodes.length > 0) {\n        splitBlock();\n      }\n    }\n  }\n  /**\n   * Takes a DOM Node and resolves it against Slate's Document.\n   *\n   * Saves the changes to `last.diff` which can be applied later using\n   * `applyDiff()`\n   *\n   * @param {DOMNode} domNode\n   */\n\n\n  function resolveDOMNode(domNode) {\n    debug$3('resolveDOMNode');\n    var value = editor.value;\n    var document = value.document;\n    var dataElement = domNode.closest('[data-key]');\n    var key = dataElement.dataset.key;\n    var path = document.getPath(key);\n    var block = document.getClosestBlock(key);\n    var node = document.getDescendant(key);\n    var prevText = node.text; // COMPAT: If this is the last leaf, and the DOM text ends in a new line,\n    // we will have added another new line in <Leaf>'s render method to account\n    // for browsers collapsing a single trailing new lines, so remove it.\n\n    var isLastNode = block.nodes.last() === node;\n    var fix = fixTextAndOffset(domNode.textContent, 0, isLastNode);\n    var nextText = fix.text; // If the text is no different, there is no diff.\n\n    if (nextText === prevText) {\n      last.diff = null;\n      return;\n    }\n\n    var diff$$1 = diff(prevText, nextText);\n    last.diff = {\n      path: path,\n      start: diff$$1.start,\n      end: diff$$1.end,\n      insertText: diff$$1.insertText\n    };\n    debug$3('resolveDOMNode:diff', last.diff);\n  }\n  /**\n   * Remove an Inline DOM Node.\n   *\n   * Happens when you delete the last character in an Inline DOM Node\n   */\n\n\n  function removeNode(domNode) {\n    debug$3('removeNode');\n    if (domNode.nodeType !== window.Node.ELEMENT_NODE) return;\n    var value = editor.value;\n    var document = value.document,\n        selection = value.selection;\n    var node = editor.findNode(domNode);\n    var nodeSelection = document.resolveRange(selection.moveToRangeOfNode(node));\n    renderSync(editor, function () {\n      editor.select(nodeSelection).delete().restoreDOM();\n    });\n  }\n  /**\n   * handle `onCompositionStart`\n   */\n\n\n  function onCompositionStart() {\n    debug$3('onCompositionStart');\n  }\n  /**\n   * handle `onCompositionEnd`\n   */\n\n\n  function onCompositionEnd() {\n    debug$3('onCompositionEnd');\n    /**\n     * The timing on the `setTimeout` with `20` ms is sensitive.\n     *\n     * It cannot use `requestAnimationFrame` because it is too short.\n     *\n     * Android 9, for example, when you type `it ` the space will first trigger\n     * a `compositionEnd` for the `it` part before the mutation for the ` `.\n     * This means that we end up with `it` if we trigger too soon because it\n     * is on the wrong value.\n     */\n\n    window.setTimeout(function () {\n      if (last.diff) {\n        debug$3('onCompositionEnd:applyDiff');\n        renderSync(editor, function () {\n          applyDiff();\n          var domRange = win.getSelection().getRangeAt(0);\n          var domText = domRange.startContainer.textContent;\n          var offset = domRange.startOffset;\n          var fix = fixTextAndOffset(domText, offset);\n          var range = editor.findRange({\n            anchorNode: domRange.startContainer,\n            anchorOffset: 0,\n            focusNode: domRange.startContainer,\n            focusOffset: 0,\n            isCollapsed: true\n          }).moveTo(fix.offset);\n          /**\n           * We must call `restoreDOM` even though this is applying a `diff` which\n           * should not require it. But if you type `it me. no.` on a blank line\n           * with a block following it, the next line will merge with the this\n           * line. A mysterious `keydown` with `input` of backspace appears in the\n           * event stream which the user not React caused.\n           *\n           * `focus` is required as well because otherwise we lose focus on hitting\n           * `enter` in such a scenario.\n           */\n\n          editor.select(range).focus().restoreDOM();\n        });\n      }\n\n      clearAction();\n    }, 20);\n  }\n  /**\n   * Handle `onSelect` event\n   *\n   * Save the selection after a `requestAnimationFrame`\n   *\n   * - If we're not in the middle of flushing mutations\n   * - and cancel save if a mutation runs before the `requestAnimationFrame`\n   */\n\n\n  function onSelect(event) {\n    debug$3('onSelect:try'); // Event can be Synthetic React or native. Grab only the native one so\n    // that we don't have to call `event.perist` for performance.\n\n    event = event.nativeEvent ? event.nativeEvent : event;\n    window.cancelAnimationFrame(onSelectTimeoutId);\n    onSelectTimeoutId = null; // Don't capture the last selection if the selection was made during the\n    // flushing of DOM mutations. This means it is all part of one user action.\n\n    if (isFlushing) return;\n    onSelectTimeoutId = window.requestAnimationFrame(function () {\n      debug$3('onSelect:save-selection');\n      var domSelection = getWindow(event.target).getSelection();\n      var range = editor.findRange(domSelection);\n      var anchorFix = fixTextAndOffset(domSelection.anchorNode.textContent, domSelection.anchorOffset);\n      var focusFix = fixTextAndOffset(domSelection.focusNode.textContent, domSelection.focusOffset);\n\n      if (range.anchor.offset !== anchorFix.offset) {\n        range = range.set('anchor', range.anchor.set('offset', anchorFix.offset));\n      }\n\n      if (range.focus.offset !== focusFix.offset) {\n        range = range.set('focus', range.focus.set('offset', focusFix.offset));\n      }\n\n      debug$3('onSelect:save-data', {\n        domSelection: normalizeDOMSelection(domSelection),\n        range: range.toJS()\n      }); // If the `domSelection` has moved into a new node, then reconcile with\n      // `applyDiff`\n\n      if (domSelection.isCollapsed && last.node !== domSelection.anchorNode && last.diff != null) {\n        debug$3('onSelect:applyDiff', last.diff);\n        applyDiff();\n        editor.select(range);\n        clearAction();\n      }\n\n      last.range = range;\n      last.node = domSelection.anchorNode;\n    });\n  }\n\n  return {\n    clearDiff: clearDiff,\n    connect: connect,\n    disconnect: disconnect,\n    onKeyDown: startAction,\n    onCompositionStart: onCompositionStart,\n    onCompositionEnd: onCompositionEnd,\n    onSelect: onSelect\n  };\n}\n\nfunction normalizeDOMSelection(selection) {\n  return {\n    anchorNode: selection.anchorNode,\n    anchorOffset: selection.anchorOffset,\n    focusNode: selection.focusNode,\n    focusOffset: selection.focusOffset\n  };\n}\n/**\n * Fixes a selection within the DOM when the cursor is in Slate's special\n * zero-width block. Slate handles empty blocks in a special manner and the\n * cursor can end up either before or after the non-breaking space. This\n * causes different behavior in Android and so we make sure the seleciton is\n * always before the zero-width space.\n *\n * @param {Window} window\n */\n\n\nfunction fixSelectionInZeroWidthBlock(window) {\n  var domSelection = window.getSelection();\n  var anchorNode = domSelection.anchorNode;\n  if (anchorNode == null) return;\n  var dataset = anchorNode.parentElement.dataset;\n  var isZeroWidth = dataset ? dataset.slateZeroWidth === 'n' : false;\n\n  if (isZeroWidth && anchorNode.textContent.length === 1 && domSelection.anchorOffset !== 0) {\n    var range = window.document.createRange();\n    range.setStart(anchorNode, 0);\n    range.setEnd(anchorNode, 0);\n    domSelection.removeAllRanges();\n    domSelection.addRange(range);\n  }\n}\n/**\n * Android Plugin\n *\n * @param {Editor} options.editor\n */\n\n\nfunction AndroidPlugin(_ref) {\n  var editor = _ref.editor;\n  var observer = new CompositionManager(editor);\n  /**\n   * handle `onCompositionStart`\n   */\n\n  function onCompositionStart() {\n    observer.onCompositionStart();\n  }\n  /**\n   * handle `onCompositionEnd`\n   */\n\n\n  function onCompositionEnd() {\n    observer.onCompositionEnd();\n  }\n  /**\n   * handle `onSelect`\n   *\n   * @param {Event} event\n   */\n\n\n  function onSelect(event) {\n    var window = getWindow(event.target);\n    fixSelectionInZeroWidthBlock(window);\n    observer.onSelect(event);\n  }\n  /**\n   * handle `onComponentDidMount`\n   */\n\n\n  function onComponentDidMount() {\n    observer.connect();\n  }\n  /**\n   * handle `onComponentDidUpdate`\n   */\n\n\n  function onComponentDidUpdate() {\n    observer.connect();\n  }\n  /**\n   * handle `onComponentWillUnmount`\n   *\n   * @param {Event} event\n   */\n\n\n  function onComponentWillUnmount() {\n    observer.disconnect();\n  }\n  /**\n   * handle `onRender`\n   *\n   * @param {Event} event\n   */\n\n\n  function onRender() {\n    observer.disconnect(); // We don't want the `diff` from a previous render to apply to a\n    // potentially different value (e.g. when we switch examples)\n\n    observer.clearDiff();\n  }\n\n  return {\n    onComponentDidMount: onComponentDidMount,\n    onComponentDidUpdate: onComponentDidUpdate,\n    onComponentWillUnmount: onComponentWillUnmount,\n    onCompositionEnd: onCompositionEnd,\n    onCompositionStart: onCompositionStart,\n    onRender: onRender,\n    onSelect: onSelect\n  };\n}\n/**\n * This plugin prevents events from going any further and is useful in dev.\n *\n * The purpose is to see how the editor events and mutations behave without\n * the noise of the editor also adding its own events and mutations.\n *\n * IMPORTANT:\n *\n * This plugin is detached (i.e. there is no way to turn it on in Slate).\n * You must hard code it into `plugins/react/index`.\n *\n * @return {Object}\n */\n\n\nfunction NoopPlugin() {\n  /**\n   * Plugin Object\n   *\n   * @type {Object}\n   */\n  var plugin = {};\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = EVENT_HANDLERS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var eventName = _step.value;\n\n      plugin[eventName] = function (event, editor, next) {};\n    }\n    /**\n     * Return the plugin.\n     *\n     * @type {Object}\n     */\n\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return plugin;\n}\n/**\n * The transfer types that Slate recognizes.\n *\n * @type {Object}\n */\n\n\nvar TRANSFER_TYPES = {\n  FRAGMENT: 'application/x-slate-fragment',\n  HTML: 'text/html',\n  NODE: 'application/x-slate-node',\n  RICH: 'text/rtf',\n  TEXT: 'text/plain'\n};\nvar FRAGMENT = TRANSFER_TYPES.FRAGMENT;\nvar HTML = TRANSFER_TYPES.HTML;\nvar TEXT = TRANSFER_TYPES.TEXT;\n/**\n * Prepares a Slate document fragment to be copied to the clipboard.\n *\n * @param {Event} event\n * @param {Editor} editor\n */\n\nfunction cloneFragment(event, editor) {\n  var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {\n    return undefined;\n  };\n  invariant(!Value.isValue(editor), 'As of Slate 0.42.0, the `cloneFragment` utility takes an `editor` instead of a `value`.');\n  var window = getWindow(event.target);\n  var native = window.getSelection();\n  var value = editor.value;\n  var document = value.document,\n      fragment = value.fragment,\n      selection = value.selection;\n  var start = selection.start,\n      end = selection.end;\n  var startVoid = document.getClosestVoid(start.path, editor);\n  var endVoid = document.getClosestVoid(end.path, editor); // If the selection is collapsed, and it isn't inside a void node, abort.\n\n  if (native.isCollapsed && !startVoid) return; // Create a fake selection so that we can add a Base64-encoded copy of the\n  // fragment to the HTML, to decode on future pastes.\n\n  var encoded = Base64.serializeNode(fragment);\n  var range = native.getRangeAt(0);\n  var contents = range.cloneContents();\n  var attach = contents.childNodes[0]; // Make sure attach is a non-empty node, since empty nodes will not get copied\n\n  contents.childNodes.forEach(function (node) {\n    if (node.textContent && node.textContent.trim() !== '') {\n      attach = node;\n    }\n  }); // COMPAT: If the end node is a void node, we need to move the end of the\n  // range from the void node's spacer span, to the end of the void node's\n  // content, since the spacer is before void's content in the DOM.\n\n  if (endVoid) {\n    var r = range.cloneRange();\n    var path = document.getPath(endVoid.key);\n\n    if (path) {\n      var node = editor.findDOMNode(path);\n      r.setEndAfter(node);\n      contents = r.cloneContents();\n    }\n  } // COMPAT: If the start node is a void node, we need to attach the encoded\n  // fragment to the void node's content node instead of the spacer, because\n  // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n  // most browsers. (2018/04/27)\n\n\n  if (startVoid) {\n    attach = contents.childNodes[0].childNodes[1].firstChild;\n  } // Remove any zero-width space spans from the cloned DOM so that they don't\n  // show up elsewhere when pasted.\n\n\n  [].slice.call(contents.querySelectorAll(SELECTORS.ZERO_WIDTH)).forEach(function (zw) {\n    var isNewline = zw.getAttribute(DATA_ATTRS.ZERO_WIDTH) === 'n';\n    zw.textContent = isNewline ? '\\n' : '';\n  }); // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n  // in the HTML, and can be used for intra-Slate pasting. If it's a text\n  // node, wrap it in a `<span>` so we have something to set an attribute on.\n\n  if (attach.nodeType === 3) {\n    var span = window.document.createElement('span'); // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n    // then leading and trailing spaces will be ignored. (2017/09/21)\n\n    span.style.whiteSpace = 'pre';\n    span.appendChild(attach);\n    contents.appendChild(span);\n    attach = span;\n  }\n\n  attach.setAttribute(DATA_ATTRS.FRAGMENT, encoded); //  Creates value from only the selected blocks\n  //  Then gets plaintext for clipboard with proper linebreaks for BLOCK elements\n  //  Via Plain serializer\n\n  var valFromSelection = Value.create({\n    document: fragment\n  });\n  var plainText = Plain.serialize(valFromSelection); // Add the phony content to a div element. This is needed to copy the\n  // contents into the html clipboard register.\n\n  var div = window.document.createElement('div');\n  div.appendChild(contents); // For browsers supporting it, we set the clipboard registers manually,\n  // since the result is more predictable.\n  // COMPAT: IE supports the setData method, but only in restricted sense.\n  // IE doesn't support arbitrary MIME types or common ones like 'text/plain';\n  // it only accepts \"Text\" (which gets mapped to 'text/plain') and \"Url\"\n  // (mapped to 'text/url-list'); so, we should only enter block if !IS_IE\n\n  if (event.clipboardData && event.clipboardData.setData && !IS_IE) {\n    event.preventDefault();\n    event.clipboardData.setData(TEXT, plainText);\n    event.clipboardData.setData(FRAGMENT, encoded);\n    event.clipboardData.setData(HTML, div.innerHTML);\n    callback();\n    return;\n  } // COMPAT: For browser that don't support the Clipboard API's setData method,\n  // we must rely on the browser to natively copy what's selected.\n  // So we add the div (containing our content) to the DOM, and select it.\n\n\n  var editorEl = event.target.closest(SELECTORS.EDITOR);\n  div.setAttribute('contenteditable', true);\n  div.style.position = 'absolute';\n  div.style.left = '-9999px';\n  editorEl.appendChild(div);\n  native.selectAllChildren(div); // Revert to the previous selection right after copying.\n\n  window.requestAnimationFrame(function () {\n    editorEl.removeChild(div);\n    removeAllRanges(native);\n    native.addRange(range);\n    callback();\n  });\n}\n/**\n * Transfer types.\n *\n * @type {String}\n */\n\n\nvar FRAGMENT$1 = TRANSFER_TYPES.FRAGMENT;\nvar HTML$1 = TRANSFER_TYPES.HTML;\nvar NODE = TRANSFER_TYPES.NODE;\nvar RICH = TRANSFER_TYPES.RICH;\nvar TEXT$1 = TRANSFER_TYPES.TEXT;\n/**\n * Fragment matching regexp for HTML nodes.\n *\n * @type {RegExp}\n */\n\nvar FRAGMENT_MATCHER = / data-slate-fragment=\"([^\\s\"]+)\"/;\n/**\n * Get the transfer data from an `event`.\n *\n * @param {Event} event\n * @return {Object}\n */\n\nfunction getEventTransfer(event) {\n  // COMPAT: IE 11 doesn't populate nativeEvent with either\n  // dataTransfer or clipboardData. We'll need to use the base event\n  // object (2018/14/6)\n  if (!IS_IE && event.nativeEvent) {\n    event = event.nativeEvent;\n  }\n\n  var transfer = event.dataTransfer || event.clipboardData;\n  var fragment = getType(transfer, FRAGMENT$1);\n  var node = getType(transfer, NODE);\n  var html = getType(transfer, HTML$1);\n  var rich = getType(transfer, RICH);\n  var text = getType(transfer, TEXT$1);\n  var files = void 0; // If there isn't a fragment, but there is HTML, check to see if the HTML is\n  // actually an encoded fragment.\n\n  if (!fragment && html && ~html.indexOf(' ' + DATA_ATTRS.FRAGMENT + '=\"')) {\n    var matches = FRAGMENT_MATCHER.exec(html);\n\n    var _matches = slicedToArray(matches, 2),\n        full = _matches[0],\n        encoded = _matches[1]; // eslint-disable-line no-unused-vars\n\n\n    if (encoded) fragment = encoded;\n  } // COMPAT: Edge doesn't handle custom data types\n  // These will be embedded in text/plain in this case (2017/7/12)\n\n\n  if (text) {\n    var embeddedTypes = getEmbeddedTypes(text);\n    if (embeddedTypes[FRAGMENT$1]) fragment = embeddedTypes[FRAGMENT$1];\n    if (embeddedTypes[NODE]) node = embeddedTypes[NODE];\n    if (embeddedTypes[TEXT$1]) text = embeddedTypes[TEXT$1];\n  } // Decode a fragment or node if they exist.\n\n\n  if (fragment) fragment = Base64.deserializeNode(fragment);\n  if (node) node = Base64.deserializeNode(node); // COMPAT: Edge sometimes throws 'NotSupportedError'\n  // when accessing `transfer.items` (2017/7/12)\n\n  try {\n    // Get and normalize files if they exist.\n    if (transfer.items && transfer.items.length) {\n      files = Array.from(transfer.items).map(function (item) {\n        return item.kind === 'file' ? item.getAsFile() : null;\n      }).filter(function (exists) {\n        return exists;\n      });\n    } else if (transfer.files && transfer.files.length) {\n      files = Array.from(transfer.files);\n    }\n  } catch (err) {\n    if (transfer.files && transfer.files.length) {\n      files = Array.from(transfer.files);\n    }\n  } // Determine the type of the data.\n\n\n  var data = {\n    files: files,\n    fragment: fragment,\n    html: html,\n    node: node,\n    rich: rich,\n    text: text\n  };\n  data.type = getTransferType(data);\n  return data;\n}\n/**\n * Takes text input, checks whether contains embedded data\n * and returns object with original text +/- additional data\n *\n * @param {String} text\n * @return {Object}\n */\n\n\nfunction getEmbeddedTypes(text) {\n  var prefix = 'SLATE-DATA-EMBED::';\n\n  if (text.substring(0, prefix.length) !== prefix) {\n    return {\n      TEXT: text\n    };\n  } // Attempt to parse, if fails then just standard text/plain\n  // Otherwise, already had data embedded\n\n\n  try {\n    return JSON.parse(text.substring(prefix.length));\n  } catch (err) {\n    throw new Error('Unable to parse custom Slate drag event data.');\n  }\n}\n/**\n * Get the type of a transfer from its `data`.\n *\n * @param {Object} data\n * @return {String}\n */\n\n\nfunction getTransferType(data) {\n  if (data.fragment) return 'fragment';\n  if (data.node) return 'node'; // COMPAT: Microsoft Word adds an image of the selected text to the data.\n  // Since files are preferred over HTML or text, this would cause the type to\n  // be considered `files`. But it also adds rich text data so we can check\n  // for that and properly set the type to `html` or `text`. (2016/11/21)\n\n  if (data.rich && data.html) return 'html';\n  if (data.rich && data.text) return 'text';\n  if (data.files && data.files.length) return 'files';\n  if (data.html) return 'html';\n  if (data.text) return 'text';\n  return 'unknown';\n}\n/**\n * Get one of types `TYPES.FRAGMENT`, `TYPES.NODE`, `text/html`, `text/rtf` or\n * `text/plain` from transfers's `data` if possible, otherwise return null.\n *\n * @param {Object} transfer\n * @param {String} type\n * @return {String}\n */\n\n\nfunction getType(transfer, type) {\n  if (!transfer.types || !transfer.types.length) {\n    // COMPAT: In IE 11, there is no `types` field but `getData('Text')`\n    // is supported`. (2017/06/23)\n    return type === TEXT$1 ? transfer.getData('Text') || null : null;\n  } // COMPAT: In Edge, transfer.types doesn't respond to `indexOf`. (2017/10/25)\n\n\n  var types = Array.from(transfer.types);\n  return types.indexOf(type) !== -1 ? transfer.getData(type) || null : null;\n}\n/**\n * The default plain text transfer type.\n *\n * @type {String}\n */\n\n\nvar TEXT$2 = TRANSFER_TYPES.TEXT;\n/**\n * Set data with `type` and `content` on an `event`.\n *\n * COMPAT: In Edge, custom types throw errors, so embed all non-standard\n * types in text/plain compound object. (2017/7/12)\n *\n * @param {Event} event\n * @param {String} type\n * @param {String} content\n */\n\nfunction setEventTransfer(event, type, content) {\n  var mime = TRANSFER_TYPES[type.toUpperCase()];\n\n  if (!mime) {\n    throw new Error('Cannot set unknown transfer type \"' + mime + '\".');\n  }\n\n  if (event.nativeEvent) {\n    event = event.nativeEvent;\n  }\n\n  var transfer = event.dataTransfer || event.clipboardData;\n\n  try {\n    transfer.setData(mime, content); // COMPAT: Safari needs to have the 'text' (and not 'text/plain') value in dataTransfer\n    // to display the cursor while dragging internally.\n\n    transfer.setData('text', transfer.getData('text'));\n  } catch (err) {\n    var prefix = 'SLATE-DATA-EMBED::';\n    var text = transfer.getData(TEXT$2);\n    var obj = {}; // If the existing plain text data is prefixed, it's Slate JSON data.\n\n    if (text.substring(0, prefix.length) === prefix) {\n      try {\n        obj = JSON.parse(text.substring(prefix.length));\n      } catch (e) {\n        throw new Error('Failed to parse Slate data from `DataTransfer` object.');\n      }\n    } else {\n      // Otherwise, it's just set it as is.\n      obj[TEXT$2] = text;\n    }\n\n    obj[mime] = content;\n    var string = '' + prefix + JSON.stringify(obj);\n    transfer.setData(TEXT$2, string);\n  }\n}\n/**\n * Debug.\n *\n * @type {Function}\n */\n\n\nvar debug$4 = Debug('slate:after');\n/**\n * A plugin that adds the \"after\" browser-specific logic to the editor.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction AfterPlugin() {\n  var isDraggingInternally = null;\n  var isMouseDown = false;\n  /**\n   * On before input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBeforeInput(event, editor, next) {\n    var value = editor.value;\n    var isSynthetic = !!event.nativeEvent; // If the event is synthetic, it's React's polyfill of `beforeinput` that\n    // isn't a true `beforeinput` event with meaningful information. It only\n    // gets triggered for character insertions, so we can just insert directly.\n\n    if (isSynthetic) {\n      event.preventDefault();\n      editor.insertText(event.data);\n      return next();\n    } // Otherwise, we can use the information in the `beforeinput` event to\n    // figure out the exact change that will occur, and prevent it.\n\n\n    var _event$getTargetRange = event.getTargetRanges(),\n        _event$getTargetRange2 = slicedToArray(_event$getTargetRange, 1),\n        targetRange = _event$getTargetRange2[0];\n\n    if (!targetRange) return next();\n    debug$4('onBeforeInput', {\n      event: event\n    });\n    event.preventDefault();\n    var document = value.document,\n        selection = value.selection;\n    var range = editor.findRange(targetRange);\n\n    switch (event.inputType) {\n      case 'deleteByDrag':\n      case 'deleteByCut':\n      case 'deleteContent':\n      case 'deleteContentBackward':\n      case 'deleteContentForward':\n        {\n          editor.deleteAtRange(range);\n          break;\n        }\n\n      case 'deleteWordBackward':\n        {\n          editor.deleteWordBackwardAtRange(range);\n          break;\n        }\n\n      case 'deleteWordForward':\n        {\n          editor.deleteWordForwardAtRange(range);\n          break;\n        }\n\n      case 'deleteSoftLineBackward':\n      case 'deleteHardLineBackward':\n        {\n          editor.deleteLineBackwardAtRange(range);\n          break;\n        }\n\n      case 'deleteSoftLineForward':\n      case 'deleteHardLineForward':\n        {\n          editor.deleteLineForwardAtRange(range);\n          break;\n        }\n\n      case 'insertLineBreak':\n      case 'insertParagraph':\n        {\n          var hasVoidParent = document.hasVoidParent(selection.start.path, editor);\n\n          if (hasVoidParent) {\n            editor.moveToStartOfNextText();\n          } else {\n            editor.splitBlockAtRange(range);\n          }\n\n          break;\n        }\n\n      case 'insertFromYank':\n      case 'insertReplacementText':\n      case 'insertText':\n        {\n          // COMPAT: `data` should have the text for the `insertText` input type\n          // and `dataTransfer` should have the text for the\n          // `insertReplacementText` input type, but Safari uses `insertText` for\n          // spell check replacements and sets `data` to `null`. (2018/08/09)\n          var text = event.data == null ? event.dataTransfer.getData('text/plain') : event.data;\n          if (text == null) break;\n          editor.insertTextAtRange(range, text, selection.marks); // If the text was successfully inserted, and the selection had marks\n          // on it, unset the selection's marks.\n\n          if (selection.marks && value.document !== editor.value.document) {\n            editor.select({\n              marks: null\n            });\n          }\n\n          break;\n        }\n    }\n\n    next();\n  }\n  /**\n   * On blur.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onBlur(event, editor, next) {\n    debug$4('onBlur', {\n      event: event\n    });\n    editor.blur();\n    next();\n  }\n  /**\n   * On click.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onClick(event, editor, next) {\n    if (editor.readOnly) return next();\n    var value = editor.value;\n    var document = value.document;\n    var path = editor.findPath(event.target);\n    if (!path) return next();\n    debug$4('onClick', {\n      event: event\n    });\n    var node = document.getNode(path);\n    var ancestors = document.getAncestors(path);\n    var isVoid = node && (editor.isVoid(node) || ancestors.some(function (a) {\n      return editor.isVoid(a);\n    }));\n\n    if (isVoid) {\n      // COMPAT: In Chrome & Safari, selections that are at the zero offset of\n      // an inline node will be automatically replaced to be at the last offset\n      // of a previous inline node, which screws us up, so we always want to set\n      // it to the end of the node. (2016/11/29)\n      editor.focus().moveToEndOfNode(node);\n    }\n\n    next();\n  }\n  /**\n   * On copy.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onCopy(event, editor, next) {\n    debug$4('onCopy', {\n      event: event\n    });\n    cloneFragment(event, editor);\n    next();\n  }\n  /**\n   * On cut.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onCut(event, editor, next) {\n    debug$4('onCut', {\n      event: event\n    }); // Once the fake cut content has successfully been added to the clipboard,\n    // delete the content in the current selection.\n\n    cloneFragment(event, editor, function () {\n      // If user cuts a void block node or a void inline node,\n      // manually removes it since selection is collapsed in this case.\n      var value = editor.value;\n      var document = value.document,\n          selection = value.selection;\n      var end = selection.end,\n          isCollapsed = selection.isCollapsed;\n      var voidPath = void 0;\n\n      if (isCollapsed) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = document.ancestors(end.path)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _ref = _step.value;\n\n            var _ref2 = slicedToArray(_ref, 2);\n\n            var node = _ref2[0];\n            var path = _ref2[1];\n\n            if (editor.isVoid(node)) {\n              voidPath = path;\n              break;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      if (voidPath) {\n        editor.removeNodeByKey(voidPath);\n      } else {\n        editor.delete();\n      }\n    });\n    next();\n  }\n  /**\n   * On drag end.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDragEnd(event, editor, next) {\n    debug$4('onDragEnd', {\n      event: event\n    });\n    isDraggingInternally = null;\n    next();\n  }\n  /**\n   * On drag start.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDragStart(event, editor, next) {\n    debug$4('onDragStart', {\n      event: event\n    });\n    isDraggingInternally = true;\n    var value = editor.value;\n    var document = value.document;\n    var path = editor.findPath(event.target);\n    var node = document.getNode(path);\n    var ancestors = document.getAncestors(path);\n    var isVoid = node && (editor.isVoid(node) || ancestors.some(function (a) {\n      return editor.isVoid(a);\n    }));\n    var selectionIncludesNode = value.blocks.some(function (block) {\n      return block === node;\n    }); // If a void block is dragged and is not selected, select it (necessary for local drags).\n\n    if (isVoid && !selectionIncludesNode) {\n      editor.moveToRangeOfNode(node);\n    }\n\n    var fragment = editor.value.fragment;\n    var encoded = Base64.serializeNode(fragment);\n    setEventTransfer(event, 'fragment', encoded);\n    next();\n  }\n  /**\n   * On drop.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDrop(event, editor, next) {\n    var value = editor.value;\n    var document = value.document,\n        selection = value.selection;\n    var window = getWindow(event.target);\n    var target = editor.findEventRange(event);\n\n    if (!target) {\n      return next();\n    }\n\n    debug$4('onDrop', {\n      event: event\n    });\n    var transfer = getEventTransfer(event);\n    var type = transfer.type,\n        fragment = transfer.fragment,\n        text = transfer.text;\n    editor.focus(); // COMPAT: React's onSelect event breaks after an onDrop event\n    // has fired in a node: https://github.com/facebook/react/issues/11379.\n    // Until this is fixed in React, we dispatch a mouseup event on that\n    // DOM node, since that will make it go back to normal.\n\n    var el = editor.findDOMNode(target.focus.path);\n\n    if (el) {\n      el.dispatchEvent(new MouseEvent('mouseup', {\n        view: window,\n        bubbles: true,\n        cancelable: true\n      }));\n    }\n\n    var draggedRange = selection;\n    editor.select(target);\n\n    if (isDraggingInternally) {\n      editor.deleteAtRange(draggedRange);\n    }\n\n    if (type === 'text' || type === 'html') {\n      var anchor = target.anchor;\n      var hasVoidParent = document.hasVoidParent(anchor.path, editor);\n\n      if (hasVoidParent) {\n        var p = anchor.path;\n        var n = document.getNode(anchor.path);\n\n        while (hasVoidParent) {\n          var _document$texts = document.texts({\n            path: p\n          }),\n              _document$texts2 = slicedToArray(_document$texts, 1),\n              nxt = _document$texts2[0];\n\n          if (!nxt) {\n            break;\n          }\n\n          var _nxt = slicedToArray(nxt, 2);\n\n          n = _nxt[0];\n          p = _nxt[1];\n          hasVoidParent = document.hasVoidParent(p, editor);\n        }\n\n        if (n) editor.moveToStartOfNode(n);\n      }\n\n      if (text) {\n        text.split('\\n').forEach(function (line, i) {\n          if (i > 0) editor.splitBlock();\n          editor.insertText(line);\n        });\n      }\n    }\n\n    if (type === 'fragment') {\n      editor.insertFragment(fragment);\n    }\n\n    next();\n  }\n  /**\n   * On focus.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onFocus(event, editor, next) {\n    debug$4('onFocus', {\n      event: event\n    }); // COMPAT: If the focus event is a mouse-based one, it will be shortly\n    // followed by a `selectionchange`, so we need to deselect here to prevent\n    // the old selection from being set by the `updateSelection` of `<Content>`,\n    // preventing the `selectionchange` from firing. (2018/11/07)\n\n    if (isMouseDown && !IS_IE && !IS_EDGE) {\n      editor.deselect().focus();\n    } else {\n      editor.focus();\n    }\n\n    next();\n  }\n  /**\n   * On input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onInput(event, editor, next) {\n    debug$4('onInput');\n    var window = getWindow(event.target);\n    var domSelection = window.getSelection();\n    var selection = editor.findSelection(domSelection);\n\n    if (selection) {\n      editor.select(selection);\n    } else {\n      editor.blur();\n    }\n\n    var anchorNode = domSelection.anchorNode;\n    editor.reconcileDOMNode(anchorNode);\n    next();\n  }\n  /**\n   * On key down.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onKeyDown(event, editor, next) {\n    debug$4('onKeyDown', {\n      event: event\n    });\n    var value = editor.value;\n    var document = value.document,\n        selection = value.selection;\n    var start = selection.start;\n    var hasVoidParent = document.hasVoidParent(start.path, editor); // COMPAT: In iOS, some of these hotkeys are handled in the\n    // `onNativeBeforeInput` handler of the `<Content>` component in order to\n    // preserve native autocorrect behavior, so they shouldn't be handled here.\n\n    if (Hotkeys.isSplitBlock(event) && !IS_IOS) {\n      return hasVoidParent ? editor.moveToStartOfNextText() : editor.splitBlock();\n    }\n\n    if (Hotkeys.isDeleteBackward(event) && !IS_IOS) {\n      return editor.deleteCharBackward();\n    }\n\n    if (Hotkeys.isDeleteForward(event) && !IS_IOS) {\n      return editor.deleteCharForward();\n    }\n\n    if (Hotkeys.isDeleteLineBackward(event)) {\n      return editor.deleteLineBackward();\n    }\n\n    if (Hotkeys.isDeleteLineForward(event)) {\n      return editor.deleteLineForward();\n    }\n\n    if (Hotkeys.isDeleteWordBackward(event)) {\n      return editor.deleteWordBackward();\n    }\n\n    if (Hotkeys.isDeleteWordForward(event)) {\n      return editor.deleteWordForward();\n    }\n\n    if (Hotkeys.isRedo(event)) {\n      return editor.redo();\n    }\n\n    if (Hotkeys.isUndo(event)) {\n      return editor.undo();\n    } // COMPAT: Certain browsers don't handle the selection updates properly. In\n    // Chrome, the selection isn't properly extended. And in Firefox, the\n    // selection isn't properly collapsed. (2017/10/17)\n\n\n    if (Hotkeys.isMoveLineBackward(event)) {\n      event.preventDefault();\n      return editor.moveToStartOfBlock();\n    }\n\n    if (Hotkeys.isMoveLineForward(event)) {\n      event.preventDefault();\n      return editor.moveToEndOfBlock();\n    }\n\n    if (Hotkeys.isExtendLineBackward(event)) {\n      event.preventDefault();\n      return editor.moveFocusToStartOfBlock();\n    }\n\n    if (Hotkeys.isExtendLineForward(event)) {\n      event.preventDefault();\n      return editor.moveFocusToEndOfBlock();\n    } // COMPAT: If a void node is selected, or a zero-width text node adjacent to\n    // an inline is selected, we need to handle these hotkeys manually because\n    // browsers won't know what to do.\n\n\n    if (Hotkeys.isMoveBackward(event)) {\n      event.preventDefault();\n\n      if (!selection.isCollapsed) {\n        return editor.moveToStart();\n      }\n\n      return editor.moveBackward();\n    }\n\n    if (Hotkeys.isMoveForward(event)) {\n      event.preventDefault();\n\n      if (!selection.isCollapsed) {\n        return editor.moveToEnd();\n      }\n\n      return editor.moveForward();\n    }\n\n    if (Hotkeys.isMoveWordBackward(event)) {\n      event.preventDefault();\n      return editor.moveWordBackward();\n    }\n\n    if (Hotkeys.isMoveWordForward(event)) {\n      event.preventDefault();\n      return editor.moveWordForward();\n    }\n\n    if (Hotkeys.isExtendBackward(event)) {\n      var startText = document.getNode(start.path);\n\n      var _document$texts3 = document.texts({\n        path: start.path,\n        direction: 'backward'\n      }),\n          _document$texts4 = slicedToArray(_document$texts3, 1),\n          prevEntry = _document$texts4[0];\n\n      var isPrevInVoid = false;\n\n      if (prevEntry) {\n        var _prevEntry = slicedToArray(prevEntry, 2),\n            prevPath = _prevEntry[1];\n\n        isPrevInVoid = document.hasVoidParent(prevPath, editor);\n      }\n\n      if (hasVoidParent || isPrevInVoid || startText.text === '') {\n        event.preventDefault();\n        return editor.moveFocusBackward();\n      }\n    }\n\n    if (Hotkeys.isExtendForward(event)) {\n      var _startText = document.getNode(start.path);\n\n      var _document$texts5 = document.texts({\n        path: start.path\n      }),\n          _document$texts6 = slicedToArray(_document$texts5, 1),\n          nextEntry = _document$texts6[0];\n\n      var isNextInVoid = false;\n\n      if (nextEntry) {\n        var _nextEntry = slicedToArray(nextEntry, 2),\n            nextPath = _nextEntry[1];\n\n        isNextInVoid = document.hasVoidParent(nextPath, editor);\n      }\n\n      if (hasVoidParent || isNextInVoid || _startText.text === '') {\n        event.preventDefault();\n        return editor.moveFocusForward();\n      }\n    }\n\n    next();\n  }\n  /**\n   * On mouse down.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onMouseDown(event, editor, next) {\n    debug$4('onMouseDown', {\n      event: event\n    });\n    isMouseDown = true;\n    next();\n  }\n  /**\n   * On mouse up.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onMouseUp(event, editor, next) {\n    debug$4('onMouseUp', {\n      event: event\n    });\n    isMouseDown = false;\n    next();\n  }\n  /**\n   * On paste.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onPaste(event, editor, next) {\n    debug$4('onPaste', {\n      event: event\n    });\n    var value = editor.value;\n    var transfer = getEventTransfer(event);\n    var type = transfer.type,\n        fragment = transfer.fragment,\n        text = transfer.text;\n\n    if (type === 'fragment') {\n      editor.insertFragment(fragment);\n    }\n\n    if (type === 'text' || type === 'html') {\n      if (!text) return next();\n      var document = value.document,\n          selection = value.selection,\n          startBlock = value.startBlock;\n      if (editor.isVoid(startBlock)) return next();\n      var defaultBlock = startBlock;\n      var defaultMarks = document.getInsertMarksAtRange(selection);\n      var frag = Plain.deserialize(text, {\n        defaultBlock: defaultBlock,\n        defaultMarks: defaultMarks\n      }).document;\n      editor.insertFragment(frag);\n    }\n\n    next();\n  }\n  /**\n   * On select.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onSelect(event, editor, next) {\n    debug$4('onSelect', {\n      event: event\n    });\n    var window = getWindow(event.target);\n    var domSelection = window.getSelection();\n    var selection = editor.findSelection(domSelection);\n\n    if (selection) {\n      editor.select(selection);\n    } else {\n      editor.blur();\n    } // COMPAT: reset the `isMouseDown` state here in case a `mouseup` event\n    // happens outside the editor. This is needed for `onFocus` handling.\n\n\n    isMouseDown = false;\n    next();\n  }\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n\n  return {\n    onBeforeInput: onBeforeInput,\n    onBlur: onBlur,\n    onClick: onClick,\n    onCopy: onCopy,\n    onCut: onCut,\n    onDragEnd: onDragEnd,\n    onDragStart: onDragStart,\n    onDrop: onDrop,\n    onFocus: onFocus,\n    onInput: onInput,\n    onKeyDown: onKeyDown,\n    onMouseDown: onMouseDown,\n    onMouseUp: onMouseUp,\n    onPaste: onPaste,\n    onSelect: onSelect\n  };\n}\n/**\n * Debug.\n *\n * @type {Function}\n */\n\n\nvar debug$5 = Debug('slate:before');\n/**\n * A plugin that adds the \"before\" browser-specific logic to the editor.\n *\n * @return {Object}\n */\n\nfunction BeforePlugin() {\n  var activeElement = null;\n  var compositionCount = 0;\n  var isComposing = false;\n  var isCopying = false;\n  var isDragging = false;\n  var isUserActionPerformed = false;\n  /**\n   * On before input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBeforeInput(event, editor, next) {\n    var isSynthetic = !!event.nativeEvent;\n    if (editor.readOnly) return;\n    isUserActionPerformed = true; // COMPAT: If the browser supports Input Events Level 2, we will have\n    // attached a custom handler for the real `beforeinput` events, instead of\n    // allowing React's synthetic polyfill, so we need to ignore synthetics.\n\n    if (isSynthetic && HAS_INPUT_EVENTS_LEVEL_2) return;\n    debug$5('onBeforeInput', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On blur.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onBlur(event, editor, next) {\n    if (isCopying) return;\n    if (editor.readOnly) return;\n    var relatedTarget = event.relatedTarget,\n        target = event.target;\n    var window = getWindow(target); // COMPAT: If the current `activeElement` is still the previous one, this is\n    // due to the window being blurred when the tab itself becomes unfocused, so\n    // we want to abort early to allow to editor to stay focused when the tab\n    // becomes focused again.\n\n    if (activeElement === window.document.activeElement) return; // COMPAT: The `relatedTarget` can be null when the new focus target is not\n    // a \"focusable\" element (eg. a `<div>` without `tabindex` set).\n\n    if (relatedTarget) {\n      var el = editor.findDOMNode([]); // COMPAT: The event should be ignored if the focus is returning to the\n      // editor from an embedded editable element (eg. an <input> element inside\n      // a void node).\n\n      if (relatedTarget === el) return; // COMPAT: The event should be ignored if the focus is moving from the\n      // editor to inside a void node's spacer element.\n\n      if (relatedTarget.hasAttribute(DATA_ATTRS.SPACER)) return; // COMPAT: The event should be ignored if the focus is moving to a non-\n      // editable section of an element that isn't a void node (eg. a list item\n      // of the check list example).\n\n      var node = editor.findNode(relatedTarget);\n\n      if (el.contains(relatedTarget) && node && !editor.isVoid(node)) {\n        return;\n      }\n    }\n\n    debug$5('onBlur', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On composition end.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onCompositionEnd(event, editor, next) {\n    var n = compositionCount;\n    isUserActionPerformed = true; // The `count` check here ensures that if another composition starts\n    // before the timeout has closed out this one, we will abort unsetting the\n    // `isComposing` flag, since a composition is still in affect.\n\n    window.requestAnimationFrame(function () {\n      if (compositionCount > n) return;\n      isComposing = false;\n    });\n    debug$5('onCompositionEnd', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On click.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onClick(event, editor, next) {\n    debug$5('onClick', {\n      event: event\n    });\n    isUserActionPerformed = true;\n    next();\n  }\n  /**\n   * On composition start.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onCompositionStart(event, editor, next) {\n    isComposing = true;\n    compositionCount++;\n    var value = editor.value;\n    var selection = value.selection;\n    isUserActionPerformed = true;\n\n    if (!selection.isCollapsed) {\n      // https://github.com/ianstormtaylor/slate/issues/1879\n      // When composition starts and the current selection is not collapsed, the\n      // second composition key-down would drop the text wrapping <spans> which\n      // resulted on crash in content.updateSelection after composition ends\n      // (because it cannot find <span> nodes in DOM). This is a workaround that\n      // erases selection as soon as composition starts and preventing <spans>\n      // to be dropped.\n      editor.delete();\n    }\n\n    debug$5('onCompositionStart', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On copy.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onCopy(event, editor, next) {\n    var window = getWindow(event.target);\n    isCopying = true;\n    window.requestAnimationFrame(function () {\n      return isCopying = false;\n    });\n    debug$5('onCopy', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On cut.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onCut(event, editor, next) {\n    if (editor.readOnly) return;\n    var window = getWindow(event.target);\n    isCopying = true;\n    window.requestAnimationFrame(function () {\n      return isCopying = false;\n    });\n    debug$5('onCut', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On drag end.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDragEnd(event, editor, next) {\n    isDragging = false;\n    debug$5('onDragEnd', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On drag enter.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDragEnter(event, editor, next) {\n    debug$5('onDragEnter', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On drag exit.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDragExit(event, editor, next) {\n    debug$5('onDragExit', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On drag leave.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDragLeave(event, editor, next) {\n    debug$5('onDragLeave', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On drag over.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDragOver(event, editor, next) {\n    // If the target is inside a void node, and only in this case,\n    // call `preventDefault` to signal that drops are allowed.\n    // When the target is editable, dropping is already allowed by\n    // default, and calling `preventDefault` hides the cursor.\n    var node = editor.findNode(event.target);\n\n    if (!node || editor.isVoid(node)) {\n      event.preventDefault();\n    } // COMPAT: IE won't call onDrop on contentEditables unless the\n    // default dragOver is prevented:\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/913982/\n    // (2018/07/11)\n\n\n    if (IS_IE) {\n      event.preventDefault();\n    } // If a drag is already in progress, don't do this again.\n\n\n    if (!isDragging) {\n      isDragging = true; // COMPAT: IE will raise an `unspecified error` if dropEffect is\n      // set. (2018/07/11)\n\n      if (!IS_IE) {\n        event.nativeEvent.dataTransfer.dropEffect = 'move';\n      }\n    }\n\n    debug$5('onDragOver', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On drag start.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDragStart(event, editor, next) {\n    isDragging = true;\n    debug$5('onDragStart', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On drop.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onDrop(event, editor, next) {\n    if (editor.readOnly) return;\n    isUserActionPerformed = true; // Prevent default so the DOM's value isn't corrupted.\n\n    event.preventDefault();\n    debug$5('onDrop', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On focus.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onFocus(event, editor, next) {\n    if (isCopying) return;\n    if (editor.readOnly) return;\n    var el = editor.findDOMNode([]); // Save the new `activeElement`.\n\n    var window = getWindow(event.target);\n    activeElement = window.document.activeElement; // COMPAT: If the editor has nested editable elements, the focus can go to\n    // those elements. In Firefox, this must be prevented because it results in\n    // issues with keyboard navigation. (2017/03/30)\n\n    if (IS_FIREFOX && event.target !== el) {\n      el.focus();\n      return;\n    }\n\n    debug$5('onFocus', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onInput(event, editor, next) {\n    if (isComposing) return;\n    if (editor.value.selection.isBlurred) return;\n    isUserActionPerformed = true;\n    debug$5('onInput', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On key down.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onKeyDown(event, editor, next) {\n    if (editor.readOnly) return; // When composing, we need to prevent all hotkeys from executing while\n    // typing. However, certain characters also move the selection before\n    // we're able to handle it, so prevent their default behavior.\n\n    if (isComposing) {\n      if (Hotkeys.isCompose(event)) event.preventDefault();\n      return;\n    } // Certain hotkeys have native editing behaviors in `contenteditable`\n    // elements which will editor the DOM and cause our value to be out of sync,\n    // so they need to always be prevented.\n\n\n    if (!IS_IOS && (Hotkeys.isBold(event) || Hotkeys.isDeleteBackward(event) || Hotkeys.isDeleteForward(event) || Hotkeys.isDeleteLineBackward(event) || Hotkeys.isDeleteLineForward(event) || Hotkeys.isDeleteWordBackward(event) || Hotkeys.isDeleteWordForward(event) || Hotkeys.isItalic(event) || Hotkeys.isRedo(event) || Hotkeys.isSplitBlock(event) || Hotkeys.isTransposeCharacter(event) || Hotkeys.isUndo(event))) {\n      event.preventDefault();\n    }\n\n    isUserActionPerformed = true;\n    debug$5('onKeyDown', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On paste.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onPaste(event, editor, next) {\n    if (editor.readOnly) return;\n    isUserActionPerformed = true; // Prevent defaults so the DOM state isn't corrupted.\n\n    event.preventDefault();\n    debug$5('onPaste', {\n      event: event\n    });\n    next();\n  }\n  /**\n   * On select.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onSelect(event, editor, next) {\n    if (isCopying) return;\n    if (isComposing) return;\n    if (editor.readOnly) return; // Save the new `activeElement`.\n\n    var window = getWindow(event.target);\n    activeElement = window.document.activeElement;\n    isUserActionPerformed = true;\n    debug$5('onSelect', {\n      event: event\n    });\n    next();\n  }\n\n  function userActionPerformed() {\n    return isUserActionPerformed;\n  }\n\n  function clearUserActionPerformed() {\n    isUserActionPerformed = false;\n    return null;\n  }\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n\n  return {\n    onBeforeInput: onBeforeInput,\n    onBlur: onBlur,\n    onClick: onClick,\n    onCompositionEnd: onCompositionEnd,\n    onCompositionStart: onCompositionStart,\n    onCopy: onCopy,\n    onCut: onCut,\n    onDragEnd: onDragEnd,\n    onDragEnter: onDragEnter,\n    onDragExit: onDragExit,\n    onDragLeave: onDragLeave,\n    onDragOver: onDragOver,\n    onDragStart: onDragStart,\n    onDrop: onDrop,\n    onFocus: onFocus,\n    onInput: onInput,\n    onKeyDown: onKeyDown,\n    onPaste: onPaste,\n    onSelect: onSelect,\n    queries: {\n      userActionPerformed: userActionPerformed\n    },\n    commands: {\n      clearUserActionPerformed: clearUserActionPerformed\n    }\n  };\n}\n/**\n * A plugin that adds the browser-specific logic to the editor.\n *\n * @param {Object} options\n * @return {Object}\n */\n\n\nfunction DOMPlugin() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _options$plugins = options.plugins,\n      plugins = _options$plugins === undefined ? [] : _options$plugins;\n  var beforePlugin = BeforePlugin();\n  var afterPlugin = AfterPlugin(); // COMPAT: Add Android specific handling separately before it gets to the\n  // other plugins because it is specific (other browser don't need it) and\n  // finicky (it has to come before other plugins to work).\n\n  var androidPlugins = IS_ANDROID ? [AndroidPlugin(options), NoopPlugin(options)] : [];\n  return [].concat(androidPlugins, [beforePlugin], toConsumableArray(plugins), [afterPlugin]);\n}\n\nfunction RestoreDOMPlugin() {\n  /**\n   * Makes sure that on the next Content `render` the DOM is restored.\n   * This gets us around issues where the DOM is in a different state than\n   * React's virtual DOM and would crash.\n   *\n   * @param {Editor} editor\n   */\n  function restoreDOM(editor) {\n    var tmp = editor.tmp.contentRef.current.tmp;\n    tmp.contentKey = tmp.contentKey + 1;\n  }\n\n  return {\n    commands: {\n      restoreDOM: restoreDOM\n    }\n  };\n}\n/**\n * Takes a React Synthetic Event or a DOM Event and turns it into a String that\n * is easy to log. It's succinct and keeps info to a bare minimum.\n *\n * @param {Event} event\n */\n\n\nfunction stringifyEvent(event) {\n  var e = event.nativeEvent || event;\n\n  switch (e.type) {\n    case 'keydown':\n      return e.type + ' ' + JSON.stringify(e.key);\n\n    case 'input':\n    case 'beforeinput':\n    case 'textInput':\n      return e.type + ':' + e.inputType + ' ' + JSON.stringify(e.data);\n\n    default:\n      return e.type;\n  }\n}\n/**\n * Debug events function.\n *\n * @type {Function}\n */\n\n\nvar debug$6 = Debug('slate:events');\n/**\n * A plugin that sends short easy to digest debug info about each event to\n * browser.\n *\n * @return {Object}\n */\n\nfunction DebugEventsPlugin() {\n  /**\n   * Plugin Object\n   *\n   * @type {Object}\n   */\n  var plugin = {};\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = EVENT_HANDLERS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var eventName = _step.value;\n\n      plugin[eventName] = function (event, editor, next) {\n        var s = stringifyEvent(event);\n        debug$6(s);\n        next();\n      };\n    }\n    /**\n     * Return the plugin.\n     *\n     * @type {Object}\n     */\n\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return plugin;\n}\n/**\n * Constants\n */\n\n\nvar INTERVAL = 2000;\n/**\n * Debug events function.\n *\n * @type {Function}\n */\n\nvar debug$7 = Debug('slate:batch-events');\n/**\n * A plugin that sends short easy to digest debug info about each event to\n * browser.\n *\n * @return {Object}\n */\n\nfunction DebugBatchEventsPlugin() {\n  /**\n   * When the batch started\n   *\n   * @type {Date}\n   */\n  var startDate = null;\n  /**\n   * The timeoutId used to cancel the timeout\n   *\n   * @type {Any}\n   */\n\n  var timeoutId = null;\n  /**\n   * An array of events not yet dumped with `debug`\n   *\n   * @type {Array}\n   */\n\n  var events = [];\n  /**\n   * Send all events to debug\n   *\n   * Note: Formatted so it can easily be cut and pasted as text for analysis or\n   * documentation.\n   */\n\n  function dumpEvents() {\n    debug$7('\\n' + events.join('\\n'));\n    events.length = 0;\n  }\n  /**\n   * Push an event on to the Array of events for debugging in a batch\n   *\n   * @param {Event} event\n   */\n\n\n  function pushEvent(event) {\n    if (events.length === 0) {\n      startDate = new Date();\n    }\n\n    var s = stringifyEvent(event);\n    var now = new Date();\n    events.push('- ' + (now - startDate) + ' - ' + s);\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(dumpEvents, INTERVAL);\n  }\n  /**\n   * Plugin Object\n   *\n   * @type {Object}\n   */\n\n\n  var plugin = {};\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = EVENT_HANDLERS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var eventName = _step.value;\n\n      plugin[eventName] = function (event, editor, next) {\n        pushEvent(event);\n        next();\n      };\n    }\n    /**\n     * Return the plugin.\n     *\n     * @type {Object}\n     */\n\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return plugin;\n}\n/**\n * Debug mutations function.\n *\n * @type {Function}\n */\n\n\nvar debug$8 = Debug('slate:mutations');\n/**\n * Properties on a MutationRecord\n *\n * @type {Object}\n */\n\nvar MUTATION_PROPERTIES = ['type', 'oldValue', 'target', 'addedNodes', 'removedNodes', 'attributeName', 'attributeNamespace', 'nextSibling', 'previousSibling'];\n/**\n * Takes a DOM node and returns an easily readable version of it.\n *\n * @param {DOMNode} node\n */\n\nfunction normalizeNode(node) {\n  if (node.nodeType === window.Node.TEXT_NODE) {\n    return node.textContent;\n  } else if (node.nodeType === window.Node.ELEMENT_NODE) {\n    var outerHTML = node.outerHTML,\n        innerHTML = node.innerHTML;\n    if (outerHTML == null) return JSON.stringify(node.textContent);\n    return outerHTML.slice(0, outerHTML.indexOf(innerHTML));\n  } else {\n    return 'Node(type=' + node.nodeType;\n  }\n}\n/**\n * A plugin that sends short easy to digest debug info about each dom mutation\n * to browser.\n *\n * More information about mutations here:\n *\n * <https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver>\n * <https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord>\n *\n * @param {Object} options\n */\n\n\nfunction DebugMutationsPlugin() {\n  var observer = new window.MutationObserver(function (mutations) {\n    var array = Array.from(mutations).map(function (mutationRecord) {\n      var object = {}; // Only add properties that provide meaningful values to the object\n      // to make the debug info easier to read\n\n      MUTATION_PROPERTIES.forEach(function (key) {\n        var value = mutationRecord[key];\n        if (value == null) return; // Make NodeList easier to read\n\n        if (value instanceof window.NodeList) {\n          if (value.length === 0) return;\n          object[key] = Array.from(value).map(normalizeNode).join(', ');\n          return;\n        } // Make Node easier to read\n\n\n        if (value instanceof window.Node) {\n          value = normalizeNode(value);\n        }\n\n        object[key] = value;\n      });\n      return object;\n    }); // The first argument must not be the array as `debug` renders the first\n    // argument in a different way than the rest\n\n    debug$8.apply(undefined, [array.length + ' Mutations'].concat(toConsumableArray(array)));\n  });\n  /**\n   * The previously observed DOM node\n   *\n   * @type {DOMNode}\n   */\n\n  var prevRootEl = null;\n  /**\n   * Start observing the DOM node for mutations if it isn't being observed\n   */\n\n  function start(event, editor, next) {\n    var rootEl = editor.findDOMNode([]);\n    if (rootEl === prevRootEl) return next();\n    debug$8('start');\n    observer.observe(rootEl, {\n      childList: true,\n      characterData: true,\n      attributes: true,\n      subtree: true,\n      characterDataOldValue: true\n    });\n    prevRootEl = rootEl;\n    next();\n  }\n  /**\n   * Stop observing the DOM node for mutations\n   */\n\n\n  function stop(event, editor, next) {\n    debug$8('stop');\n    observer.disconnect();\n    prevRootEl = null;\n    next();\n  }\n\n  return {\n    onComponentDidMount: start,\n    onComponentDidUpdate: start,\n    onComponentWillUnmount: stop\n  };\n}\n/**\n * A plugin that adds the React-specific rendering logic to the editor.\n *\n * @param {Object} options\n * @return {Object}\n */\n\n\nfunction ReactPlugin() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _options$placeholder = options.placeholder,\n      placeholder = _options$placeholder === undefined ? '' : _options$placeholder;\n  var debugEventsPlugin = Debug.enabled('slate:events') ? DebugEventsPlugin(options) : null;\n  var debugBatchEventsPlugin = Debug.enabled('slate:batch-events') ? DebugBatchEventsPlugin(options) : null;\n  var debugMutationsPlugin = Debug.enabled('slate:mutations') ? DebugMutationsPlugin(options) : null;\n  var renderingPlugin = Rendering(options);\n  var commandsPlugin = CommandsPlugin(options);\n  var queriesPlugin = QueriesPlugin(options);\n  var editorPropsPlugin = EditorPropsPlugin(options);\n  var domPlugin = DOMPlugin(options);\n  var restoreDomPlugin = RestoreDOMPlugin(); // Disable placeholder for Android because it messes with reconciliation\n  // and doesn't disappear until composition is complete.\n  // e.g. In empty, type \"h\" and autocomplete on Android 9 and deletes all text.\n\n  var placeholderPlugin = IS_ANDROID ? null : PlaceholderPlugin({\n    placeholder: placeholder,\n    when: function when(editor, node) {\n      return node.object === 'document' && node.text === '' && node.nodes.size === 1 && Array.from(node.texts()).length === 1;\n    }\n  });\n  return [debugEventsPlugin, debugBatchEventsPlugin, debugMutationsPlugin, editorPropsPlugin, domPlugin, restoreDomPlugin, placeholderPlugin, renderingPlugin, commandsPlugin, queriesPlugin];\n}\n/**\n * Debug.\n *\n * @type {Function}\n */\n\n\nvar debug$9 = Debug('slate:editor');\n/**\n * Editor.\n *\n * @type {Component}\n */\n\nvar Editor$1 = function (_React$Component) {\n  inherits(Editor$$1, _React$Component);\n\n  function Editor$$1() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, Editor$$1);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Editor$$1.__proto__ || Object.getPrototypeOf(Editor$$1)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      value: _this.props.defaultValue,\n      contentKey: 0\n      /**\n       * Temporary values.\n       *\n       * @type {Object}\n       */\n\n    }, _this.tmp = {\n      mounted: false,\n      change: null,\n      resolves: 0,\n      updates: 0,\n      contentRef: React.createRef()\n      /**\n       * When the component first mounts, flush a queued change if one exists.\n       */\n\n    }, _this.resolveController = memoizeOne(function () {\n      var TheReactPlugin = arguments[5]; // If we've resolved a few times already, and it's exactly in line with\n      // the updates, then warn the user that they may be doing something wrong.\n\n      warning(_this.tmp.resolves < 5 || _this.tmp.resolves !== _this.tmp.updates, 'A Slate <Editor> component is re-resolving the `plugins`, `schema`, `commands`, `queries` or `placeholder` prop on each update, which leads to poor performance. This is often due to passing in a new references for these props with each render by declaring them inline in your render function. Do not do this! Declare them outside your render function, or memoize them instead.');\n      _this.tmp.resolves++;\n      var react = TheReactPlugin(_extends({}, _this.props, {\n        editor: _this,\n        value: _this.props.value || _this.state.value\n      }));\n\n      var onChange = function onChange(change) {\n        if (_this.tmp.mounted) {\n          _this.handleChange(change);\n        } else {\n          _this.tmp.change = change;\n        }\n      };\n\n      _this.controller = new Editor({\n        plugins: [react],\n        onChange: onChange\n      }, {\n        controller: _this,\n        construct: false\n      });\n\n      _this.controller.run('onConstruct');\n    }), _temp), possibleConstructorReturn(_this, _ret);\n  }\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Initial state.\n   *\n   * @type {Object}\n   */\n\n\n  createClass(Editor$$1, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.tmp.mounted = true;\n      this.tmp.updates++;\n\n      if (this.props.autoFocus) {\n        this.focus();\n      }\n\n      if (this.tmp.change) {\n        this.handleChange(this.tmp.change);\n        this.tmp.change = null;\n      }\n    }\n    /**\n     * When the component updates, flush a queued change if one exists.\n     */\n\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate() {\n      this.tmp.updates++;\n\n      if (this.tmp.change) {\n        this.handleChange(this.tmp.change);\n        this.tmp.change = null;\n      }\n    }\n    /**\n     * When the component unmounts, make sure async commands don't trigger react updates.\n     */\n\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      this.tmp.mounted = false;\n    }\n    /**\n     * Render the editor.\n     *\n     * @return {Element}\n     */\n\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      debug$9('render', this); // Re-resolve the controller if needed based on memoized props.\n\n      var _props = this.props,\n          commands = _props.commands,\n          placeholder = _props.placeholder,\n          plugins = _props.plugins,\n          queries = _props.queries,\n          schema = _props.schema;\n      this.resolveController(plugins, schema, commands, queries, placeholder, ReactPlugin); // Set the current props on the controller.\n\n      var _props2 = this.props,\n          options = _props2.options,\n          readOnly = _props2.readOnly,\n          valueFromProps = _props2.value;\n      var valueFromState = this.state.value;\n      var value = valueFromProps || valueFromState;\n      var contentKey = this.state.contentKey;\n      this.controller.setReadOnly(readOnly);\n      this.controller.setValue(value, options);\n      var _props3 = this.props,\n          autoCorrect = _props3.autoCorrect,\n          className = _props3.className,\n          id = _props3.id,\n          role = _props3.role,\n          spellCheck = _props3.spellCheck,\n          tabIndex = _props3.tabIndex,\n          style = _props3.style,\n          tagName = _props3.tagName;\n      var domProps = omit(this.props, Object.keys(Editor$$1.propTypes));\n      var children = React.createElement(Content, _extends({}, domProps, {\n        ref: this.tmp.contentRef,\n        autoCorrect: autoCorrect,\n        className: className,\n        contentKey: contentKey,\n        editor: this,\n        id: id,\n        onEvent: function onEvent(handler, event) {\n          return _this2.run(handler, event);\n        },\n        readOnly: readOnly,\n        role: role,\n        spellCheck: spellCheck,\n        style: style,\n        tabIndex: tabIndex,\n        tagName: tagName\n      })); // Render the editor's children with the controller.\n\n      var element = this.controller.run('renderEditor', _extends({}, this.props, {\n        editor: this,\n        children: children\n      }));\n      return element;\n    }\n    /**\n     * Resolve an editor controller from the passed-in props. This method takes\n     * all of the props as individual arguments to be able to properly memoize\n     * against anything that could change and invalidate the old editor.\n     *\n     * @param {Array} plugins\n     * @param {Object} schema\n     * @param {Object} commands\n     * @param {Object} queries\n     * @param {String} placeholder\n     * @return {Editor}\n     */\n\n  }, {\n    key: 'handleChange',\n    value: function handleChange(change) {\n      var onChange = this.props.onChange;\n      var value = this.state.value;\n\n      if (value) {\n        // Syncing value inside this component since parent does not want control of it (defaultValue was used)\n        this.setState({\n          value: change.value\n        });\n      }\n\n      onChange(change);\n    }\n    /**\n     * Mimic the API of the `Editor` controller, so that this component instance\n     * can be passed in its place to plugins.\n     */\n\n  }, {\n    key: 'applyOperation',\n    value: function applyOperation() {\n      var _controller;\n\n      return (_controller = this.controller).applyOperation.apply(_controller, arguments);\n    }\n  }, {\n    key: 'command',\n    value: function command() {\n      var _controller2;\n\n      return (_controller2 = this.controller).command.apply(_controller2, arguments);\n    }\n  }, {\n    key: 'hasCommand',\n    value: function hasCommand() {\n      var _controller3;\n\n      return (_controller3 = this.controller).hasCommand.apply(_controller3, arguments);\n    }\n  }, {\n    key: 'hasQuery',\n    value: function hasQuery() {\n      var _controller4;\n\n      return (_controller4 = this.controller).hasQuery.apply(_controller4, arguments);\n    }\n  }, {\n    key: 'normalize',\n    value: function normalize() {\n      var _controller5;\n\n      return (_controller5 = this.controller).normalize.apply(_controller5, arguments);\n    }\n  }, {\n    key: 'query',\n    value: function query() {\n      var _controller6;\n\n      return (_controller6 = this.controller).query.apply(_controller6, arguments);\n    }\n  }, {\n    key: 'registerCommand',\n    value: function registerCommand() {\n      var _controller7;\n\n      return (_controller7 = this.controller).registerCommand.apply(_controller7, arguments);\n    }\n  }, {\n    key: 'registerQuery',\n    value: function registerQuery() {\n      var _controller8;\n\n      return (_controller8 = this.controller).registerQuery.apply(_controller8, arguments);\n    }\n  }, {\n    key: 'run',\n    value: function run() {\n      var _controller9;\n\n      return (_controller9 = this.controller).run.apply(_controller9, arguments);\n    }\n  }, {\n    key: 'withoutNormalizing',\n    value: function withoutNormalizing() {\n      var _controller10;\n\n      return (_controller10 = this.controller).withoutNormalizing.apply(_controller10, arguments);\n    }\n    /**\n     * Deprecated.\n     */\n\n  }, {\n    key: 'call',\n    value: function call() {\n      var _controller11;\n\n      return (_controller11 = this.controller).call.apply(_controller11, arguments);\n    }\n  }, {\n    key: 'change',\n    value: function change() {\n      var _controller12;\n\n      return (_controller12 = this.controller).change.apply(_controller12, arguments);\n    }\n  }, {\n    key: 'onChange',\n    value: function onChange() {\n      var _controller13;\n\n      return (_controller13 = this.controller).onChange.apply(_controller13, arguments);\n    }\n  }, {\n    key: 'applyOperations',\n    value: function applyOperations() {\n      var _controller14;\n\n      return (_controller14 = this.controller).applyOperations.apply(_controller14, arguments);\n    }\n  }, {\n    key: 'setOperationFlag',\n    value: function setOperationFlag() {\n      var _controller15;\n\n      return (_controller15 = this.controller).setOperationFlag.apply(_controller15, arguments);\n    }\n  }, {\n    key: 'getFlag',\n    value: function getFlag() {\n      var _controller16;\n\n      return (_controller16 = this.controller).getFlag.apply(_controller16, arguments);\n    }\n  }, {\n    key: 'unsetOperationFlag',\n    value: function unsetOperationFlag() {\n      var _controller17;\n\n      return (_controller17 = this.controller).unsetOperationFlag.apply(_controller17, arguments);\n    }\n  }, {\n    key: 'withoutNormalization',\n    value: function withoutNormalization() {\n      var _controller18;\n\n      return (_controller18 = this.controller).withoutNormalization.apply(_controller18, arguments);\n    }\n  }, {\n    key: 'operations',\n    get: function get$$1() {\n      return this.controller.operations;\n    }\n  }, {\n    key: 'readOnly',\n    get: function get$$1() {\n      return this.controller.readOnly;\n    }\n  }, {\n    key: 'value',\n    get: function get$$1() {\n      return this.controller.value;\n    }\n  }, {\n    key: 'editor',\n    get: function get$$1() {\n      return this.controller.editor;\n    }\n  }, {\n    key: 'schema',\n    get: function get$$1() {\n      invariant(false, 'As of Slate 0.42, the `editor.schema` property no longer exists, and its functionality has been folded into the editor itself. Use the `editor` instead.');\n    }\n  }, {\n    key: 'stack',\n    get: function get$$1() {\n      invariant(false, 'As of Slate 0.42, the `editor.stack` property no longer exists, and its functionality has been folded into the editor itself. Use the `editor` instead.');\n    }\n  }]);\n  return Editor$$1;\n}(React.Component);\n/**\n * Export.\n *\n * @type {Component}\n */\n\n\nEditor$1.propTypes = _extends({\n  autoCorrect: Types.bool,\n  autoFocus: Types.bool,\n  className: Types.string,\n  defaultValue: SlateTypes.value,\n  id: Types.string,\n  onChange: Types.func,\n  options: Types.object,\n  placeholder: Types.any,\n  plugins: Types.array,\n  readOnly: Types.bool,\n  role: Types.string,\n  schema: Types.object,\n  spellCheck: Types.bool,\n  style: Types.object,\n  tabIndex: Types.number,\n  value: SlateTypes.value\n}, EVENT_HANDLERS.reduce(function (obj, handler) {\n  obj[handler] = Types.func;\n  return obj;\n}, {}), OTHER_HANDLERS.reduce(function (obj, handler) {\n  obj[handler] = Types.func;\n  return obj;\n}, {}));\nEditor$1.defaultProps = {\n  autoFocus: false,\n  autoCorrect: true,\n  onChange: function onChange() {},\n  options: {},\n  placeholder: '',\n  plugins: [],\n  readOnly: false,\n  schema: {},\n  spellCheck: true\n};\n/**\n * Find the DOM node for a `key`.\n *\n * @param {String|Node} key\n * @param {Window} win (optional)\n * @return {Element}\n */\n\nfunction findDOMNode(key) {\n  var win = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n  warning(false, 'As of slate-react@0.22 the `findDOMNode(key)` helper is deprecated in favor of `editor.findDOMNode(path)`.');\n\n  if (Node.isNode(key)) {\n    key = key.key;\n  }\n\n  var el = win.document.querySelector('[' + DATA_ATTRS.KEY + '=\"' + key + '\"]');\n\n  if (!el) {\n    throw new Error('Unable to find a DOM node for \"' + key + '\". This is often because of forgetting to add `props.attributes` to a custom component.');\n  }\n\n  return el;\n}\n/**\n * Find a native DOM selection point from a Slate `point`.\n *\n * @param {Point} point\n * @param {Window} win (optional)\n * @return {Object|Null}\n */\n\n\nfunction findDOMPoint(point) {\n  var win = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n  warning(false, 'As of slate-react@0.22 the `findDOMPoint(point)` helper is deprecated in favor of `editor.findDOMPoint(point)`.');\n  var el = findDOMNode(point.key, win);\n  var start = 0; // For each leaf, we need to isolate its content, which means filtering to its\n  // direct text and zero-width spans. (We have to filter out any other siblings\n  // that may have been rendered alongside them.)\n\n  var texts = Array.from(el.querySelectorAll(SELECTORS.STRING + ', ' + SELECTORS.ZERO_WIDTH));\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = texts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var text = _step.value;\n      var node = text.childNodes[0];\n      var domLength = node.textContent.length;\n      var slateLength = domLength;\n\n      if (text.hasAttribute(DATA_ATTRS.LENGTH)) {\n        slateLength = parseInt(text.getAttribute(DATA_ATTRS.LENGTH), 10);\n      }\n\n      var end = start + slateLength;\n\n      if (point.offset <= end) {\n        var offset = Math.min(domLength, Math.max(0, point.offset - start));\n        return {\n          node: node,\n          offset: offset\n        };\n      }\n\n      start = end;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return null;\n}\n/**\n * Find a native DOM range Slate `range`.\n *\n * @param {Range} range\n * @param {Window} win (optional)\n * @return {Object|Null}\n */\n\n\nfunction findDOMRange(range) {\n  var win = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n  warning(false, 'As of slate-react@0.22 the `findDOMRange(range)` helper is deprecated in favor of `editor.findDOMRange(range)`.');\n  var anchor = range.anchor,\n      focus = range.focus,\n      isBackward$$1 = range.isBackward,\n      isCollapsed = range.isCollapsed;\n  var domAnchor = findDOMPoint(anchor, win);\n  var domFocus = isCollapsed ? domAnchor : findDOMPoint(focus, win);\n  if (!domAnchor || !domFocus) return null;\n  var r = win.document.createRange();\n  var start = isBackward$$1 ? domFocus : domAnchor;\n  var end = isBackward$$1 ? domAnchor : domFocus;\n  r.setStart(start.node, start.offset);\n  r.setEnd(end.node, end.offset);\n  return r;\n}\n/**\n * Find a Slate node from a DOM `element`.\n *\n * @param {Element} element\n * @param {Editor} editor\n * @return {Node|Null}\n */\n\n\nfunction findNode(element, editor) {\n  warning(false, 'As of slate-react@0.22 the `findNode(element)` helper is deprecated in favor of `editor.findNode(element)`.');\n  invariant(!Value.isValue(editor), 'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.');\n  var closest = element.closest(SELECTORS.KEY);\n  if (!closest) return null;\n  var key = closest.getAttribute(DATA_ATTRS.KEY);\n  if (!key) return null;\n  var value = editor.value;\n  var document = value.document;\n  var node = document.getNode(key);\n  return node || null;\n}\n/**\n * Find a Slate path from a DOM `element`.\n *\n * @param {Element} element\n * @param {Editor} editor\n * @return {List|Null}\n */\n\n\nfunction findPath(element, editor) {\n  warning(false, 'As of slate-react@0.22 the `findPath(element)` helper is deprecated in favor of `editor.findPath(element)`.');\n  var node = findNode(element, editor);\n\n  if (!node) {\n    return null;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var path = document.getPath(node);\n  return path;\n}\n/**\n * Find a Slate point from a DOM selection's `nativeNode` and `nativeOffset`.\n *\n * @param {Element} nativeNode\n * @param {Number} nativeOffset\n * @param {Editor} editor\n * @return {Point}\n */\n\n\nfunction findPoint(nativeNode, nativeOffset, editor) {\n  warning(false, 'As of slate-react@0.22 the `findPoint(node, offset)` helper is deprecated in favor of `editor.findPoint(node, offset)`.');\n  invariant(!Value.isValue(editor), 'As of Slate 0.42.0, the `findPoint` utility takes an `editor` instead of a `value`.');\n\n  var _normalizeNodeAndOffs = normalizeNodeAndOffset$1(nativeNode, nativeOffset),\n      nearestNode = _normalizeNodeAndOffs.node,\n      nearestOffset = _normalizeNodeAndOffs.offset;\n\n  var window = getWindow(nativeNode);\n  var parentNode = nearestNode.parentNode;\n  var rangeNode = parentNode.closest(SELECTORS.LEAF);\n  var offset = void 0;\n  var node = void 0; // Calculate how far into the text node the `nearestNode` is, so that we can\n  // determine what the offset relative to the text node is.\n\n  if (rangeNode) {\n    var range = window.document.createRange();\n    var textNode = rangeNode.closest(SELECTORS.TEXT);\n    range.setStart(textNode, 0);\n    range.setEnd(nearestNode, nearestOffset);\n    node = textNode; // COMPAT: Edge has a bug where Range.prototype.toString() will convert \\n\n    // into \\r\\n. The bug causes a loop when slate-react attempts to reposition\n    // its cursor to match the native position. Use textContent.length instead.\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n\n    var fragment = range.cloneContents();\n    var zeroWidthNodes = fragment.querySelectorAll('[' + DATA_ATTRS.ZERO_WIDTH + ']');\n    offset = fragment.textContent.length - zeroWidthNodes.length;\n  } else {\n    // For void nodes, the element with the offset key will be a cousin, not an\n    // ancestor, so find it by going down from the nearest void parent.\n    var voidNode = parentNode.closest(SELECTORS.VOID);\n    if (!voidNode) return null;\n    rangeNode = voidNode.querySelector(SELECTORS.LEAF);\n    if (!rangeNode) return null;\n    node = rangeNode;\n    offset = node.textContent.length;\n  } // COMPAT: If the parent node is a Slate zero-width space, this is because the\n  // text node should have no characters. However, during IME composition the\n  // ASCII characters will be prepended to the zero-width space, so subtract 1\n  // from the offset to account for the zero-width space character.\n\n\n  if (offset === node.textContent.length && parentNode.hasAttribute(DATA_ATTRS.ZERO_WIDTH)) {\n    offset--;\n  } // Get the string value of the offset key attribute.\n\n\n  var offsetKey = rangeNode.getAttribute(DATA_ATTRS.OFFSET_KEY);\n  if (!offsetKey) return null;\n\n  var _OffsetKey$parse = OffsetKey.parse(offsetKey),\n      key = _OffsetKey$parse.key; // COMPAT: If someone is clicking from one Slate editor into another, the\n  // select event fires twice, once for the old editor's `element` first, and\n  // then afterwards for the correct `element`. (2017/03/03)\n\n\n  var value = editor.value;\n  if (!value.document.hasDescendant(key)) return null;\n  var point = value.document.createPoint({\n    key: key,\n    offset: offset\n  });\n  return point;\n}\n/**\n * From a DOM selection's `node` and `offset`, normalize so that it always\n * refers to a text node.\n *\n * @param {Element} node\n * @param {Number} offset\n * @return {Object}\n */\n\n\nfunction normalizeNodeAndOffset$1(node, offset) {\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (node.nodeType === 1 && node.childNodes.length) {\n    var isLast = offset === node.childNodes.length;\n    var direction = isLast ? 'backward' : 'forward';\n    var index = isLast ? offset - 1 : offset;\n    node = getEditableChild$1(node, index, direction); // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n\n    while (node.nodeType === 1 && node.childNodes.length) {\n      var i = isLast ? node.childNodes.length - 1 : 0;\n      node = getEditableChild$1(node, i, direction);\n    } // Determine the new offset inside the text node.\n\n\n    offset = isLast ? node.textContent.length : 0;\n  } // Return the node and offset.\n\n\n  return {\n    node: node,\n    offset: offset\n  };\n}\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n *\n * @param {Element} parent\n * @param {Number} index\n * @param {String} direction ('forward' or 'backward')\n * @return {Element|Null}\n */\n\n\nfunction getEditableChild$1(parent, index, direction) {\n  var childNodes = parent.childNodes;\n  var child = childNodes[index];\n  var i = index;\n  var triedForward = false;\n  var triedBackward = false; // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n\n  while (child.nodeType === 8 || child.nodeType === 1 && child.childNodes.length === 0 || child.nodeType === 1 && child.getAttribute('contenteditable') === 'false') {\n    if (triedForward && triedBackward) break;\n\n    if (i >= childNodes.length) {\n      triedForward = true;\n      i = index - 1;\n      direction = 'backward';\n      continue;\n    }\n\n    if (i < 0) {\n      triedBackward = true;\n      i = index + 1;\n      direction = 'forward';\n      continue;\n    }\n\n    child = childNodes[i];\n    if (direction === 'forward') i++;\n    if (direction === 'backward') i--;\n  }\n\n  return child || null;\n}\n/**\n * Find a Slate range from a DOM `native` selection.\n *\n * @param {Selection} native\n * @param {Editor} editor\n * @return {Range}\n */\n\n\nfunction findRange(native, editor) {\n  warning(false, 'As of slate-react@0.22 the `findRange(selection)` helper is deprecated in favor of `editor.findRange(selection)`.');\n  invariant(!Value.isValue(editor), 'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.');\n  var el = native.anchorNode || native.startContainer;\n  if (!el) return null;\n  var window = getWindow(el); // If the `native` object is a DOM `Range` or `StaticRange` object, change it\n  // into something that looks like a DOM `Selection` instead.\n\n  if (native instanceof window.Range || window.StaticRange && native instanceof window.StaticRange) {\n    native = {\n      anchorNode: native.startContainer,\n      anchorOffset: native.startOffset,\n      focusNode: native.endContainer,\n      focusOffset: native.endOffset\n    };\n  }\n\n  var _native = native,\n      anchorNode = _native.anchorNode,\n      anchorOffset = _native.anchorOffset,\n      focusNode = _native.focusNode,\n      focusOffset = _native.focusOffset,\n      isCollapsed = _native.isCollapsed;\n  var value = editor.value;\n  var anchor = findPoint(anchorNode, anchorOffset, editor);\n  var focus = isCollapsed ? anchor : findPoint(focusNode, focusOffset, editor);\n  if (!anchor || !focus) return null;\n  var document = value.document;\n  var range = document.createRange({\n    anchor: anchor,\n    focus: focus\n  });\n  return range;\n}\n/**\n * Get the target range from a DOM `event`.\n *\n * @param {Event} event\n * @param {Editor} editor\n * @return {Range}\n */\n\n\nfunction getEventRange(event, editor) {\n  warning(false, 'As of slate-react@0.22 the `getEventRange(event, editor)` helper is deprecated in favor of `editor.findEventRange(event)`.');\n  invariant(!Value.isValue(editor), 'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.');\n\n  if (event.nativeEvent) {\n    event = event.nativeEvent;\n  }\n\n  var _event = event,\n      x = _event.clientX,\n      y = _event.clientY,\n      target = _event.target;\n  if (x == null || y == null) return null;\n  var value = editor.value;\n  var document = value.document;\n  var path = findPath(event.target, editor);\n  if (!path) return null;\n  var node = document.getNode(path); // If the drop target is inside a void node, move it into either the next or\n  // previous node, depending on which side the `x` and `y` coordinates are\n  // closest to.\n\n  if (editor.isVoid(node)) {\n    var rect = target.getBoundingClientRect();\n    var isPrevious = node.object === 'inline' ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\n\n    var _range = document.createRange();\n\n    var move = isPrevious ? 'moveToEndOfNode' : 'moveToStartOfNode';\n    var entry = document[isPrevious ? 'getPreviousText' : 'getNextText'](path);\n\n    if (entry) {\n      return _range[move](entry);\n    }\n\n    return null;\n  } // Else resolve a range from the caret position where the drop occured.\n\n\n  var window = getWindow(target);\n  var native = void 0; // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n\n  if (window.document.caretRangeFromPoint) {\n    native = window.document.caretRangeFromPoint(x, y);\n  } else if (window.document.caretPositionFromPoint) {\n    var position = window.document.caretPositionFromPoint(x, y);\n    native = window.document.createRange();\n    native.setStart(position.offsetNode, position.offset);\n    native.setEnd(position.offsetNode, position.offset);\n  } else if (window.document.body.createTextRange) {\n    // COMPAT: In IE, `caretRangeFromPoint` and\n    // `caretPositionFromPoint` don't exist. (2018/07/11)\n    native = window.document.body.createTextRange();\n\n    try {\n      native.moveToPoint(x, y);\n    } catch (error) {\n      // IE11 will raise an `unspecified error` if `moveToPoint` is\n      // called during a dropEvent.\n      return null;\n    }\n  } // Resolve a Slate range from the DOM range.\n\n\n  var range = findRange(native, editor);\n  if (!range) return null;\n  return range;\n}\n\nvar index = {\n  Editor: Editor$1,\n  cloneFragment: cloneFragment,\n  findDOMNode: findDOMNode,\n  findDOMPoint: findDOMPoint,\n  findDOMRange: findDOMRange,\n  findNode: findNode,\n  findPath: findPath,\n  findPoint: findPoint,\n  findRange: findRange,\n  getEventRange: getEventRange,\n  getEventTransfer: getEventTransfer,\n  setEventTransfer: setEventTransfer,\n  ReactPlugin: ReactPlugin\n};\nexport default index;\nexport { Editor$1 as Editor, cloneFragment, findDOMNode, findDOMPoint, findDOMRange, findNode, findPath, findPoint, findRange, getEventRange, getEventTransfer, setEventTransfer, ReactPlugin };","map":{"version":3,"sources":["../src/constants/event-handlers.js","../src/constants/other-handlers.js","../src/constants/data-attributes.js","../src/constants/selectors.js","../src/utils/offset-key.js","../src/components/leaf.js","../src/components/text.js","../src/components/void.js","../src/components/node.js","../src/utils/scroll-to-selection.js","../src/utils/remove-all-ranges.js","../src/components/content.js","../src/plugins/react/editor-props.js","../src/plugins/react/rendering.js","../src/plugins/react/commands.js","../src/plugins/react/queries.js","../src/plugins/android/diff-text.js","../src/plugins/android/composition-manager.js","../src/plugins/android/index.js","../src/plugins/debug/noop.js","../src/constants/transfer-types.js","../src/utils/clone-fragment.js","../src/utils/get-event-transfer.js","../src/utils/set-event-transfer.js","../src/plugins/dom/after.js","../src/plugins/dom/before.js","../src/plugins/dom/index.js","../src/plugins/react/restore-dom.js","../src/plugins/debug/stringify-event.js","../src/plugins/debug/debug-events.js","../src/plugins/debug/debug-batch-events.js","../src/plugins/debug/debug-mutations.js","../src/plugins/react/index.js","../src/components/editor.js","../src/utils/find-dom-node.js","../src/utils/find-dom-point.js","../src/utils/find-dom-range.js","../src/utils/find-node.js","../src/utils/find-path.js","../src/utils/find-point.js","../src/utils/find-range.js","../src/utils/get-event-range.js","../src/index.js"],"names":["EVENT_HANDLERS","OTHER_HANDLERS","DATA_ATTRS","PARSER","matches","original","key","index","parseInt","object","TextString","text","isTrailing","ZeroWidthString","length","isLineBreak","Leaf","marks","annotations","decorations","node","offset","editor","parent","block","leaves","props","offsetKey","children","lastText","lastChar","isLastText","isLastLeaf","renderProps","mark","ret","decoration","annotation","attrs","ImmutableTypes","SlateTypes","Types","isRequired","MemoizedLeaf","next","prev","Text","style","at","leaf","MemoizedText","debug","Debug","Void","React","Component","propTypes","args","type","id","readOnly","Tag","spacerAttrs","spacer","content","renderText","textRef","child","Node","tmp","ref","nextProps","shouldUpdate","n","p","selection","newDecorations","sel","getRelativeRange","decs","anns","attributes","direction","render","element","range","start","end","startPath","endPath","startIndex","endIndex","PathUtils","first","firstNode","firstPath","last","lastNode","lastPath","OVERFLOWS","IS_IOS_11","IS_IOS","window","el","scroller","overflowY","getWindow","findScrollContainer","isWindow","backward","isBackward","cursorRect","width","height","yOffset","xOffset","scrollerTop","scrollerLeft","scrollerBordersY","scrollerBordersX","scrollerPaddingTop","scrollerPaddingBottom","scrollerPaddingLeft","scrollerPaddingRight","innerWidth","innerHeight","pageYOffset","pageXOffset","offsetWidth","offsetHeight","scrollTop","scrollLeft","borderTopWidth","borderBottomWidth","borderLeftWidth","borderRightWidth","paddingTop","paddingBottom","paddingLeft","paddingRight","scrollerRect","cursorTop","cursorLeft","x","y","FIREFOX_NODE_TYPE_ACCESS_ERROR","Content","defaultProps","error","info","setRef","handlers","updateSelection","value","native","activeElement","rangeCount","anchorNode","updated","propsToCompare","selectionsEqual","prop","preventScroll","current","startContainer","startOffset","endContainer","endOffset","IS_FIREFOX","anchorOffset","focusOffset","isInEditor","target","err","SELECTORS","handler","event","nativeEvent","isUndoRedo","Hotkeys","domSelection","closest","onNativeSelectionChange","className","tabIndex","role","tagName","spellCheck","Container","document","WebkitUserModify","data","domProps","omit","Object","contentKey","List","nodeRef","PROPS","options","plugin","memo","position","path","domElement","domText","isLastNode","entire","domNode","search","instance","rest","point","texts","Array","domLength","slateLength","Math","anchor","focus","isCollapsed","domAnchor","domFocus","r","rect","isPrevious","move","entry","nodeElement","nodeRefs","keys","i","nearestNode","nearestOffset","normalizeNodeAndOffset","parentNode","leafNode","textNode","contents","zeroWidths","voidNode","domRange","focusNode","anchorText","focusText","anchorInline","focusInline","focusBlock","anchorBlock","depth","relativePath","nextPath","absolutePath","isLast","getEditableChild","childNodes","triedForward","triedBackward","prevLength","nextLength","prevChar","nextChar","getDiffStart","maxEnd","getDiffEnd","total","offsets","getDiffOffsets","insertText","sliceText","removeText","ZERO_WIDTH_SPACE","String","flushControlled","ReactDOM","prevOffset","nextOffset","nextText","maxOffset","observer","win","rootEl","diff","onSelectTimeoutId","bufferedMutations","startActionFrameId","isFlushing","mutations","splitBlockMutation","m","addedNode","dataset","firstMutation","dataElement","prevText","fix","fixTextAndOffset","diffText","nodeSelection","anchorFix","focusFix","normalizeDOMSelection","isZeroWidth","eventName","FRAGMENT","HTML","TEXT","TRANSFER_TYPES","callback","Value","fragment","startVoid","endVoid","encoded","Base64","attach","isNewline","zw","span","valFromSelection","plainText","Plain","div","editorEl","NODE","RICH","FRAGMENT_MATCHER","transfer","getType","html","rich","files","full","embeddedTypes","getEmbeddedTypes","item","getTransferType","prefix","JSON","types","mime","obj","string","isDraggingInternally","isMouseDown","isSynthetic","targetRange","hasVoidParent","ancestors","isVoid","voidPath","selectionIncludesNode","getEventTransfer","draggedRange","nxt","startText","prevEntry","isPrevInVoid","prevPath","nextEntry","isNextInVoid","startBlock","defaultBlock","defaultMarks","frag","compositionCount","isComposing","isCopying","isDragging","isUserActionPerformed","relatedTarget","userActionPerformed","clearUserActionPerformed","plugins","beforePlugin","BeforePlugin","afterPlugin","AfterPlugin","androidPlugins","IS_ANDROID","AndroidPlugin","NoopPlugin","e","s","stringifyEvent","INTERVAL","startDate","timeoutId","events","now","setTimeout","MUTATION_PROPERTIES","outerHTML","innerHTML","array","mutationRecord","normalizeNode","prevRootEl","stop","placeholder","debugEventsPlugin","DebugEventsPlugin","debugBatchEventsPlugin","DebugBatchEventsPlugin","debugMutationsPlugin","DebugMutationsPlugin","renderingPlugin","RenderingPlugin","commandsPlugin","CommandsPlugin","queriesPlugin","QueriesPlugin","editorPropsPlugin","EditorPropsPlugin","domPlugin","DOMPlugin","restoreDomPlugin","RestoreDOMPlugin","placeholderPlugin","Editor","bool","func","any","number","state","commands","queries","schema","valueFromProps","valueFromState","autoCorrect","resolveController","TheReactPlugin","react","onChange","controller","construct","change","findDOMNode","findDOMPoint","findNode","rangeNode","zeroWidthNodes","OffsetKey","findPoint","findPath","findRange"],"mappings":"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","sourcesContent":["/**\n * Event handlers used by Slate plugins.\n *\n * @type {Array}\n */\n\nconst EVENT_HANDLERS = [\n  'onBeforeInput',\n  'onBlur',\n  'onClick',\n  'onContextMenu',\n  'onCompositionEnd',\n  'onCompositionStart',\n  'onCopy',\n  'onCut',\n  'onDragEnd',\n  'onDragEnter',\n  'onDragExit',\n  'onDragLeave',\n  'onDragOver',\n  'onDragStart',\n  'onDrop',\n  'onInput',\n  'onFocus',\n  'onKeyDown',\n  'onKeyUp',\n  'onMouseDown',\n  'onMouseUp',\n  'onPaste',\n  'onSelect',\n]\n\n/**\n * Export.\n *\n * @type {Array}\n */\n\nexport default EVENT_HANDLERS\n","/**\n * Other handlers used by Slate plugins.\n *\n * @type {Array}\n */\n\nconst OTHER_HANDLERS = [\n  'decorateNode',\n  'renderAnnotation',\n  'renderBlock',\n  'renderDecoration',\n  'renderDocument',\n  'renderEditor',\n  'renderInline',\n  'renderMark',\n]\n\n/**\n * Export.\n *\n * @type {Array}\n */\n\nexport default OTHER_HANDLERS\n","/**\n * DOM data attribute strings that refer to Slate concepts.\n *\n * @type {String}\n */\n\nexport default {\n  EDITOR: 'data-slate-editor',\n  FRAGMENT: 'data-slate-fragment',\n  KEY: 'data-key',\n  LEAF: 'data-slate-leaf',\n  LENGTH: 'data-slate-length',\n  OBJECT: 'data-slate-object',\n  OFFSET_KEY: 'data-offset-key',\n  SPACER: 'data-slate-spacer',\n  STRING: 'data-slate-string',\n  TEXT: 'data-slate-object',\n  VOID: 'data-slate-void',\n  ZERO_WIDTH: 'data-slate-zero-width',\n}\n","import DATA_ATTRS from './data-attributes'\n\n/**\n * DOM selector strings that refer to Slate concepts.\n *\n * @type {String}\n */\n\nexport default {\n  BLOCK: `[${DATA_ATTRS.OBJECT}=\"block\"]`,\n  EDITOR: `[${DATA_ATTRS.EDITOR}]`,\n  INLINE: `[${DATA_ATTRS.OBJECT}=\"inline\"]`,\n  KEY: `[${DATA_ATTRS.KEY}]`,\n  LEAF: `[${DATA_ATTRS.LEAF}]`,\n  OBJECT: `[${DATA_ATTRS.OBJECT}]`,\n  STRING: `[${DATA_ATTRS.STRING}]`,\n  TEXT: `[${DATA_ATTRS.OBJECT}=\"text\"]`,\n  VOID: `[${DATA_ATTRS.VOID}]`,\n  ZERO_WIDTH: `[${DATA_ATTRS.ZERO_WIDTH}]`,\n}\n","/**\n * Offset key parser regex.\n *\n * @type {RegExp}\n */\n\nconst PARSER = /^([\\w-]+)(?::(\\d+))?$/\n\n/**\n * Parse an offset key `string`.\n *\n * @param {String} string\n * @return {Object}\n */\n\nfunction parse(string) {\n  const matches = PARSER.exec(string)\n\n  if (!matches) {\n    throw new Error(`Invalid offset key string \"${string}\".`)\n  }\n\n  const [original, key, index] = matches // eslint-disable-line no-unused-vars\n  return {\n    key,\n    index: parseInt(index, 10),\n  }\n}\n\n/**\n * Stringify an offset key `object`.\n *\n * @param {Object} object\n *   @property {String} key\n *   @property {Number} index\n * @return {String}\n */\n\nfunction stringify(object) {\n  return `${object.key}:${object.index}`\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  parse,\n  stringify,\n}\n","import React from 'react'\nimport Types from 'prop-types'\nimport SlateTypes from 'slate-prop-types'\nimport ImmutableTypes from 'react-immutable-proptypes'\n\nimport OffsetKey from '../utils/offset-key'\nimport DATA_ATTRS from '../constants/data-attributes'\n\n/**\n * Leaf strings with text in them.\n *\n * @type {Component}\n */\n\nconst TextString = ({ text = '', isTrailing = false }) => {\n  return (\n    <span\n      {...{\n        [DATA_ATTRS.STRING]: true,\n      }}\n    >\n      {text}\n      {isTrailing ? '\\n' : null}\n    </span>\n  )\n}\n\n/**\n * Leaf strings without text, render as zero-width strings.\n *\n * @type {Component}\n */\n\nconst ZeroWidthString = ({ length = 0, isLineBreak = false }) => {\n  return (\n    <span\n      {...{\n        [DATA_ATTRS.ZERO_WIDTH]: isLineBreak ? 'n' : 'z',\n        [DATA_ATTRS.LENGTH]: length,\n      }}\n    >\n      {'\\uFEFF'}\n      {isLineBreak ? <br /> : null}\n    </span>\n  )\n}\n\n/**\n * Individual leaves in a text node with unique formatting.\n *\n * @type {Component}\n */\n\nconst Leaf = props => {\n  const {\n    marks,\n    annotations,\n    decorations,\n    node,\n    index,\n    offset,\n    text,\n    editor,\n    parent,\n    block,\n    leaves,\n  } = props\n\n  const offsetKey = OffsetKey.stringify({\n    key: node.key,\n    index,\n  })\n\n  let children\n\n  if (editor.query('isVoid', parent)) {\n    // COMPAT: Render text inside void nodes with a zero-width space.\n    // So the node can contain selection but the text is not visible.\n    children = <ZeroWidthString length={parent.text.length} />\n  } else if (\n    text === '' &&\n    parent.object === 'block' &&\n    parent.text === '' &&\n    parent.nodes.last() === node\n  ) {\n    // COMPAT: If this is the last text node in an empty block, render a zero-\n    // width space that will convert into a line break when copying and pasting\n    // to support expected plain text.\n    children = <ZeroWidthString isLineBreak />\n  } else if (text === '') {\n    // COMPAT: If the text is empty, it's because it's on the edge of an inline\n    // node, so we render a zero-width space so that the selection can be\n    // inserted next to it still.\n    children = <ZeroWidthString />\n  } else {\n    // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n    // so we need to add an extra trailing new lines to prevent that.\n    const lastText = block.getLastText()\n    const lastChar = text.charAt(text.length - 1)\n    const isLastText = node === lastText\n    const isLastLeaf = index === leaves.size - 1\n\n    if (isLastText && isLastLeaf && lastChar === '\\n') {\n      children = <TextString isTrailing text={text} />\n    } else {\n      children = <TextString text={text} />\n    }\n  }\n\n  const renderProps = {\n    editor,\n    marks,\n    annotations,\n    decorations,\n    node,\n    offset,\n    text,\n  }\n\n  // COMPAT: Having the `data-` attributes on these leaf elements ensures that\n  // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\n  // contenteditable behaviors. (2019/05/08)\n  for (const mark of marks) {\n    const ret = editor.run('renderMark', {\n      ...renderProps,\n      mark,\n      children,\n      attributes: {\n        [DATA_ATTRS.OBJECT]: 'mark',\n      },\n    })\n\n    if (ret) {\n      children = ret\n    }\n  }\n\n  for (const decoration of decorations) {\n    const ret = editor.run('renderDecoration', {\n      ...renderProps,\n      decoration,\n      children,\n      attributes: {\n        [DATA_ATTRS.OBJECT]: 'decoration',\n      },\n    })\n\n    if (ret) {\n      children = ret\n    }\n  }\n\n  for (const annotation of annotations) {\n    const ret = editor.run('renderAnnotation', {\n      ...renderProps,\n      annotation,\n      children,\n      attributes: {\n        [DATA_ATTRS.OBJECT]: 'annotation',\n      },\n    })\n\n    if (ret) {\n      children = ret\n    }\n  }\n\n  const attrs = {\n    [DATA_ATTRS.LEAF]: true,\n    [DATA_ATTRS.OFFSET_KEY]: offsetKey,\n  }\n\n  return <span {...attrs}>{children}</span>\n}\n\n/**\n * Prop types.\n *\n * @type {Object}\n */\n\nLeaf.propTypes = {\n  annotations: ImmutableTypes.list.isRequired,\n  block: SlateTypes.block.isRequired,\n  decorations: ImmutableTypes.list.isRequired,\n  editor: Types.object.isRequired,\n  index: Types.number.isRequired,\n  leaves: Types.object.isRequired,\n  marks: SlateTypes.marks.isRequired,\n  node: SlateTypes.node.isRequired,\n  offset: Types.number.isRequired,\n  parent: SlateTypes.node.isRequired,\n  text: Types.string.isRequired,\n}\n\n/**\n * A memoized version of `Leaf` that updates less frequently.\n *\n * @type {Component}\n */\n\nconst MemoizedLeaf = React.memo(Leaf, (prev, next) => {\n  return (\n    next.block === prev.block &&\n    next.index === prev.index &&\n    next.marks === prev.marks &&\n    next.parent === prev.parent &&\n    next.text === prev.text &&\n    next.annotations.equals(prev.annotations) &&\n    next.decorations.equals(prev.decorations)\n  )\n})\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default MemoizedLeaf\n","import ImmutableTypes from 'react-immutable-proptypes'\nimport React from 'react'\nimport SlateTypes from 'slate-prop-types'\nimport Types from 'prop-types'\n\nimport Leaf from './leaf'\nimport DATA_ATTRS from '../constants/data-attributes'\n\n/**\n * Text node.\n *\n * @type {Component}\n */\n\nconst Text = React.forwardRef((props, ref) => {\n  const { annotations, block, decorations, node, parent, editor, style } = props\n  const { key } = node\n  const leaves = node.getLeaves(annotations, decorations)\n  let at = 0\n\n  return (\n    <span\n      ref={ref}\n      style={style}\n      {...{\n        [DATA_ATTRS.OBJECT]: node.object,\n        [DATA_ATTRS.KEY]: key,\n      }}\n    >\n      {leaves.map((leaf, index) => {\n        const { text } = leaf\n        const offset = at\n        at += text.length\n\n        return (\n          <Leaf\n            key={`${node.key}-${index}`}\n            block={block}\n            editor={editor}\n            index={index}\n            annotations={leaf.annotations}\n            decorations={leaf.decorations}\n            marks={leaf.marks}\n            node={node}\n            offset={offset}\n            parent={parent}\n            leaves={leaves}\n            text={text}\n          />\n        )\n      })}\n    </span>\n  )\n})\n\n/**\n * Prop types.\n *\n * @type {Object}\n */\n\nText.propTypes = {\n  annotations: ImmutableTypes.map.isRequired,\n  block: SlateTypes.block,\n  decorations: ImmutableTypes.list.isRequired,\n  editor: Types.object.isRequired,\n  node: SlateTypes.node.isRequired,\n  parent: SlateTypes.node.isRequired,\n  style: Types.object,\n}\n\n/**\n * A memoized version of `Text` that updates less frequently.\n *\n * @type {Component}\n */\n\nconst MemoizedText = React.memo(Text, (prev, next) => {\n  return (\n    // PERF: There are cases where it will have\n    // changed, but it's properties will be exactly the same (eg. copy-paste)\n    // which this won't catch. But that's rare and not a drag on performance, so\n    // for simplicity we just let them through.\n    next.node === prev.node &&\n    // If the node parent is a block node, and it was the last child of the\n    // block, re-render to cleanup extra `\\n`.\n    (next.parent.object === 'block' &&\n      prev.parent.nodes.last() === prev.node &&\n      next.parent.nodes.last() !== next.node) &&\n    // The formatting hasn't changed.\n    next.annotations.equals(prev.annotations) &&\n    next.decorations.equals(prev.decorations)\n  )\n})\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default MemoizedText\n","import Debug from 'debug'\nimport React from 'react'\nimport SlateTypes from 'slate-prop-types'\nimport Types from 'prop-types'\n\nimport Text from './text'\nimport DATA_ATTRS from '../constants/data-attributes'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:void')\n\n/**\n * Void.\n *\n * @type {Component}\n */\n\nclass Void extends React.Component {\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  static propTypes = {\n    block: SlateTypes.block,\n    children: Types.any.isRequired,\n    editor: Types.object.isRequired,\n    node: SlateTypes.node.isRequired,\n    parent: SlateTypes.node.isRequired,\n    readOnly: Types.bool.isRequired,\n  }\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n  debug = (message, ...args) => {\n    const { node } = this.props\n    const { key, type } = node\n    const id = `${key} (${type})`\n    debug(message, `${id}`, ...args)\n  }\n\n  /**\n   * Render.\n   *\n   * @return {Element}\n   */\n\n  render() {\n    const { props } = this\n    const { children, node, readOnly } = props\n    const Tag = node.object === 'block' ? 'div' : 'span'\n    const style = {\n      height: '0',\n      color: 'transparent',\n      outline: 'none',\n      position: 'absolute',\n    }\n\n    const spacerAttrs = {\n      [DATA_ATTRS.SPACER]: true,\n    }\n\n    const spacer = (\n      <Tag style={style} {...spacerAttrs}>\n        {this.renderText()}\n      </Tag>\n    )\n\n    const content = (\n      <Tag contentEditable={readOnly ? null : false}>{children}</Tag>\n    )\n\n    this.debug('render', { props })\n\n    const attrs = {\n      [DATA_ATTRS.VOID]: true,\n      [DATA_ATTRS.KEY]: node.key,\n    }\n\n    return (\n      <Tag\n        contentEditable={readOnly || node.object === 'block' ? null : false}\n        {...attrs}\n      >\n        {readOnly ? null : spacer}\n        {content}\n      </Tag>\n    )\n  }\n\n  /**\n   * Render the void node's text node, which will catch the cursor when it the\n   * void node is navigated to with the arrow keys.\n   *\n   * Having this text node there means the browser continues to manage the\n   * selection natively, so it keeps track of the right offset when moving\n   * across the block.\n   *\n   * @return {Element}\n   */\n\n  renderText = () => {\n    const {\n      annotations,\n      block,\n      decorations,\n      node,\n      readOnly,\n      editor,\n      textRef,\n    } = this.props\n    const child = node.getFirstText()\n    return (\n      <Text\n        ref={textRef}\n        annotations={annotations}\n        block={node.object === 'block' ? node : block}\n        decorations={decorations}\n        editor={editor}\n        key={child.key}\n        node={child}\n        parent={node}\n        readOnly={readOnly}\n      />\n    )\n  }\n}\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Void\n","import Debug from 'debug'\nimport ImmutableTypes from 'react-immutable-proptypes'\nimport React from 'react'\nimport SlateTypes from 'slate-prop-types'\nimport warning from 'tiny-warning'\nimport Types from 'prop-types'\nimport { PathUtils } from 'slate'\n\nimport Void from './void'\nimport Text from './text'\nimport DATA_ATTRS from '../constants/data-attributes'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:node')\n\n/**\n * Node.\n *\n * @type {Component}\n */\n\nclass Node extends React.Component {\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  static propTypes = {\n    annotations: ImmutableTypes.map.isRequired,\n    block: SlateTypes.block,\n    decorations: ImmutableTypes.list.isRequired,\n    editor: Types.object.isRequired,\n    node: SlateTypes.node.isRequired,\n    parent: SlateTypes.node,\n    readOnly: Types.bool.isRequired,\n    selection: SlateTypes.selection,\n  }\n\n  /**\n   * Temporary values.\n   *\n   * @type {Object}\n   */\n\n  tmp = {\n    nodeRefs: {},\n  }\n\n  /**\n   * A ref for the contenteditable DOM node.\n   *\n   * @type {Object}\n   */\n\n  ref = React.createRef()\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n  debug = (message, ...args) => {\n    const { node } = this.props\n    const { key, type } = node\n    debug(message, `${key} (${type})`, ...args)\n  }\n\n  /**\n   * Should the node update?\n   *\n   * @param {Object} nextProps\n   * @param {Object} value\n   * @return {Boolean}\n   */\n\n  shouldComponentUpdate(nextProps) {\n    const { props } = this\n    const { editor } = props\n    const shouldUpdate = editor.run(\n      'shouldNodeComponentUpdate',\n      props,\n      nextProps\n    )\n    const n = nextProps\n    const p = props\n\n    // If the `Component` has a custom logic to determine whether the component\n    // needs to be updated or not, return true if it returns true. If it returns\n    // false, we need to ignore it, because it shouldn't be allowed it.\n    if (shouldUpdate != null) {\n      warning(\n        false,\n        'As of slate-react@0.22 the `shouldNodeComponentUpdate` middleware is deprecated. You can pass specific values down the tree using React\\'s built-in \"context\" construct instead.'\n      )\n\n      if (shouldUpdate) {\n        return true\n      }\n\n      warning(\n        shouldUpdate !== false,\n        \"Returning false in `shouldNodeComponentUpdate` does not disable Slate's internal `shouldComponentUpdate` logic. If you want to prevent updates, use React's `shouldComponentUpdate` instead.\"\n      )\n    }\n\n    // If the `readOnly` status has changed, re-render in case there is any\n    // user-land logic that depends on it, like nested editable contents.\n    if (n.readOnly !== p.readOnly) {\n      return true\n    }\n\n    // If the node has changed, update. PERF: There are cases where it will have\n    // changed, but it's properties will be exactly the same (eg. copy-paste)\n    // which this won't catch. But that's rare and not a drag on performance, so\n    // for simplicity we just let them through.\n    if (n.node !== p.node) {\n      return true\n    }\n\n    // If the selection value of the node or of some of its children has changed,\n    // re-render in case there is any user-land logic depends on it to render.\n    // if the node is selected update it, even if it was already selected: the\n    // selection value of some of its children could have been changed and they\n    // need to be rendered again.\n    if (\n      (!n.selection && p.selection) ||\n      (n.selection && !p.selection) ||\n      (n.selection && p.selection && !n.selection.equals(p.selection))\n    ) {\n      return true\n    }\n\n    // If the annotations have changed, update.\n    if (!n.annotations.equals(p.annotations)) {\n      return true\n    }\n\n    // If the decorations have changed, update.\n    if (!n.decorations.equals(p.decorations)) {\n      return true\n    }\n\n    // Otherwise, don't update.\n    return false\n  }\n\n  /**\n   * Render.\n   *\n   * @return {Element}\n   */\n\n  render() {\n    this.debug('render', this)\n    const {\n      annotations,\n      block,\n      decorations,\n      editor,\n      node,\n      parent,\n      readOnly,\n      selection,\n    } = this.props\n\n    const newDecorations = node.getDecorations(editor)\n    const children = node.nodes.toArray().map((child, i) => {\n      const Component = child.object === 'text' ? Text : Node\n      const sel = selection && getRelativeRange(node, i, selection)\n\n      const decs = newDecorations\n        .concat(decorations)\n        .map(d => getRelativeRange(node, i, d))\n        .filter(d => d)\n\n      const anns = annotations\n        .map(a => getRelativeRange(node, i, a))\n        .filter(a => a)\n\n      return (\n        <Component\n          block={node.object === 'block' ? node : block}\n          editor={editor}\n          annotations={anns}\n          decorations={decs}\n          selection={sel}\n          key={child.key}\n          node={child}\n          parent={node}\n          readOnly={readOnly}\n          // COMPAT: We use this map of refs to lookup a DOM node down the\n          // tree of components by path.\n          ref={ref => {\n            if (ref) {\n              this.tmp.nodeRefs[i] = ref\n            } else {\n              delete this.tmp.nodeRefs[i]\n            }\n          }}\n        />\n      )\n    })\n\n    // Attributes that the developer must mix into the element in their\n    // custom node renderer component.\n    const attributes = {\n      [DATA_ATTRS.OBJECT]: node.object,\n      [DATA_ATTRS.KEY]: node.key,\n      ref: this.ref,\n    }\n\n    // If it's a block node with inline children, add the proper `dir` attribute\n    // for text direction.\n    if (node.isLeafBlock()) {\n      const direction = node.getTextDirection()\n      if (direction === 'rtl') attributes.dir = 'rtl'\n    }\n\n    let render\n\n    if (node.object === 'block') {\n      render = 'renderBlock'\n    } else if (node.object === 'document') {\n      render = 'renderDocument'\n    } else if (node.object === 'inline') {\n      render = 'renderInline'\n    }\n\n    const element = editor.run(render, {\n      attributes,\n      children,\n      editor,\n      isFocused: !!selection && selection.isFocused,\n      isSelected: !!selection,\n      node,\n      parent,\n      readOnly,\n    })\n\n    return editor.isVoid(node) ? (\n      <Void\n        {...this.props}\n        textRef={ref => {\n          if (ref) {\n            this.tmp.nodeRefs[0] = ref\n          } else {\n            delete this.tmp.nodeRefs[0]\n          }\n        }}\n      >\n        {element}\n      </Void>\n    ) : (\n      element\n    )\n  }\n}\n\n/**\n * Return a `range` relative to a child at `index`.\n *\n * @param {Range} range\n * @param {Number} index\n * @return {Range}\n */\n\nfunction getRelativeRange(node, index, range) {\n  if (range.isUnset) {\n    return null\n  }\n\n  const child = node.nodes.get(index)\n  let { start, end } = range\n  const { path: startPath } = start\n  const { path: endPath } = end\n  const startIndex = startPath.first()\n  const endIndex = endPath.first()\n\n  if (startIndex === index) {\n    start = start.setPath(startPath.rest())\n  } else if (startIndex < index && index <= endIndex) {\n    if (child.object === 'text') {\n      start = start.moveTo(PathUtils.create([index]), 0).setKey(child.key)\n    } else {\n      const [first] = child.texts()\n      const [firstNode, firstPath] = first\n      start = start.moveTo(firstPath, 0).setKey(firstNode.key)\n    }\n  } else {\n    start = null\n  }\n\n  if (endIndex === index) {\n    end = end.setPath(endPath.rest())\n  } else if (startIndex <= index && index < endIndex) {\n    if (child.object === 'text') {\n      const length = child.text.length\n      end = end.moveTo(PathUtils.create([index]), length).setKey(child.key)\n    } else {\n      const [last] = child.texts({ direction: 'backward' })\n      const [lastNode, lastPath] = last\n      end = end.moveTo(lastPath, lastNode.text.length).setKey(lastNode.key)\n    }\n  } else {\n    end = null\n  }\n\n  if (!start || !end) {\n    return null\n  }\n\n  range = range.setAnchor(start)\n  range = range.setFocus(end)\n  return range\n}\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Node\n","import getWindow from 'get-window'\nimport isBackward from 'selection-is-backward'\nimport { IS_SAFARI, IS_IOS } from 'slate-dev-environment'\n\n/**\n * CSS overflow values that would cause scrolling.\n *\n * @type {Array}\n */\n\nconst OVERFLOWS = ['auto', 'overlay', 'scroll']\n\n/**\n * Detect whether we are running IOS version 11\n */\n\nconst IS_IOS_11 = IS_IOS && !!window.navigator.userAgent.match(/os 11_/i)\n\n/**\n * Find the nearest parent with scrolling, or window.\n *\n * @param {el} Element\n */\n\nfunction findScrollContainer(el, window) {\n  let parent = el.parentNode\n  let scroller\n\n  while (!scroller) {\n    if (!parent.parentNode) break\n\n    const style = window.getComputedStyle(parent)\n    const { overflowY } = style\n\n    if (OVERFLOWS.includes(overflowY)) {\n      scroller = parent\n      break\n    }\n\n    parent = parent.parentNode\n  }\n\n  // COMPAT: Because Chrome does not allow doucment.body.scrollTop, we're\n  // assuming that window.scrollTo() should be used if the scrollable element\n  // turns out to be document.body or document.documentElement. This will work\n  // unless body is intentionally set to scrollable by restricting its height\n  // (e.g. height: 100vh).\n  if (!scroller) {\n    return window.document.body\n  }\n\n  return scroller\n}\n\n/**\n * Scroll the current selection's focus point into view if needed.\n *\n * @param {Selection} selection\n */\n\nfunction scrollToSelection(selection) {\n  if (IS_IOS_11) return\n  if (!selection.anchorNode) return\n\n  const window = getWindow(selection.anchorNode)\n  const scroller = findScrollContainer(selection.anchorNode, window)\n  const isWindow =\n    scroller === window.document.body ||\n    scroller === window.document.documentElement\n  const backward = isBackward(selection)\n\n  const range = selection.getRangeAt(0).cloneRange()\n  range.collapse(backward)\n  let cursorRect = range.getBoundingClientRect()\n\n  // COMPAT: range.getBoundingClientRect() returns 0s in Safari when range is\n  // collapsed. Expanding the range by 1 is a relatively effective workaround\n  // for vertical scroll, although horizontal may be off by 1 character.\n  // https://bugs.webkit.org/show_bug.cgi?id=138949\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=435438\n  if (IS_SAFARI) {\n    if (range.collapsed && cursorRect.top === 0 && cursorRect.height === 0) {\n      if (range.startOffset === 0) {\n        range.setEnd(range.endContainer, 1)\n      } else {\n        range.setStart(range.startContainer, range.startOffset - 1)\n      }\n\n      cursorRect = range.getBoundingClientRect()\n\n      if (cursorRect.top === 0 && cursorRect.height === 0) {\n        if (range.getClientRects().length) {\n          cursorRect = range.getClientRects()[0]\n        }\n      }\n    }\n  }\n\n  let width\n  let height\n  let yOffset\n  let xOffset\n  let scrollerTop = 0\n  let scrollerLeft = 0\n  let scrollerBordersY = 0\n  let scrollerBordersX = 0\n  let scrollerPaddingTop = 0\n  let scrollerPaddingBottom = 0\n  let scrollerPaddingLeft = 0\n  let scrollerPaddingRight = 0\n\n  if (isWindow) {\n    const { innerWidth, innerHeight, pageYOffset, pageXOffset } = window\n    width = innerWidth\n    height = innerHeight\n    yOffset = pageYOffset\n    xOffset = pageXOffset\n  } else {\n    const { offsetWidth, offsetHeight, scrollTop, scrollLeft } = scroller\n    const {\n      borderTopWidth,\n      borderBottomWidth,\n      borderLeftWidth,\n      borderRightWidth,\n      paddingTop,\n      paddingBottom,\n      paddingLeft,\n      paddingRight,\n    } = window.getComputedStyle(scroller)\n\n    const scrollerRect = scroller.getBoundingClientRect()\n    width = offsetWidth\n    height = offsetHeight\n    scrollerTop = scrollerRect.top + parseInt(borderTopWidth, 10)\n    scrollerLeft = scrollerRect.left + parseInt(borderLeftWidth, 10)\n\n    scrollerBordersY =\n      parseInt(borderTopWidth, 10) + parseInt(borderBottomWidth, 10)\n\n    scrollerBordersX =\n      parseInt(borderLeftWidth, 10) + parseInt(borderRightWidth, 10)\n\n    scrollerPaddingTop = parseInt(paddingTop, 10)\n    scrollerPaddingBottom = parseInt(paddingBottom, 10)\n    scrollerPaddingLeft = parseInt(paddingLeft, 10)\n    scrollerPaddingRight = parseInt(paddingRight, 10)\n    yOffset = scrollTop\n    xOffset = scrollLeft\n  }\n\n  const cursorTop = cursorRect.top + yOffset - scrollerTop\n  const cursorLeft = cursorRect.left + xOffset - scrollerLeft\n\n  let x = xOffset\n  let y = yOffset\n\n  if (cursorLeft < xOffset) {\n    // selection to the left of viewport\n    x = cursorLeft - scrollerPaddingLeft\n  } else if (\n    cursorLeft + cursorRect.width + scrollerBordersX >\n    xOffset + width\n  ) {\n    // selection to the right of viewport\n    x = cursorLeft + scrollerBordersX + scrollerPaddingRight - width\n  }\n\n  if (cursorTop < yOffset) {\n    // selection above viewport\n    y = cursorTop - scrollerPaddingTop\n  } else if (\n    cursorTop + cursorRect.height + scrollerBordersY >\n    yOffset + height\n  ) {\n    // selection below viewport\n    y =\n      cursorTop +\n      scrollerBordersY +\n      scrollerPaddingBottom +\n      cursorRect.height -\n      height\n  }\n\n  if (isWindow) {\n    window.scrollTo(x, y)\n  } else {\n    scroller.scrollTop = y\n    scroller.scrollLeft = x\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default scrollToSelection\n","import { IS_IE } from 'slate-dev-environment'\n\n/**\n * Cross-browser remove all ranges from a `domSelection`.\n *\n * @param {Selection} domSelection\n */\n\nfunction removeAllRanges(domSelection) {\n  // COMPAT: In IE 11, if the selection contains nested tables, then\n  // `removeAllRanges` will throw an error.\n  if (IS_IE) {\n    const range = window.document.body.createTextRange()\n    range.collapse()\n    range.select()\n  } else {\n    domSelection.removeAllRanges()\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default removeAllRanges\n","import Debug from 'debug'\nimport React from 'react'\nimport Types from 'prop-types'\nimport getWindow from 'get-window'\nimport warning from 'tiny-warning'\nimport throttle from 'lodash/throttle'\nimport omit from 'lodash/omit'\nimport { List } from 'immutable'\nimport {\n  IS_ANDROID,\n  IS_FIREFOX,\n  HAS_INPUT_EVENTS_LEVEL_2,\n} from 'slate-dev-environment'\nimport Hotkeys from 'slate-hotkeys'\n\nimport EVENT_HANDLERS from '../constants/event-handlers'\nimport DATA_ATTRS from '../constants/data-attributes'\nimport SELECTORS from '../constants/selectors'\nimport Node from './node'\nimport scrollToSelection from '../utils/scroll-to-selection'\nimport removeAllRanges from '../utils/remove-all-ranges'\n\nconst FIREFOX_NODE_TYPE_ACCESS_ERROR = /Permission denied to access property \"nodeType\"/\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:content')\n\n/**\n * Separate debug to easily see when the DOM has updated either by render or\n * changing selection.\n *\n * @type {Function}\n */\n\ndebug.update = Debug('slate:update')\n\n/**\n * Content.\n *\n * @type {Component}\n */\n\nclass Content extends React.Component {\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  static propTypes = {\n    autoCorrect: Types.bool.isRequired,\n    className: Types.string,\n    contentKey: Types.number,\n    editor: Types.object.isRequired,\n    id: Types.string,\n    onEvent: Types.func.isRequired,\n    readOnly: Types.bool.isRequired,\n    role: Types.string,\n    spellCheck: Types.bool.isRequired,\n    style: Types.object,\n    tabIndex: Types.number,\n    tagName: Types.string,\n  }\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n  static defaultProps = {\n    style: {},\n    tagName: 'div',\n  }\n\n  /**\n   * An error boundary. If there is a render error, we increment `errorKey`\n   * which is part of the container `key` which forces a re-render from\n   * scratch.\n   *\n   * @param {Error} error\n   * @param {String} info\n   */\n\n  componentDidCatch(error, info) {\n    debug('componentDidCatch', { error, info })\n    // The call to `setState` is required despite not setting a value.\n    // Without this call, React will not try to recreate the component tree.\n    this.setState({})\n  }\n\n  /**\n   * Temporary values.\n   *\n   * @type {Object}\n   */\n\n  tmp = {\n    isUpdatingSelection: false,\n    nodeRef: React.createRef(),\n    nodeRefs: {},\n    contentKey: 0,\n    nativeSelection: {}, // Native selection object stored to check if `onNativeSelectionChange` has triggered yet\n  }\n\n  /**\n   * A ref for the contenteditable DOM node.\n   *\n   * @type {Object}\n   */\n\n  ref = React.createRef()\n\n  /**\n   * Set both `this.ref` and `editor.el`\n   *\n   * @type {DOMElement}\n   */\n\n  setRef = el => {\n    this.ref.current = el\n    this.props.editor.el = el\n  }\n\n  /**\n   * Create a set of bound event handlers.\n   *\n   * @type {Object}\n   */\n\n  handlers = EVENT_HANDLERS.reduce((obj, handler) => {\n    obj[handler] = event => this.onEvent(handler, event)\n    return obj\n  }, {})\n\n  /**\n   * When the editor first mounts in the DOM we need to:\n   *\n   *   - Add native DOM event listeners.\n   *   - Update the selection, in case it starts focused.\n   */\n\n  componentDidMount() {\n    const window = getWindow(this.ref.current)\n\n    window.document.addEventListener(\n      'selectionchange',\n      this.onNativeSelectionChange\n    )\n\n    // COMPAT: Restrict scope of `beforeinput` to clients that support the\n    // Input Events Level 2 spec, since they are preventable events.\n    if (HAS_INPUT_EVENTS_LEVEL_2) {\n      this.ref.current.addEventListener(\n        'beforeinput',\n        this.handlers.onBeforeInput\n      )\n    }\n\n    this.updateSelection()\n\n    this.props.onEvent('onComponentDidMount')\n  }\n\n  /**\n   * When unmounting, remove DOM event listeners.\n   */\n\n  componentWillUnmount() {\n    const window = getWindow(this.ref.current)\n\n    if (window) {\n      window.document.removeEventListener(\n        'selectionchange',\n        this.onNativeSelectionChange\n      )\n    }\n\n    if (HAS_INPUT_EVENTS_LEVEL_2) {\n      this.ref.current.removeEventListener(\n        'beforeinput',\n        this.handlers.onBeforeInput\n      )\n    }\n\n    this.props.onEvent('onComponentWillUnmount')\n  }\n\n  /**\n   * On update, update the selection.\n   */\n\n  componentDidUpdate() {\n    debug.update('componentDidUpdate')\n\n    this.updateSelection()\n    this.props.editor.clearUserActionPerformed()\n\n    this.props.onEvent('onComponentDidUpdate')\n  }\n\n  /**\n   * Update the native DOM selection to reflect the internal model.\n   */\n\n  updateSelection = () => {\n    const { editor } = this.props\n    const { value } = editor\n    const { selection } = value\n    const { isBackward } = selection\n    const window = getWindow(this.ref.current)\n    const native = window.getSelection()\n    const { activeElement } = window.document\n\n    if (debug.update.enabled) {\n      debug.update('updateSelection', { selection: selection.toJSON() })\n    }\n\n    // COMPAT: In Firefox, there's a but where `getSelection` can return `null`.\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=827585 (2018/11/07)\n    if (!native) {\n      return\n    }\n\n    const { rangeCount, anchorNode } = native\n    let updated = false\n\n    // If the Slate selection is blurred, but the DOM's active element is still\n    // the editor, we need to blur it.\n    if (selection.isBlurred && activeElement === this.ref.current) {\n      this.ref.current.blur()\n      updated = true\n    }\n\n    // If the Slate selection is unset, but the DOM selection has a range\n    // selected in the editor, we need to remove the range.\n    // However we should _not_ remove the range if the selection as\n    // reported by `getSelection` is not equal to `this.tmp.nativeSelection`\n    // as this suggests `onNativeSelectionChange` has not triggered yet (which can occur in Firefox)\n    // See: https://github.com/ianstormtaylor/slate/pull/2995\n\n    const propsToCompare = [\n      'anchorNode',\n      'anchorOffset',\n      'focusNode',\n      'focusOffset',\n      'isCollapsed',\n      'rangeCount',\n      'type',\n    ]\n\n    let selectionsEqual = true\n\n    for (const prop of propsToCompare) {\n      if (this.tmp.nativeSelection[prop] !== native[prop]) {\n        selectionsEqual = false\n      }\n    }\n\n    if (\n      selection.isUnset &&\n      rangeCount &&\n      this.isInEditor(anchorNode) &&\n      selectionsEqual\n    ) {\n      removeAllRanges(native)\n      updated = true\n    }\n\n    // If the Slate selection is focused, but the DOM's active element is not\n    // the editor, we need to focus it. We prevent scrolling because we handle\n    // scrolling to the correct selection.\n    if (selection.isFocused && activeElement !== this.ref.current) {\n      this.ref.current.focus({ preventScroll: true })\n      updated = true\n    }\n\n    // Otherwise, figure out which DOM nodes should be selected...\n    if (selection.isFocused && selection.isSet) {\n      const current = !!native.rangeCount && native.getRangeAt(0)\n      const range = editor.findDOMRange(selection)\n\n      if (!range) {\n        warning(\n          false,\n          'Unable to find a native DOM range from the current selection.'\n        )\n\n        return\n      }\n\n      const { startContainer, startOffset, endContainer, endOffset } = range\n\n      // If the new range matches the current selection, there is nothing to fix.\n      // COMPAT: The native `Range` object always has it's \"start\" first and \"end\"\n      // last in the DOM. It has no concept of \"backwards/forwards\", so we have\n      // to check both orientations here. (2017/10/31)\n      if (current) {\n        if (\n          (startContainer === current.startContainer &&\n            startOffset === current.startOffset &&\n            endContainer === current.endContainer &&\n            endOffset === current.endOffset) ||\n          (startContainer === current.endContainer &&\n            startOffset === current.endOffset &&\n            endContainer === current.startContainer &&\n            endOffset === current.startOffset)\n        ) {\n          return\n        }\n      }\n\n      // Otherwise, set the `isUpdatingSelection` flag and update the selection.\n      updated = true\n      this.tmp.isUpdatingSelection = true\n      removeAllRanges(native)\n\n      // COMPAT: IE 11 does not support `setBaseAndExtent`. (2018/11/07)\n      if (native.setBaseAndExtent) {\n        // COMPAT: Since the DOM range has no concept of backwards/forwards\n        // we need to check and do the right thing here.\n        if (isBackward) {\n          native.setBaseAndExtent(\n            range.endContainer,\n            range.endOffset,\n            range.startContainer,\n            range.startOffset\n          )\n        } else {\n          native.setBaseAndExtent(\n            range.startContainer,\n            range.startOffset,\n            range.endContainer,\n            range.endOffset\n          )\n        }\n      } else {\n        native.addRange(range)\n      }\n\n      // Only scroll to selection when a user action is performed\n      if (editor.userActionPerformed() === true) {\n        // Scroll to the selection, in case it's out of view.\n        scrollToSelection(native)\n      }\n\n      // Then unset the `isUpdatingSelection` flag after a delay, to ensure that\n      // it is still set when selection-related events from updating it fire.\n      setTimeout(() => {\n        // COMPAT: In Firefox, it's not enough to create a range, you also need\n        // to focus the contenteditable element too. (2016/11/16)\n        if (IS_FIREFOX && this.ref.current) {\n          this.ref.current.focus()\n        }\n\n        this.tmp.isUpdatingSelection = false\n\n        debug.update('updateSelection:setTimeout', {\n          anchorOffset: window.getSelection().anchorOffset,\n        })\n      })\n    }\n\n    if (updated && (debug.enabled || debug.update.enabled)) {\n      debug('updateSelection', { selection, native, activeElement })\n\n      debug.update('updateSelection:applied', {\n        selection: selection.toJSON(),\n        native: {\n          anchorOffset: native.anchorOffset,\n          focusOffset: native.focusOffset,\n        },\n      })\n    }\n  }\n\n  /**\n   * Check if an event `target` is fired from within the contenteditable\n   * element. This should be false for edits happening in non-contenteditable\n   * children, such as void nodes and other nested Slate editors.\n   *\n   * @param {Element} target\n   * @return {Boolean}\n   */\n\n  isInEditor = target => {\n    let el\n\n    try {\n      // COMPAT: In Firefox, sometimes the node can be comment which doesn't\n      // have .closest and it crashes.\n      if (target.nodeType === 8) {\n        return false\n      }\n\n      // COMPAT: Text nodes don't have `isContentEditable` property. So, when\n      // `target` is a text node use its parent node for check.\n      el = target.nodeType === 3 ? target.parentNode : target\n    } catch (err) {\n      // COMPAT: In Firefox, `target.nodeType` will throw an error if target is\n      // originating from an internal \"restricted\" element (e.g. a stepper\n      // arrow on a number input)\n      // see github.com/ianstormtaylor/slate/issues/1819\n      if (IS_FIREFOX && FIREFOX_NODE_TYPE_ACCESS_ERROR.test(err.message)) {\n        return false\n      }\n\n      throw err\n    }\n\n    return (\n      el.isContentEditable &&\n      (el === this.ref.current ||\n        el.closest(SELECTORS.EDITOR) === this.ref.current)\n    )\n  }\n\n  /**\n   * On `event` with `handler`.\n   *\n   * @param {String} handler\n   * @param {Event} event\n   */\n\n  onEvent(handler, event) {\n    debug('onEvent', handler)\n\n    const nativeEvent = event.nativeEvent || event\n    const isUndoRedo =\n      event.type === 'keydown' &&\n      (Hotkeys.isUndo(nativeEvent) || Hotkeys.isRedo(nativeEvent))\n\n    // Ignore `onBlur`, `onFocus` and `onSelect` events generated\n    // programmatically while updating selection.\n    if (\n      (this.tmp.isUpdatingSelection || isUndoRedo) &&\n      (handler === 'onSelect' || handler === 'onBlur' || handler === 'onFocus')\n    ) {\n      return\n    }\n\n    // COMPAT: There are situations where a select event will fire with a new\n    // native selection that resolves to the same internal position. In those\n    // cases we don't need to trigger any changes, since our internal model is\n    // already up to date, but we do want to update the native selection again\n    // to make sure it is in sync. (2017/10/16)\n    //\n    // ANDROID: The updateSelection causes issues in Android when you are\n    // at the end of a block. The selection ends up to the left of the inserted\n    // character instead of to the right. This behavior continues even if\n    // you enter more than one character. (2019/01/03)\n    if (!IS_ANDROID && handler === 'onSelect') {\n      const { editor } = this.props\n      const { value } = editor\n      const { selection } = value\n      const window = getWindow(event.target)\n      const domSelection = window.getSelection()\n      const range = editor.findRange(domSelection)\n\n      if (range && range.equals(selection.toRange())) {\n        this.updateSelection()\n        return\n      }\n    }\n\n    // Don't handle drag and drop events coming from embedded editors.\n    if (\n      handler === 'onDragEnd' ||\n      handler === 'onDragEnter' ||\n      handler === 'onDragExit' ||\n      handler === 'onDragLeave' ||\n      handler === 'onDragOver' ||\n      handler === 'onDragStart' ||\n      handler === 'onDrop'\n    ) {\n      const closest = event.target.closest(SELECTORS.EDITOR)\n\n      if (closest !== this.ref.current) {\n        return\n      }\n    }\n\n    // Some events require being in editable in the editor, so if the event\n    // target isn't, ignore them.\n    if (\n      handler === 'onBeforeInput' ||\n      handler === 'onBlur' ||\n      handler === 'onCompositionEnd' ||\n      handler === 'onCompositionStart' ||\n      handler === 'onCopy' ||\n      handler === 'onCut' ||\n      handler === 'onFocus' ||\n      handler === 'onInput' ||\n      handler === 'onKeyDown' ||\n      handler === 'onKeyUp' ||\n      handler === 'onPaste' ||\n      handler === 'onSelect'\n    ) {\n      if (!this.isInEditor(event.target)) {\n        return\n      }\n    }\n\n    this.props.onEvent(handler, event)\n  }\n\n  /**\n   * On native `selectionchange` event, trigger the `onSelect` handler. This is\n   * needed to account for React's `onSelect` being non-standard and not firing\n   * until after a selection has been released. This causes issues in situations\n   * where another change happens while a selection is being made.\n   *\n   * @param {Event} event\n   */\n\n  onNativeSelectionChange = throttle(event => {\n    if (this.props.readOnly) return\n\n    const window = getWindow(event.target)\n    const { activeElement } = window.document\n\n    const native = window.getSelection()\n\n    debug.update('onNativeSelectionChange', {\n      anchorOffset: native.anchorOffset,\n    })\n\n    if (activeElement !== this.ref.current) return\n\n    this.tmp.nativeSelection = {\n      anchorNode: native.anchorNode,\n      anchorOffset: native.anchorOffset,\n      focusNode: native.focusNode,\n      focusOffset: native.focusOffset,\n      isCollapsed: native.isCollapsed,\n      rangeCount: native.rangeCount,\n      type: native.type,\n    }\n\n    this.props.onEvent('onSelect', event)\n  }, 100)\n\n  /**\n   * Render the editor content.\n   *\n   * @return {Element}\n   */\n\n  render() {\n    const { props, handlers } = this\n    const {\n      id,\n      className,\n      readOnly,\n      editor,\n      tabIndex,\n      role,\n      tagName,\n      spellCheck,\n    } = props\n    const { value } = editor\n    const Container = tagName\n    const { document, selection } = value\n\n    const style = {\n      // Prevent the default outline styles.\n      outline: 'none',\n      // Preserve adjacent whitespace and new lines.\n      whiteSpace: 'pre-wrap',\n      // Allow words to break if they are too long.\n      wordWrap: 'break-word',\n      // COMPAT: In iOS, a formatting menu with bold, italic and underline\n      // buttons is shown which causes our internal value to get out of sync in\n      // weird ways. This hides that. (2016/06/21)\n      ...(readOnly ? {} : { WebkitUserModify: 'read-write-plaintext-only' }),\n      // Allow for passed-in styles to override anything.\n      ...props.style,\n    }\n\n    // console.log('rerender content', this.tmp.contentKey, document.text)\n\n    debug('render', { props })\n    debug.update('render', this.tmp.contentKey, document.text)\n\n    this.props.onEvent('onRender')\n\n    const data = {\n      [DATA_ATTRS.EDITOR]: true,\n      [DATA_ATTRS.KEY]: document.key,\n    }\n\n    const domProps = omit(this.props, Object.keys(Content.propTypes))\n\n    return (\n      <Container\n        {...domProps}\n        key={this.tmp.contentKey}\n        {...handlers}\n        {...data}\n        ref={this.setRef}\n        contentEditable={readOnly ? null : true}\n        suppressContentEditableWarning\n        id={id}\n        className={className}\n        autoCorrect={props.autoCorrect ? 'on' : 'off'}\n        spellCheck={spellCheck}\n        style={style}\n        role={readOnly ? null : role || 'textbox'}\n        tabIndex={tabIndex}\n        // COMPAT: The Grammarly Chrome extension works by changing the DOM out\n        // from under `contenteditable` elements, which leads to weird behaviors\n        // so we have to disable it like this. (2017/04/24)\n\n        // just the existence of the flag is disabling the extension irrespective of its value\n        data-gramm={domProps['data-gramm'] ? undefined : false}\n      >\n        <Node\n          annotations={value.annotations}\n          block={null}\n          decorations={List()}\n          editor={editor}\n          node={document}\n          parent={null}\n          readOnly={readOnly}\n          selection={selection}\n          ref={this.tmp.nodeRef}\n        />\n      </Container>\n    )\n  }\n}\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Content\n","import EVENT_HANDLERS from '../../constants/event-handlers'\n\n/**\n * Props that can be defined by plugins.\n *\n * @type {Array}\n */\n\nconst PROPS = [\n  ...EVENT_HANDLERS,\n  'commands',\n  'decorateNode',\n  'queries',\n  'renderAnnotation',\n  'renderBlock',\n  'renderDecoration',\n  'renderDocument',\n  'renderEditor',\n  'renderInline',\n  'renderMark',\n  'schema',\n]\n\n/**\n * The top-level editor props in a plugin.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction EditorPropsPlugin(options = {}) {\n  const plugin = PROPS.reduce((memo, prop) => {\n    if (prop in options) memo[prop] = options[prop]\n    return memo\n  }, {})\n\n  return plugin\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default EditorPropsPlugin\n","import React from 'react'\n\n/**\n * The default rendering behavior for the React plugin.\n *\n * @return {Object}\n */\n\nfunction Rendering() {\n  return {\n    decorateNode() {\n      return []\n    },\n\n    renderAnnotation({ attributes, children }) {\n      return <span {...attributes}>{children}</span>\n    },\n\n    renderBlock({ attributes, children }) {\n      return (\n        <div {...attributes} style={{ position: 'relative' }}>\n          {children}\n        </div>\n      )\n    },\n\n    renderDecoration({ attributes, children }) {\n      return <span {...attributes}>{children}</span>\n    },\n\n    renderDocument({ children }) {\n      return children\n    },\n\n    renderEditor({ children }) {\n      return children\n    },\n\n    renderInline({ attributes, children }) {\n      return (\n        <span {...attributes} style={{ position: 'relative' }}>\n          {children}\n        </span>\n      )\n    },\n\n    renderMark({ attributes, children }) {\n      return <span {...attributes}>{children}</span>\n    },\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default Rendering\n","/**\n * A set of commands for the React plugin.\n *\n * @return {Object}\n */\n\nfunction CommandsPlugin() {\n  /**\n   * Takes a `node`, find the matching `domNode` and uses it to set the text\n   * in the `node`.\n   *\n   * @param {Editor} editor\n   * @param {Node} node\n   */\n\n  function reconcileNode(editor, node) {\n    const { value } = editor\n    const { document, selection } = value\n    const path = document.getPath(node.key)\n\n    const domElement = editor.findDOMNode(path)\n    const block = document.getClosestBlock(path)\n\n    // Get text information\n    const { text } = node\n    let { textContent: domText } = domElement\n\n    const isLastNode = block.nodes.last() === node\n    const lastChar = domText.charAt(domText.length - 1)\n\n    // COMPAT: If this is the last leaf, and the DOM text ends in a new line,\n    // we will have added another new line in <Leaf>'s render method to account\n    // for browsers collapsing a single trailing new lines, so remove it.\n    if (isLastNode && lastChar === '\\n') {\n      domText = domText.slice(0, -1)\n    }\n\n    // If the text is no different, abort.\n    if (text === domText) return\n\n    let entire = selection.moveAnchorTo(path, 0).moveFocusTo(path, text.length)\n\n    entire = document.resolveRange(entire)\n\n    // Change the current value to have the leaf's text replaced.\n    editor.insertTextAtRange(entire, domText, node.marks)\n    return\n  }\n\n  /**\n   * Takes text from the `domNode` and uses it to set the text in the matching\n   * `node` in Slate.\n   *\n   * @param {Editor} editor\n   * @param {DOMNode} domNode\n   */\n\n  function reconcileDOMNode(editor, domNode) {\n    const domElement = domNode.parentElement.closest('[data-key]')\n    const node = editor.findNode(domElement)\n    editor.reconcileNode(node)\n  }\n\n  return {\n    commands: {\n      reconcileNode,\n      reconcileDOMNode,\n    },\n  }\n}\n\nexport default CommandsPlugin\n","import getWindow from 'get-window'\nimport { PathUtils } from 'slate'\n\nimport DATA_ATTRS from '../../constants/data-attributes'\nimport SELECTORS from '../../constants/selectors'\n\n/**\n * A set of queries for the React plugin.\n *\n * @return {Object}\n */\n\nfunction QueriesPlugin() {\n  /**\n   * Find the native DOM element for a node at `path`.\n   *\n   * @param {Editor} editor\n   * @param {Array|List} path\n   * @return {DOMNode|Null}\n   */\n\n  function findDOMNode(editor, path) {\n    path = PathUtils.create(path)\n    const content = editor.tmp.contentRef.current\n\n    if (!content) {\n      return null\n    }\n\n    if (!path.size) {\n      return content.ref.current || null\n    }\n\n    const search = (instance, p) => {\n      if (!instance) {\n        return null\n      }\n\n      if (!p.size) {\n        if (instance.ref) {\n          return instance.ref.current || null\n        } else {\n          return instance || null\n        }\n      }\n\n      const index = p.first()\n      const rest = p.rest()\n      const ref = instance.tmp.nodeRefs[index]\n      return search(ref, rest)\n    }\n\n    const document = content.tmp.nodeRef.current\n    const el = search(document, path)\n    return el\n  }\n\n  /**\n   * Find a native DOM selection point from a Slate `point`.\n   *\n   * @param {Editor} editor\n   * @param {Point} point\n   * @return {Object|Null}\n   */\n\n  function findDOMPoint(editor, point) {\n    const el = editor.findDOMNode(point.path)\n    let start = 0\n\n    if (!el) {\n      return null\n    }\n\n    // For each leaf, we need to isolate its content, which means filtering to its\n    // direct text and zero-width spans. (We have to filter out any other siblings\n    // that may have been rendered alongside them.)\n    const texts = Array.from(\n      el.querySelectorAll(`${SELECTORS.STRING}, ${SELECTORS.ZERO_WIDTH}`)\n    )\n\n    for (const text of texts) {\n      const node = text.childNodes[0]\n      const domLength = node.textContent.length\n      let slateLength = domLength\n\n      if (text.hasAttribute(DATA_ATTRS.LENGTH)) {\n        slateLength = parseInt(text.getAttribute(DATA_ATTRS.LENGTH), 10)\n      }\n\n      const end = start + slateLength\n\n      if (point.offset <= end) {\n        const offset = Math.min(domLength, Math.max(0, point.offset - start))\n        return { node, offset }\n      }\n\n      start = end\n    }\n\n    return null\n  }\n\n  /**\n   * Find a native DOM range from a Slate `range`.\n   *\n   * @param {Editor} editor\n   * @param {Range} range\n   * @return {DOMRange|Null}\n   */\n\n  function findDOMRange(editor, range) {\n    const { anchor, focus, isBackward, isCollapsed } = range\n    const domAnchor = editor.findDOMPoint(anchor)\n    const domFocus = isCollapsed ? domAnchor : editor.findDOMPoint(focus)\n\n    if (!domAnchor || !domFocus) {\n      return null\n    }\n\n    const window = getWindow(domAnchor.node)\n    const r = window.document.createRange()\n    const start = isBackward ? domFocus : domAnchor\n    const end = isBackward ? domAnchor : domFocus\n    r.setStart(start.node, start.offset)\n    r.setEnd(end.node, end.offset)\n    return r\n  }\n\n  /**\n   * Find a Slate node from a native DOM `element`.\n   *\n   * @param {Editor} editor\n   * @param {Element} element\n   * @return {List|Null}\n   */\n\n  function findNode(editor, element) {\n    const path = editor.findPath(element)\n\n    if (!path) {\n      return null\n    }\n\n    const { value } = editor\n    const { document } = value\n    const node = document.getNode(path)\n    return node\n  }\n\n  /**\n   * Get the target range from a DOM `event`.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @return {Range}\n   */\n\n  function findEventRange(editor, event) {\n    if (event.nativeEvent) {\n      event = event.nativeEvent\n    }\n\n    const { clientX: x, clientY: y, target } = event\n    if (x == null || y == null) return null\n\n    const { value } = editor\n    const { document } = value\n    const path = editor.findPath(event.target)\n    if (!path) return null\n\n    const node = document.getNode(path)\n\n    // If the drop target is inside a void node, move it into either the next or\n    // previous node, depending on which side the `x` and `y` coordinates are\n    // closest to.\n    if (editor.isVoid(node)) {\n      const rect = target.getBoundingClientRect()\n      const isPrevious =\n        node.object === 'inline'\n          ? x - rect.left < rect.left + rect.width - x\n          : y - rect.top < rect.top + rect.height - y\n\n      const range = document.createRange()\n      const move = isPrevious ? 'moveToEndOfNode' : 'moveToStartOfNode'\n      const entry = document[isPrevious ? 'getPreviousText' : 'getNextText'](\n        path\n      )\n\n      if (entry) {\n        return range[move](entry)\n      }\n\n      return null\n    }\n\n    // Else resolve a range from the caret position where the drop occured.\n    const window = getWindow(target)\n    let native\n\n    // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n    if (window.document.caretRangeFromPoint) {\n      native = window.document.caretRangeFromPoint(x, y)\n    } else if (window.document.caretPositionFromPoint) {\n      const position = window.document.caretPositionFromPoint(x, y)\n      native = window.document.createRange()\n      native.setStart(position.offsetNode, position.offset)\n      native.setEnd(position.offsetNode, position.offset)\n    } else if (window.document.body.createTextRange) {\n      // COMPAT: In IE, `caretRangeFromPoint` and\n      // `caretPositionFromPoint` don't exist. (2018/07/11)\n      native = window.document.body.createTextRange()\n\n      try {\n        native.moveToPoint(x, y)\n      } catch (error) {\n        // IE11 will raise an `unspecified error` if `moveToPoint` is\n        // called during a dropEvent.\n        return null\n      }\n    }\n\n    // Resolve a Slate range from the DOM range.\n    const range = editor.findRange(native)\n    return range\n  }\n\n  /**\n   * Find the path of a native DOM `element` by searching React refs.\n   *\n   * @param {Editor} editor\n   * @param {Element} element\n   * @return {List|Null}\n   */\n\n  function findPath(editor, element) {\n    const content = editor.tmp.contentRef.current\n    let nodeElement = element\n\n    // If element does not have a key, it is likely a string or\n    // mark, return the closest parent Node that can be looked up.\n    if (!nodeElement.hasAttribute(DATA_ATTRS.KEY)) {\n      nodeElement = nodeElement.closest(SELECTORS.KEY)\n    }\n\n    if (!nodeElement || !nodeElement.getAttribute(DATA_ATTRS.KEY)) {\n      return null\n    }\n\n    if (nodeElement === content.ref.current) {\n      return PathUtils.create([])\n    }\n\n    const search = (instance, p) => {\n      if (nodeElement === instance) {\n        return p\n      }\n\n      if (!instance.ref) {\n        return null\n      }\n\n      if (nodeElement === instance.ref.current) {\n        return p\n      }\n\n      // If there's no `tmp` then we're at a leaf node without success.\n      if (!instance.tmp) {\n        return null\n      }\n\n      const { nodeRefs } = instance.tmp\n      const keys = Object.keys(nodeRefs)\n\n      for (const i of keys) {\n        const ref = nodeRefs[i]\n        const n = parseInt(i, 10)\n        const path = search(ref, [...p, n])\n\n        if (path) {\n          return path\n        }\n      }\n\n      return null\n    }\n\n    const document = content.tmp.nodeRef.current\n    const path = search(document, [])\n\n    if (!path) {\n      return null\n    }\n\n    return PathUtils.create(path)\n  }\n\n  /**\n   * Find a Slate point from a DOM selection's `nativeNode` and `nativeOffset`.\n   *\n   * @param {Editor} editor\n   * @param {Element} nativeNode\n   * @param {Number} nativeOffset\n   * @return {Point}\n   */\n\n  function findPoint(editor, nativeNode, nativeOffset) {\n    const { node: nearestNode, offset: nearestOffset } = normalizeNodeAndOffset(\n      nativeNode,\n      nativeOffset\n    )\n\n    const window = getWindow(nativeNode)\n    const { parentNode } = nearestNode\n    let leafNode = parentNode.closest(SELECTORS.LEAF)\n    let textNode\n    let offset\n    let node\n\n    // Calculate how far into the text node the `nearestNode` is, so that we can\n    // determine what the offset relative to the text node is.\n    if (leafNode) {\n      textNode = leafNode.closest(SELECTORS.TEXT)\n      const range = window.document.createRange()\n      range.setStart(textNode, 0)\n      range.setEnd(nearestNode, nearestOffset)\n      const contents = range.cloneContents()\n      const zeroWidths = contents.querySelectorAll(SELECTORS.ZERO_WIDTH)\n\n      Array.from(zeroWidths).forEach(el => {\n        el.parentNode.removeChild(el)\n      })\n\n      // COMPAT: Edge has a bug where Range.prototype.toString() will convert \\n\n      // into \\r\\n. The bug causes a loop when slate-react attempts to reposition\n      // its cursor to match the native position. Use textContent.length instead.\n      // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n      offset = contents.textContent.length\n      node = textNode\n    } else {\n      // For void nodes, the element with the offset key will be a cousin, not an\n      // ancestor, so find it by going down from the nearest void parent.\n      const voidNode = parentNode.closest(SELECTORS.VOID)\n\n      if (!voidNode) {\n        return null\n      }\n\n      leafNode = voidNode.querySelector(SELECTORS.LEAF)\n\n      if (!leafNode) {\n        return null\n      }\n\n      textNode = leafNode.closest(SELECTORS.TEXT)\n      node = leafNode\n      offset = node.textContent.length\n    }\n\n    // COMPAT: If the parent node is a Slate zero-width space, this is because the\n    // text node should have no characters. However, during IME composition the\n    // ASCII characters will be prepended to the zero-width space, so subtract 1\n    // from the offset to account for the zero-width space character.\n    if (\n      offset === node.textContent.length &&\n      parentNode.hasAttribute(DATA_ATTRS.ZERO_WIDTH)\n    ) {\n      offset--\n    }\n\n    // COMPAT: If someone is clicking from one Slate editor into another, the\n    // select event fires twice, once for the old editor's `element` first, and\n    // then afterwards for the correct `element`. (2017/03/03)\n    const path = editor.findPath(textNode)\n\n    if (!path) {\n      return null\n    }\n\n    const { value } = editor\n    const { document } = value\n    const point = document.createPoint({ path, offset })\n    return point\n  }\n\n  /**\n   * Find a Slate range from a DOM range or selection.\n   *\n   * @param {Editor} editor\n   * @param {Selection} domRange\n   * @return {Range}\n   */\n\n  function findRange(editor, domRange) {\n    const el = domRange.anchorNode || domRange.startContainer\n\n    if (!el) {\n      return null\n    }\n\n    const window = getWindow(el)\n\n    // If the `domRange` object is a DOM `Range` or `StaticRange` object, change it\n    // into something that looks like a DOM `Selection` instead.\n    if (\n      domRange instanceof window.Range ||\n      (window.StaticRange && domRange instanceof window.StaticRange)\n    ) {\n      domRange = {\n        anchorNode: domRange.startContainer,\n        anchorOffset: domRange.startOffset,\n        focusNode: domRange.endContainer,\n        focusOffset: domRange.endOffset,\n      }\n    }\n\n    const {\n      anchorNode,\n      anchorOffset,\n      focusNode,\n      focusOffset,\n      isCollapsed,\n    } = domRange\n    const { value } = editor\n    const anchor = editor.findPoint(anchorNode, anchorOffset)\n    const focus = isCollapsed\n      ? anchor\n      : editor.findPoint(focusNode, focusOffset)\n\n    if (!anchor || !focus) {\n      return null\n    }\n\n    const { document } = value\n    const range = document.createRange({\n      anchor,\n      focus,\n    })\n\n    return range\n  }\n\n  /**\n   * Find a Slate selection from a DOM selection.\n   *\n   * @param {Editor} editor\n   * @param {Selection} domSelection\n   * @return {Range}\n   */\n\n  function findSelection(editor, domSelection) {\n    const { value } = editor\n    const { document } = value\n\n    // If there are no ranges, the editor was blurred natively.\n    if (!domSelection.rangeCount) {\n      return null\n    }\n\n    // Otherwise, determine the Slate selection from the native one.\n    let range = editor.findRange(domSelection)\n\n    if (!range) {\n      return null\n    }\n\n    const { anchor, focus } = range\n    const anchorText = document.getNode(anchor.path)\n    const focusText = document.getNode(focus.path)\n    const anchorInline = document.getClosestInline(anchor.path)\n    const focusInline = document.getClosestInline(focus.path)\n    const focusBlock = document.getClosestBlock(focus.path)\n    const anchorBlock = document.getClosestBlock(anchor.path)\n\n    // COMPAT: If the anchor point is at the start of a non-void, and the\n    // focus point is inside a void node with an offset that isn't `0`, set\n    // the focus offset to `0`. This is due to void nodes <span>'s being\n    // positioned off screen, resulting in the offset always being greater\n    // than `0`. Since we can't know what it really should be, and since an\n    // offset of `0` is less destructive because it creates a hanging\n    // selection, go with `0`. (2017/09/07)\n    if (\n      anchorBlock &&\n      !editor.isVoid(anchorBlock) &&\n      anchor.offset === 0 &&\n      focusBlock &&\n      editor.isVoid(focusBlock) &&\n      focus.offset !== 0\n    ) {\n      range = range.setFocus(focus.setOffset(0))\n    }\n\n    // COMPAT: If the selection is at the end of a non-void inline node, and\n    // there is a node after it, put it in the node after instead. This\n    // standardizes the behavior, since it's indistinguishable to the user.\n    if (\n      anchorInline &&\n      !editor.isVoid(anchorInline) &&\n      anchor.offset === anchorText.text.length\n    ) {\n      const block = document.getClosestBlock(anchor.path)\n      const depth = document.getDepth(block.key)\n      const relativePath = PathUtils.drop(anchor.path, depth)\n      const [next] = block.texts({ path: relativePath })\n\n      if (next) {\n        const [, nextPath] = next\n        const absolutePath = anchor.path.slice(0, depth).concat(nextPath)\n        range = range.moveAnchorTo(absolutePath, 0)\n      }\n    }\n\n    if (\n      focusInline &&\n      !editor.isVoid(focusInline) &&\n      focus.offset === focusText.text.length\n    ) {\n      const block = document.getClosestBlock(focus.path)\n      const depth = document.getDepth(block.key)\n      const relativePath = PathUtils.drop(focus.path, depth)\n      const [next] = block.texts({ path: relativePath })\n\n      if (next) {\n        const [, nextPath] = next\n        const absolutePath = focus.path.slice(0, depth).concat(nextPath)\n        range = range.moveFocusTo(absolutePath, 0)\n      }\n    }\n\n    let selection = document.createSelection(range)\n\n    // COMPAT: Ensure that the `isFocused` argument is set.\n    selection = selection.setIsFocused(true)\n\n    // COMPAT: Preserve the marks, since we have no way of knowing what the DOM\n    // selection's marks were. They will be cleared automatically by the\n    // `select` command if the selection moves.\n    selection = selection.set('marks', value.selection.marks)\n\n    return selection\n  }\n\n  return {\n    queries: {\n      findDOMNode,\n      findDOMPoint,\n      findDOMRange,\n      findEventRange,\n      findNode,\n      findPath,\n      findPoint,\n      findRange,\n      findSelection,\n    },\n  }\n}\n\n/**\n * From a DOM selection's `node` and `offset`, normalize so that it always\n * refers to a text node.\n *\n * @param {Element} node\n * @param {Number} offset\n * @return {Object}\n */\n\nfunction normalizeNodeAndOffset(node, offset) {\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (node.nodeType === 1 && node.childNodes.length) {\n    const isLast = offset === node.childNodes.length\n    const direction = isLast ? 'backward' : 'forward'\n    const index = isLast ? offset - 1 : offset\n    node = getEditableChild(node, index, direction)\n\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n    while (node.nodeType === 1 && node.childNodes.length) {\n      const i = isLast ? node.childNodes.length - 1 : 0\n      node = getEditableChild(node, i, direction)\n    }\n\n    // Determine the new offset inside the text node.\n    offset = isLast ? node.textContent.length : 0\n  }\n\n  // Return the node and offset.\n  return { node, offset }\n}\n\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n *\n * @param {Element} parent\n * @param {Number} index\n * @param {String} direction ('forward' or 'backward')\n * @return {Element|Null}\n */\n\nfunction getEditableChild(parent, index, direction) {\n  const { childNodes } = parent\n  let child = childNodes[index]\n  let i = index\n  let triedForward = false\n  let triedBackward = false\n\n  // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n  while (\n    child.nodeType === 8 ||\n    (child.nodeType === 1 && child.childNodes.length === 0) ||\n    (child.nodeType === 1 && child.getAttribute('contenteditable') === 'false')\n  ) {\n    if (triedForward && triedBackward) break\n\n    if (i >= childNodes.length) {\n      triedForward = true\n      i = index - 1\n      direction = 'backward'\n      continue\n    }\n\n    if (i < 0) {\n      triedBackward = true\n      i = index + 1\n      direction = 'forward'\n      continue\n    }\n\n    child = childNodes[i]\n    if (direction === 'forward') i++\n    if (direction === 'backward') i--\n  }\n\n  return child || null\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default QueriesPlugin\n","/**\n * Returns the number of characters that are the same at the beginning of the\n * String.\n *\n * @param {String} prev\n * @param {String} next\n */\n\nfunction getDiffStart(prev, next) {\n  const length = Math.min(prev.length, next.length)\n\n  for (let i = 0; i < length; i++) {\n    if (prev.charAt(i) !== next.charAt(i)) return i\n  }\n\n  if (prev.length !== next.length) return length\n  return null\n}\n\n/**\n * Returns the number of characters that are the same at the end of the String\n * up to `max`. Max prevents double-counting characters when there are\n * multiple duplicate characters around the diff area.\n *\n * @param {String} prev\n * @param {String} next\n * @param {Number} max\n */\n\nfunction getDiffEnd(prev, next, max) {\n  const prevLength = prev.length\n  const nextLength = next.length\n  const length = Math.min(prevLength, nextLength, max)\n\n  for (let i = 0; i < length; i++) {\n    const prevChar = prev.charAt(prevLength - i - 1)\n    const nextChar = next.charAt(nextLength - i - 1)\n    if (prevChar !== nextChar) return i\n  }\n\n  if (prev.length !== next.length) return length\n  return null\n}\n\n/**\n * Takes two strings and returns an object representing two offsets. The\n * first, `start` represents the number of characters that are the same at\n * the front of the String. The `end` represents the number of characters\n * that are the same at the end of the String.\n *\n * Returns null if they are identical.\n *\n * @param {String} prev\n * @param {String} next\n */\n\nfunction getDiffOffsets(prev, next) {\n  if (prev === next) return null\n  const start = getDiffStart(prev, next)\n  const maxEnd = Math.min(prev.length - start, next.length - start)\n  const end = getDiffEnd(prev, next, maxEnd)\n  return { start, end, total: start + end }\n}\n\n/**\n * Takes a text string and returns a slice from the string at the given offses\n *\n * @param {String} text\n * @param {Object} offsets\n */\n\nfunction sliceText(text, offsets) {\n  return text.slice(offsets.start, text.length - offsets.end)\n}\n\n/**\n * Takes two strings and returns a smart diff that can be used to describe the\n * change in a way that can be used as operations like inserting, removing or\n * replacing text.\n *\n * @param {String} prev\n * @param {String} next\n */\n\nexport default function diff(prev, next) {\n  const offsets = getDiffOffsets(prev, next)\n  if (offsets == null) return null\n  const insertText = sliceText(next, offsets)\n  const removeText = sliceText(prev, offsets)\n  return {\n    start: offsets.start,\n    end: prev.length - offsets.end,\n    cursor: offsets.start + insertText.length,\n    insertText,\n    removeText,\n  }\n}\n","import Debug from 'debug'\nimport getWindow from 'get-window'\nimport ReactDOM from 'react-dom'\nimport diffText from './diff-text'\n\n/**\n * @type {Debug}\n */\n\nconst debug = Debug('slate:composition-manager')\n\n/**\n * Unicode String for a ZERO_WIDTH_SPACE\n *\n * @type {String}\n */\n\nconst ZERO_WIDTH_SPACE = String.fromCharCode(65279)\n\n/**\n * https://github.com/facebook/draft-js/commit/cda13cb8ff9c896cdb9ff832d1edeaa470d3b871\n */\n\nconst flushControlled = ReactDOM.unstable_flushControlled\n\nfunction renderSync(editor, fn) {\n  flushControlled(() => {\n    fn()\n    editor.controller.flush()\n  })\n}\n\n/**\n * Takes text from a dom node and an offset within that text and returns an\n * object with fixed text and fixed offset which removes zero width spaces\n * and adjusts the offset.\n *\n * Optionally, if an `isLastNode` argument is passed in, it will also remove\n * a trailing newline.\n *\n * @param {String} text\n * @param {Number} offset\n * @param {Boolean} isLastNode\n */\n\nfunction fixTextAndOffset(prevText, prevOffset = 0, isLastNode = false) {\n  let nextOffset = prevOffset\n  let nextText = prevText\n  let index = 0\n\n  while (index !== -1) {\n    index = nextText.indexOf(ZERO_WIDTH_SPACE, index)\n    if (index === -1) break\n    if (nextOffset > index) nextOffset--\n    nextText = `${nextText.slice(0, index)}${nextText.slice(index + 1)}`\n  }\n\n  // remove the last newline if we are in the last node of a block\n  const lastChar = nextText.charAt(nextText.length - 1)\n\n  if (isLastNode && lastChar === '\\n') {\n    nextText = nextText.slice(0, -1)\n  }\n\n  const maxOffset = nextText.length\n\n  if (nextOffset > maxOffset) nextOffset = maxOffset\n  return { text: nextText, offset: nextOffset }\n}\n\n/**\n * Based loosely on:\n *\n * https://github.com/facebook/draft-js/blob/master/src/component/handlers/composition/DOMObserver.js\n * https://github.com/ProseMirror/prosemirror-view/blob/master/src/domobserver.js\n *\n * But is an analysis mainly for `backspace` and `enter` as we handle\n * compositions as a single operation.\n *\n * @param {} element\n */\n\nfunction CompositionManager(editor) {\n  /**\n   * A MutationObserver that flushes to the method `flush`\n   *\n   * @type {MutationObserver}\n   */\n\n  const observer = new window.MutationObserver(flush)\n\n  let win = null\n\n  /**\n   * Object that keeps track of the most recent state\n   *\n   * @type {Range}\n   */\n\n  const last = {\n    rootEl: null, // root element that MutationObserver is attached to\n    diff: null, // last text node diff between Slate and DOM\n    range: null, // last range selected\n    domNode: null, // last DOM node the cursor was in\n  }\n\n  /**\n   * Connect the MutationObserver to a specific editor root element\n   */\n\n  function connect() {\n    debug('connect', { rootEl })\n\n    const rootEl = editor.findDOMNode([])\n\n    if (last.rootEl === rootEl) return\n\n    debug('connect:run')\n\n    win = getWindow(rootEl)\n\n    observer.observe(rootEl, {\n      childList: true,\n      characterData: true,\n      attributes: true,\n      subtree: true,\n      characterDataOldValue: true,\n    })\n  }\n\n  function disconnect() {\n    debug('disconnect')\n    observer.disconnect()\n    last.rootEl = null\n  }\n\n  function clearDiff() {\n    debug('clearDIff')\n    last.diff = null\n  }\n\n  /**\n   * Clear the `last` properties related to an action only\n   */\n\n  function clearAction() {\n    debug('clearAction')\n    last.diff = null\n    last.domNode = null\n  }\n\n  /**\n   * Apply the last `diff`\n   *\n   * We don't want to apply the `diff` at the time it is created because we\n   * may be in a composition. There are a few things that trigger the applying\n   * of the saved diff. Sometimeson its own and sometimes immediately before\n   * doing something else with the Editor.\n   *\n   * - `onCompositionEnd` event\n   * - `onSelect` event only when the user has moved into a different node\n   * - The user hits `enter`\n   * - The user hits `backspace` and removes an inline node\n   * - The user hits `backspace` and merges two blocks\n   */\n\n  function applyDiff() {\n    debug('applyDiff')\n    const { diff } = last\n    if (diff == null) return\n    debug('applyDiff:run')\n    const { document } = editor.value\n\n    let entire = editor.value.selection\n      .moveAnchorTo(diff.path, diff.start)\n      .moveFocusTo(diff.path, diff.end)\n\n    entire = document.resolveRange(entire)\n\n    editor.insertTextAtRange(entire, diff.insertText)\n  }\n\n  /**\n   * Handle `enter` that splits block\n   */\n\n  function splitBlock() {\n    debug('splitBlock')\n\n    renderSync(editor, () => {\n      applyDiff()\n\n      if (last.range) {\n        editor.select(last.range)\n      } else {\n        debug('splitBlock:NO-SELECTION')\n      }\n\n      editor\n        .splitBlock()\n        .focus()\n        .restoreDOM()\n\n      clearAction()\n    })\n  }\n\n  /**\n   * Handle `backspace` that merges blocks\n   */\n\n  function mergeBlock() {\n    debug('mergeBlock')\n\n    /**\n     * The delay is required because hitting `enter`, `enter` then `backspace`\n     * in a word results in the cursor being one position to the right in\n     * Android 9.\n     *\n     * Slate sets the position to `0` and we even check it immediately after\n     * setting it and it is correct, but somewhere Android moves it to the right.\n     *\n     * This happens only when using the virtual keyboard. Hitting enter on a\n     * hardware keyboard does not trigger this bug.\n     *\n     * The call to `focus` is required because when we switch examples then\n     * merge a block, we lose focus in Android 9 (possibly others).\n     */\n\n    win.requestAnimationFrame(() => {\n      renderSync(editor, () => {\n        applyDiff()\n\n        editor\n          .select(last.range)\n          .deleteBackward()\n          .focus()\n          .restoreDOM()\n\n        clearAction()\n      })\n    })\n  }\n\n  /**\n   * The requestId used to the save selection\n   *\n   * @type {Any}\n   */\n\n  let onSelectTimeoutId = null\n\n  let bufferedMutations = []\n  let startActionFrameId = null\n  let isFlushing = false\n\n  /**\n   * Mark the beginning of an action. The action happens when the\n   * `requestAnimationFrame` expires.\n   *\n   * If `startAction` is called again, it pushes the `action` to a new\n   * `requestAnimationFrame` and cancels the old one.\n   */\n\n  function startAction() {\n    if (onSelectTimeoutId) {\n      window.cancelAnimationFrame(onSelectTimeoutId)\n      onSelectTimeoutId = null\n    }\n\n    isFlushing = true\n\n    if (startActionFrameId) window.cancelAnimationFrame(startActionFrameId)\n\n    startActionFrameId = window.requestAnimationFrame(() => {\n      if (bufferedMutations.length > 0) {\n        flushAction(bufferedMutations)\n      }\n\n      startActionFrameId = null\n      bufferedMutations = []\n      isFlushing = false\n    })\n  }\n\n  /**\n   * Handle MutationObserver flush\n   *\n   * @param {MutationList} mutations\n   */\n\n  function flush(mutations) {\n    debug('flush')\n    bufferedMutations.push(...mutations)\n    startAction()\n  }\n\n  /**\n   * Handle a `requestAnimationFrame` long batch of mutations.\n   *\n   * @param {Array} mutations\n   */\n\n  function flushAction(mutations) {\n    debug('flushAction', mutations.length, mutations)\n\n    // If there is an expanded collection, delete it\n    if (last.range && !last.range.isCollapsed) {\n      renderSync(editor, () => {\n        editor\n          .select(last.range)\n          .deleteBackward()\n          .focus()\n          .restoreDOM()\n      })\n      return\n    }\n\n    if (mutations.length > 1) {\n      // check if one of the mutations matches the signature of an `enter`\n      // which we use to signify a `splitBlock`\n      const splitBlockMutation = mutations.find(m => {\n        if (m.type !== 'childList') return false\n        if (m.addedNodes.length === 0) return false\n        const addedNode = m.addedNodes[0]\n\n        // If a text node is created anywhere with a newline in it, it's an\n        // enter\n        if (\n          addedNode.nodeType === window.Node.TEXT_NODE &&\n          addedNode.textContent === '\\n'\n        )\n          return true\n\n        // If an element is created with a key that matches a block in our\n        // document, that means the mutation is splitting an existing block\n        // by creating a new element with the same key.\n        if (addedNode.nodeType !== window.Node.ELEMENT_NODE) return false\n        const dataset = addedNode.dataset\n        const key = dataset.key\n        if (key == null) return false\n        const block = editor.value.document.getClosestBlock(key)\n        return !!block\n      })\n\n      if (splitBlockMutation) {\n        splitBlock()\n        return\n      }\n    }\n\n    // If we haven't matched a more specific mutation already, these general\n    // mutation catchers will try and determine what the user was trying to\n    // do.\n\n    const firstMutation = mutations[0]\n\n    if (firstMutation.type === 'characterData') {\n      resolveDOMNode(firstMutation.target.parentNode)\n    } else if (firstMutation.type === 'childList') {\n      if (firstMutation.removedNodes.length > 0) {\n        if (mutations.length === 1) {\n          removeNode(firstMutation.removedNodes[0])\n        } else {\n          mergeBlock()\n        }\n      } else if (firstMutation.addedNodes.length > 0) {\n        splitBlock()\n      }\n    }\n  }\n\n  /**\n   * Takes a DOM Node and resolves it against Slate's Document.\n   *\n   * Saves the changes to `last.diff` which can be applied later using\n   * `applyDiff()`\n   *\n   * @param {DOMNode} domNode\n   */\n\n  function resolveDOMNode(domNode) {\n    debug('resolveDOMNode')\n\n    const { value } = editor\n    const { document } = value\n\n    const dataElement = domNode.closest(`[data-key]`)\n    const key = dataElement.dataset.key\n    const path = document.getPath(key)\n    const block = document.getClosestBlock(key)\n    const node = document.getDescendant(key)\n    const prevText = node.text\n\n    // COMPAT: If this is the last leaf, and the DOM text ends in a new line,\n    // we will have added another new line in <Leaf>'s render method to account\n    // for browsers collapsing a single trailing new lines, so remove it.\n    const isLastNode = block.nodes.last() === node\n\n    const fix = fixTextAndOffset(domNode.textContent, 0, isLastNode)\n\n    const nextText = fix.text\n\n    // If the text is no different, there is no diff.\n    if (nextText === prevText) {\n      last.diff = null\n      return\n    }\n\n    const diff = diffText(prevText, nextText)\n\n    last.diff = {\n      path,\n      start: diff.start,\n      end: diff.end,\n      insertText: diff.insertText,\n    }\n\n    debug('resolveDOMNode:diff', last.diff)\n  }\n\n  /**\n   * Remove an Inline DOM Node.\n   *\n   * Happens when you delete the last character in an Inline DOM Node\n   */\n\n  function removeNode(domNode) {\n    debug('removeNode')\n    if (domNode.nodeType !== window.Node.ELEMENT_NODE) return\n    const { value } = editor\n    const { document, selection } = value\n    const node = editor.findNode(domNode)\n    const nodeSelection = document.resolveRange(\n      selection.moveToRangeOfNode(node)\n    )\n\n    renderSync(editor, () => {\n      editor\n        .select(nodeSelection)\n        .delete()\n        .restoreDOM()\n    })\n  }\n\n  /**\n   * handle `onCompositionStart`\n   */\n\n  function onCompositionStart() {\n    debug('onCompositionStart')\n  }\n\n  /**\n   * handle `onCompositionEnd`\n   */\n\n  function onCompositionEnd() {\n    debug('onCompositionEnd')\n\n    /**\n     * The timing on the `setTimeout` with `20` ms is sensitive.\n     *\n     * It cannot use `requestAnimationFrame` because it is too short.\n     *\n     * Android 9, for example, when you type `it ` the space will first trigger\n     * a `compositionEnd` for the `it` part before the mutation for the ` `.\n     * This means that we end up with `it` if we trigger too soon because it\n     * is on the wrong value.\n     */\n\n    window.setTimeout(() => {\n      if (last.diff) {\n        debug('onCompositionEnd:applyDiff')\n\n        renderSync(editor, () => {\n          applyDiff()\n\n          const domRange = win.getSelection().getRangeAt(0)\n          const domText = domRange.startContainer.textContent\n          const offset = domRange.startOffset\n\n          const fix = fixTextAndOffset(domText, offset)\n\n          const range = editor\n            .findRange({\n              anchorNode: domRange.startContainer,\n              anchorOffset: 0,\n              focusNode: domRange.startContainer,\n              focusOffset: 0,\n              isCollapsed: true,\n            })\n            .moveTo(fix.offset)\n\n          /**\n           * We must call `restoreDOM` even though this is applying a `diff` which\n           * should not require it. But if you type `it me. no.` on a blank line\n           * with a block following it, the next line will merge with the this\n           * line. A mysterious `keydown` with `input` of backspace appears in the\n           * event stream which the user not React caused.\n           *\n           * `focus` is required as well because otherwise we lose focus on hitting\n           * `enter` in such a scenario.\n           */\n\n          editor\n            .select(range)\n            .focus()\n            .restoreDOM()\n        })\n      }\n\n      clearAction()\n    }, 20)\n  }\n\n  /**\n   * Handle `onSelect` event\n   *\n   * Save the selection after a `requestAnimationFrame`\n   *\n   * - If we're not in the middle of flushing mutations\n   * - and cancel save if a mutation runs before the `requestAnimationFrame`\n   */\n\n  function onSelect(event) {\n    debug('onSelect:try')\n\n    // Event can be Synthetic React or native. Grab only the native one so\n    // that we don't have to call `event.perist` for performance.\n    event = event.nativeEvent ? event.nativeEvent : event\n\n    window.cancelAnimationFrame(onSelectTimeoutId)\n    onSelectTimeoutId = null\n\n    // Don't capture the last selection if the selection was made during the\n    // flushing of DOM mutations. This means it is all part of one user action.\n    if (isFlushing) return\n\n    onSelectTimeoutId = window.requestAnimationFrame(() => {\n      debug('onSelect:save-selection')\n\n      const domSelection = getWindow(event.target).getSelection()\n      let range = editor.findRange(domSelection)\n\n      const anchorFix = fixTextAndOffset(\n        domSelection.anchorNode.textContent,\n        domSelection.anchorOffset\n      )\n\n      const focusFix = fixTextAndOffset(\n        domSelection.focusNode.textContent,\n        domSelection.focusOffset\n      )\n\n      if (range.anchor.offset !== anchorFix.offset) {\n        range = range.set(\n          'anchor',\n          range.anchor.set('offset', anchorFix.offset)\n        )\n      }\n\n      if (range.focus.offset !== focusFix.offset) {\n        range = range.set('focus', range.focus.set('offset', focusFix.offset))\n      }\n\n      debug('onSelect:save-data', {\n        domSelection: normalizeDOMSelection(domSelection),\n        range: range.toJS(),\n      })\n\n      // If the `domSelection` has moved into a new node, then reconcile with\n      // `applyDiff`\n      if (\n        domSelection.isCollapsed &&\n        last.node !== domSelection.anchorNode &&\n        last.diff != null\n      ) {\n        debug('onSelect:applyDiff', last.diff)\n        applyDiff()\n        editor.select(range)\n        clearAction()\n      }\n\n      last.range = range\n      last.node = domSelection.anchorNode\n    })\n  }\n\n  return {\n    clearDiff,\n    connect,\n    disconnect,\n    onKeyDown: startAction,\n    onCompositionStart,\n    onCompositionEnd,\n    onSelect,\n  }\n}\n\nfunction normalizeDOMSelection(selection) {\n  return {\n    anchorNode: selection.anchorNode,\n    anchorOffset: selection.anchorOffset,\n    focusNode: selection.focusNode,\n    focusOffset: selection.focusOffset,\n  }\n}\n\nexport default CompositionManager\n","import getWindow from 'get-window'\nimport CompositionManager from './composition-manager'\n\n/**\n * Fixes a selection within the DOM when the cursor is in Slate's special\n * zero-width block. Slate handles empty blocks in a special manner and the\n * cursor can end up either before or after the non-breaking space. This\n * causes different behavior in Android and so we make sure the seleciton is\n * always before the zero-width space.\n *\n * @param {Window} window\n */\n\nfunction fixSelectionInZeroWidthBlock(window) {\n  const domSelection = window.getSelection()\n  const { anchorNode } = domSelection\n  if (anchorNode == null) return\n  const { dataset } = anchorNode.parentElement\n  const isZeroWidth = dataset ? dataset.slateZeroWidth === 'n' : false\n\n  if (\n    isZeroWidth &&\n    anchorNode.textContent.length === 1 &&\n    domSelection.anchorOffset !== 0\n  ) {\n    const range = window.document.createRange()\n    range.setStart(anchorNode, 0)\n    range.setEnd(anchorNode, 0)\n    domSelection.removeAllRanges()\n    domSelection.addRange(range)\n  }\n}\n\n/**\n * Android Plugin\n *\n * @param {Editor} options.editor\n */\n\nfunction AndroidPlugin({ editor }) {\n  const observer = new CompositionManager(editor)\n\n  /**\n   * handle `onCompositionStart`\n   */\n\n  function onCompositionStart() {\n    observer.onCompositionStart()\n  }\n\n  /**\n   * handle `onCompositionEnd`\n   */\n\n  function onCompositionEnd() {\n    observer.onCompositionEnd()\n  }\n\n  /**\n   * handle `onSelect`\n   *\n   * @param {Event} event\n   */\n\n  function onSelect(event) {\n    const window = getWindow(event.target)\n    fixSelectionInZeroWidthBlock(window)\n    observer.onSelect(event)\n  }\n\n  /**\n   * handle `onComponentDidMount`\n   */\n\n  function onComponentDidMount() {\n    observer.connect()\n  }\n\n  /**\n   * handle `onComponentDidUpdate`\n   */\n\n  function onComponentDidUpdate() {\n    observer.connect()\n  }\n\n  /**\n   * handle `onComponentWillUnmount`\n   *\n   * @param {Event} event\n   */\n\n  function onComponentWillUnmount() {\n    observer.disconnect()\n  }\n\n  /**\n   * handle `onRender`\n   *\n   * @param {Event} event\n   */\n\n  function onRender() {\n    observer.disconnect()\n\n    // We don't want the `diff` from a previous render to apply to a\n    // potentially different value (e.g. when we switch examples)\n    observer.clearDiff()\n  }\n\n  return {\n    onComponentDidMount,\n    onComponentDidUpdate,\n    onComponentWillUnmount,\n    onCompositionEnd,\n    onCompositionStart,\n    onRender,\n    onSelect,\n  }\n}\n\nexport default AndroidPlugin\n","import EVENT_HANDLERS from '../../constants/event-handlers'\n\n/**\n * This plugin prevents events from going any further and is useful in dev.\n *\n * The purpose is to see how the editor events and mutations behave without\n * the noise of the editor also adding its own events and mutations.\n *\n * IMPORTANT:\n *\n * This plugin is detached (i.e. there is no way to turn it on in Slate).\n * You must hard code it into `plugins/react/index`.\n *\n * @return {Object}\n */\n\nfunction NoopPlugin() {\n  /**\n   * Plugin Object\n   *\n   * @type {Object}\n   */\n\n  const plugin = {}\n\n  for (const eventName of EVENT_HANDLERS) {\n    plugin[eventName] = function(event, editor, next) {}\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return plugin\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default NoopPlugin\n","/**\n * The transfer types that Slate recognizes.\n *\n * @type {Object}\n */\n\nexport default {\n  FRAGMENT: 'application/x-slate-fragment',\n  HTML: 'text/html',\n  NODE: 'application/x-slate-node',\n  RICH: 'text/rtf',\n  TEXT: 'text/plain',\n}\n","import Base64 from 'slate-base64-serializer'\nimport Plain from 'slate-plain-serializer'\nimport getWindow from 'get-window'\nimport invariant from 'tiny-invariant'\nimport { IS_IE } from 'slate-dev-environment'\nimport { Value } from 'slate'\n\nimport TRANSFER_TYPES from '../constants/transfer-types'\nimport removeAllRanges from './remove-all-ranges'\nimport DATA_ATTRS from '../constants/data-attributes'\nimport SELECTORS from '../constants/selectors'\n\nconst { FRAGMENT, HTML, TEXT } = TRANSFER_TYPES\n\n/**\n * Prepares a Slate document fragment to be copied to the clipboard.\n *\n * @param {Event} event\n * @param {Editor} editor\n */\n\nfunction cloneFragment(event, editor, callback = () => undefined) {\n  invariant(\n    !Value.isValue(editor),\n    'As of Slate 0.42.0, the `cloneFragment` utility takes an `editor` instead of a `value`.'\n  )\n\n  const window = getWindow(event.target)\n  const native = window.getSelection()\n  const { value } = editor\n  const { document, fragment, selection } = value\n  const { start, end } = selection\n  const startVoid = document.getClosestVoid(start.path, editor)\n  const endVoid = document.getClosestVoid(end.path, editor)\n\n  // If the selection is collapsed, and it isn't inside a void node, abort.\n  if (native.isCollapsed && !startVoid) return\n\n  // Create a fake selection so that we can add a Base64-encoded copy of the\n  // fragment to the HTML, to decode on future pastes.\n  const encoded = Base64.serializeNode(fragment)\n  const range = native.getRangeAt(0)\n  let contents = range.cloneContents()\n  let attach = contents.childNodes[0]\n\n  // Make sure attach is a non-empty node, since empty nodes will not get copied\n  contents.childNodes.forEach(node => {\n    if (node.textContent && node.textContent.trim() !== '') {\n      attach = node\n    }\n  })\n\n  // COMPAT: If the end node is a void node, we need to move the end of the\n  // range from the void node's spacer span, to the end of the void node's\n  // content, since the spacer is before void's content in the DOM.\n  if (endVoid) {\n    const r = range.cloneRange()\n    const path = document.getPath(endVoid.key)\n\n    if (path) {\n      const node = editor.findDOMNode(path)\n      r.setEndAfter(node)\n      contents = r.cloneContents()\n    }\n  }\n\n  // COMPAT: If the start node is a void node, we need to attach the encoded\n  // fragment to the void node's content node instead of the spacer, because\n  // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n  // most browsers. (2018/04/27)\n  if (startVoid) {\n    attach = contents.childNodes[0].childNodes[1].firstChild\n  }\n\n  // Remove any zero-width space spans from the cloned DOM so that they don't\n  // show up elsewhere when pasted.\n  ;[].slice\n    .call(contents.querySelectorAll(SELECTORS.ZERO_WIDTH))\n    .forEach(zw => {\n      const isNewline = zw.getAttribute(DATA_ATTRS.ZERO_WIDTH) === 'n'\n      zw.textContent = isNewline ? '\\n' : ''\n    })\n\n  // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n  // in the HTML, and can be used for intra-Slate pasting. If it's a text\n  // node, wrap it in a `<span>` so we have something to set an attribute on.\n  if (attach.nodeType === 3) {\n    const span = window.document.createElement('span')\n\n    // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n    // then leading and trailing spaces will be ignored. (2017/09/21)\n    span.style.whiteSpace = 'pre'\n\n    span.appendChild(attach)\n    contents.appendChild(span)\n    attach = span\n  }\n\n  attach.setAttribute(DATA_ATTRS.FRAGMENT, encoded)\n\n  //  Creates value from only the selected blocks\n  //  Then gets plaintext for clipboard with proper linebreaks for BLOCK elements\n  //  Via Plain serializer\n  const valFromSelection = Value.create({ document: fragment })\n  const plainText = Plain.serialize(valFromSelection)\n\n  // Add the phony content to a div element. This is needed to copy the\n  // contents into the html clipboard register.\n  const div = window.document.createElement('div')\n  div.appendChild(contents)\n\n  // For browsers supporting it, we set the clipboard registers manually,\n  // since the result is more predictable.\n  // COMPAT: IE supports the setData method, but only in restricted sense.\n  // IE doesn't support arbitrary MIME types or common ones like 'text/plain';\n  // it only accepts \"Text\" (which gets mapped to 'text/plain') and \"Url\"\n  // (mapped to 'text/url-list'); so, we should only enter block if !IS_IE\n  if (event.clipboardData && event.clipboardData.setData && !IS_IE) {\n    event.preventDefault()\n    event.clipboardData.setData(TEXT, plainText)\n    event.clipboardData.setData(FRAGMENT, encoded)\n    event.clipboardData.setData(HTML, div.innerHTML)\n    callback()\n    return\n  }\n\n  // COMPAT: For browser that don't support the Clipboard API's setData method,\n  // we must rely on the browser to natively copy what's selected.\n  // So we add the div (containing our content) to the DOM, and select it.\n  const editorEl = event.target.closest(SELECTORS.EDITOR)\n  div.setAttribute('contenteditable', true)\n  div.style.position = 'absolute'\n  div.style.left = '-9999px'\n  editorEl.appendChild(div)\n  native.selectAllChildren(div)\n\n  // Revert to the previous selection right after copying.\n  window.requestAnimationFrame(() => {\n    editorEl.removeChild(div)\n    removeAllRanges(native)\n    native.addRange(range)\n    callback()\n  })\n}\n\nexport default cloneFragment\n","import Base64 from 'slate-base64-serializer'\nimport { IS_IE } from 'slate-dev-environment'\n\nimport TRANSFER_TYPES from '../constants/transfer-types'\nimport DATA_ATTRS from '../constants/data-attributes'\n\n/**\n * Transfer types.\n *\n * @type {String}\n */\n\nconst { FRAGMENT, HTML, NODE, RICH, TEXT } = TRANSFER_TYPES\n\n/**\n * Fragment matching regexp for HTML nodes.\n *\n * @type {RegExp}\n */\n\nconst FRAGMENT_MATCHER = / data-slate-fragment=\"([^\\s\"]+)\"/\n\n/**\n * Get the transfer data from an `event`.\n *\n * @param {Event} event\n * @return {Object}\n */\n\nfunction getEventTransfer(event) {\n  // COMPAT: IE 11 doesn't populate nativeEvent with either\n  // dataTransfer or clipboardData. We'll need to use the base event\n  // object (2018/14/6)\n  if (!IS_IE && event.nativeEvent) {\n    event = event.nativeEvent\n  }\n\n  const transfer = event.dataTransfer || event.clipboardData\n  let fragment = getType(transfer, FRAGMENT)\n  let node = getType(transfer, NODE)\n  const html = getType(transfer, HTML)\n  const rich = getType(transfer, RICH)\n  let text = getType(transfer, TEXT)\n  let files\n\n  // If there isn't a fragment, but there is HTML, check to see if the HTML is\n  // actually an encoded fragment.\n  if (!fragment && html && ~html.indexOf(` ${DATA_ATTRS.FRAGMENT}=\"`)) {\n    const matches = FRAGMENT_MATCHER.exec(html)\n    const [full, encoded] = matches // eslint-disable-line no-unused-vars\n    if (encoded) fragment = encoded\n  }\n\n  // COMPAT: Edge doesn't handle custom data types\n  // These will be embedded in text/plain in this case (2017/7/12)\n  if (text) {\n    const embeddedTypes = getEmbeddedTypes(text)\n\n    if (embeddedTypes[FRAGMENT]) fragment = embeddedTypes[FRAGMENT]\n    if (embeddedTypes[NODE]) node = embeddedTypes[NODE]\n    if (embeddedTypes[TEXT]) text = embeddedTypes[TEXT]\n  }\n\n  // Decode a fragment or node if they exist.\n  if (fragment) fragment = Base64.deserializeNode(fragment)\n  if (node) node = Base64.deserializeNode(node)\n\n  // COMPAT: Edge sometimes throws 'NotSupportedError'\n  // when accessing `transfer.items` (2017/7/12)\n  try {\n    // Get and normalize files if they exist.\n    if (transfer.items && transfer.items.length) {\n      files = Array.from(transfer.items)\n        .map(item => (item.kind === 'file' ? item.getAsFile() : null))\n        .filter(exists => exists)\n    } else if (transfer.files && transfer.files.length) {\n      files = Array.from(transfer.files)\n    }\n  } catch (err) {\n    if (transfer.files && transfer.files.length) {\n      files = Array.from(transfer.files)\n    }\n  }\n\n  // Determine the type of the data.\n  const data = { files, fragment, html, node, rich, text }\n  data.type = getTransferType(data)\n  return data\n}\n\n/**\n * Takes text input, checks whether contains embedded data\n * and returns object with original text +/- additional data\n *\n * @param {String} text\n * @return {Object}\n */\n\nfunction getEmbeddedTypes(text) {\n  const prefix = 'SLATE-DATA-EMBED::'\n\n  if (text.substring(0, prefix.length) !== prefix) {\n    return { TEXT: text }\n  }\n\n  // Attempt to parse, if fails then just standard text/plain\n  // Otherwise, already had data embedded\n  try {\n    return JSON.parse(text.substring(prefix.length))\n  } catch (err) {\n    throw new Error('Unable to parse custom Slate drag event data.')\n  }\n}\n\n/**\n * Get the type of a transfer from its `data`.\n *\n * @param {Object} data\n * @return {String}\n */\n\nfunction getTransferType(data) {\n  if (data.fragment) return 'fragment'\n  if (data.node) return 'node'\n\n  // COMPAT: Microsoft Word adds an image of the selected text to the data.\n  // Since files are preferred over HTML or text, this would cause the type to\n  // be considered `files`. But it also adds rich text data so we can check\n  // for that and properly set the type to `html` or `text`. (2016/11/21)\n  if (data.rich && data.html) return 'html'\n  if (data.rich && data.text) return 'text'\n\n  if (data.files && data.files.length) return 'files'\n  if (data.html) return 'html'\n  if (data.text) return 'text'\n  return 'unknown'\n}\n\n/**\n * Get one of types `TYPES.FRAGMENT`, `TYPES.NODE`, `text/html`, `text/rtf` or\n * `text/plain` from transfers's `data` if possible, otherwise return null.\n *\n * @param {Object} transfer\n * @param {String} type\n * @return {String}\n */\n\nfunction getType(transfer, type) {\n  if (!transfer.types || !transfer.types.length) {\n    // COMPAT: In IE 11, there is no `types` field but `getData('Text')`\n    // is supported`. (2017/06/23)\n    return type === TEXT ? transfer.getData('Text') || null : null\n  }\n\n  // COMPAT: In Edge, transfer.types doesn't respond to `indexOf`. (2017/10/25)\n  const types = Array.from(transfer.types)\n\n  return types.indexOf(type) !== -1 ? transfer.getData(type) || null : null\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default getEventTransfer\n","import TRANSFER_TYPES from '../constants/transfer-types'\n\n/**\n * The default plain text transfer type.\n *\n * @type {String}\n */\n\nconst { TEXT } = TRANSFER_TYPES\n\n/**\n * Set data with `type` and `content` on an `event`.\n *\n * COMPAT: In Edge, custom types throw errors, so embed all non-standard\n * types in text/plain compound object. (2017/7/12)\n *\n * @param {Event} event\n * @param {String} type\n * @param {String} content\n */\n\nfunction setEventTransfer(event, type, content) {\n  const mime = TRANSFER_TYPES[type.toUpperCase()]\n\n  if (!mime) {\n    throw new Error(`Cannot set unknown transfer type \"${mime}\".`)\n  }\n\n  if (event.nativeEvent) {\n    event = event.nativeEvent\n  }\n\n  const transfer = event.dataTransfer || event.clipboardData\n\n  try {\n    transfer.setData(mime, content)\n    // COMPAT: Safari needs to have the 'text' (and not 'text/plain') value in dataTransfer\n    // to display the cursor while dragging internally.\n    transfer.setData('text', transfer.getData('text'))\n  } catch (err) {\n    const prefix = 'SLATE-DATA-EMBED::'\n    const text = transfer.getData(TEXT)\n    let obj = {}\n\n    // If the existing plain text data is prefixed, it's Slate JSON data.\n    if (text.substring(0, prefix.length) === prefix) {\n      try {\n        obj = JSON.parse(text.substring(prefix.length))\n      } catch (e) {\n        throw new Error(\n          'Failed to parse Slate data from `DataTransfer` object.'\n        )\n      }\n    } else {\n      // Otherwise, it's just set it as is.\n      obj[TEXT] = text\n    }\n\n    obj[mime] = content\n    const string = `${prefix}${JSON.stringify(obj)}`\n    transfer.setData(TEXT, string)\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default setEventTransfer\n","import Base64 from 'slate-base64-serializer'\nimport Debug from 'debug'\nimport Hotkeys from 'slate-hotkeys'\nimport Plain from 'slate-plain-serializer'\nimport getWindow from 'get-window'\nimport { IS_IOS, IS_IE, IS_EDGE } from 'slate-dev-environment'\n\nimport cloneFragment from '../../utils/clone-fragment'\nimport getEventTransfer from '../../utils/get-event-transfer'\nimport setEventTransfer from '../../utils/set-event-transfer'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:after')\n\n/**\n * A plugin that adds the \"after\" browser-specific logic to the editor.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction AfterPlugin(options = {}) {\n  let isDraggingInternally = null\n  let isMouseDown = false\n\n  /**\n   * On before input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBeforeInput(event, editor, next) {\n    const { value } = editor\n    const isSynthetic = !!event.nativeEvent\n\n    // If the event is synthetic, it's React's polyfill of `beforeinput` that\n    // isn't a true `beforeinput` event with meaningful information. It only\n    // gets triggered for character insertions, so we can just insert directly.\n    if (isSynthetic) {\n      event.preventDefault()\n      editor.insertText(event.data)\n      return next()\n    }\n\n    // Otherwise, we can use the information in the `beforeinput` event to\n    // figure out the exact change that will occur, and prevent it.\n    const [targetRange] = event.getTargetRanges()\n    if (!targetRange) return next()\n\n    debug('onBeforeInput', { event })\n\n    event.preventDefault()\n\n    const { document, selection } = value\n    const range = editor.findRange(targetRange)\n\n    switch (event.inputType) {\n      case 'deleteByDrag':\n      case 'deleteByCut':\n      case 'deleteContent':\n      case 'deleteContentBackward':\n      case 'deleteContentForward': {\n        editor.deleteAtRange(range)\n        break\n      }\n\n      case 'deleteWordBackward': {\n        editor.deleteWordBackwardAtRange(range)\n        break\n      }\n\n      case 'deleteWordForward': {\n        editor.deleteWordForwardAtRange(range)\n        break\n      }\n\n      case 'deleteSoftLineBackward':\n      case 'deleteHardLineBackward': {\n        editor.deleteLineBackwardAtRange(range)\n        break\n      }\n\n      case 'deleteSoftLineForward':\n      case 'deleteHardLineForward': {\n        editor.deleteLineForwardAtRange(range)\n        break\n      }\n\n      case 'insertLineBreak':\n      case 'insertParagraph': {\n        const hasVoidParent = document.hasVoidParent(\n          selection.start.path,\n          editor\n        )\n\n        if (hasVoidParent) {\n          editor.moveToStartOfNextText()\n        } else {\n          editor.splitBlockAtRange(range)\n        }\n\n        break\n      }\n\n      case 'insertFromYank':\n      case 'insertReplacementText':\n      case 'insertText': {\n        // COMPAT: `data` should have the text for the `insertText` input type\n        // and `dataTransfer` should have the text for the\n        // `insertReplacementText` input type, but Safari uses `insertText` for\n        // spell check replacements and sets `data` to `null`. (2018/08/09)\n        const text =\n          event.data == null\n            ? event.dataTransfer.getData('text/plain')\n            : event.data\n\n        if (text == null) break\n\n        editor.insertTextAtRange(range, text, selection.marks)\n\n        // If the text was successfully inserted, and the selection had marks\n        // on it, unset the selection's marks.\n        if (selection.marks && value.document !== editor.value.document) {\n          editor.select({ marks: null })\n        }\n\n        break\n      }\n    }\n\n    next()\n  }\n\n  /**\n   * On blur.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBlur(event, editor, next) {\n    debug('onBlur', { event })\n    editor.blur()\n    next()\n  }\n\n  /**\n   * On click.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onClick(event, editor, next) {\n    if (editor.readOnly) return next()\n\n    const { value } = editor\n    const { document } = value\n    const path = editor.findPath(event.target)\n    if (!path) return next()\n\n    debug('onClick', { event })\n\n    const node = document.getNode(path)\n    const ancestors = document.getAncestors(path)\n    const isVoid =\n      node && (editor.isVoid(node) || ancestors.some(a => editor.isVoid(a)))\n\n    if (isVoid) {\n      // COMPAT: In Chrome & Safari, selections that are at the zero offset of\n      // an inline node will be automatically replaced to be at the last offset\n      // of a previous inline node, which screws us up, so we always want to set\n      // it to the end of the node. (2016/11/29)\n      editor.focus().moveToEndOfNode(node)\n    }\n\n    next()\n  }\n\n  /**\n   * On copy.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCopy(event, editor, next) {\n    debug('onCopy', { event })\n    cloneFragment(event, editor)\n    next()\n  }\n\n  /**\n   * On cut.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCut(event, editor, next) {\n    debug('onCut', { event })\n\n    // Once the fake cut content has successfully been added to the clipboard,\n    // delete the content in the current selection.\n    cloneFragment(event, editor, () => {\n      // If user cuts a void block node or a void inline node,\n      // manually removes it since selection is collapsed in this case.\n      const { value } = editor\n      const { document, selection } = value\n      const { end, isCollapsed } = selection\n      let voidPath\n\n      if (isCollapsed) {\n        for (const [node, path] of document.ancestors(end.path)) {\n          if (editor.isVoid(node)) {\n            voidPath = path\n            break\n          }\n        }\n      }\n\n      if (voidPath) {\n        editor.removeNodeByKey(voidPath)\n      } else {\n        editor.delete()\n      }\n    })\n\n    next()\n  }\n\n  /**\n   * On drag end.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragEnd(event, editor, next) {\n    debug('onDragEnd', { event })\n    isDraggingInternally = null\n    next()\n  }\n\n  /**\n   * On drag start.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragStart(event, editor, next) {\n    debug('onDragStart', { event })\n\n    isDraggingInternally = true\n\n    const { value } = editor\n    const { document } = value\n    const path = editor.findPath(event.target)\n    const node = document.getNode(path)\n    const ancestors = document.getAncestors(path)\n    const isVoid =\n      node && (editor.isVoid(node) || ancestors.some(a => editor.isVoid(a)))\n    const selectionIncludesNode = value.blocks.some(block => block === node)\n\n    // If a void block is dragged and is not selected, select it (necessary for local drags).\n    if (isVoid && !selectionIncludesNode) {\n      editor.moveToRangeOfNode(node)\n    }\n\n    const fragment = editor.value.fragment\n    const encoded = Base64.serializeNode(fragment)\n    setEventTransfer(event, 'fragment', encoded)\n    next()\n  }\n\n  /**\n   * On drop.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDrop(event, editor, next) {\n    const { value } = editor\n    const { document, selection } = value\n    const window = getWindow(event.target)\n    const target = editor.findEventRange(event)\n\n    if (!target) {\n      return next()\n    }\n\n    debug('onDrop', { event })\n\n    const transfer = getEventTransfer(event)\n    const { type, fragment, text } = transfer\n\n    editor.focus()\n\n    // COMPAT: React's onSelect event breaks after an onDrop event\n    // has fired in a node: https://github.com/facebook/react/issues/11379.\n    // Until this is fixed in React, we dispatch a mouseup event on that\n    // DOM node, since that will make it go back to normal.\n    const el = editor.findDOMNode(target.focus.path)\n\n    if (el) {\n      el.dispatchEvent(\n        new MouseEvent('mouseup', {\n          view: window,\n          bubbles: true,\n          cancelable: true,\n        })\n      )\n    }\n\n    const draggedRange = selection\n\n    editor.select(target)\n\n    if (isDraggingInternally) {\n      editor.deleteAtRange(draggedRange)\n    }\n\n    if (type === 'text' || type === 'html') {\n      const { anchor } = target\n      let hasVoidParent = document.hasVoidParent(anchor.path, editor)\n\n      if (hasVoidParent) {\n        let p = anchor.path\n        let n = document.getNode(anchor.path)\n\n        while (hasVoidParent) {\n          const [nxt] = document.texts({ path: p })\n\n          if (!nxt) {\n            break\n          }\n\n          ;[n, p] = nxt\n          hasVoidParent = document.hasVoidParent(p, editor)\n        }\n\n        if (n) editor.moveToStartOfNode(n)\n      }\n\n      if (text) {\n        text.split('\\n').forEach((line, i) => {\n          if (i > 0) editor.splitBlock()\n          editor.insertText(line)\n        })\n      }\n    }\n\n    if (type === 'fragment') {\n      editor.insertFragment(fragment)\n    }\n\n    next()\n  }\n\n  /**\n   * On focus.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onFocus(event, editor, next) {\n    debug('onFocus', { event })\n\n    // COMPAT: If the focus event is a mouse-based one, it will be shortly\n    // followed by a `selectionchange`, so we need to deselect here to prevent\n    // the old selection from being set by the `updateSelection` of `<Content>`,\n    // preventing the `selectionchange` from firing. (2018/11/07)\n    if (isMouseDown && !IS_IE && !IS_EDGE) {\n      editor.deselect().focus()\n    } else {\n      editor.focus()\n    }\n\n    next()\n  }\n\n  /**\n   * On input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onInput(event, editor, next) {\n    debug('onInput')\n\n    const window = getWindow(event.target)\n    const domSelection = window.getSelection()\n    const selection = editor.findSelection(domSelection)\n\n    if (selection) {\n      editor.select(selection)\n    } else {\n      editor.blur()\n    }\n\n    const { anchorNode } = domSelection\n    editor.reconcileDOMNode(anchorNode)\n\n    next()\n  }\n\n  /**\n   * On key down.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onKeyDown(event, editor, next) {\n    debug('onKeyDown', { event })\n\n    const { value } = editor\n    const { document, selection } = value\n    const { start } = selection\n    const hasVoidParent = document.hasVoidParent(start.path, editor)\n\n    // COMPAT: In iOS, some of these hotkeys are handled in the\n    // `onNativeBeforeInput` handler of the `<Content>` component in order to\n    // preserve native autocorrect behavior, so they shouldn't be handled here.\n    if (Hotkeys.isSplitBlock(event) && !IS_IOS) {\n      return hasVoidParent\n        ? editor.moveToStartOfNextText()\n        : editor.splitBlock()\n    }\n\n    if (Hotkeys.isDeleteBackward(event) && !IS_IOS) {\n      return editor.deleteCharBackward()\n    }\n\n    if (Hotkeys.isDeleteForward(event) && !IS_IOS) {\n      return editor.deleteCharForward()\n    }\n\n    if (Hotkeys.isDeleteLineBackward(event)) {\n      return editor.deleteLineBackward()\n    }\n\n    if (Hotkeys.isDeleteLineForward(event)) {\n      return editor.deleteLineForward()\n    }\n\n    if (Hotkeys.isDeleteWordBackward(event)) {\n      return editor.deleteWordBackward()\n    }\n\n    if (Hotkeys.isDeleteWordForward(event)) {\n      return editor.deleteWordForward()\n    }\n\n    if (Hotkeys.isRedo(event)) {\n      return editor.redo()\n    }\n\n    if (Hotkeys.isUndo(event)) {\n      return editor.undo()\n    }\n\n    // COMPAT: Certain browsers don't handle the selection updates properly. In\n    // Chrome, the selection isn't properly extended. And in Firefox, the\n    // selection isn't properly collapsed. (2017/10/17)\n    if (Hotkeys.isMoveLineBackward(event)) {\n      event.preventDefault()\n      return editor.moveToStartOfBlock()\n    }\n\n    if (Hotkeys.isMoveLineForward(event)) {\n      event.preventDefault()\n      return editor.moveToEndOfBlock()\n    }\n\n    if (Hotkeys.isExtendLineBackward(event)) {\n      event.preventDefault()\n      return editor.moveFocusToStartOfBlock()\n    }\n\n    if (Hotkeys.isExtendLineForward(event)) {\n      event.preventDefault()\n      return editor.moveFocusToEndOfBlock()\n    }\n\n    // COMPAT: If a void node is selected, or a zero-width text node adjacent to\n    // an inline is selected, we need to handle these hotkeys manually because\n    // browsers won't know what to do.\n    if (Hotkeys.isMoveBackward(event)) {\n      event.preventDefault()\n\n      if (!selection.isCollapsed) {\n        return editor.moveToStart()\n      }\n\n      return editor.moveBackward()\n    }\n\n    if (Hotkeys.isMoveForward(event)) {\n      event.preventDefault()\n\n      if (!selection.isCollapsed) {\n        return editor.moveToEnd()\n      }\n\n      return editor.moveForward()\n    }\n\n    if (Hotkeys.isMoveWordBackward(event)) {\n      event.preventDefault()\n      return editor.moveWordBackward()\n    }\n\n    if (Hotkeys.isMoveWordForward(event)) {\n      event.preventDefault()\n      return editor.moveWordForward()\n    }\n\n    if (Hotkeys.isExtendBackward(event)) {\n      const startText = document.getNode(start.path)\n      const [prevEntry] = document.texts({\n        path: start.path,\n        direction: 'backward',\n      })\n\n      let isPrevInVoid = false\n\n      if (prevEntry) {\n        const [, prevPath] = prevEntry\n        isPrevInVoid = document.hasVoidParent(prevPath, editor)\n      }\n\n      if (hasVoidParent || isPrevInVoid || startText.text === '') {\n        event.preventDefault()\n        return editor.moveFocusBackward()\n      }\n    }\n\n    if (Hotkeys.isExtendForward(event)) {\n      const startText = document.getNode(start.path)\n      const [nextEntry] = document.texts({ path: start.path })\n      let isNextInVoid = false\n\n      if (nextEntry) {\n        const [, nextPath] = nextEntry\n        isNextInVoid = document.hasVoidParent(nextPath, editor)\n      }\n\n      if (hasVoidParent || isNextInVoid || startText.text === '') {\n        event.preventDefault()\n        return editor.moveFocusForward()\n      }\n    }\n\n    next()\n  }\n\n  /**\n   * On mouse down.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onMouseDown(event, editor, next) {\n    debug('onMouseDown', { event })\n    isMouseDown = true\n    next()\n  }\n\n  /**\n   * On mouse up.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onMouseUp(event, editor, next) {\n    debug('onMouseUp', { event })\n    isMouseDown = false\n    next()\n  }\n\n  /**\n   * On paste.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onPaste(event, editor, next) {\n    debug('onPaste', { event })\n\n    const { value } = editor\n    const transfer = getEventTransfer(event)\n    const { type, fragment, text } = transfer\n\n    if (type === 'fragment') {\n      editor.insertFragment(fragment)\n    }\n\n    if (type === 'text' || type === 'html') {\n      if (!text) return next()\n      const { document, selection, startBlock } = value\n      if (editor.isVoid(startBlock)) return next()\n\n      const defaultBlock = startBlock\n      const defaultMarks = document.getInsertMarksAtRange(selection)\n      const frag = Plain.deserialize(text, { defaultBlock, defaultMarks })\n        .document\n      editor.insertFragment(frag)\n    }\n\n    next()\n  }\n\n  /**\n   * On select.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onSelect(event, editor, next) {\n    debug('onSelect', { event })\n    const window = getWindow(event.target)\n    const domSelection = window.getSelection()\n    const selection = editor.findSelection(domSelection)\n\n    if (selection) {\n      editor.select(selection)\n    } else {\n      editor.blur()\n    }\n\n    // COMPAT: reset the `isMouseDown` state here in case a `mouseup` event\n    // happens outside the editor. This is needed for `onFocus` handling.\n    isMouseDown = false\n\n    next()\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onBeforeInput,\n    onBlur,\n    onClick,\n    onCopy,\n    onCut,\n    onDragEnd,\n    onDragStart,\n    onDrop,\n    onFocus,\n    onInput,\n    onKeyDown,\n    onMouseDown,\n    onMouseUp,\n    onPaste,\n    onSelect,\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default AfterPlugin\n","import Debug from 'debug'\nimport Hotkeys from 'slate-hotkeys'\nimport getWindow from 'get-window'\nimport {\n  IS_FIREFOX,\n  IS_IE,\n  IS_IOS,\n  HAS_INPUT_EVENTS_LEVEL_2,\n} from 'slate-dev-environment'\n\nimport DATA_ATTRS from '../../constants/data-attributes'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:before')\n\n/**\n * A plugin that adds the \"before\" browser-specific logic to the editor.\n *\n * @return {Object}\n */\n\nfunction BeforePlugin() {\n  let activeElement = null\n  let compositionCount = 0\n  let isComposing = false\n  let isCopying = false\n  let isDragging = false\n  let isUserActionPerformed = false\n\n  /**\n   * On before input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBeforeInput(event, editor, next) {\n    const isSynthetic = !!event.nativeEvent\n    if (editor.readOnly) return\n    isUserActionPerformed = true\n\n    // COMPAT: If the browser supports Input Events Level 2, we will have\n    // attached a custom handler for the real `beforeinput` events, instead of\n    // allowing React's synthetic polyfill, so we need to ignore synthetics.\n    if (isSynthetic && HAS_INPUT_EVENTS_LEVEL_2) return\n\n    debug('onBeforeInput', { event })\n    next()\n  }\n\n  /**\n   * On blur.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBlur(event, editor, next) {\n    if (isCopying) return\n    if (editor.readOnly) return\n\n    const { relatedTarget, target } = event\n    const window = getWindow(target)\n\n    // COMPAT: If the current `activeElement` is still the previous one, this is\n    // due to the window being blurred when the tab itself becomes unfocused, so\n    // we want to abort early to allow to editor to stay focused when the tab\n    // becomes focused again.\n    if (activeElement === window.document.activeElement) return\n\n    // COMPAT: The `relatedTarget` can be null when the new focus target is not\n    // a \"focusable\" element (eg. a `<div>` without `tabindex` set).\n    if (relatedTarget) {\n      const el = editor.findDOMNode([])\n\n      // COMPAT: The event should be ignored if the focus is returning to the\n      // editor from an embedded editable element (eg. an <input> element inside\n      // a void node).\n      if (relatedTarget === el) return\n\n      // COMPAT: The event should be ignored if the focus is moving from the\n      // editor to inside a void node's spacer element.\n      if (relatedTarget.hasAttribute(DATA_ATTRS.SPACER)) return\n\n      // COMPAT: The event should be ignored if the focus is moving to a non-\n      // editable section of an element that isn't a void node (eg. a list item\n      // of the check list example).\n      const node = editor.findNode(relatedTarget)\n\n      if (el.contains(relatedTarget) && node && !editor.isVoid(node)) {\n        return\n      }\n    }\n\n    debug('onBlur', { event })\n    next()\n  }\n\n  /**\n   * On composition end.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCompositionEnd(event, editor, next) {\n    const n = compositionCount\n    isUserActionPerformed = true\n\n    // The `count` check here ensures that if another composition starts\n    // before the timeout has closed out this one, we will abort unsetting the\n    // `isComposing` flag, since a composition is still in affect.\n    window.requestAnimationFrame(() => {\n      if (compositionCount > n) return\n      isComposing = false\n    })\n\n    debug('onCompositionEnd', { event })\n    next()\n  }\n\n  /**\n   * On click.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onClick(event, editor, next) {\n    debug('onClick', { event })\n    isUserActionPerformed = true\n    next()\n  }\n\n  /**\n   * On composition start.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCompositionStart(event, editor, next) {\n    isComposing = true\n    compositionCount++\n\n    const { value } = editor\n    const { selection } = value\n    isUserActionPerformed = true\n\n    if (!selection.isCollapsed) {\n      // https://github.com/ianstormtaylor/slate/issues/1879\n      // When composition starts and the current selection is not collapsed, the\n      // second composition key-down would drop the text wrapping <spans> which\n      // resulted on crash in content.updateSelection after composition ends\n      // (because it cannot find <span> nodes in DOM). This is a workaround that\n      // erases selection as soon as composition starts and preventing <spans>\n      // to be dropped.\n      editor.delete()\n    }\n\n    debug('onCompositionStart', { event })\n    next()\n  }\n\n  /**\n   * On copy.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCopy(event, editor, next) {\n    const window = getWindow(event.target)\n    isCopying = true\n    window.requestAnimationFrame(() => (isCopying = false))\n\n    debug('onCopy', { event })\n    next()\n  }\n\n  /**\n   * On cut.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCut(event, editor, next) {\n    if (editor.readOnly) return\n\n    const window = getWindow(event.target)\n    isCopying = true\n    window.requestAnimationFrame(() => (isCopying = false))\n\n    debug('onCut', { event })\n    next()\n  }\n\n  /**\n   * On drag end.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragEnd(event, editor, next) {\n    isDragging = false\n    debug('onDragEnd', { event })\n    next()\n  }\n\n  /**\n   * On drag enter.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragEnter(event, editor, next) {\n    debug('onDragEnter', { event })\n    next()\n  }\n\n  /**\n   * On drag exit.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragExit(event, editor, next) {\n    debug('onDragExit', { event })\n    next()\n  }\n\n  /**\n   * On drag leave.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragLeave(event, editor, next) {\n    debug('onDragLeave', { event })\n    next()\n  }\n\n  /**\n   * On drag over.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragOver(event, editor, next) {\n    // If the target is inside a void node, and only in this case,\n    // call `preventDefault` to signal that drops are allowed.\n    // When the target is editable, dropping is already allowed by\n    // default, and calling `preventDefault` hides the cursor.\n    const node = editor.findNode(event.target)\n\n    if (!node || editor.isVoid(node)) {\n      event.preventDefault()\n    }\n\n    // COMPAT: IE won't call onDrop on contentEditables unless the\n    // default dragOver is prevented:\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/913982/\n    // (2018/07/11)\n    if (IS_IE) {\n      event.preventDefault()\n    }\n\n    // If a drag is already in progress, don't do this again.\n    if (!isDragging) {\n      isDragging = true\n\n      // COMPAT: IE will raise an `unspecified error` if dropEffect is\n      // set. (2018/07/11)\n      if (!IS_IE) {\n        event.nativeEvent.dataTransfer.dropEffect = 'move'\n      }\n    }\n\n    debug('onDragOver', { event })\n    next()\n  }\n\n  /**\n   * On drag start.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragStart(event, editor, next) {\n    isDragging = true\n    debug('onDragStart', { event })\n    next()\n  }\n\n  /**\n   * On drop.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDrop(event, editor, next) {\n    if (editor.readOnly) return\n    isUserActionPerformed = true\n\n    // Prevent default so the DOM's value isn't corrupted.\n    event.preventDefault()\n\n    debug('onDrop', { event })\n    next()\n  }\n\n  /**\n   * On focus.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onFocus(event, editor, next) {\n    if (isCopying) return\n    if (editor.readOnly) return\n\n    const el = editor.findDOMNode([])\n\n    // Save the new `activeElement`.\n    const window = getWindow(event.target)\n    activeElement = window.document.activeElement\n\n    // COMPAT: If the editor has nested editable elements, the focus can go to\n    // those elements. In Firefox, this must be prevented because it results in\n    // issues with keyboard navigation. (2017/03/30)\n    if (IS_FIREFOX && event.target !== el) {\n      el.focus()\n      return\n    }\n\n    debug('onFocus', { event })\n    next()\n  }\n\n  /**\n   * On input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onInput(event, editor, next) {\n    if (isComposing) return\n    if (editor.value.selection.isBlurred) return\n    isUserActionPerformed = true\n    debug('onInput', { event })\n    next()\n  }\n\n  /**\n   * On key down.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onKeyDown(event, editor, next) {\n    if (editor.readOnly) return\n\n    // When composing, we need to prevent all hotkeys from executing while\n    // typing. However, certain characters also move the selection before\n    // we're able to handle it, so prevent their default behavior.\n    if (isComposing) {\n      if (Hotkeys.isCompose(event)) event.preventDefault()\n      return\n    }\n\n    // Certain hotkeys have native editing behaviors in `contenteditable`\n    // elements which will editor the DOM and cause our value to be out of sync,\n    // so they need to always be prevented.\n    if (\n      !IS_IOS &&\n      (Hotkeys.isBold(event) ||\n        Hotkeys.isDeleteBackward(event) ||\n        Hotkeys.isDeleteForward(event) ||\n        Hotkeys.isDeleteLineBackward(event) ||\n        Hotkeys.isDeleteLineForward(event) ||\n        Hotkeys.isDeleteWordBackward(event) ||\n        Hotkeys.isDeleteWordForward(event) ||\n        Hotkeys.isItalic(event) ||\n        Hotkeys.isRedo(event) ||\n        Hotkeys.isSplitBlock(event) ||\n        Hotkeys.isTransposeCharacter(event) ||\n        Hotkeys.isUndo(event))\n    ) {\n      event.preventDefault()\n    }\n\n    isUserActionPerformed = true\n    debug('onKeyDown', { event })\n    next()\n  }\n\n  /**\n   * On paste.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onPaste(event, editor, next) {\n    if (editor.readOnly) return\n    isUserActionPerformed = true\n\n    // Prevent defaults so the DOM state isn't corrupted.\n    event.preventDefault()\n\n    debug('onPaste', { event })\n    next()\n  }\n\n  /**\n   * On select.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onSelect(event, editor, next) {\n    if (isCopying) return\n    if (isComposing) return\n\n    if (editor.readOnly) return\n\n    // Save the new `activeElement`.\n    const window = getWindow(event.target)\n    activeElement = window.document.activeElement\n    isUserActionPerformed = true\n\n    debug('onSelect', { event })\n    next()\n  }\n\n  function userActionPerformed() {\n    return isUserActionPerformed\n  }\n\n  function clearUserActionPerformed() {\n    isUserActionPerformed = false\n    return null\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onBeforeInput,\n    onBlur,\n    onClick,\n    onCompositionEnd,\n    onCompositionStart,\n    onCopy,\n    onCut,\n    onDragEnd,\n    onDragEnter,\n    onDragExit,\n    onDragLeave,\n    onDragOver,\n    onDragStart,\n    onDrop,\n    onFocus,\n    onInput,\n    onKeyDown,\n    onPaste,\n    onSelect,\n    queries: { userActionPerformed },\n    commands: { clearUserActionPerformed },\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default BeforePlugin\n","import { IS_ANDROID } from 'slate-dev-environment'\n\nimport AndroidPlugin from '../android'\nimport NoopPlugin from '../debug/noop'\n\nimport AfterPlugin from './after'\nimport BeforePlugin from './before'\n\n/**\n * A plugin that adds the browser-specific logic to the editor.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction DOMPlugin(options = {}) {\n  const { plugins = [] } = options\n  const beforePlugin = BeforePlugin()\n  const afterPlugin = AfterPlugin()\n\n  // COMPAT: Add Android specific handling separately before it gets to the\n  // other plugins because it is specific (other browser don't need it) and\n  // finicky (it has to come before other plugins to work).\n  const androidPlugins = IS_ANDROID\n    ? [AndroidPlugin(options), NoopPlugin(options)]\n    : []\n\n  return [...androidPlugins, beforePlugin, ...plugins, afterPlugin]\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default DOMPlugin\n","function RestoreDOMPlugin() {\n  /**\n   * Makes sure that on the next Content `render` the DOM is restored.\n   * This gets us around issues where the DOM is in a different state than\n   * React's virtual DOM and would crash.\n   *\n   * @param {Editor} editor\n   */\n\n  function restoreDOM(editor) {\n    const tmp = editor.tmp.contentRef.current.tmp\n    tmp.contentKey = tmp.contentKey + 1\n  }\n\n  return {\n    commands: {\n      restoreDOM,\n    },\n  }\n}\n\nexport default RestoreDOMPlugin\n","/**\n * Takes a React Synthetic Event or a DOM Event and turns it into a String that\n * is easy to log. It's succinct and keeps info to a bare minimum.\n *\n * @param {Event} event\n */\n\nexport default function stringifyEvent(event) {\n  const e = event.nativeEvent || event\n\n  switch (e.type) {\n    case 'keydown':\n      return `${e.type} ${JSON.stringify(e.key)}`\n    case 'input':\n    case 'beforeinput':\n    case 'textInput':\n      return `${e.type}:${e.inputType} ${JSON.stringify(e.data)}`\n    default:\n      return e.type\n  }\n}\n","import Debug from 'debug'\nimport EVENT_HANDLERS from '../../constants/event-handlers'\nimport stringifyEvent from './stringify-event'\n\n/**\n * Debug events function.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:events')\n\n/**\n * A plugin that sends short easy to digest debug info about each event to\n * browser.\n *\n * @return {Object}\n */\n\nfunction DebugEventsPlugin() {\n  /**\n   * Plugin Object\n   *\n   * @type {Object}\n   */\n\n  const plugin = {}\n\n  for (const eventName of EVENT_HANDLERS) {\n    plugin[eventName] = function(event, editor, next) {\n      const s = stringifyEvent(event)\n      debug(s)\n      next()\n    }\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return plugin\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default DebugEventsPlugin\n","import Debug from 'debug'\nimport EVENT_HANDLERS from '../../constants/event-handlers'\nimport stringifyEvent from './stringify-event'\n\n/**\n * Constants\n */\n\nconst INTERVAL = 2000\n\n/**\n * Debug events function.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:batch-events')\n\n/**\n * A plugin that sends short easy to digest debug info about each event to\n * browser.\n *\n * @return {Object}\n */\n\nfunction DebugBatchEventsPlugin() {\n  /**\n   * When the batch started\n   *\n   * @type {Date}\n   */\n\n  let startDate = null\n\n  /**\n   * The timeoutId used to cancel the timeout\n   *\n   * @type {Any}\n   */\n\n  let timeoutId = null\n\n  /**\n   * An array of events not yet dumped with `debug`\n   *\n   * @type {Array}\n   */\n\n  const events = []\n\n  /**\n   * Send all events to debug\n   *\n   * Note: Formatted so it can easily be cut and pasted as text for analysis or\n   * documentation.\n   */\n\n  function dumpEvents() {\n    debug(`\\n${events.join('\\n')}`)\n    events.length = 0\n  }\n\n  /**\n   * Push an event on to the Array of events for debugging in a batch\n   *\n   * @param {Event} event\n   */\n\n  function pushEvent(event) {\n    if (events.length === 0) {\n      startDate = new Date()\n    }\n\n    const s = stringifyEvent(event)\n    const now = new Date()\n    events.push(`- ${now - startDate} - ${s}`)\n    clearTimeout(timeoutId)\n    timeoutId = setTimeout(dumpEvents, INTERVAL)\n  }\n\n  /**\n   * Plugin Object\n   *\n   * @type {Object}\n   */\n\n  const plugin = {}\n\n  for (const eventName of EVENT_HANDLERS) {\n    plugin[eventName] = function(event, editor, next) {\n      pushEvent(event)\n      next()\n    }\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return plugin\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default DebugBatchEventsPlugin\n","import Debug from 'debug'\n\n/**\n * Debug mutations function.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:mutations')\n\n/**\n * Properties on a MutationRecord\n *\n * @type {Object}\n */\n\nconst MUTATION_PROPERTIES = [\n  'type',\n  'oldValue',\n  'target',\n  'addedNodes',\n  'removedNodes',\n  'attributeName',\n  'attributeNamespace',\n  'nextSibling',\n  'previousSibling',\n]\n\n/**\n * Takes a DOM node and returns an easily readable version of it.\n *\n * @param {DOMNode} node\n */\n\nfunction normalizeNode(node) {\n  if (node.nodeType === window.Node.TEXT_NODE) {\n    return node.textContent\n  } else if (node.nodeType === window.Node.ELEMENT_NODE) {\n    const { outerHTML, innerHTML } = node\n    if (outerHTML == null) return JSON.stringify(node.textContent)\n    return outerHTML.slice(0, outerHTML.indexOf(innerHTML))\n  } else {\n    return `Node(type=${node.nodeType}`\n  }\n}\n\n/**\n * A plugin that sends short easy to digest debug info about each dom mutation\n * to browser.\n *\n * More information about mutations here:\n *\n * <https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver>\n * <https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord>\n *\n * @param {Object} options\n */\n\nfunction DebugMutationsPlugin() {\n  const observer = new window.MutationObserver(mutations => {\n    const array = Array.from(mutations).map(mutationRecord => {\n      const object = {}\n\n      // Only add properties that provide meaningful values to the object\n      // to make the debug info easier to read\n      MUTATION_PROPERTIES.forEach(key => {\n        let value = mutationRecord[key]\n        if (value == null) return\n\n        // Make NodeList easier to read\n        if (value instanceof window.NodeList) {\n          if (value.length === 0) return\n\n          object[key] = Array.from(value)\n            .map(normalizeNode)\n            .join(', ')\n          return\n        }\n\n        // Make Node easier to read\n        if (value instanceof window.Node) {\n          value = normalizeNode(value)\n        }\n\n        object[key] = value\n      })\n\n      return object\n    })\n\n    // The first argument must not be the array as `debug` renders the first\n    // argument in a different way than the rest\n    debug(`${array.length} Mutations`, ...array)\n  })\n\n  /**\n   * The previously observed DOM node\n   *\n   * @type {DOMNode}\n   */\n\n  let prevRootEl = null\n\n  /**\n   * Start observing the DOM node for mutations if it isn't being observed\n   */\n\n  function start(event, editor, next) {\n    const rootEl = editor.findDOMNode([])\n\n    if (rootEl === prevRootEl) return next()\n\n    debug('start')\n\n    observer.observe(rootEl, {\n      childList: true,\n      characterData: true,\n      attributes: true,\n      subtree: true,\n      characterDataOldValue: true,\n    })\n\n    prevRootEl = rootEl\n\n    next()\n  }\n\n  /**\n   * Stop observing the DOM node for mutations\n   */\n\n  function stop(event, editor, next) {\n    debug('stop')\n\n    observer.disconnect()\n    prevRootEl = null\n    next()\n  }\n\n  return {\n    onComponentDidMount: start,\n    onComponentDidUpdate: start,\n    onComponentWillUnmount: stop,\n  }\n}\n\nexport default DebugMutationsPlugin\n","import Debug from 'debug'\n\nimport { IS_ANDROID } from 'slate-dev-environment'\nimport PlaceholderPlugin from 'slate-react-placeholder'\nimport EditorPropsPlugin from './editor-props'\nimport RenderingPlugin from './rendering'\nimport CommandsPlugin from './commands'\nimport QueriesPlugin from './queries'\nimport DOMPlugin from '../dom'\nimport RestoreDOMPlugin from './restore-dom'\nimport DebugEventsPlugin from '../debug/debug-events'\nimport DebugBatchEventsPlugin from '../debug/debug-batch-events'\nimport DebugMutationsPlugin from '../debug/debug-mutations'\n\n/**\n * A plugin that adds the React-specific rendering logic to the editor.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction ReactPlugin(options = {}) {\n  const { placeholder = '' } = options\n  const debugEventsPlugin = Debug.enabled('slate:events')\n    ? DebugEventsPlugin(options)\n    : null\n  const debugBatchEventsPlugin = Debug.enabled('slate:batch-events')\n    ? DebugBatchEventsPlugin(options)\n    : null\n  const debugMutationsPlugin = Debug.enabled('slate:mutations')\n    ? DebugMutationsPlugin(options)\n    : null\n  const renderingPlugin = RenderingPlugin(options)\n  const commandsPlugin = CommandsPlugin(options)\n  const queriesPlugin = QueriesPlugin(options)\n  const editorPropsPlugin = EditorPropsPlugin(options)\n  const domPlugin = DOMPlugin(options)\n  const restoreDomPlugin = RestoreDOMPlugin()\n\n  // Disable placeholder for Android because it messes with reconciliation\n  // and doesn't disappear until composition is complete.\n  // e.g. In empty, type \"h\" and autocomplete on Android 9 and deletes all text.\n  const placeholderPlugin = IS_ANDROID\n    ? null\n    : PlaceholderPlugin({\n        placeholder,\n        when: (editor, node) =>\n          node.object === 'document' &&\n          node.text === '' &&\n          node.nodes.size === 1 &&\n          Array.from(node.texts()).length === 1,\n      })\n\n  return [\n    debugEventsPlugin,\n    debugBatchEventsPlugin,\n    debugMutationsPlugin,\n    editorPropsPlugin,\n    domPlugin,\n    restoreDomPlugin,\n    placeholderPlugin,\n    renderingPlugin,\n    commandsPlugin,\n    queriesPlugin,\n  ]\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default ReactPlugin\n","import Debug from 'debug'\nimport React from 'react'\nimport SlateTypes from 'slate-prop-types'\nimport Types from 'prop-types'\nimport invariant from 'tiny-invariant'\nimport memoizeOne from 'memoize-one'\nimport warning from 'tiny-warning'\nimport omit from 'lodash/omit'\nimport { Editor as Controller } from 'slate'\n\nimport EVENT_HANDLERS from '../constants/event-handlers'\nimport OTHER_HANDLERS from '../constants/other-handlers'\nimport Content from './content'\nimport ReactPlugin from '../plugins/react'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:editor')\n\n/**\n * Editor.\n *\n * @type {Component}\n */\n\nclass Editor extends React.Component {\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  static propTypes = {\n    autoCorrect: Types.bool,\n    autoFocus: Types.bool,\n    className: Types.string,\n    defaultValue: SlateTypes.value,\n    id: Types.string,\n    onChange: Types.func,\n    options: Types.object,\n    placeholder: Types.any,\n    plugins: Types.array,\n    readOnly: Types.bool,\n    role: Types.string,\n    schema: Types.object,\n    spellCheck: Types.bool,\n    style: Types.object,\n    tabIndex: Types.number,\n    value: SlateTypes.value,\n    ...EVENT_HANDLERS.reduce((obj, handler) => {\n      obj[handler] = Types.func\n      return obj\n    }, {}),\n    ...OTHER_HANDLERS.reduce((obj, handler) => {\n      obj[handler] = Types.func\n      return obj\n    }, {}),\n  }\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n  static defaultProps = {\n    autoFocus: false,\n    autoCorrect: true,\n    onChange: () => {},\n    options: {},\n    placeholder: '',\n    plugins: [],\n    readOnly: false,\n    schema: {},\n    spellCheck: true,\n  }\n\n  /**\n   * Initial state.\n   *\n   * @type {Object}\n   */\n\n  state = { value: this.props.defaultValue, contentKey: 0 }\n\n  /**\n   * Temporary values.\n   *\n   * @type {Object}\n   */\n\n  tmp = {\n    mounted: false,\n    change: null,\n    resolves: 0,\n    updates: 0,\n    contentRef: React.createRef(),\n  }\n\n  /**\n   * When the component first mounts, flush a queued change if one exists.\n   */\n\n  componentDidMount() {\n    this.tmp.mounted = true\n    this.tmp.updates++\n\n    if (this.props.autoFocus) {\n      this.focus()\n    }\n\n    if (this.tmp.change) {\n      this.handleChange(this.tmp.change)\n      this.tmp.change = null\n    }\n  }\n\n  /**\n   * When the component updates, flush a queued change if one exists.\n   */\n\n  componentDidUpdate() {\n    this.tmp.updates++\n\n    if (this.tmp.change) {\n      this.handleChange(this.tmp.change)\n      this.tmp.change = null\n    }\n  }\n\n  /**\n   * When the component unmounts, make sure async commands don't trigger react updates.\n   */\n\n  componentWillUnmount() {\n    this.tmp.mounted = false\n  }\n\n  /**\n   * Render the editor.\n   *\n   * @return {Element}\n   */\n\n  render() {\n    debug('render', this)\n\n    // Re-resolve the controller if needed based on memoized props.\n    const { commands, placeholder, plugins, queries, schema } = this.props\n\n    this.resolveController(\n      plugins,\n      schema,\n      commands,\n      queries,\n      placeholder,\n      ReactPlugin\n    )\n\n    // Set the current props on the controller.\n    const { options, readOnly, value: valueFromProps } = this.props\n    const { value: valueFromState } = this.state\n    const value = valueFromProps || valueFromState\n    const { contentKey } = this.state\n    this.controller.setReadOnly(readOnly)\n    this.controller.setValue(value, options)\n\n    const {\n      autoCorrect,\n      className,\n      id,\n      role,\n      spellCheck,\n      tabIndex,\n      style,\n      tagName,\n    } = this.props\n\n    const domProps = omit(this.props, Object.keys(Editor.propTypes))\n\n    const children = (\n      <Content\n        {...domProps}\n        ref={this.tmp.contentRef}\n        autoCorrect={autoCorrect}\n        className={className}\n        contentKey={contentKey}\n        editor={this}\n        id={id}\n        onEvent={(handler, event) => this.run(handler, event)}\n        readOnly={readOnly}\n        role={role}\n        spellCheck={spellCheck}\n        style={style}\n        tabIndex={tabIndex}\n        tagName={tagName}\n      />\n    )\n\n    // Render the editor's children with the controller.\n    const element = this.controller.run('renderEditor', {\n      ...this.props,\n      editor: this,\n      children,\n    })\n\n    return element\n  }\n\n  /**\n   * Resolve an editor controller from the passed-in props. This method takes\n   * all of the props as individual arguments to be able to properly memoize\n   * against anything that could change and invalidate the old editor.\n   *\n   * @param {Array} plugins\n   * @param {Object} schema\n   * @param {Object} commands\n   * @param {Object} queries\n   * @param {String} placeholder\n   * @return {Editor}\n   */\n\n  resolveController = memoizeOne(\n    (plugins = [], schema, commands, queries, placeholder, TheReactPlugin) => {\n      // If we've resolved a few times already, and it's exactly in line with\n      // the updates, then warn the user that they may be doing something wrong.\n      warning(\n        this.tmp.resolves < 5 || this.tmp.resolves !== this.tmp.updates,\n        'A Slate <Editor> component is re-resolving the `plugins`, `schema`, `commands`, `queries` or `placeholder` prop on each update, which leads to poor performance. This is often due to passing in a new references for these props with each render by declaring them inline in your render function. Do not do this! Declare them outside your render function, or memoize them instead.'\n      )\n\n      this.tmp.resolves++\n      const react = TheReactPlugin({\n        ...this.props,\n        editor: this,\n        value: this.props.value || this.state.value,\n      })\n\n      const onChange = change => {\n        if (this.tmp.mounted) {\n          this.handleChange(change)\n        } else {\n          this.tmp.change = change\n        }\n      }\n\n      this.controller = new Controller(\n        { plugins: [react], onChange },\n        { controller: this, construct: false }\n      )\n\n      this.controller.run('onConstruct')\n    }\n  )\n\n  handleChange(change) {\n    const { onChange } = this.props\n    const { value } = this.state\n\n    if (value) {\n      // Syncing value inside this component since parent does not want control of it (defaultValue was used)\n      this.setState({ value: change.value })\n    }\n\n    onChange(change)\n  }\n\n  /**\n   * Mimic the API of the `Editor` controller, so that this component instance\n   * can be passed in its place to plugins.\n   */\n\n  get operations() {\n    return this.controller.operations\n  }\n\n  get readOnly() {\n    return this.controller.readOnly\n  }\n\n  get value() {\n    return this.controller.value\n  }\n\n  applyOperation(...args) {\n    return this.controller.applyOperation(...args)\n  }\n\n  command(...args) {\n    return this.controller.command(...args)\n  }\n\n  hasCommand(...args) {\n    return this.controller.hasCommand(...args)\n  }\n\n  hasQuery(...args) {\n    return this.controller.hasQuery(...args)\n  }\n\n  normalize(...args) {\n    return this.controller.normalize(...args)\n  }\n\n  query(...args) {\n    return this.controller.query(...args)\n  }\n\n  registerCommand(...args) {\n    return this.controller.registerCommand(...args)\n  }\n\n  registerQuery(...args) {\n    return this.controller.registerQuery(...args)\n  }\n\n  run(...args) {\n    return this.controller.run(...args)\n  }\n\n  withoutNormalizing(...args) {\n    return this.controller.withoutNormalizing(...args)\n  }\n\n  /**\n   * Deprecated.\n   */\n\n  get editor() {\n    return this.controller.editor\n  }\n\n  get schema() {\n    invariant(\n      false,\n      'As of Slate 0.42, the `editor.schema` property no longer exists, and its functionality has been folded into the editor itself. Use the `editor` instead.'\n    )\n  }\n\n  get stack() {\n    invariant(\n      false,\n      'As of Slate 0.42, the `editor.stack` property no longer exists, and its functionality has been folded into the editor itself. Use the `editor` instead.'\n    )\n  }\n\n  call(...args) {\n    return this.controller.call(...args)\n  }\n\n  change(...args) {\n    return this.controller.change(...args)\n  }\n\n  onChange(...args) {\n    return this.controller.onChange(...args)\n  }\n\n  applyOperations(...args) {\n    return this.controller.applyOperations(...args)\n  }\n\n  setOperationFlag(...args) {\n    return this.controller.setOperationFlag(...args)\n  }\n\n  getFlag(...args) {\n    return this.controller.getFlag(...args)\n  }\n\n  unsetOperationFlag(...args) {\n    return this.controller.unsetOperationFlag(...args)\n  }\n\n  withoutNormalization(...args) {\n    return this.controller.withoutNormalization(...args)\n  }\n}\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nexport default Editor\n","import { Node } from 'slate'\nimport warning from 'tiny-warning'\n\nimport DATA_ATTRS from '../constants/data-attributes'\n\n/**\n * Find the DOM node for a `key`.\n *\n * @param {String|Node} key\n * @param {Window} win (optional)\n * @return {Element}\n */\n\nfunction findDOMNode(key, win = window) {\n  warning(\n    false,\n    'As of slate-react@0.22 the `findDOMNode(key)` helper is deprecated in favor of `editor.findDOMNode(path)`.'\n  )\n\n  if (Node.isNode(key)) {\n    key = key.key\n  }\n\n  const el = win.document.querySelector(`[${DATA_ATTRS.KEY}=\"${key}\"]`)\n\n  if (!el) {\n    throw new Error(\n      `Unable to find a DOM node for \"${key}\". This is often because of forgetting to add \\`props.attributes\\` to a custom component.`\n    )\n  }\n\n  return el\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findDOMNode\n","import findDOMNode from './find-dom-node'\nimport warning from 'tiny-warning'\n\nimport DATA_ATTRS from '../constants/data-attributes'\nimport SELECTORS from '../constants/selectors'\n\n/**\n * Find a native DOM selection point from a Slate `point`.\n *\n * @param {Point} point\n * @param {Window} win (optional)\n * @return {Object|Null}\n */\n\nfunction findDOMPoint(point, win = window) {\n  warning(\n    false,\n    'As of slate-react@0.22 the `findDOMPoint(point)` helper is deprecated in favor of `editor.findDOMPoint(point)`.'\n  )\n\n  const el = findDOMNode(point.key, win)\n  let start = 0\n\n  // For each leaf, we need to isolate its content, which means filtering to its\n  // direct text and zero-width spans. (We have to filter out any other siblings\n  // that may have been rendered alongside them.)\n  const texts = Array.from(\n    el.querySelectorAll(`${SELECTORS.STRING}, ${SELECTORS.ZERO_WIDTH}`)\n  )\n\n  for (const text of texts) {\n    const node = text.childNodes[0]\n    const domLength = node.textContent.length\n    let slateLength = domLength\n\n    if (text.hasAttribute(DATA_ATTRS.LENGTH)) {\n      slateLength = parseInt(text.getAttribute(DATA_ATTRS.LENGTH), 10)\n    }\n\n    const end = start + slateLength\n\n    if (point.offset <= end) {\n      const offset = Math.min(domLength, Math.max(0, point.offset - start))\n      return { node, offset }\n    }\n\n    start = end\n  }\n\n  return null\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findDOMPoint\n","import findDOMPoint from './find-dom-point'\nimport warning from 'tiny-warning'\n\n/**\n * Find a native DOM range Slate `range`.\n *\n * @param {Range} range\n * @param {Window} win (optional)\n * @return {Object|Null}\n */\n\nfunction findDOMRange(range, win = window) {\n  warning(\n    false,\n    'As of slate-react@0.22 the `findDOMRange(range)` helper is deprecated in favor of `editor.findDOMRange(range)`.'\n  )\n\n  const { anchor, focus, isBackward, isCollapsed } = range\n  const domAnchor = findDOMPoint(anchor, win)\n  const domFocus = isCollapsed ? domAnchor : findDOMPoint(focus, win)\n\n  if (!domAnchor || !domFocus) return null\n\n  const r = win.document.createRange()\n  const start = isBackward ? domFocus : domAnchor\n  const end = isBackward ? domAnchor : domFocus\n  r.setStart(start.node, start.offset)\n  r.setEnd(end.node, end.offset)\n  return r\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findDOMRange\n","import invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { Value } from 'slate'\n\nimport DATA_ATTRS from '../constants/data-attributes'\nimport SELECTORS from '../constants/selectors'\n\n/**\n * Find a Slate node from a DOM `element`.\n *\n * @param {Element} element\n * @param {Editor} editor\n * @return {Node|Null}\n */\n\nfunction findNode(element, editor) {\n  warning(\n    false,\n    'As of slate-react@0.22 the `findNode(element)` helper is deprecated in favor of `editor.findNode(element)`.'\n  )\n\n  invariant(\n    !Value.isValue(editor),\n    'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.'\n  )\n\n  const closest = element.closest(SELECTORS.KEY)\n  if (!closest) return null\n\n  const key = closest.getAttribute(DATA_ATTRS.KEY)\n  if (!key) return null\n\n  const { value } = editor\n  const { document } = value\n  const node = document.getNode(key)\n  return node || null\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findNode\n","import findNode from './find-node'\nimport warning from 'tiny-warning'\n\n/**\n * Find a Slate path from a DOM `element`.\n *\n * @param {Element} element\n * @param {Editor} editor\n * @return {List|Null}\n */\n\nfunction findPath(element, editor) {\n  warning(\n    false,\n    'As of slate-react@0.22 the `findPath(element)` helper is deprecated in favor of `editor.findPath(element)`.'\n  )\n\n  const node = findNode(element, editor)\n\n  if (!node) {\n    return null\n  }\n\n  const { value } = editor\n  const { document } = value\n  const path = document.getPath(node)\n  return path\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findPath\n","import getWindow from 'get-window'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { Value } from 'slate'\n\nimport OffsetKey from './offset-key'\nimport DATA_ATTRS from '../constants/data-attributes'\nimport SELECTORS from '../constants/selectors'\n\n/**\n * Find a Slate point from a DOM selection's `nativeNode` and `nativeOffset`.\n *\n * @param {Element} nativeNode\n * @param {Number} nativeOffset\n * @param {Editor} editor\n * @return {Point}\n */\n\nfunction findPoint(nativeNode, nativeOffset, editor) {\n  warning(\n    false,\n    'As of slate-react@0.22 the `findPoint(node, offset)` helper is deprecated in favor of `editor.findPoint(node, offset)`.'\n  )\n\n  invariant(\n    !Value.isValue(editor),\n    'As of Slate 0.42.0, the `findPoint` utility takes an `editor` instead of a `value`.'\n  )\n\n  const { node: nearestNode, offset: nearestOffset } = normalizeNodeAndOffset(\n    nativeNode,\n    nativeOffset\n  )\n\n  const window = getWindow(nativeNode)\n  const { parentNode } = nearestNode\n  let rangeNode = parentNode.closest(SELECTORS.LEAF)\n  let offset\n  let node\n\n  // Calculate how far into the text node the `nearestNode` is, so that we can\n  // determine what the offset relative to the text node is.\n  if (rangeNode) {\n    const range = window.document.createRange()\n    const textNode = rangeNode.closest(SELECTORS.TEXT)\n    range.setStart(textNode, 0)\n    range.setEnd(nearestNode, nearestOffset)\n    node = textNode\n\n    // COMPAT: Edge has a bug where Range.prototype.toString() will convert \\n\n    // into \\r\\n. The bug causes a loop when slate-react attempts to reposition\n    // its cursor to match the native position. Use textContent.length instead.\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n    const fragment = range.cloneContents()\n    const zeroWidthNodes = fragment.querySelectorAll(\n      `[${DATA_ATTRS.ZERO_WIDTH}]`\n    )\n    offset = fragment.textContent.length - zeroWidthNodes.length\n  } else {\n    // For void nodes, the element with the offset key will be a cousin, not an\n    // ancestor, so find it by going down from the nearest void parent.\n    const voidNode = parentNode.closest(SELECTORS.VOID)\n    if (!voidNode) return null\n    rangeNode = voidNode.querySelector(SELECTORS.LEAF)\n    if (!rangeNode) return null\n    node = rangeNode\n    offset = node.textContent.length\n  }\n\n  // COMPAT: If the parent node is a Slate zero-width space, this is because the\n  // text node should have no characters. However, during IME composition the\n  // ASCII characters will be prepended to the zero-width space, so subtract 1\n  // from the offset to account for the zero-width space character.\n  if (\n    offset === node.textContent.length &&\n    parentNode.hasAttribute(DATA_ATTRS.ZERO_WIDTH)\n  ) {\n    offset--\n  }\n\n  // Get the string value of the offset key attribute.\n  const offsetKey = rangeNode.getAttribute(DATA_ATTRS.OFFSET_KEY)\n  if (!offsetKey) return null\n\n  const { key } = OffsetKey.parse(offsetKey)\n\n  // COMPAT: If someone is clicking from one Slate editor into another, the\n  // select event fires twice, once for the old editor's `element` first, and\n  // then afterwards for the correct `element`. (2017/03/03)\n  const { value } = editor\n  if (!value.document.hasDescendant(key)) return null\n\n  const point = value.document.createPoint({ key, offset })\n  return point\n}\n\n/**\n * From a DOM selection's `node` and `offset`, normalize so that it always\n * refers to a text node.\n *\n * @param {Element} node\n * @param {Number} offset\n * @return {Object}\n */\n\nfunction normalizeNodeAndOffset(node, offset) {\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (node.nodeType === 1 && node.childNodes.length) {\n    const isLast = offset === node.childNodes.length\n    const direction = isLast ? 'backward' : 'forward'\n    const index = isLast ? offset - 1 : offset\n    node = getEditableChild(node, index, direction)\n\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n    while (node.nodeType === 1 && node.childNodes.length) {\n      const i = isLast ? node.childNodes.length - 1 : 0\n      node = getEditableChild(node, i, direction)\n    }\n\n    // Determine the new offset inside the text node.\n    offset = isLast ? node.textContent.length : 0\n  }\n\n  // Return the node and offset.\n  return { node, offset }\n}\n\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n *\n * @param {Element} parent\n * @param {Number} index\n * @param {String} direction ('forward' or 'backward')\n * @return {Element|Null}\n */\n\nfunction getEditableChild(parent, index, direction) {\n  const { childNodes } = parent\n  let child = childNodes[index]\n  let i = index\n  let triedForward = false\n  let triedBackward = false\n\n  // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n  while (\n    child.nodeType === 8 ||\n    (child.nodeType === 1 && child.childNodes.length === 0) ||\n    (child.nodeType === 1 && child.getAttribute('contenteditable') === 'false')\n  ) {\n    if (triedForward && triedBackward) break\n\n    if (i >= childNodes.length) {\n      triedForward = true\n      i = index - 1\n      direction = 'backward'\n      continue\n    }\n\n    if (i < 0) {\n      triedBackward = true\n      i = index + 1\n      direction = 'forward'\n      continue\n    }\n\n    child = childNodes[i]\n    if (direction === 'forward') i++\n    if (direction === 'backward') i--\n  }\n\n  return child || null\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findPoint\n","import getWindow from 'get-window'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { Value } from 'slate'\n\nimport findPoint from './find-point'\n\n/**\n * Find a Slate range from a DOM `native` selection.\n *\n * @param {Selection} native\n * @param {Editor} editor\n * @return {Range}\n */\n\nfunction findRange(native, editor) {\n  warning(\n    false,\n    'As of slate-react@0.22 the `findRange(selection)` helper is deprecated in favor of `editor.findRange(selection)`.'\n  )\n\n  invariant(\n    !Value.isValue(editor),\n    'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.'\n  )\n\n  const el = native.anchorNode || native.startContainer\n  if (!el) return null\n\n  const window = getWindow(el)\n\n  // If the `native` object is a DOM `Range` or `StaticRange` object, change it\n  // into something that looks like a DOM `Selection` instead.\n  if (\n    native instanceof window.Range ||\n    (window.StaticRange && native instanceof window.StaticRange)\n  ) {\n    native = {\n      anchorNode: native.startContainer,\n      anchorOffset: native.startOffset,\n      focusNode: native.endContainer,\n      focusOffset: native.endOffset,\n    }\n  }\n\n  const {\n    anchorNode,\n    anchorOffset,\n    focusNode,\n    focusOffset,\n    isCollapsed,\n  } = native\n  const { value } = editor\n  const anchor = findPoint(anchorNode, anchorOffset, editor)\n  const focus = isCollapsed ? anchor : findPoint(focusNode, focusOffset, editor)\n  if (!anchor || !focus) return null\n\n  const { document } = value\n  const range = document.createRange({\n    anchor,\n    focus,\n  })\n\n  return range\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default findRange\n","import getWindow from 'get-window'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { Value } from 'slate'\n\nimport findPath from './find-path'\nimport findRange from './find-range'\n\n/**\n * Get the target range from a DOM `event`.\n *\n * @param {Event} event\n * @param {Editor} editor\n * @return {Range}\n */\n\nfunction getEventRange(event, editor) {\n  warning(\n    false,\n    'As of slate-react@0.22 the `getEventRange(event, editor)` helper is deprecated in favor of `editor.findEventRange(event)`.'\n  )\n\n  invariant(\n    !Value.isValue(editor),\n    'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.'\n  )\n\n  if (event.nativeEvent) {\n    event = event.nativeEvent\n  }\n\n  const { clientX: x, clientY: y, target } = event\n  if (x == null || y == null) return null\n\n  const { value } = editor\n  const { document } = value\n  const path = findPath(event.target, editor)\n  if (!path) return null\n\n  const node = document.getNode(path)\n\n  // If the drop target is inside a void node, move it into either the next or\n  // previous node, depending on which side the `x` and `y` coordinates are\n  // closest to.\n  if (editor.isVoid(node)) {\n    const rect = target.getBoundingClientRect()\n    const isPrevious =\n      node.object === 'inline'\n        ? x - rect.left < rect.left + rect.width - x\n        : y - rect.top < rect.top + rect.height - y\n\n    const range = document.createRange()\n    const move = isPrevious ? 'moveToEndOfNode' : 'moveToStartOfNode'\n    const entry = document[isPrevious ? 'getPreviousText' : 'getNextText'](path)\n\n    if (entry) {\n      return range[move](entry)\n    }\n\n    return null\n  }\n\n  // Else resolve a range from the caret position where the drop occured.\n  const window = getWindow(target)\n  let native\n\n  // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n  if (window.document.caretRangeFromPoint) {\n    native = window.document.caretRangeFromPoint(x, y)\n  } else if (window.document.caretPositionFromPoint) {\n    const position = window.document.caretPositionFromPoint(x, y)\n    native = window.document.createRange()\n    native.setStart(position.offsetNode, position.offset)\n    native.setEnd(position.offsetNode, position.offset)\n  } else if (window.document.body.createTextRange) {\n    // COMPAT: In IE, `caretRangeFromPoint` and\n    // `caretPositionFromPoint` don't exist. (2018/07/11)\n    native = window.document.body.createTextRange()\n\n    try {\n      native.moveToPoint(x, y)\n    } catch (error) {\n      // IE11 will raise an `unspecified error` if `moveToPoint` is\n      // called during a dropEvent.\n      return null\n    }\n  }\n\n  // Resolve a Slate range from the DOM range.\n  const range = findRange(native, editor)\n  if (!range) return null\n\n  return range\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default getEventRange\n","import Editor from './components/editor'\nimport cloneFragment from './utils/clone-fragment'\nimport findDOMNode from './utils/find-dom-node'\nimport findDOMPoint from './utils/find-dom-point'\nimport findDOMRange from './utils/find-dom-range'\nimport findNode from './utils/find-node'\nimport findPath from './utils/find-path'\nimport findPoint from './utils/find-point'\nimport findRange from './utils/find-range'\nimport getEventRange from './utils/get-event-range'\nimport getEventTransfer from './utils/get-event-transfer'\nimport setEventTransfer from './utils/set-event-transfer'\nimport ReactPlugin from './plugins/react'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport {\n  Editor,\n  cloneFragment,\n  findDOMNode,\n  findDOMPoint,\n  findDOMRange,\n  findNode,\n  findPath,\n  findPoint,\n  findRange,\n  getEventRange,\n  getEventTransfer,\n  setEventTransfer,\n  ReactPlugin,\n}\n\nexport default {\n  Editor,\n  cloneFragment,\n  findDOMNode,\n  findDOMPoint,\n  findDOMRange,\n  findNode,\n  findPath,\n  findPoint,\n  findRange,\n  getEventRange,\n  getEventTransfer,\n  setEventTransfer,\n  ReactPlugin,\n}\n"]},"metadata":{},"sourceType":"module"}