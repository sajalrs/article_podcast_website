{"ast":null,"code":"import { List, Record, Map, Set, is, OrderedSet } from 'immutable';\nimport isPlainObject from 'is-plain-object';\nimport warning from 'tiny-warning';\nimport invariant from 'tiny-invariant';\nimport Debug from 'debug';\nimport { reverse } from 'esrever';\nimport pick from 'lodash/pick';\nimport omit from 'lodash/omit';\nimport getDirection from 'direction';\n/**\n * An auto-incrementing index for generating keys.\n *\n * @type {Number}\n */\n\nvar n = void 0;\n/**\n * The global key generating function.\n *\n * @type {Function}\n */\n\nvar generate = void 0;\n/**\n * Create a key, using a provided key if available.\n *\n * @param {String|Void} key\n * @return {String}\n */\n\nfunction create(key) {\n  if (key == null) {\n    return generate();\n  }\n\n  if (typeof key === 'string') {\n    return key;\n  }\n\n  throw new Error('Keys must be strings, but you passed: ' + key);\n}\n/**\n * Set a different unique ID generating `function`.\n *\n * @param {Function} func\n */\n\n\nfunction setGenerator(func) {\n  generate = func;\n}\n/**\n * Reset the key generating function to its initial state.\n */\n\n\nfunction resetGenerator() {\n  n = 0;\n\n  generate = function generate() {\n    return '' + n++;\n  };\n}\n/**\n * Set the initial state.\n */\n\n\nresetGenerator();\n/**\n * Export.\n *\n * @type {Object}\n */\n\nvar KeyUtils = {\n  create: create,\n  setGenerator: setGenerator,\n  resetGenerator: resetGenerator\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n/**\n * Compare paths `path` and `target` to see which is before or after.\n *\n * @param {List} path\n * @param {List} target\n * @return {Number|Null}\n */\n\n\nfunction compare(path, target) {\n  var m = min(path, target);\n\n  for (var i = 0; i < m; i++) {\n    var pv = path.get(i);\n    var tv = target.get(i); // If the path's value is ever less than the target's, it's before.\n\n    if (pv < tv) return -1; // If the target's value is ever less than the path's, it's after.\n\n    if (pv > tv) return 1;\n  } // Paths should now be equal, otherwise something is wrong\n\n\n  return path.size === target.size ? 0 : null;\n}\n/**\n * Create a path from `attrs`.\n *\n * @param {Array|List} attrs\n * @return {List}\n */\n\n\nfunction create$1(attrs) {\n  if (attrs == null) {\n    return null;\n  }\n\n  if (List.isList(attrs)) {\n    return attrs;\n  }\n\n  if (Array.isArray(attrs)) {\n    return List(attrs);\n  }\n\n  throw new Error('Paths can only be created from arrays or lists, but you passed: ' + attrs);\n}\n/**\n * Crop paths `a` and `b` to an equal size, defaulting to the shortest.\n *\n * @param {List} a\n * @param {List} b\n */\n\n\nfunction crop(a, b) {\n  var size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : min(a, b);\n  var ca = a.slice(0, size);\n  var cb = b.slice(0, size);\n  return [ca, cb];\n}\n/**\n * Decrement a `path` by `n` at `index`, defaulting to the last index.\n *\n * @param {List} path\n * @param {Number} n\n * @param {Number} index\n */\n\n\nfunction decrement(path) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : path.size - 1;\n  return increment(path, 0 - n, index);\n}\n/**\n * Get all ancestor paths of th given path.\n *\n * @param {List} path\n * @returns {List}\n */\n\n\nfunction getAncestors(path) {\n  var ancestors = List().withMutations(function (list) {\n    for (var i = 0; i < path.size; i++) {\n      list.push(path.slice(0, i));\n    }\n  });\n  return ancestors;\n}\n/**\n * Increment a `path` by `n` at `index`, defaulting to the last index.\n *\n * @param {List} path\n * @param {Number} n\n * @param {Number} index\n */\n\n\nfunction increment(path) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : path.size - 1;\n  var value = path.get(index);\n  var newValue = value + n;\n  var newPath = path.set(index, newValue);\n  return newPath;\n}\n/**\n * Is a `path` above another `target` path?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\n\nfunction isAbove(path, target) {\n  var _crop = crop(path, target),\n      _crop2 = slicedToArray(_crop, 2),\n      p = _crop2[0],\n      t = _crop2[1];\n\n  return path.size < target.size && compare(p, t) === 0;\n}\n/**\n * Is a `path` after another `target` path in a document?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\n\nfunction isAfter(path, target) {\n  var _crop3 = crop(path, target),\n      _crop4 = slicedToArray(_crop3, 2),\n      p = _crop4[0],\n      t = _crop4[1];\n\n  return compare(p, t) === 1;\n}\n/**\n * Is a `path` before another `target` path in a document?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\n\nfunction isBefore(path, target) {\n  var _crop5 = crop(path, target),\n      _crop6 = slicedToArray(_crop5, 2),\n      p = _crop6[0],\n      t = _crop6[1];\n\n  return compare(p, t) === -1;\n}\n/**\n * Is a `path` equal to another `target` path in a document?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\n\nfunction isEqual(path, target) {\n  return path.equals(target);\n}\n/**\n * Is a `path` older than a `target` path? Meaning that it ends as an older\n * sibling of one of the indexes in the target.\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\n\nfunction isOlder(path, target) {\n  var index = path.size - 1;\n\n  var _crop7 = crop(path, target, index),\n      _crop8 = slicedToArray(_crop7, 2),\n      p = _crop8[0],\n      t = _crop8[1];\n\n  var pl = path.get(index);\n  var tl = target.get(index);\n  return isEqual(p, t) && pl > tl;\n}\n/**\n * Is an `any` object a path?\n *\n * @param {Mixed} any\n * @return {Boolean}\n */\n\n\nfunction isPath(any) {\n  return (List.isList(any) || Array.isArray(any)) && any.every(function (n) {\n    return typeof n === 'number';\n  });\n}\n/**\n * Is a `path` a sibling of a `target` path?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\n\nfunction isSibling(path, target) {\n  if (path.size !== target.size) return false;\n  var p = path.butLast();\n  var t = target.butLast();\n  return p.equals(t);\n}\n/**\n * Is a `path` younger than a `target` path? Meaning that it ends as a younger\n * sibling of one of the indexes in the target.\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\n\nfunction isYounger(path, target) {\n  var index = path.size - 1;\n\n  var _crop9 = crop(path, target, index),\n      _crop10 = slicedToArray(_crop9, 2),\n      p = _crop10[0],\n      t = _crop10[1];\n\n  var pl = path.get(index);\n  var tl = target.get(index);\n  return isEqual(p, t) && pl < tl;\n}\n/**\n * Lift a `path` to refer to its `n`th ancestor.\n *\n * @param {List} path\n * @return {List}\n */\n\n\nfunction lift(path) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var ancestor = path.slice(0, -1 * n);\n  return ancestor;\n}\n/**\n * Drop a `path`, returning a relative path from a depth of `n`.\n *\n * @param {List} path\n * @param {Number} n\n * @return {List}\n */\n\n\nfunction drop(path) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var relative = path.slice(n);\n  return relative;\n}\n/**\n * Get the maximum length of paths `a` and `b`.\n *\n * @param {List} path\n * @param {List} path\n * @return {Number}\n */\n\n\nfunction max(a, b) {\n  var n = Math.max(a.size, b.size);\n  return n;\n}\n/**\n * Get the minimum length of paths `a` and `b`.\n *\n * @param {List} path\n * @param {List} path\n * @return {Number}\n */\n\n\nfunction min(a, b) {\n  var n = Math.min(a.size, b.size);\n  return n;\n}\n/**\n * Get the common ancestor path of path `a` and path `b`.\n *\n * @param {List} a\n * @param {List} b\n * @return {List}\n */\n\n\nfunction relate(a, b) {\n  var array = [];\n\n  for (var i = 0; i < a.size && i < b.size; i++) {\n    var av = a.get(i);\n    var bv = b.get(i); // If the values aren't equal, they've diverged and don't share an ancestor.\n\n    if (av !== bv) break; // Otherwise, the current value is still a common ancestor.\n\n    array.push(av);\n  }\n\n  var path = create$1(array);\n  return path;\n}\n/**\n * Transform a `path` by an `operation`, adjusting it to stay current.\n *\n * @param {List} path\n * @param {Operation} operation\n * @return {List<List>}\n */\n\n\nfunction transform(path, operation) {\n  var type = operation.type,\n      position = operation.position,\n      p = operation.path;\n\n  if (type === 'add_mark' || type === 'insert_text' || type === 'remove_mark' || type === 'remove_text' || type === 'set_mark' || type === 'set_node' || type === 'set_selection' || type === 'set_value' || type === 'add_annotation' || type === 'remove_annotation' || type === 'set_annotation' || path.size === 0) {\n    return List([path]);\n  }\n\n  var pIndex = p.size - 1;\n  var pEqual = isEqual(p, path);\n  var pYounger = isYounger(p, path);\n  var pAbove = isAbove(p, path);\n\n  if (type === 'insert_node') {\n    if (pEqual || pYounger || pAbove) {\n      path = increment(path, 1, pIndex);\n    }\n  }\n\n  if (type === 'remove_node') {\n    if (pYounger) {\n      path = decrement(path, 1, pIndex);\n    } else if (pEqual || pAbove) {\n      path = [];\n    }\n  }\n\n  if (type === 'merge_node') {\n    if (pEqual || pYounger) {\n      path = decrement(path, 1, pIndex);\n    } else if (pAbove) {\n      path = decrement(path, 1, pIndex);\n      path = increment(path, position, pIndex + 1);\n    }\n  }\n\n  if (type === 'split_node') {\n    if (pEqual) {\n      path = [path, increment(path)];\n    } else if (pYounger) {\n      path = increment(path, 1, pIndex);\n    } else if (pAbove) {\n      if (path.get(pIndex + 1) >= position) {\n        path = increment(path, 1, pIndex);\n        path = decrement(path, position, pIndex + 1);\n      }\n    }\n  }\n\n  if (type === 'move_node') {\n    var np = operation.newPath;\n\n    if (isEqual(p, np)) {\n      return List([path]);\n    }\n\n    if (pAbove || pEqual) {\n      // We are comparing something that was moved\n      // The new path is unaffected unless the old path was the left-sibling of an ancestor\n      if (isYounger(p, np) && p.size < np.size) {\n        path = decrement(np, 1, min(np, p) - 1).concat(path.slice(p.size));\n      } else {\n        path = np.concat(path.slice(p.size));\n      }\n    } else {\n      // This is equivalent logic to remove_node for path\n      if (pYounger) {\n        path = decrement(path, 1, pIndex);\n      } // This is the equivalent logic to insert_node for newPath\n\n\n      if (isYounger(np, path) || isEqual(np, path) || isAbove(np, path)) {\n        path = increment(path, 1, np.size - 1);\n      }\n    }\n  }\n\n  var paths = Array.isArray(path) ? path : [path];\n  return List(paths);\n}\n/**\n * Export.\n *\n * @type {Object}\n */\n\n\nvar PathUtils = {\n  compare: compare,\n  create: create$1,\n  crop: crop,\n  decrement: decrement,\n  getAncestors: getAncestors,\n  increment: increment,\n  isAbove: isAbove,\n  isAfter: isAfter,\n  isBefore: isBefore,\n  isEqual: isEqual,\n  isOlder: isOlder,\n  isPath: isPath,\n  isSibling: isSibling,\n  isYounger: isYounger,\n  lift: lift,\n  drop: drop,\n  max: max,\n  min: min,\n  relate: relate,\n  transform: transform\n};\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS = {\n  key: undefined,\n  offset: undefined,\n  path: undefined\n  /**\n   * Point.\n   *\n   * @type {Point}\n   */\n\n};\n\nvar Point = function (_Record) {\n  inherits(Point, _Record);\n\n  function Point() {\n    classCallCheck(this, Point);\n    return possibleConstructorReturn(this, (Point.__proto__ || Object.getPrototypeOf(Point)).apply(this, arguments));\n  }\n\n  createClass(Point, [{\n    key: 'isAfterPoint',\n\n    /**\n     * Check whether the point is after another `point`.\n     *\n     * @return {Boolean}\n     */\n    value: function isAfterPoint(point) {\n      if (this.isUnset) return false;\n      var is$$1 = this.key === point.key && this.offset > point.offset || PathUtils.compare(this.path, point.path) === 1;\n      return is$$1;\n    }\n    /**\n     * Check whether the point is after a `range`.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isAfterRange',\n    value: function isAfterRange(range) {\n      if (this.isUnset) return false;\n      var is$$1 = this.isAfterPoint(range.end);\n      return is$$1;\n    }\n    /**\n     * Check whether the point is at the end of a `range`.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isAtEndOfRange',\n    value: function isAtEndOfRange(range) {\n      if (this.isUnset) return false;\n      var is$$1 = this.equals(range.end);\n      return is$$1;\n    }\n    /**\n     * Check whether the point is at the start of a `range`.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isAtStartOfRange',\n    value: function isAtStartOfRange(range) {\n      if (this.isUnset) return false;\n      var is$$1 = this.equals(range.start);\n      return is$$1;\n    }\n    /**\n     * Check whether the point is before another `point`.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isBeforePoint',\n    value: function isBeforePoint(point) {\n      if (this.isUnset) return false;\n      var is$$1 = this.key === point.key && this.offset < point.offset || PathUtils.compare(this.path, point.path) === -1;\n      return is$$1;\n    }\n    /**\n     * Check whether the point is before a `range`.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isBeforeRange',\n    value: function isBeforeRange(range) {\n      if (this.isUnset) return false;\n      var is$$1 = this.isBeforePoint(range.start);\n      return is$$1;\n    }\n    /**\n     * Check whether the point is inside a `range`.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isInRange',\n    value: function isInRange(range) {\n      if (this.isUnset) return false;\n      var is$$1 = this.equals(range.start) || this.equals(range.end) || this.isAfterPoint(range.start) && this.isBeforePoint(range.end);\n      return is$$1;\n    }\n    /**\n     * Check whether the point is at the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isAtEndOfNode',\n    value: function isAtEndOfNode(node) {\n      if (this.isUnset) return false;\n      var last = node.getLastText();\n      var is$$1 = this.key === last.key && this.offset === last.text.length;\n      return is$$1;\n    }\n    /**\n     * Check whether the point is at the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isAtStartOfNode',\n    value: function isAtStartOfNode(node) {\n      if (this.isUnset) return false; // PERF: Do a check for a `0` offset first since it's quickest.\n\n      if (this.offset !== 0) return false;\n      var first = node.getFirstText();\n      var is$$1 = this.key === first.key;\n      return is$$1;\n    }\n    /**\n     * Check whether the point is in a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isInNode',\n    value: function isInNode(node) {\n      if (this.isUnset) return false;\n      if (node.object === 'text' && node.key === this.key) return true;\n      if (node.hasNode(this.key)) return true;\n      return false;\n    }\n    /**\n     * Move the point's offset backward `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Point}\n     */\n\n  }, {\n    key: 'moveBackward',\n    value: function moveBackward() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      if (n === 0) return this;\n      if (n < 0) return this.moveForward(-n);\n      var point = this.setOffset(this.offset - n);\n      return point;\n    }\n    /**\n     * Move the point's offset forward `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Point}\n     */\n\n  }, {\n    key: 'moveForward',\n    value: function moveForward() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      if (n === 0) return this;\n      if (n < 0) return this.moveBackward(-n);\n      var point = this.setOffset(this.offset + n);\n      return point;\n    }\n    /**\n     * Move the point's anchor point to a new `path` and `offset`.\n     *\n     * Optionally, the `path` can be a key string, or omitted entirely in which\n     * case it would be the offset number.\n     *\n     * @param {List|String|Number} path\n     * @param {Number} offset\n     * @return {Point}\n     */\n\n  }, {\n    key: 'moveTo',\n    value: function moveTo(path) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var key = this.key;\n\n      if (typeof path === 'number') {\n        offset = path;\n        path = this.path;\n      } else if (typeof path === 'string') {\n        key = path;\n        path = key === this.key ? this.path : null;\n      } else {\n        key = path.equals(this.path) ? this.key : null;\n      }\n\n      var point = this.merge({\n        key: key,\n        path: path,\n        offset: offset\n      });\n      return point;\n    }\n    /**\n     * Move the point's anchor point to the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Point}\n     */\n\n  }, {\n    key: 'moveToStartOfNode',\n    value: function moveToStartOfNode(node) {\n      var first = node.getFirstText();\n      var point = this.moveTo(first.key, 0);\n      return point;\n    }\n    /**\n     * Move the point's anchor point to the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Point}\n     */\n\n  }, {\n    key: 'moveToEndOfNode',\n    value: function moveToEndOfNode(node) {\n      var last = node.getLastText();\n      var point = this.moveTo(last.key, last.text.length);\n      return point;\n    }\n    /**\n     * Normalize the point relative to a `node`, ensuring that its key and path\n     * reference a text node, or that it gets unset.\n     *\n     * @param {Node} node\n     * @return {Point}\n     */\n\n  }, {\n    key: 'normalize',\n    value: function normalize(node) {\n      // If both the key and path are null, there's no reference to a node, so\n      // make sure it is entirely unset.\n      if (this.key == null && this.path == null) {\n        return this.setOffset(null);\n      }\n\n      var key = this.key,\n          offset = this.offset,\n          path = this.path; // PERF: this function gets called a lot.\n      // to avoid creating the key -> path lookup table, we attempt to look up by path first.\n\n      var target = path && node.getNode(path);\n\n      if (!target) {\n        target = node.getNode(key);\n\n        if (target) {\n          // There is a misalignment of path and key\n          var _point = this.merge({\n            path: node.getPath(key)\n          });\n\n          return _point;\n        }\n      }\n\n      if (!target) {\n        warning(false, \"A point's `path` or `key` invalid and was reset!\");\n        var text = node.getFirstText();\n        if (!text) return Point.create();\n\n        var _point2 = this.merge({\n          key: text.key,\n          offset: 0,\n          path: node.getPath(text.key)\n        });\n\n        return _point2;\n      }\n\n      if (target.object !== 'text') {\n        warning(false, 'A point should not reference a non-text node!');\n\n        var _text = target.getTextAtOffset(offset);\n\n        var before = target.getOffset(_text.key);\n\n        var _point3 = this.merge({\n          offset: offset - before,\n          key: _text.key,\n          path: node.getPath(_text.key)\n        });\n\n        return _point3;\n      }\n\n      if (target && path && key && key !== target.key) {\n        warning(false, \"A point's `key` did not match its `path`!\"); // TODO: if we look up by path above and it differs by key, do we want to reset it to looking up by key?\n      }\n\n      var point = this.merge({\n        key: target.key,\n        path: path == null ? node.getPath(target.key) : path,\n        offset: offset == null ? 0 : Math.min(offset, target.text.length)\n      }); // COMPAT: There is an ambiguity, since a point can exist at the end of a\n      // text node, or at the start of the following one. To eliminate it we\n      // enforce that if there is a following text node, we always move it there.\n\n      if (point.offset === target.text.length) {\n        var block = node.getClosestBlock(point.path); // TODO: this next line is broken because `getNextText` takes a path\n\n        var next = block.getNextText();\n\n        if (next) {\n          point = point.merge({\n            key: next.key,\n            path: node.getPath(next.key),\n            offset: 0\n          });\n        }\n      }\n\n      return point;\n    }\n    /**\n     * Set the point's key to a new `key`.\n     *\n     * @param {String} key\n     * @return {Point}\n     */\n\n  }, {\n    key: 'setKey',\n    value: function setKey(key) {\n      if (key != null) {\n        key = KeyUtils.create(key);\n      }\n\n      var point = this.set('key', key);\n      return point;\n    }\n    /**\n     * Set the point's offset to a new `offset`.\n     *\n     * @param {Number} offset\n     * @return {Point}\n     */\n\n  }, {\n    key: 'setOffset',\n    value: function setOffset(offset) {\n      var point = this.set('offset', offset);\n      return point;\n    }\n    /**\n     * Set the point's path to a new `path`.\n     *\n     * @param {List|Array} path\n     * @return {Point}\n     */\n\n  }, {\n    key: 'setPath',\n    value: function setPath(path) {\n      if (path != null) {\n        path = PathUtils.create(path);\n      }\n\n      var point = this.set('path', path);\n      return point;\n    }\n    /**\n     * Return a JSON representation of the point.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var object = {\n        object: this.object,\n        key: this.key,\n        offset: this.offset,\n        path: this.path && this.path.toArray()\n      };\n\n      if (!options.preserveKeys) {\n        delete object.key;\n      }\n\n      return object;\n    }\n    /**\n     * Unset the point.\n     *\n     * @return {Point}\n     */\n\n  }, {\n    key: 'unset',\n    value: function unset() {\n      return this.merge({\n        key: null,\n        offset: null,\n        path: null\n      });\n    }\n  }, {\n    key: 'isSet',\n\n    /**\n     * Check whether all properties of the point are set.\n     *\n     * @return {Boolean}\n     */\n    get: function get$$1() {\n      return this.key != null && this.offset != null && this.path != null;\n    }\n    /**\n     * Check whether any property of the point is not set.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isUnset',\n    get: function get$$1() {\n      return !this.isSet;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Point` with `attrs`.\n     *\n     * @param {Object|Point} attrs\n     * @return {Point}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Point.isPoint(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        return Point.fromJSON(attrs);\n      }\n\n      throw new Error('`Point.create` only accepts objects or points, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a dictionary of settable point properties from `attrs`.\n     *\n     * @param {Object|Point} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Point.isPoint(a)) {\n        return {\n          key: a.key,\n          offset: a.offset,\n          path: a.path\n        };\n      }\n\n      if (isPlainObject(a)) {\n        var p = {};\n        if ('key' in a) p.key = a.key;\n        if ('offset' in a) p.offset = a.offset;\n        if ('path' in a) p.path = PathUtils.create(a.path); // If only a path is set, or only a key is set, ensure that the other is\n        // set to null so that it can be normalized back to the right value.\n        // Otherwise we won't realize that the path and key don't match anymore.\n\n        if ('path' in a && !('key' in a)) p.key = null;\n        if ('key' in a && !('path' in a)) p.path = null;\n        return p;\n      }\n\n      throw new Error('`Point.createProperties` only accepts objects or points, but you passed it: ' + a);\n    }\n    /**\n     * Create a `Point` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Point}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var _object$key = object.key,\n          key = _object$key === undefined ? null : _object$key,\n          _object$offset = object.offset,\n          offset = _object$offset === undefined ? null : _object$offset,\n          _object$path = object.path,\n          path = _object$path === undefined ? null : _object$path;\n      var point = new Point({\n        key: key,\n        offset: offset,\n        path: PathUtils.create(path)\n      });\n      return point;\n    }\n  }]);\n  return Point;\n}(Record(DEFAULTS));\n/**\n * Data.\n *\n * This isn't an immutable record, it's just a thin wrapper around `Map` so that\n * we can allow for more convenient creation.\n *\n * @type {Object}\n */\n\n\nvar Data = function () {\n  function Data() {\n    classCallCheck(this, Data);\n  }\n\n  createClass(Data, null, [{\n    key: 'create',\n\n    /**\n     * Create a new `Data` with `attrs`.\n     *\n     * @param {Object|Data|Map} attrs\n     * @return {Data} data\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Map.isMap(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        return Data.fromJSON(attrs);\n      }\n\n      throw new Error('`Data.create` only accepts objects or maps, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a `Data` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Data}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      return new Map(object);\n    }\n    /**\n     * Alias `fromJS`.\n     */\n\n  }]);\n  return Data;\n}();\n/**\n * Export.\n *\n * @type {Object}\n */\n\n\nData.fromJS = Data.fromJSON;\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$1 = {\n  data: undefined,\n  type: undefined\n  /**\n   * Mark.\n   *\n   * @type {Mark}\n   */\n\n};\n\nvar Mark = function (_Record) {\n  inherits(Mark, _Record);\n\n  function Mark() {\n    classCallCheck(this, Mark);\n    return possibleConstructorReturn(this, (Mark.__proto__ || Object.getPrototypeOf(Mark)).apply(this, arguments));\n  }\n\n  createClass(Mark, [{\n    key: 'toJSON',\n\n    /**\n     * Return a JSON representation of the mark.\n     *\n     * @return {Object}\n     */\n    value: function toJSON() {\n      var object = {\n        object: this.object,\n        type: this.type,\n        data: this.data.toJSON()\n      };\n      return object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Mark` with `attrs`.\n     *\n     * @param {Object|Mark} attrs\n     * @return {Mark}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Mark.isMark(attrs)) {\n        return attrs;\n      }\n\n      if (typeof attrs === 'string') {\n        attrs = {\n          type: attrs\n        };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Mark.fromJSON(attrs);\n      }\n\n      throw new Error('`Mark.create` only accepts objects, strings or marks, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a set of marks.\n     *\n     * @param {Array<Object|Mark>} elements\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'createSet',\n    value: function createSet(elements) {\n      if (Set.isSet(elements) || Array.isArray(elements)) {\n        var marks = new Set(elements.map(Mark.create));\n        return marks;\n      }\n\n      if (elements == null) {\n        return Set();\n      }\n\n      throw new Error('`Mark.createSet` only accepts sets, arrays or null, but you passed it: ' + elements);\n    }\n    /**\n     * Create a dictionary of settable mark properties from `attrs`.\n     *\n     * @param {Object|String|Mark} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Mark.isMark(attrs)) {\n        return {\n          data: attrs.data,\n          type: attrs.type\n        };\n      }\n\n      if (typeof attrs === 'string') {\n        return {\n          type: attrs\n        };\n      }\n\n      if (isPlainObject(attrs)) {\n        var props = {};\n        if ('type' in attrs) props.type = attrs.type;\n        if ('data' in attrs) props.data = Data.create(attrs.data);\n        return props;\n      }\n\n      throw new Error('`Mark.createProperties` only accepts objects, strings or marks, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a `Mark` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Mark}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var _object$data = object.data,\n          data = _object$data === undefined ? {} : _object$data,\n          type = object.type;\n\n      if (typeof type !== 'string') {\n        throw new Error('`Mark.fromJS` requires a `type` string.');\n      }\n\n      var mark = new Mark({\n        type: type,\n        data: new Map(data)\n      });\n      return mark;\n    }\n    /**\n     * Check if `any` is a set of marks.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isMarkSet',\n    value: function isMarkSet(any) {\n      return Set.isSet(any) && any.every(function (item) {\n        return Mark.isMark(item);\n      });\n    }\n  }]);\n  return Mark;\n}(Record(DEFAULTS$1));\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\n\nvar DEFAULTS$2 = {\n  type: undefined,\n  data: undefined,\n  anchor: undefined,\n  focus: undefined\n  /**\n   * Decoration.\n   *\n   * @type {Decoration}\n   */\n\n};\n\nvar Decoration = function (_Record) {\n  inherits(Decoration, _Record);\n\n  function Decoration() {\n    classCallCheck(this, Decoration);\n    return possibleConstructorReturn(this, (Decoration.__proto__ || Object.getPrototypeOf(Decoration)).apply(this, arguments));\n  }\n\n  createClass(Decoration, [{\n    key: 'setProperties',\n\n    /**\n     * Set new `properties` on the decoration.\n     *\n     * @param {Object|Range|Selection} properties\n     * @return {Range}\n     */\n    value: function setProperties(properties) {\n      properties = Decoration.createProperties(properties);\n      var decoration = this.merge(properties);\n      return decoration;\n    }\n    /**\n     * Return a JSON representation of the decoration.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var object = {\n        object: this.object,\n        type: this.type,\n        data: this.data.toJSON(),\n        anchor: this.anchor.toJSON(options),\n        focus: this.focus.toJSON(options)\n      };\n      return object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Decoration` with `attrs`.\n     *\n     * @param {Object|Decoration} attrs\n     * @return {Decoration}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Decoration.isDecoration(attrs)) {\n        return attrs;\n      }\n\n      if (Range.isRange(attrs)) {\n        return Decoration.fromJSON(Range.createProperties(attrs));\n      }\n\n      if (isPlainObject(attrs)) {\n        return Decoration.fromJSON(attrs);\n      }\n\n      throw new Error('`Decoration.create` only accepts objects or decorations, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a list of `Ranges` from `elements`.\n     *\n     * @param {Array<Decoration|Object>|List<Decoration|Object>} elements\n     * @return {List<Decoration>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (List.isList(elements) || Array.isArray(elements)) {\n        var list = new List(elements.map(Decoration.create));\n        return list;\n      }\n\n      throw new Error('`Decoration.createList` only accepts arrays or lists, but you passed it: ' + elements);\n    }\n    /**\n     * Create a dictionary of settable decoration properties from `attrs`.\n     *\n     * @param {Object|String|Decoration} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Decoration.isDecoration(a)) {\n        return {\n          type: a.type,\n          data: a.data,\n          anchor: Point.createProperties(a.anchor),\n          focus: Point.createProperties(a.focus),\n          mark: Mark.create(a.mark)\n        };\n      }\n\n      if (isPlainObject(a)) {\n        var p = {};\n        if ('type' in a) p.type = a.type;\n        if ('data' in a) p.data = Data.create(a.data);\n        if ('anchor' in a) p.anchor = Point.create(a.anchor);\n        if ('focus' in a) p.focus = Point.create(a.focus);\n        return p;\n      }\n\n      throw new Error('`Decoration.createProperties` only accepts objects or decorations, but you passed it: ' + a);\n    }\n    /**\n     * Create a `Decoration` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Decoration}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var anchor = object.anchor,\n          focus = object.focus;\n      var type = object.type,\n          data = object.data;\n\n      if (object.mark && !type) {\n        warning(false, 'As of slate@0.47 the `decoration.mark` property has been changed to `decoration.type` and `decoration.data` directly.');\n        type = object.mark.type;\n        data = object.mark.data;\n      }\n\n      if (!type) {\n        throw new Error('Decorations must be created with a `type`, but you passed: ' + JSON.stringify(object));\n      }\n\n      var decoration = new Decoration({\n        type: type,\n        data: Data.create(data || {}),\n        anchor: Point.fromJSON(anchor || {}),\n        focus: Point.fromJSON(focus || {})\n      });\n      return decoration;\n    }\n  }]);\n  return Decoration;\n}(Record(DEFAULTS$2));\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\n\nvar DEFAULTS$3 = {\n  anchor: undefined,\n  focus: undefined,\n  isFocused: undefined,\n  marks: undefined\n  /**\n   * Selection.\n   *\n   * @type {Selection}\n   */\n\n};\n\nvar Selection = function (_Record) {\n  inherits(Selection, _Record);\n\n  function Selection() {\n    classCallCheck(this, Selection);\n    return possibleConstructorReturn(this, (Selection.__proto__ || Object.getPrototypeOf(Selection)).apply(this, arguments));\n  }\n\n  createClass(Selection, [{\n    key: 'setIsFocused',\n\n    /**\n     * Set the `isFocused` property to a new `value`.\n     *\n     * @param {Boolean} value\n     * @return {Selection}\n     */\n    value: function setIsFocused(value) {\n      var selection = this.set('isFocused', value);\n      return selection;\n    }\n    /**\n     * Set the `marks` property to a new set of `marks`.\n     *\n     * @param {Set} marks\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'setMarks',\n    value: function setMarks(marks) {\n      var selection = this.set('marks', marks);\n      return selection;\n    }\n    /**\n     * Set new `properties` on the selection.\n     *\n     * @param {Object|Range|Selection} properties\n     * @return {Range}\n     */\n\n  }, {\n    key: 'setProperties',\n    value: function setProperties(properties) {\n      properties = Selection.createProperties(properties);\n      var _properties = properties,\n          anchor = _properties.anchor,\n          focus = _properties.focus,\n          props = objectWithoutProperties(_properties, ['anchor', 'focus']);\n\n      if (anchor) {\n        props.anchor = Point.create(anchor);\n      }\n\n      if (focus) {\n        props.focus = Point.create(focus);\n      }\n\n      var selection = this.merge(props);\n      return selection;\n    }\n    /**\n     * Return a JSON representation of the selection.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var object = {\n        object: this.object,\n        anchor: this.anchor.toJSON(options),\n        focus: this.focus.toJSON(options),\n        isFocused: this.isFocused,\n        marks: this.marks == null ? null : this.marks.toArray().map(function (m) {\n          return m.toJSON();\n        })\n      };\n      return object;\n    }\n  }, {\n    key: 'isBlurred',\n\n    /**\n     * Check whether the selection is blurred.\n     *\n     * @return {Boolean}\n     */\n    get: function get$$1() {\n      return !this.isFocused;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Selection` with `attrs`.\n     *\n     * @param {Object|Selection} attrs\n     * @return {Selection}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Selection.isSelection(attrs)) {\n        return attrs;\n      }\n\n      if (Range.isRange(attrs)) {\n        return Selection.fromJSON(Range.createProperties(attrs));\n      }\n\n      if (isPlainObject(attrs)) {\n        return Selection.fromJSON(attrs);\n      }\n\n      throw new Error('`Selection.create` only accepts objects, ranges or selections, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a dictionary of settable selection properties from `attrs`.\n     *\n     * @param {Object|String|Selection} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Selection.isSelection(a)) {\n        return {\n          anchor: Point.createProperties(a.anchor),\n          focus: Point.createProperties(a.focus),\n          isFocused: a.isFocused,\n          marks: a.marks\n        };\n      }\n\n      if (Range.isRange(a)) {\n        return {\n          anchor: Point.createProperties(a.anchor),\n          focus: Point.createProperties(a.focus)\n        };\n      }\n\n      if (isPlainObject(a)) {\n        var p = {};\n        if ('anchor' in a) p.anchor = Point.create(a.anchor);\n        if ('focus' in a) p.focus = Point.create(a.focus);\n        if ('isFocused' in a) p.isFocused = a.isFocused;\n        if ('marks' in a) p.marks = a.marks == null ? null : Mark.createSet(a.marks);\n        return p;\n      }\n\n      throw new Error('`Selection.createProperties` only accepts objects, ranges or selections, but you passed it: ' + a);\n    }\n    /**\n     * Create a `Selection` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var anchor = object.anchor,\n          focus = object.focus,\n          _object$isFocused = object.isFocused,\n          isFocused = _object$isFocused === undefined ? false : _object$isFocused,\n          _object$marks = object.marks,\n          marks = _object$marks === undefined ? null : _object$marks;\n      var selection = new Selection({\n        anchor: Point.fromJSON(anchor || {}),\n        focus: Point.fromJSON(focus || {}),\n        isFocused: isFocused,\n        marks: marks == null ? null : new Set(marks.map(Mark.fromJSON))\n      });\n      return selection;\n    }\n  }]);\n  return Selection;\n}(Record(DEFAULTS$3));\n/**\n * Slate-specific object types.\n *\n * @type {Object}\n */\n\n\nvar TYPES = {\n  annotation: '@@__SLATE_ANNOTATION__@@',\n  block: '@@__SLATE_BLOCK__@@',\n  change: '@@__SLATE_CHANGE__@@',\n  decoration: '@@__SLATE_DECORATION__@@',\n  document: '@@__SLATE_DOCUMENT__@@',\n  editor: '@@__SLATE_EDITOR__@@',\n  inline: '@@__SLATE_INLINE__@@',\n  leaf: '@@__SLATE_LEAF__@@',\n  mark: '@@__SLATE_MARK__@@',\n  operation: '@@__SLATE_OPERATION__@@',\n  point: '@@__SLATE_POINT__@@',\n  range: '@@__SLATE_RANGE__@@',\n  selection: '@@__SLATE_SELECTION__@@',\n  text: '@@__SLATE_TEXT__@@',\n  value: '@@__SLATE_VALUE__@@'\n  /**\n   * Determine whether a `value` is of `type`.\n   *\n   * @param {string} type\n   * @param {any} value\n   * @return {boolean}\n   */\n\n};\n\nfunction isObject(type, value) {\n  return !!(value && value[TYPES[type]]);\n}\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\n\nvar DEFAULTS$4 = {\n  anchor: undefined,\n  focus: undefined\n  /**\n   * Range.\n   *\n   * @type {Range}\n   */\n\n};\n\nvar Range = function (_Record) {\n  inherits(Range, _Record);\n\n  function Range() {\n    classCallCheck(this, Range);\n    return possibleConstructorReturn(this, (Range.__proto__ || Object.getPrototypeOf(Range)).apply(this, arguments));\n  }\n\n  createClass(Range, [{\n    key: 'toJSON',\n\n    /**\n     * Return a JSON representation of the range.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var object = {\n        object: this.object,\n        anchor: this.anchor.toJSON(options),\n        focus: this.focus.toJSON(options)\n      };\n      return object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Range` with `attrs`.\n     *\n     * @param {Object|Range} attrs\n     * @return {Range}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Range.isRange(attrs)) {\n        if (attrs.object === 'range') {\n          return attrs;\n        } else {\n          return Range.fromJSON(Range.createProperties(attrs));\n        }\n      }\n\n      if (isPlainObject(attrs)) {\n        return Range.fromJSON(attrs);\n      }\n\n      throw new Error('`Range.create` only accepts objects or ranges, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a list of `Ranges` from `elements`.\n     *\n     * @param {Array<Range|Object>|List<Range|Object>} elements\n     * @return {List<Range>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (List.isList(elements) || Array.isArray(elements)) {\n        var list = new List(elements.map(Range.create));\n        return list;\n      }\n\n      throw new Error('`Range.createList` only accepts arrays or lists, but you passed it: ' + elements);\n    }\n    /**\n     * Create a dictionary of settable range properties from `attrs`.\n     *\n     * @param {Object|String|Range} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Range.isRange(a)) {\n        return {\n          anchor: Point.createProperties(a.anchor),\n          focus: Point.createProperties(a.focus)\n        };\n      }\n\n      if (isPlainObject(a)) {\n        var p = {};\n        if ('anchor' in a) p.anchor = Point.create(a.anchor);\n        if ('focus' in a) p.focus = Point.create(a.focus);\n        return p;\n      }\n\n      throw new Error('`Range.createProperties` only accepts objects, annotations, decorations, ranges or selections, but you passed it: ' + a);\n    }\n    /**\n     * Create a `Range` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Range}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var anchor = object.anchor,\n          focus = object.focus;\n      var range = new Range({\n        anchor: Point.fromJSON(anchor || {}),\n        focus: Point.fromJSON(focus || {})\n      });\n      return range;\n    }\n    /**\n     * Check if a `value` is a `Range`, or is range-like.\n     *\n     * @param {Any} value\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isRange',\n    value: function isRange(value) {\n      return isObject('range', value) || Decoration.isDecoration(value) || Selection.isSelection(value);\n    }\n  }]);\n  return Range;\n}(Record(DEFAULTS$4));\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\n\nvar DEFAULTS$5 = {\n  key: undefined,\n  type: undefined,\n  data: undefined,\n  anchor: undefined,\n  focus: undefined\n  /**\n   * Annotation.\n   *\n   * @type {Annotation}\n   */\n\n};\n\nvar Annotation = function (_Record) {\n  inherits(Annotation, _Record);\n\n  function Annotation() {\n    classCallCheck(this, Annotation);\n    return possibleConstructorReturn(this, (Annotation.__proto__ || Object.getPrototypeOf(Annotation)).apply(this, arguments));\n  }\n\n  createClass(Annotation, [{\n    key: 'setProperties',\n\n    /**\n     * Set new `properties` on the annotation.\n     *\n     * @param {Object|Range|Selection} properties\n     * @return {Range}\n     */\n    value: function setProperties(properties) {\n      properties = Annotation.createProperties(properties);\n      var annotation = this.merge(properties);\n      return annotation;\n    }\n    /**\n     * Return a JSON representation of the annotation.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var object = {\n        object: this.object,\n        key: this.key,\n        type: this.type,\n        data: this.data.toJSON(),\n        anchor: this.anchor.toJSON(options),\n        focus: this.focus.toJSON(options)\n      };\n      return object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Annotation` with `attrs`.\n     *\n     * @param {Object|Annotation} attrs\n     * @return {Annotation}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Annotation.isAnnotation(attrs)) {\n        return attrs;\n      }\n\n      if (Range.isRange(attrs)) {\n        return Annotation.fromJSON(Range.createProperties(attrs));\n      }\n\n      if (isPlainObject(attrs)) {\n        return Annotation.fromJSON(attrs);\n      }\n\n      throw new Error('`Annotation.create` only accepts objects or annotations, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a map of annotations from `elements`.\n     *\n     * @param {Object<String,Annotation>|Map<String,Annotation>} elements\n     * @return {Map<String,Annotation>}\n     */\n\n  }, {\n    key: 'createMap',\n    value: function createMap() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (Map.isMap(elements)) {\n        return elements;\n      }\n\n      if (isPlainObject(elements)) {\n        var obj = {};\n\n        for (var key in elements) {\n          var value = elements[key];\n          var annotation = Annotation.create(value);\n          obj[key] = annotation;\n        }\n\n        return Map(obj);\n      }\n\n      throw new Error('`Annotation.createMap` only accepts arrays or lists, but you passed it: ' + elements);\n    }\n    /**\n     * Create a dictionary of settable annotation properties from `attrs`.\n     *\n     * @param {Object|String|Annotation} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Annotation.isAnnotation(a)) {\n        return {\n          key: a.key,\n          type: a.type,\n          data: a.data,\n          anchor: Point.createProperties(a.anchor),\n          focus: Point.createProperties(a.focus)\n        };\n      }\n\n      if (isPlainObject(a)) {\n        var p = {};\n        if ('key' in a) p.key = a.key;\n        if ('type' in a) p.type = a.type;\n        if ('data' in a) p.data = Data.create(a.data);\n        if ('anchor' in a) p.anchor = Point.create(a.anchor);\n        if ('focus' in a) p.focus = Point.create(a.focus);\n        return p;\n      }\n\n      throw new Error('`Annotation.createProperties` only accepts objects or annotations, but you passed it: ' + a);\n    }\n    /**\n     * Create a `Annotation` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Annotation}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var key = object.key,\n          type = object.type,\n          data = object.data,\n          anchor = object.anchor,\n          focus = object.focus;\n\n      if (!key) {\n        throw new Error('Annotations must be created with a `key`, but you passed: ' + JSON.stringify(object));\n      }\n\n      if (!type) {\n        throw new Error('Annotations must be created with a `type`, but you passed: ' + JSON.stringify(object));\n      }\n\n      var annotation = new Annotation({\n        key: key,\n        type: type,\n        data: Data.create(data || {}),\n        anchor: Point.fromJSON(anchor || {}),\n        focus: Point.fromJSON(focus || {})\n      });\n      return annotation;\n    }\n  }]);\n  return Annotation;\n}(Record(DEFAULTS$5));\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\n\nvar DEFAULTS$6 = {\n  data: undefined,\n  key: undefined,\n  nodes: undefined\n  /**\n   * Document.\n   *\n   * @type {Document}\n   */\n\n};\n\nvar Document = function (_Record) {\n  inherits(Document, _Record);\n\n  function Document() {\n    classCallCheck(this, Document);\n    return possibleConstructorReturn(this, (Document.__proto__ || Object.getPrototypeOf(Document)).apply(this, arguments));\n  }\n\n  createClass(Document, [{\n    key: 'toJSON',\n\n    /**\n     * Return a JSON representation of the document.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var object = {\n        object: this.object,\n        data: this.data.toJSON(),\n        nodes: this.nodes.toArray().map(function (n) {\n          return n.toJSON(options);\n        })\n      };\n\n      if (options.preserveKeys) {\n        object.key = this.key;\n      }\n\n      return object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Document` with `attrs`.\n     *\n     * @param {Object|Array|List|Text} attrs\n     * @return {Document}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Document.isDocument(attrs)) {\n        return attrs;\n      }\n\n      if (List.isList(attrs) || Array.isArray(attrs)) {\n        attrs = {\n          nodes: attrs\n        };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Document.fromJSON(attrs);\n      }\n\n      throw new Error('`Document.create` only accepts objects, arrays, lists or documents, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a `Document` from a JSON `object`.\n     *\n     * @param {Object|Document} object\n     * @return {Document}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      if (Document.isDocument(object)) {\n        return object;\n      }\n\n      var _object$data = object.data,\n          data = _object$data === undefined ? {} : _object$data,\n          _object$key = object.key,\n          key = _object$key === undefined ? KeyUtils.create() : _object$key,\n          _object$nodes = object.nodes,\n          nodes = _object$nodes === undefined ? [] : _object$nodes;\n      var document = new Document({\n        key: key,\n        data: new Map(data),\n        nodes: Node.createList(nodes)\n      });\n      return document;\n    }\n  }]);\n  return Document;\n}(Record(DEFAULTS$6));\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\n\nvar DEFAULTS$7 = {\n  data: undefined,\n  key: undefined,\n  nodes: undefined,\n  type: undefined\n  /**\n   * Inline.\n   *\n   * @type {Inline}\n   */\n\n};\n\nvar Inline = function (_Record) {\n  inherits(Inline, _Record);\n\n  function Inline() {\n    classCallCheck(this, Inline);\n    return possibleConstructorReturn(this, (Inline.__proto__ || Object.getPrototypeOf(Inline)).apply(this, arguments));\n  }\n\n  createClass(Inline, [{\n    key: 'toJSON',\n\n    /**\n     * Return a JSON representation of the inline.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var object = {\n        object: this.object,\n        type: this.type,\n        data: this.data.toJSON(),\n        nodes: this.nodes.toArray().map(function (n) {\n          return n.toJSON(options);\n        })\n      };\n\n      if (options.preserveKeys) {\n        object.key = this.key;\n      }\n\n      return object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Inline` with `attrs`.\n     *\n     * @param {Object|String|Inline} attrs\n     * @return {Inline}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Inline.isInline(attrs)) {\n        return attrs;\n      }\n\n      if (typeof attrs === 'string') {\n        attrs = {\n          type: attrs\n        };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Inline.fromJSON(attrs);\n      }\n\n      throw new Error('`Inline.create` only accepts objects, strings or inlines, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a list of `Inlines` from an array.\n     *\n     * @param {Array<Inline|Object>|List<Inline|Object>} elements\n     * @return {List<Inline>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (List.isList(elements) || Array.isArray(elements)) {\n        var list = new List(elements.map(Inline.create));\n        return list;\n      }\n\n      throw new Error('`Inline.createList` only accepts arrays or lists, but you passed it: ' + elements);\n    }\n    /**\n     * Create a `Inline` from a JSON `object`.\n     *\n     * @param {Object|Inline} object\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      if (Inline.isInline(object)) {\n        return object;\n      }\n\n      var _object$data = object.data,\n          data = _object$data === undefined ? {} : _object$data,\n          _object$key = object.key,\n          key = _object$key === undefined ? KeyUtils.create() : _object$key,\n          _object$nodes = object.nodes,\n          nodes = _object$nodes === undefined ? [] : _object$nodes,\n          type = object.type;\n\n      if (typeof type !== 'string') {\n        throw new Error('`Inline.fromJS` requires a `type` string.');\n      }\n\n      var inline = new Inline({\n        key: key,\n        type: type,\n        data: new Map(data),\n        nodes: Node.createList(nodes)\n      });\n      return inline;\n    }\n    /**\n     * Check if `any` is a list of inlines.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isInlineList',\n    value: function isInlineList(any) {\n      return List.isList(any) && any.every(function (item) {\n        return Inline.isInline(item);\n      });\n    }\n  }]);\n  return Inline;\n}(Record(DEFAULTS$7));\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\n\nvar DEFAULTS$8 = {\n  key: undefined,\n  marks: undefined,\n  text: undefined\n};\nvar Leaf = Record({\n  text: undefined,\n  marks: undefined,\n  annotations: undefined,\n  decorations: undefined\n});\n/**\n * Text.\n *\n * @type {Text}\n */\n\nvar Text = function (_Record) {\n  inherits(Text, _Record);\n\n  function Text() {\n    classCallCheck(this, Text);\n    return possibleConstructorReturn(this, (Text.__proto__ || Object.getPrototypeOf(Text)).apply(this, arguments));\n  }\n\n  createClass(Text, [{\n    key: 'addMark',\n\n    /**\n     * Add a `mark`.\n     *\n     * @param {Mark} mark\n     * @return {Text}\n     */\n    value: function addMark(mark) {\n      mark = Mark.create(mark);\n      var marks = this.marks;\n      var next = marks.add(mark);\n      var node = this.set('marks', next);\n      return node;\n    }\n    /**\n     * Add a set of `marks`.\n     *\n     * @param {Set<Mark>} marks\n     * @return {Text}\n     */\n\n  }, {\n    key: 'addMarks',\n    value: function addMarks(marks) {\n      marks = Mark.createSet(marks);\n      var node = this.set('marks', this.marks.union(marks));\n      return node;\n    }\n    /**\n     * Get a list of uniquely-formatted leaves for the text node, given its\n     * existing marks, and its current `annotations` and `decorations`.\n     *\n     * @param {Map<String,Annotation>} annotations\n     * @param {List<Decoration>} decorations\n     * @return {List<Leaf>}\n     */\n\n  }, {\n    key: 'getLeaves',\n    value: function getLeaves(annotations, decorations) {\n      var text = this.text,\n          marks = this.marks;\n      var leaves = [{\n        text: text,\n        marks: marks,\n        annotations: [],\n        decorations: []\n      }]; // Helper to split a leaf into two `at` an offset.\n\n      var split = function split(leaf, at) {\n        return [{\n          text: leaf.text.slice(0, at),\n          marks: leaf.marks,\n          annotations: [].concat(toConsumableArray(leaf.annotations)),\n          decorations: [].concat(toConsumableArray(leaf.decorations))\n        }, {\n          text: leaf.text.slice(at),\n          marks: leaf.marks,\n          annotations: [].concat(toConsumableArray(leaf.annotations)),\n          decorations: [].concat(toConsumableArray(leaf.decorations))\n        }];\n      }; // Helper to compile the leaves for a `kind` of format.\n\n\n      var compile = function compile(kind) {\n        var formats = kind === 'annotations' ? annotations.values() : decorations;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = formats[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var format = _step.value;\n            var start = format.start,\n                end = format.end;\n            var next = [];\n            var o = 0;\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n              for (var _iterator2 = leaves[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var leaf = _step2.value;\n                var length = leaf.text.length;\n                var offset = o;\n                o += length; // If the range encompases the entire leaf, add the format.\n\n                if (start.offset <= offset && end.offset >= offset + length) {\n                  leaf[kind].push(format);\n                  next.push(leaf);\n                  continue;\n                } // If the range starts after the leaf, or ends before it, continue.\n\n\n                if (start.offset > offset + length || end.offset < offset || end.offset === offset && offset !== 0) {\n                  next.push(leaf);\n                  continue;\n                } // Otherwise we need to split the leaf, at the start, end, or both,\n                // and add the format to the middle intersecting section. Do the end\n                // split first since we don't need to update the offset that way.\n\n\n                var middle = leaf;\n                var before = void 0;\n                var after = void 0;\n\n                if (end.offset < offset + length) {\n                  var _split = split(middle, end.offset - offset);\n\n                  var _split2 = slicedToArray(_split, 2);\n\n                  middle = _split2[0];\n                  after = _split2[1];\n                }\n\n                if (start.offset > offset) {\n                  var _split3 = split(middle, start.offset - offset);\n\n                  var _split4 = slicedToArray(_split3, 2);\n\n                  before = _split4[0];\n                  middle = _split4[1];\n                }\n\n                middle[kind].push(format);\n\n                if (before) {\n                  next.push(before);\n                }\n\n                next.push(middle);\n\n                if (after) {\n                  next.push(after);\n                }\n              }\n            } catch (err) {\n              _didIteratorError2 = true;\n              _iteratorError2 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                  _iterator2.return();\n                }\n              } finally {\n                if (_didIteratorError2) {\n                  throw _iteratorError2;\n                }\n              }\n            }\n\n            leaves = next;\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      };\n\n      compile('annotations');\n      compile('decorations');\n      leaves = leaves.map(function (leaf) {\n        return new Leaf(_extends({}, leaf, {\n          annotations: List(leaf.annotations),\n          decorations: List(leaf.decorations)\n        }));\n      });\n      var list = List(leaves);\n      return list;\n    }\n    /**\n     * Insert `text` at `index`.\n     *\n     * @param {Number} index\n     * @param {String} string\n     * @return {Text}\n     */\n\n  }, {\n    key: 'insertText',\n    value: function insertText(index, string) {\n      var text = this.text;\n      var next = text.slice(0, index) + string + text.slice(index);\n      var node = this.set('text', next);\n      return node;\n    }\n    /**\n     * Remove a `mark`.\n     *\n     * @param {Mark} mark\n     * @return {Text}\n     */\n\n  }, {\n    key: 'removeMark',\n    value: function removeMark(mark) {\n      mark = Mark.create(mark);\n      var marks = this.marks;\n      var next = marks.remove(mark);\n      var node = this.set('marks', next);\n      return node;\n    }\n    /**\n     * Remove text from the text node at `index` for `length`.\n     *\n     * @param {Number} index\n     * @param {Number} length\n     * @return {Text}\n     */\n\n  }, {\n    key: 'removeText',\n    value: function removeText(index, length) {\n      var text = this.text;\n      var next = text.slice(0, index) + text.slice(index + length);\n      var node = this.set('text', next);\n      return node;\n    }\n    /**\n     * Return a JSON representation of the text.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var object = {\n        object: this.object,\n        text: this.text,\n        marks: this.marks.toArray().map(function (m) {\n          return m.toJSON();\n        })\n      };\n\n      if (options.preserveKeys) {\n        object.key = this.key;\n      }\n\n      return object;\n    }\n    /**\n     * Set a `newProperties` on an existing `mark`.\n     *\n     * @param {Object} mark\n     * @param {Object} newProperties\n     * @return {Text}\n     */\n\n  }, {\n    key: 'setMark',\n    value: function setMark(properties, newProperties) {\n      var marks = this.marks;\n      var mark = Mark.create(properties);\n      var newMark = mark.merge(newProperties);\n      var next = marks.remove(mark).add(newMark);\n      var node = this.set('marks', next);\n      return node;\n    }\n    /**\n     * Split the node into two at `index`.\n     *\n     * @param {Number} index\n     * @returns {Array<Text>}\n     */\n\n  }, {\n    key: 'splitText',\n    value: function splitText(index) {\n      var text = this.text;\n      var one = this.set('text', text.slice(0, index));\n      var two = this.set('text', text.slice(index)).regenerateKey();\n      return [one, two];\n    }\n    /**\n     * Merge the node with an `other` text node.\n     *\n     * @param {Text} other\n     * @returns {Text}\n     */\n\n  }, {\n    key: 'mergeText',\n    value: function mergeText(other) {\n      var next = this.text + other.text;\n      var node = this.set('text', next);\n      return node;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Text` with `attrs`.\n     *\n     * @param {Object|Array|List|String|Text} attrs\n     * @return {Text}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n      if (Text.isText(attrs)) {\n        return attrs;\n      }\n\n      if (typeof attrs === 'string') {\n        attrs = {\n          text: attrs\n        };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Text.fromJSON(attrs);\n      }\n\n      throw new Error('`Text.create` only accepts objects, arrays, strings or texts, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a list of `Texts` from `elements`.\n     *\n     * @param {Array<Text|Object>|List<Text|Object>} elements\n     * @return {List<Text>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (List.isList(elements) || Array.isArray(elements)) {\n        var list = new List(elements.map(Text.create));\n        return list;\n      }\n\n      throw new Error('`Text.createList` only accepts arrays or lists, but you passed it: ' + elements);\n    }\n    /**\n     * Create a `Text` from a JSON `object`.\n     *\n     * @param {Object|Text} object\n     * @return {Text}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      if (Text.isText(object)) {\n        return object;\n      }\n\n      invariant(object.leaves == null, 'As of slate@0.46, the `leaves` property of text nodes has been removed! Each individual leaf should be created as a text node instead.');\n      var _object$text = object.text,\n          text = _object$text === undefined ? '' : _object$text,\n          _object$marks = object.marks,\n          marks = _object$marks === undefined ? [] : _object$marks,\n          _object$key = object.key,\n          key = _object$key === undefined ? KeyUtils.create() : _object$key;\n      var node = new Text({\n        key: key,\n        text: text,\n        marks: Mark.createSet(marks)\n      });\n      return node;\n    }\n    /**\n     * Check if `any` is a list of texts.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isTextList',\n    value: function isTextList(any) {\n      return List.isList(any) && any.every(function (item) {\n        return Text.isText(item);\n      });\n    }\n  }]);\n  return Text;\n}(Record(DEFAULTS$8));\n/**\n * A pseudo-model that is used for its static methods only.\n *\n * @type {Node}\n */\n\n\nvar Node = function () {\n  function Node() {\n    classCallCheck(this, Node);\n  }\n\n  createClass(Node, null, [{\n    key: 'create',\n\n    /**\n     * Create a new `Node` with `attrs`.\n     *\n     * @param {Object|Node} attrs\n     * @return {Node}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Node.isNode(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        var object = attrs.object;\n\n        if (!object && attrs.kind) {\n          warning(false, 'As of slate@0.32.0, the `kind` property of Slate objects has been renamed to `object`.');\n          object = attrs.kind;\n        }\n\n        switch (object) {\n          case 'block':\n            return Block.create(attrs);\n\n          case 'document':\n            return Document.create(attrs);\n\n          case 'inline':\n            return Inline.create(attrs);\n\n          case 'text':\n            return Text.create(attrs);\n\n          default:\n            {\n              throw new Error('`Node.create` requires a `object` string.');\n            }\n        }\n      }\n\n      throw new Error('`Node.create` only accepts objects or nodes but you passed it: ' + attrs);\n    }\n    /**\n     * Create a list of `Nodes` from an array.\n     *\n     * @param {Array<Object|Node>} elements\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (List.isList(elements) || Array.isArray(elements)) {\n        var array = [];\n        elements.forEach(function (el) {\n          if (el && el.object === 'text' && el.leaves && Array.isArray(el.leaves)) {\n            warning(false, 'As of slate@0.46, the `leaves` property of Text nodes has been removed. Instead, each text node contains a string of text and a unique set of marks and leaves are unnecessary.');\n            var texts = Text.createList(el.leaves).toArray();\n            array = array.concat(texts);\n            return;\n          }\n\n          var node = Node.create(el);\n          array.push(node);\n        });\n        var list = List(array);\n        return list;\n      }\n\n      throw new Error('`Node.createList` only accepts lists or arrays, but you passed it: ' + elements);\n    }\n    /**\n     * Create a dictionary of settable node properties from `attrs`.\n     *\n     * @param {Object|String|Node} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Block.isBlock(attrs) || Inline.isInline(attrs)) {\n        return {\n          data: attrs.data,\n          type: attrs.type\n        };\n      }\n\n      if (typeof attrs === 'string') {\n        return {\n          type: attrs\n        };\n      }\n\n      if (isPlainObject(attrs)) {\n        var props = {};\n        if ('type' in attrs) props.type = attrs.type;\n        if ('data' in attrs) props.data = Data.create(attrs.data);\n        return props;\n      }\n\n      throw new Error('`Node.createProperties` only accepts objects, strings, blocks or inlines, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a `Node` from a JSON `value`.\n     *\n     * @param {Object} value\n     * @return {Node}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(value) {\n      var object = value.object;\n\n      if (!object && value.kind) {\n        warning(false, 'As of slate@0.32.0, the `kind` property of Slate objects has been renamed to `object`.');\n        object = value.kind;\n      }\n\n      switch (object) {\n        case 'block':\n          return Block.fromJSON(value);\n\n        case 'document':\n          return Document.fromJSON(value);\n\n        case 'inline':\n          return Inline.fromJSON(value);\n\n        case 'text':\n          return Text.fromJSON(value);\n\n        default:\n          {\n            throw new Error('`Node.fromJSON` requires an `object` of either \\'block\\', \\'document\\', \\'inline\\' or \\'text\\', but you passed: ' + value);\n          }\n      }\n    }\n    /**\n     * Check if `any` is a `Node`.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isNode',\n    value: function isNode(any) {\n      return Block.isBlock(any) || Document.isDocument(any) || Inline.isInline(any) || Text.isText(any);\n    }\n    /**\n     * Check if `any` is a list of nodes.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isNodeList',\n    value: function isNodeList(any) {\n      return List.isList(any) && any.every(function (item) {\n        return Node.isNode(item);\n      });\n    }\n  }]);\n  return Node;\n}();\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\n\nvar DEFAULTS$9 = {\n  data: undefined,\n  key: undefined,\n  nodes: undefined,\n  type: undefined\n  /**\n   * Block.\n   *\n   * @type {Block}\n   */\n\n};\n\nvar Block = function (_Record) {\n  inherits(Block, _Record);\n\n  function Block() {\n    classCallCheck(this, Block);\n    return possibleConstructorReturn(this, (Block.__proto__ || Object.getPrototypeOf(Block)).apply(this, arguments));\n  }\n\n  createClass(Block, [{\n    key: 'toJSON',\n\n    /**\n     * Return a JSON representation of the block.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var object = {\n        object: this.object,\n        type: this.type,\n        data: this.data.toJSON(),\n        nodes: this.nodes.toArray().map(function (n) {\n          return n.toJSON(options);\n        })\n      };\n\n      if (options.preserveKeys) {\n        object.key = this.key;\n      }\n\n      return object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Block` from `attrs`.\n     *\n     * @param {Object|String|Block} attrs\n     * @return {Block}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Block.isBlock(attrs)) {\n        return attrs;\n      }\n\n      if (typeof attrs === 'string') {\n        attrs = {\n          type: attrs\n        };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Block.fromJSON(attrs);\n      }\n\n      throw new Error('`Block.create` only accepts objects, strings or blocks, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a list of `Blocks` from `attrs`.\n     *\n     * @param {Array<Block|Object>|List<Block|Object>} attrs\n     * @return {List<Block>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (List.isList(attrs) || Array.isArray(attrs)) {\n        var list = new List(attrs.map(Block.create));\n        return list;\n      }\n\n      throw new Error('`Block.createList` only accepts arrays or lists, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a `Block` from a JSON `object`.\n     *\n     * @param {Object|Block} object\n     * @return {Block}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      if (Block.isBlock(object)) {\n        return object;\n      }\n\n      var _object$data = object.data,\n          data = _object$data === undefined ? {} : _object$data,\n          _object$key = object.key,\n          key = _object$key === undefined ? KeyUtils.create() : _object$key,\n          _object$nodes = object.nodes,\n          nodes = _object$nodes === undefined ? [] : _object$nodes,\n          type = object.type;\n\n      if (typeof type !== 'string') {\n        throw new Error('`Block.fromJSON` requires a `type` string.');\n      }\n\n      var block = new Block({\n        key: key,\n        type: type,\n        data: Map(data),\n        nodes: Node.createList(nodes)\n      });\n      return block;\n    }\n    /**\n     * Check if `any` is a block list.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isBlockList',\n    value: function isBlockList(any) {\n      return List.isList(any) && any.every(function (item) {\n        return Block.isBlock(item);\n      });\n    }\n  }]);\n  return Block;\n}(Record(DEFAULTS$9));\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\n\nvar DEFAULTS$10 = {\n  annotations: undefined,\n  data: undefined,\n  document: undefined,\n  selection: undefined\n  /**\n   * Value.\n   *\n   * @type {Value}\n   */\n\n};\n\nvar Value = function (_Record) {\n  inherits(Value, _Record);\n\n  function Value() {\n    classCallCheck(this, Value);\n    return possibleConstructorReturn(this, (Value.__proto__ || Object.getPrototypeOf(Value)).apply(this, arguments));\n  }\n\n  createClass(Value, [{\n    key: 'addAnnotation',\n\n    /**\n     * Add an `annotation` to the value.\n     *\n     * @param {Annotation} annotation\n     * @param {Mark} mark\n     * @return {Value}\n     */\n    value: function addAnnotation(annotation) {\n      annotation = Annotation.create(annotation);\n      var value = this;\n      var _value = value,\n          annotations = _value.annotations,\n          document = _value.document;\n      var _annotation = annotation,\n          key = _annotation.key;\n      annotation = annotation.updatePoints(function (point) {\n        return point.normalize(document);\n      });\n      annotations = annotations.set(key, annotation);\n      value = value.set('annotations', annotations);\n      return value;\n    }\n    /**\n     * Add `mark` to text at `path`.\n     *\n     * @param {List|String} path\n     * @param {Mark} mark\n     * @return {Value}\n     */\n\n  }, {\n    key: 'addMark',\n    value: function addMark(path, mark) {\n      mark = Mark.create(mark);\n      var value = this;\n      var _value2 = value,\n          document = _value2.document;\n      document = document.addMark(path, mark);\n      value = value.set('document', document);\n      return value;\n    }\n    /**\n     * Insert a `node`.\n     *\n     * @param {List|String} path\n     * @param {Node} node\n     * @return {Value}\n     */\n\n  }, {\n    key: 'insertNode',\n    value: function insertNode(path, node) {\n      var value = this;\n      var _value3 = value,\n          document = _value3.document;\n      document = document.insertNode(path, node);\n      value = value.set('document', document);\n      value = value.mapRanges(function (range) {\n        return range.updatePoints(function (point) {\n          return point.setPath(null);\n        });\n      });\n      return value;\n    }\n    /**\n     * Insert `text` at `offset` in node by `path`.\n     *\n     * @param {List|String} path\n     * @param {Number} offset\n     * @param {String} text\n     * @return {Value}\n     */\n\n  }, {\n    key: 'insertText',\n    value: function insertText(path, offset, text) {\n      var value = this;\n      var _value4 = value,\n          document = _value4.document;\n      var node = document.assertNode(path);\n      document = document.insertText(path, offset, text);\n      node = document.assertNode(path);\n      value = value.set('document', document);\n      value = value.mapPoints(function (point) {\n        if (point.key === node.key && point.offset >= offset) {\n          return point.setOffset(point.offset + text.length);\n        } else {\n          return point;\n        }\n      });\n      return value;\n    }\n    /**\n     * Merge a node backwards its previous sibling.\n     *\n     * @param {List|Key} path\n     * @return {Value}\n     */\n\n  }, {\n    key: 'mergeNode',\n    value: function mergeNode(path) {\n      var value = this;\n      var _value5 = value,\n          document = _value5.document;\n      var newDocument = document.mergeNode(path);\n      path = document.resolvePath(path);\n      var withPath = PathUtils.decrement(path);\n      var one = document.getNode(withPath);\n      var two = document.getNode(path);\n      value = value.set('document', newDocument);\n      value = value.mapRanges(function (range) {\n        if (two.object === 'text') {\n          var max = one.text.length;\n\n          if (range.anchor.key === two.key) {\n            range = range.moveAnchorTo(one.key, max + range.anchor.offset);\n          }\n\n          if (range.focus.key === two.key) {\n            range = range.moveFocusTo(one.key, max + range.focus.offset);\n          }\n        }\n\n        range = range.updatePoints(function (point) {\n          return point.setPath(null);\n        });\n        return range;\n      });\n      return value;\n    }\n    /**\n     * Move a node by `path` to `newPath`.\n     *\n     * A `newIndex` can be provided when move nodes by `key`, to account for not\n     * being able to have a key for a location in the tree that doesn't exist yet.\n     *\n     * @param {List|Key} path\n     * @param {List|Key} newPath\n     * @param {Number} newIndex\n     * @return {Value}\n     */\n\n  }, {\n    key: 'moveNode',\n    value: function moveNode(path, newPath) {\n      var newIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var value = this;\n      var _value6 = value,\n          document = _value6.document;\n\n      if (PathUtils.isEqual(path, newPath)) {\n        return value;\n      }\n\n      document = document.moveNode(path, newPath, newIndex);\n      value = value.set('document', document);\n      value = value.mapPoints(function (point) {\n        return point.setPath(null);\n      });\n      return value;\n    }\n    /**\n     * Remove an `annotation` from the value.\n     *\n     * @param {Annotation} annotation\n     * @param {Mark} mark\n     * @return {Value}\n     */\n\n  }, {\n    key: 'removeAnnotation',\n    value: function removeAnnotation(annotation) {\n      annotation = Annotation.create(annotation);\n      var value = this;\n      var _value7 = value,\n          annotations = _value7.annotations;\n      var _annotation2 = annotation,\n          key = _annotation2.key;\n      annotations = annotations.delete(key);\n      value = value.set('annotations', annotations);\n      return value;\n    }\n    /**\n     * Remove `mark` at `path`.\n     *\n     * @param {List|String} path\n     * @param {Mark} mark\n     * @return {Value}\n     */\n\n  }, {\n    key: 'removeMark',\n    value: function removeMark(path, mark) {\n      mark = Mark.create(mark);\n      var value = this;\n      var _value8 = value,\n          document = _value8.document;\n      document = document.removeMark(path, mark);\n      value = value.set('document', document);\n      return value;\n    }\n    /**\n     * Remove a node by `path`.\n     *\n     * @param {List|String} path\n     * @return {Value}\n     */\n\n  }, {\n    key: 'removeNode',\n    value: function removeNode(path) {\n      var value = this;\n      var _value9 = value,\n          document = _value9.document;\n      var node = document.assertNode(path);\n      var first = node.object === 'text' ? node : node.getFirstText() || node;\n      var last = node.object === 'text' ? node : node.getLastText() || node;\n      var prev = document.getPreviousText(first.key);\n      var next = document.getNextText(last.key);\n      document = document.removeNode(path);\n      value = value.set('document', document);\n      value = value.mapRanges(function (range) {\n        var _range = range,\n            anchor = _range.anchor,\n            focus = _range.focus;\n\n        if (node.hasNode(anchor.key)) {\n          range = prev ? range.moveAnchorTo(prev.key, prev.text.length) : next ? range.moveAnchorTo(next.key, 0) : range.unset();\n        }\n\n        if (node.hasNode(focus.key)) {\n          range = prev ? range.moveFocusTo(prev.key, prev.text.length) : next ? range.moveFocusTo(next.key, 0) : range.unset();\n        }\n\n        range = range.updatePoints(function (point) {\n          return point.setPath(null);\n        });\n        return range;\n      });\n      return value;\n    }\n    /**\n     * Remove `text` at `offset` in node by `path`.\n     *\n     * @param {List|Key} path\n     * @param {Number} offset\n     * @param {String} text\n     * @return {Value}\n     */\n\n  }, {\n    key: 'removeText',\n    value: function removeText(path, offset, text) {\n      var value = this;\n      var _value10 = value,\n          document = _value10.document;\n      var node = document.assertNode(path);\n      document = document.removeText(path, offset, text);\n      value = value.set('document', document);\n      var length = text.length;\n      var start = offset;\n      var end = offset + length;\n      value = value.mapPoints(function (point) {\n        if (point.key !== node.key) {\n          return point;\n        }\n\n        if (point.offset >= end) {\n          return point.setOffset(point.offset - length);\n        }\n\n        if (point.offset > start) {\n          return point.setOffset(start);\n        }\n\n        return point;\n      });\n      return value;\n    }\n    /**\n     * Add an `annotation` to the value.\n     *\n     * @param {Annotation} annotation\n     * @param {Mark} mark\n     * @return {Value}\n     */\n\n  }, {\n    key: 'setAnnotation',\n    value: function setAnnotation(properties, newProperties) {\n      newProperties = Annotation.createProperties(newProperties);\n      var annotation = Annotation.create(properties);\n      var next = annotation.merge(newProperties);\n      var value = this;\n      var _value11 = value,\n          annotations = _value11.annotations;\n      var key = annotation.key;\n      annotations = annotations.set(key, next);\n      value = value.set('annotations', annotations);\n      return value;\n    }\n    /**\n     * Set `properties` on a node.\n     *\n     * @param {List|String} path\n     * @param {Object} properties\n     * @return {Value}\n     */\n\n  }, {\n    key: 'setNode',\n    value: function setNode(path, properties) {\n      var value = this;\n      var _value12 = value,\n          document = _value12.document;\n      document = document.setNode(path, properties);\n      value = value.set('document', document);\n      return value;\n    }\n    /**\n     * Set `properties` on `mark` on text at `offset` and `length` in node.\n     *\n     * @param {List|String} path\n     * @param {Mark} mark\n     * @param {Object} properties\n     * @return {Value}\n     */\n\n  }, {\n    key: 'setMark',\n    value: function setMark(path, mark, properties) {\n      var value = this;\n      var _value13 = value,\n          document = _value13.document;\n      document = document.setMark(path, mark, properties);\n      value = value.set('document', document);\n      return value;\n    }\n    /**\n     * Set `properties` on the value.\n     *\n     * @param {Object} properties\n     * @return {Value}\n     */\n\n  }, {\n    key: 'setProperties',\n    value: function setProperties(properties) {\n      var value = this;\n      var _value14 = value,\n          document = _value14.document;\n      var data = properties.data,\n          annotations = properties.annotations;\n      var props = {};\n\n      if (data) {\n        props.data = data;\n      }\n\n      if (annotations) {\n        props.annotations = annotations.map(function (a) {\n          return a.isSet ? a : document.resolveAnnotation(a);\n        });\n      }\n\n      value = value.merge(props);\n      return value;\n    }\n    /**\n     * Set `properties` on the selection.\n     *\n     * @param {Value} value\n     * @param {Operation} operation\n     * @return {Value}\n     */\n\n  }, {\n    key: 'setSelection',\n    value: function setSelection(properties) {\n      var value = this;\n      var _value15 = value,\n          document = _value15.document,\n          selection = _value15.selection;\n      var next = selection.setProperties(properties);\n      selection = document.resolveSelection(next);\n      value = value.set('selection', selection);\n      return value;\n    }\n    /**\n     * Split a node by `path` at `position` with optional `properties` to apply\n     * to the newly split node.\n     *\n     * @param {List|String} path\n     * @param {Number} position\n     * @param {Object} properties\n     * @return {Value}\n     */\n\n  }, {\n    key: 'splitNode',\n    value: function splitNode(path, position, properties) {\n      var value = this;\n      var _value16 = value,\n          document = _value16.document;\n      var newDocument = document.splitNode(path, position, properties);\n      var node = document.assertNode(path);\n      value = value.set('document', newDocument);\n      value = value.mapRanges(function (range) {\n        var next = newDocument.getNextText(node.key);\n        var _range2 = range,\n            anchor = _range2.anchor,\n            focus = _range2.focus; // If the anchor was after the split, move it to the next node.\n\n        if (node.key === anchor.key && position <= anchor.offset) {\n          range = range.moveAnchorTo(next.key, anchor.offset - position);\n        } // If the focus was after the split, move it to the next node.\n\n\n        if (node.key === focus.key && position <= focus.offset) {\n          range = range.moveFocusTo(next.key, focus.offset - position);\n        }\n\n        range = range.updatePoints(function (point) {\n          return point.setPath(null);\n        });\n        return range;\n      });\n      return value;\n    }\n    /**\n     * Map all range objects to apply adjustments with an `iterator`.\n     *\n     * @param {Function} iterator\n     * @return {Value}\n     */\n\n  }, {\n    key: 'mapRanges',\n    value: function mapRanges(iterator) {\n      var value = this;\n      var _value17 = value,\n          document = _value17.document,\n          selection = _value17.selection,\n          annotations = _value17.annotations;\n      var sel = selection.isSet ? iterator(selection) : selection;\n      if (!sel) sel = selection.unset();\n      if (sel !== selection) sel = document.createSelection(sel);\n      value = value.set('selection', sel);\n      var anns = annotations.map(function (annotation) {\n        var n = annotation.isSet ? iterator(annotation) : annotation;\n        if (n && n !== annotation) n = document.createAnnotation(n);\n        return n;\n      });\n      anns = anns.filter(function (annotation) {\n        return !!annotation;\n      });\n      value = value.set('annotations', anns);\n      return value;\n    }\n  }, {\n    key: 'mapPoints',\n    value: function mapPoints(iterator) {\n      return this.mapRanges(function (range) {\n        return range.updatePoints(iterator);\n      });\n    }\n    /**\n     * Return a JSON representation of the value.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var object = {\n        object: this.object,\n        document: this.document.toJSON(options)\n      };\n\n      if (options.preserveData) {\n        object.data = this.data.toJSON(options);\n      }\n\n      if (options.preserveAnnotations) {\n        object.annotations = this.annotations.map(function (a) {\n          return a.toJSON(options);\n        }).toObject();\n      }\n\n      if (options.preserveSelection) {\n        object.selection = this.selection.toJSON(options);\n      }\n\n      return object;\n    }\n    /**\n     * Deprecated.\n     */\n\n  }, {\n    key: 'change',\n    value: function change() {\n      invariant(false, 'As of Slate 0.42.0, value object are no longer schema-aware, and the `value.change()` method is no longer available. Use the `editor.change()` method on the new `Editor` controller instead.');\n    }\n  }, {\n    key: 'startBlock',\n\n    /**\n     * Get the current start text node's closest block parent.\n     *\n     * @return {Block}\n     */\n    get: function get$$1() {\n      return this.selection.start.key && this.document.getClosestBlock(this.selection.start.key);\n    }\n    /**\n     * Get the current end text node's closest block parent.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'endBlock',\n    get: function get$$1() {\n      return this.selection.end.key && this.document.getClosestBlock(this.selection.end.key);\n    }\n    /**\n     * Get the current anchor text node's closest block parent.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'anchorBlock',\n    get: function get$$1() {\n      return this.selection.anchor.key && this.document.getClosestBlock(this.selection.anchor.key);\n    }\n    /**\n     * Get the current focus text node's closest block parent.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'focusBlock',\n    get: function get$$1() {\n      return this.selection.focus.key && this.document.getClosestBlock(this.selection.focus.key);\n    }\n    /**\n     * Get the current start text node's closest inline parent.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'startInline',\n    get: function get$$1() {\n      return this.selection.start.key && this.document.getClosestInline(this.selection.start.key);\n    }\n    /**\n     * Get the current end text node's closest inline parent.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'endInline',\n    get: function get$$1() {\n      return this.selection.end.key && this.document.getClosestInline(this.selection.end.key);\n    }\n    /**\n     * Get the current anchor text node's closest inline parent.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'anchorInline',\n    get: function get$$1() {\n      return this.selection.anchor.key && this.document.getClosestInline(this.selection.anchor.key);\n    }\n    /**\n     * Get the current focus text node's closest inline parent.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'focusInline',\n    get: function get$$1() {\n      return this.selection.focus.key && this.document.getClosestInline(this.selection.focus.key);\n    }\n    /**\n     * Get the current start text node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'startText',\n    get: function get$$1() {\n      return this.selection.start.key && this.document.getDescendant(this.selection.start.key);\n    }\n    /**\n     * Get the current end node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'endText',\n    get: function get$$1() {\n      return this.selection.end.key && this.document.getDescendant(this.selection.end.key);\n    }\n    /**\n     * Get the current anchor node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'anchorText',\n    get: function get$$1() {\n      return this.selection.anchor.key && this.document.getDescendant(this.selection.anchor.key);\n    }\n    /**\n     * Get the current focus node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'focusText',\n    get: function get$$1() {\n      return this.selection.focus.key && this.document.getDescendant(this.selection.focus.key);\n    }\n    /**\n     * Get the next block node.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'nextBlock',\n    get: function get$$1() {\n      return this.selection.end.key && this.document.getNextBlock(this.selection.end.key);\n    }\n    /**\n     * Get the previous block node.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'previousBlock',\n    get: function get$$1() {\n      return this.selection.start.key && this.document.getPreviousBlock(this.selection.start.key);\n    }\n    /**\n     * Get the next inline node.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'nextInline',\n    get: function get$$1() {\n      return this.selection.end.key && this.document.getNextInline(this.selection.end.key);\n    }\n    /**\n     * Get the previous inline node.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'previousInline',\n    get: function get$$1() {\n      return this.selection.start.key && this.document.getPreviousInline(this.selection.start.key);\n    }\n    /**\n     * Get the next text node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'nextText',\n    get: function get$$1() {\n      return this.selection.end.key && this.document.getNextText(this.selection.end.key);\n    }\n    /**\n     * Get the previous text node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'previousText',\n    get: function get$$1() {\n      return this.selection.start.key && this.document.getPreviousText(this.selection.start.key);\n    }\n    /**\n     * Get the marks of the current selection.\n     *\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'marks',\n    get: function get$$1() {\n      return this.selection.isUnset ? new Set() : this.selection.marks || this.document.getMarksAtRange(this.selection);\n    }\n    /**\n     * Get the active marks of the current selection.\n     *\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'activeMarks',\n    get: function get$$1() {\n      return this.selection.isUnset ? new Set() : this.selection.marks || this.document.getActiveMarksAtRange(this.selection);\n    }\n    /**\n     * Get the block nodes in the current selection.\n     *\n     * @return {List<Block>}\n     */\n\n  }, {\n    key: 'blocks',\n    get: function get$$1() {\n      return this.selection.isUnset ? new List() : this.document.getLeafBlocksAtRange(this.selection);\n    }\n    /**\n     * Get the fragment of the current selection.\n     *\n     * @return {Document}\n     */\n\n  }, {\n    key: 'fragment',\n    get: function get$$1() {\n      return this.selection.isUnset ? Document.create() : this.document.getFragmentAtRange(this.selection);\n    }\n    /**\n     * Get the bottom-most inline nodes in the current selection.\n     *\n     * @return {List<Inline>}\n     */\n\n  }, {\n    key: 'inlines',\n    get: function get$$1() {\n      return this.selection.isUnset ? new List() : this.document.getLeafInlinesAtRange(this.selection);\n    }\n    /**\n     * Get the text nodes in the current selection.\n     *\n     * @return {List<Text>}\n     */\n\n  }, {\n    key: 'texts',\n    get: function get$$1() {\n      return this.selection.isUnset ? new List() : this.document.getTextsAtRange(this.selection);\n    }\n  }, {\n    key: 'history',\n    get: function get$$1() {\n      invariant(false, 'As of Slate 0.42.0, the `value.history` model no longer exists, and the history is stored in `value.data` instead using plugins.');\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Value` with `attrs`.\n     *\n     * @param {Object|Value} attrs\n     * @param {Object} options\n     * @return {Value}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (Value.isValue(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        return Value.fromJSON(attrs, options);\n      }\n\n      throw new Error('`Value.create` only accepts objects or values, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a dictionary of settable value properties from `attrs`.\n     *\n     * @param {Object|Value} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Value.isValue(a)) {\n        return {\n          annotations: a.annotations,\n          data: a.data\n        };\n      }\n\n      if (isPlainObject(a)) {\n        var p = {};\n        if ('annotations' in a) p.annotations = Annotation.createMap(a.annotations);\n        if ('data' in a) p.data = Data.create(a.data);\n        return p;\n      }\n\n      throw new Error('`Value.createProperties` only accepts objects or values, but you passed it: ' + a);\n    }\n    /**\n     * Create a `Value` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @param {Object} options\n     *   @property {Boolean} normalize\n     *   @property {Array} plugins\n     * @return {Value}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var _object$data = object.data,\n          data = _object$data === undefined ? {} : _object$data,\n          _object$annotations = object.annotations,\n          annotations = _object$annotations === undefined ? {} : _object$annotations,\n          _object$document = object.document,\n          document = _object$document === undefined ? {} : _object$document,\n          _object$selection = object.selection,\n          selection = _object$selection === undefined ? {} : _object$selection;\n      data = Data.fromJSON(data);\n      document = Document.fromJSON(document);\n      selection = document.createSelection(selection);\n      annotations = Annotation.createMap(annotations);\n\n      if (selection.isUnset) {\n        var text = document.getFirstText();\n        if (text) selection = selection.moveToStartOfNode(text);\n        selection = document.createSelection(selection);\n      }\n\n      var value = new Value({\n        annotations: annotations,\n        data: data,\n        document: document,\n        selection: selection\n      });\n      return value;\n    }\n  }]);\n  return Value;\n}(Record(DEFAULTS$10));\n/**\n * Debug.\n *\n * @type {Function}\n */\n\n\nvar debug = Debug('slate:operation:apply');\n/**\n * Apply an `op` to a `value`.\n *\n * @param {Value} value\n * @param {Object|Operation} op\n * @return {Value} value\n */\n\nfunction applyOperation(value, op) {\n  op = Operation.create(op);\n  var _op = op,\n      type = _op.type;\n  debug(type, op);\n\n  switch (type) {\n    case 'add_annotation':\n      {\n        var _op2 = op,\n            annotation = _op2.annotation;\n        var next = value.addAnnotation(annotation);\n        return next;\n      }\n\n    case 'add_mark':\n      {\n        var _op3 = op,\n            path = _op3.path,\n            mark = _op3.mark;\n\n        var _next = value.addMark(path, mark);\n\n        return _next;\n      }\n\n    case 'insert_node':\n      {\n        var _op4 = op,\n            _path = _op4.path,\n            node = _op4.node;\n\n        var _next2 = value.insertNode(_path, node);\n\n        return _next2;\n      }\n\n    case 'insert_text':\n      {\n        var _op5 = op,\n            _path2 = _op5.path,\n            offset = _op5.offset,\n            text = _op5.text,\n            marks = _op5.marks;\n\n        var _next3 = value.insertText(_path2, offset, text, marks);\n\n        return _next3;\n      }\n\n    case 'merge_node':\n      {\n        var _op6 = op,\n            _path3 = _op6.path;\n\n        var _next4 = value.mergeNode(_path3);\n\n        return _next4;\n      }\n\n    case 'move_node':\n      {\n        var _op7 = op,\n            _path4 = _op7.path,\n            newPath = _op7.newPath;\n\n        var _next5 = value.moveNode(_path4, newPath);\n\n        return _next5;\n      }\n\n    case 'remove_annotation':\n      {\n        var _op8 = op,\n            _annotation = _op8.annotation;\n\n        var _next6 = value.removeAnnotation(_annotation);\n\n        return _next6;\n      }\n\n    case 'remove_mark':\n      {\n        var _op9 = op,\n            _path5 = _op9.path,\n            _mark = _op9.mark;\n\n        var _next7 = value.removeMark(_path5, _mark);\n\n        return _next7;\n      }\n\n    case 'remove_node':\n      {\n        var _op10 = op,\n            _path6 = _op10.path;\n\n        var _next8 = value.removeNode(_path6);\n\n        return _next8;\n      }\n\n    case 'remove_text':\n      {\n        var _op11 = op,\n            _path7 = _op11.path,\n            _offset = _op11.offset,\n            _text = _op11.text;\n\n        var _next9 = value.removeText(_path7, _offset, _text);\n\n        return _next9;\n      }\n\n    case 'set_annotation':\n      {\n        var _op12 = op,\n            properties = _op12.properties,\n            newProperties = _op12.newProperties;\n\n        var _next10 = value.setAnnotation(properties, newProperties);\n\n        return _next10;\n      }\n\n    case 'set_mark':\n      {\n        var _op13 = op,\n            _path8 = _op13.path,\n            _properties = _op13.properties,\n            _newProperties = _op13.newProperties;\n\n        var _next11 = value.setMark(_path8, _properties, _newProperties);\n\n        return _next11;\n      }\n\n    case 'set_node':\n      {\n        var _op14 = op,\n            _path9 = _op14.path,\n            _newProperties2 = _op14.newProperties;\n\n        var _next12 = value.setNode(_path9, _newProperties2);\n\n        return _next12;\n      }\n\n    case 'set_selection':\n      {\n        var _op15 = op,\n            _newProperties3 = _op15.newProperties;\n\n        var _next13 = value.setSelection(_newProperties3);\n\n        return _next13;\n      }\n\n    case 'set_value':\n      {\n        var _op16 = op,\n            _newProperties4 = _op16.newProperties;\n\n        var _next14 = value.setProperties(_newProperties4);\n\n        return _next14;\n      }\n\n    case 'split_node':\n      {\n        var _op17 = op,\n            _path10 = _op17.path,\n            position = _op17.position,\n            _properties2 = _op17.properties;\n\n        var _next15 = value.splitNode(_path10, position, _properties2);\n\n        return _next15;\n      }\n\n    default:\n      {\n        throw new Error('Unknown operation type: \"' + type + '\".');\n      }\n  }\n}\n/**\n * Debug.\n *\n * @type {Function}\n */\n\n\nvar debug$1 = Debug('slate:operation:invert');\n/**\n * Invert an `op`.\n *\n * @param {Object} op\n * @return {Object}\n */\n\nfunction invertOperation(op) {\n  op = Operation.create(op);\n  var _op = op,\n      type = _op.type;\n  debug$1(type, op);\n\n  switch (type) {\n    case 'move_node':\n      {\n        var _op2 = op,\n            newPath = _op2.newPath,\n            path = _op2.path; // PERF: this case can exit early.\n\n        if (PathUtils.isEqual(newPath, path)) {\n          return op;\n        }\n\n        var inversePath = PathUtils.transform(path, op).first(); // Get the true path we are trying to move back to\n        // We transform the right-sibling of the path\n        // This will end up at the operation.path most of the time\n        // But if the newPath is a left-sibling or left-ancestor-sibling, this will account for it\n\n        var inverseNewPath = PathUtils.transform(PathUtils.increment(path), op).first();\n        var inverse = op.set('path', inversePath).set('newPath', inverseNewPath);\n        return inverse;\n      }\n\n    case 'merge_node':\n      {\n        var _op3 = op,\n            _path = _op3.path;\n\n        var _inversePath = PathUtils.decrement(_path);\n\n        var _inverse = op.set('type', 'split_node').set('path', _inversePath);\n\n        return _inverse;\n      }\n\n    case 'split_node':\n      {\n        var _op4 = op,\n            _path2 = _op4.path;\n\n        var _inversePath2 = PathUtils.increment(_path2);\n\n        var _inverse2 = op.set('type', 'merge_node').set('path', _inversePath2);\n\n        return _inverse2;\n      }\n\n    case 'set_annotation':\n    case 'set_node':\n    case 'set_value':\n    case 'set_selection':\n    case 'set_mark':\n      {\n        var _op5 = op,\n            properties = _op5.properties,\n            newProperties = _op5.newProperties;\n\n        var _inverse3 = op.set('properties', newProperties).set('newProperties', properties);\n\n        return _inverse3;\n      }\n\n    case 'insert_node':\n    case 'insert_text':\n      {\n        var _inverse4 = op.set('type', type.replace('insert_', 'remove_'));\n\n        return _inverse4;\n      }\n\n    case 'remove_node':\n    case 'remove_text':\n      {\n        var _inverse5 = op.set('type', type.replace('remove_', 'insert_'));\n\n        return _inverse5;\n      }\n\n    case 'add_annotation':\n    case 'add_mark':\n      {\n        var _inverse6 = op.set('type', type.replace('add_', 'remove_'));\n\n        return _inverse6;\n      }\n\n    case 'remove_annotation':\n    case 'remove_mark':\n      {\n        var _inverse7 = op.set('type', type.replace('remove_', 'add_'));\n\n        return _inverse7;\n      }\n\n    default:\n      {\n        throw new Error('Unknown operation type: \"' + type + '\".');\n      }\n  }\n}\n/**\n * Operation attributes.\n *\n * @type {Array}\n */\n\n\nvar OPERATION_ATTRIBUTES = {\n  add_mark: ['path', 'mark', 'data'],\n  add_annotation: ['annotation', 'data'],\n  insert_node: ['path', 'node', 'data'],\n  insert_text: ['path', 'offset', 'text', 'data'],\n  merge_node: ['path', 'position', 'properties', 'target', 'data'],\n  move_node: ['path', 'newPath', 'data'],\n  remove_annotation: ['annotation', 'data'],\n  remove_mark: ['path', 'mark', 'data'],\n  remove_node: ['path', 'node', 'data'],\n  remove_text: ['path', 'offset', 'text', 'data'],\n  set_annotation: ['properties', 'newProperties', 'data'],\n  set_mark: ['path', 'properties', 'newProperties', 'data'],\n  set_node: ['path', 'properties', 'newProperties', 'data'],\n  set_selection: ['properties', 'newProperties', 'data'],\n  set_value: ['properties', 'newProperties', 'data'],\n  split_node: ['path', 'position', 'properties', 'target', 'data']\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n};\nvar DEFAULTS$11 = {\n  annotation: undefined,\n  data: undefined,\n  length: undefined,\n  mark: undefined,\n  marks: undefined,\n  newPath: undefined,\n  newProperties: undefined,\n  node: undefined,\n  offset: undefined,\n  path: undefined,\n  position: undefined,\n  properties: undefined,\n  target: undefined,\n  text: undefined,\n  type: undefined\n  /**\n   * Operation.\n   *\n   * @type {Operation}\n   */\n\n};\n\nvar Operation = function (_Record) {\n  inherits(Operation, _Record);\n\n  function Operation() {\n    classCallCheck(this, Operation);\n    return possibleConstructorReturn(this, (Operation.__proto__ || Object.getPrototypeOf(Operation)).apply(this, arguments));\n  }\n\n  createClass(Operation, [{\n    key: 'apply',\n\n    /**\n     * Apply the operation to a `value`.\n     *\n     * @param {Value} value\n     * @return {Value}\n     */\n    value: function apply(value) {\n      var next = applyOperation(value, this);\n      return next;\n    }\n    /**\n     * Invert the operation.\n     *\n     * @return {Operation}\n     */\n\n  }, {\n    key: 'invert',\n    value: function invert() {\n      var inverted = invertOperation(this);\n      return inverted;\n    }\n    /**\n     * Return a JSON representation of the operation.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var object = this.object,\n          type = this.type;\n      var json = {\n        object: object,\n        type: type\n      };\n      var ATTRIBUTES = OPERATION_ATTRIBUTES[type];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = ATTRIBUTES[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var key = _step.value;\n          var value = this[key];\n\n          if (key === 'annotation' || key === 'mark' || key === 'marks' || key === 'node' || key === 'path' || key === 'newPath') {\n            value = value.toJSON();\n          }\n\n          if (key === 'properties' && type === 'merge_node') {\n            var v = {};\n            if ('data' in value) v.data = value.data.toJS();\n            if ('type' in value) v.type = value.type;\n            value = v;\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_annotation') {\n            var _v = {};\n            if ('anchor' in value) _v.anchor = value.anchor.toJS();\n            if ('focus' in value) _v.focus = value.focus.toJS();\n            if ('key' in value) _v.key = value.key;\n            if ('data' in value) _v.data = value.data.toJS();\n            if ('type' in value) _v.type = value.type;\n            value = _v;\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_mark') {\n            var _v2 = {};\n            if ('data' in value) _v2.data = value.data.toJS();\n            if ('type' in value) _v2.type = value.type;\n            value = _v2;\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_node') {\n            var _v3 = {};\n            if ('data' in value) _v3.data = value.data.toJS();\n            if ('type' in value) _v3.type = value.type;\n            value = _v3;\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_selection') {\n            var _v4 = {};\n            if ('anchor' in value) _v4.anchor = value.anchor.toJSON();\n            if ('focus' in value) _v4.focus = value.focus.toJSON();\n            if ('isFocused' in value) _v4.isFocused = value.isFocused;\n            if ('marks' in value) _v4.marks = value.marks && value.marks.toJSON();\n            value = _v4;\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_value') {\n            var _v5 = {};\n            if ('data' in value) _v5.data = value.data.toJS();\n            value = _v5;\n          }\n\n          if (key === 'properties' && type === 'split_node') {\n            var _v6 = {};\n            if ('data' in value) _v6.data = value.data.toJS();\n            if ('type' in value) _v6.type = value.type;\n            value = _v6;\n          }\n\n          if (key === 'data') {\n            value = value.toJSON();\n          }\n\n          json[key] = value;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return json;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Operation` with `attrs`.\n     *\n     * @param {Object|Array|List|String|Operation} attrs\n     * @return {Operation}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Operation.isOperation(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        return Operation.fromJSON(attrs);\n      }\n\n      throw new Error('`Operation.create` only accepts objects or operations, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a list of `Operations` from `elements`.\n     *\n     * @param {Array<Operation|Object>|List<Operation|Object>} elements\n     * @return {List<Operation>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (List.isList(elements) || Array.isArray(elements)) {\n        var list = new List(elements.map(Operation.create));\n        return list;\n      }\n\n      throw new Error('`Operation.createList` only accepts arrays or lists, but you passed it: ' + elements);\n    }\n    /**\n     * Create a `Operation` from a JSON `object`.\n     *\n     * @param {Object|Operation} object\n     * @return {Operation}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      if (Operation.isOperation(object)) {\n        return object;\n      }\n\n      var type = object.type;\n      var ATTRIBUTES = OPERATION_ATTRIBUTES[type];\n      var attrs = {\n        type: type\n      };\n\n      if (!ATTRIBUTES) {\n        throw new Error('`Operation.fromJSON` was passed an unrecognized operation type: \"' + type + '\"');\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = ATTRIBUTES[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var key = _step2.value;\n          var v = object[key]; // Default `data` to an empty object.\n\n          if (key === 'data' && v === undefined) {\n            v = {};\n          }\n\n          if (v === undefined) {\n            throw new Error('`Operation.fromJSON` was passed a \"' + type + '\" operation without the required \"' + key + '\" attribute.');\n          }\n\n          if (key === 'annotation') {\n            v = Annotation.create(v);\n          }\n\n          if (key === 'path' || key === 'newPath') {\n            v = PathUtils.create(v);\n          }\n\n          if (key === 'mark') {\n            v = Mark.create(v);\n          }\n\n          if (key === 'node') {\n            v = Node.create(v);\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_annotation') {\n            v = Annotation.createProperties(v);\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_mark') {\n            v = Mark.createProperties(v);\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && (type === 'set_node' || type === 'merge_node' || type === 'split_node')) {\n            v = Node.createProperties(v);\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_selection') {\n            v = Selection.createProperties(v);\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_value') {\n            v = Value.createProperties(v);\n          }\n\n          if (key === 'data') {\n            v = Map(v);\n          }\n\n          attrs[key] = v;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      var op = new Operation(attrs);\n      return op;\n    }\n    /**\n     * Check if `any` is a list of operations.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isOperationList',\n    value: function isOperationList(any) {\n      return List.isList(any) && any.every(function (item) {\n        return Operation.isOperation(item);\n      });\n    }\n  }]);\n  return Operation;\n}(Record(DEFAULTS$11));\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\n\nvar DEFAULTS$12 = {\n  operations: undefined,\n  value: undefined\n  /**\n   * Change.\n   *\n   * @type {Change}\n   */\n\n};\n\nvar Change = function (_Record) {\n  inherits(Change, _Record);\n\n  function Change() {\n    classCallCheck(this, Change);\n    return possibleConstructorReturn(this, (Change.__proto__ || Object.getPrototypeOf(Change)).apply(this, arguments));\n  }\n\n  createClass(Change, [{\n    key: 'toJSON',\n\n    /**\n     * Return a JSON representation of the change.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var object = {\n        object: this.object,\n        value: this.value.toJSON(options),\n        operations: this.operations.toArray().map(function (o) {\n          return o.toJSON(options);\n        })\n      };\n      return object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Change` with `attrs`.\n     *\n     * @param {Object|Change} attrs\n     * @return {Change}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Change.isChange(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        return Change.fromJSON(attrs);\n      }\n\n      throw new Error('`Change.create` only accepts objects or changes, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a `Change` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Change}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var value = object.value,\n          _object$operations = object.operations,\n          operations = _object$operations === undefined ? [] : _object$operations;\n      var change = new Change({\n        value: Value.create(value),\n        operations: Operation.createList(operations)\n      });\n      return change;\n    }\n  }]);\n  return Change;\n}(Record(DEFAULTS$12));\n/**\n * A plugin that adds a set of commands to the editor.\n *\n * @param {Object} commands\n * @return {Object}\n */\n\n\nfunction CommandsPlugin() {\n  var commands = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  /**\n   * On command, if it exists in our list of commands, call it.\n   *\n   * @param {Object} command\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCommand(command, editor, next) {\n    var type = command.type,\n        args = command.args;\n    var fn = commands[type];\n    if (!fn) return next();\n    editor.command.apply(editor, [fn].concat(toConsumableArray(args)));\n  }\n  /**\n   * On construct, register all the commands.\n   *\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onConstruct(editor, next) {\n    for (var command in commands) {\n      editor.registerCommand(command);\n    }\n\n    return next();\n  }\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n\n  return {\n    onCommand: onCommand,\n    onConstruct: onConstruct\n  };\n}\n/**\n * Surrogate pair start and end points.\n *\n * @type {Number}\n */\n\n\nvar SURROGATE_START = 0xd800;\nvar SURROGATE_END = 0xdfff;\n/**\n * A regex to match space characters.\n *\n * @type {RegExp}\n */\n\nvar SPACE = /\\s/;\n/**\n * A regex to match chameleon characters, that count as word characters as long\n * as they are inside of a word.\n *\n * @type {RegExp}\n */\n\nvar CHAMELEON = /['\\u2018\\u2019]/;\n/**\n * A regex that matches punctuation.\n *\n * @type {RegExp}\n */\n\nvar PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\n/**\n * Is a character `code` in a surrogate character.\n *\n * @param {Number} code\n * @return {Boolean}\n */\n\nfunction isSurrogate(code) {\n  return SURROGATE_START <= code && code <= SURROGATE_END;\n}\n/**\n * Does `code` form Modifier with next one.\n *\n * https://emojipedia.org/modifiers/\n *\n * @param {Number} code\n * @param {String} text\n * @param {Number} offset\n * @return {Boolean}\n */\n\n\nfunction isModifier(code, text, offset) {\n  if (code === 0xd83c) {\n    var next = text.charCodeAt(offset + 1);\n    return next <= 0xdfff && next >= 0xdffb;\n  }\n\n  return false;\n}\n/**\n * Is `code` a Variation Selector.\n *\n * https://codepoints.net/variation_selectors\n *\n * @param {Number} code\n * @return {Boolean}\n */\n\n\nfunction isVariationSelector(code) {\n  return code <= 0xfe0f && code >= 0xfe00;\n}\n/**\n * Is `code` one of the BMP codes used in emoji sequences.\n *\n * https://emojipedia.org/emoji-zwj-sequences/\n *\n * @param {Number} code\n * @return {Boolean}\n */\n\n\nfunction isBMPEmoji(code) {\n  // This requires tiny bit of maintanance, better ideas?\n  // Fortunately it only happens if new Unicode Standard\n  // is released. Fails gracefully if upkeep lags behind,\n  // same way Slate previously behaved with all emojis.\n  return code === 0x2764 || // heart (❤)\n  code === 0x2642 || // male (♂)\n  code === 0x2640 || // female (♀)\n  code === 0x2620 || // scull (☠)\n  code === 0x2695 || // medical (⚕)\n  code === 0x2708 || // plane (✈️)\n  code === 0x25ef // large circle (◯)\n  ;\n}\n/**\n * Is a character a word character? Needs the `remaining` characters too.\n *\n * @param {String} char\n * @param {String|Void} remaining\n * @return {Boolean}\n */\n\n\nfunction isWord(char, remaining) {\n  if (SPACE.test(char)) return false; // If it's a chameleon character, recurse to see if the next one is or not.\n\n  if (CHAMELEON.test(char)) {\n    var next = remaining.charAt(0);\n    var length = getCharLength(next);\n    next = remaining.slice(0, length);\n    var rest = remaining.slice(length);\n    if (isWord(next, rest)) return true;\n  }\n\n  if (PUNCTUATION.test(char)) return false;\n  return true;\n}\n/**\n * Get the length of a `character`.\n *\n * @param {String} char\n * @return {Number}\n */\n\n\nfunction getCharLength(char) {\n  return isSurrogate(char.charCodeAt(0)) ? 2 : 1;\n}\n/**\n * Get the offset to the end of the character(s) in `text`.\n * This function is emoji aware and handles them correctly.\n *\n * @param {String} text\n * @param {Number} chars\n * @param {Boolean} forward\n * @return {Number}\n */\n\n\nfunction getCharOffset(text, chars, forward) {\n  var offset = 0; // Handle end/beginning of node: we have to return 1 in order not to\n  // break cursor's jumping to next/previous node. We need to return early\n  // because otherwise, ''.charCodeAt(0) returned NaN and, the default\n  // handling 'latin characters' at the end of the while loop would\n  // would never be reached an we returned '0' as offset.\n\n  if (text === '') return 1; // Calculate offset sum of each character\n\n  for (var i = 0; i < chars; i++) {\n    // `prev` types (better ideas?):\n    // - SURR: surrogate pair\n    // - MOD: modifier (technically also surrogate pair)\n    // - ZWJ: zero width joiner\n    // - VAR: variation selector\n    // - BMP: sequenceable character from Basic Multilingual Plane\n    var prev = null;\n    var charCode = text.charCodeAt(offset);\n\n    while (charCode) {\n      if (isSurrogate(charCode)) {\n        var modifier = isModifier(charCode, text, offset); // Early returns are the heart of this loop where\n        // we decide if previous and current codepoints\n        // should form a single character (in other words:\n        // how many of them should selection jump over).\n\n        if (forward) {\n          if (!modifier && prev && prev !== 'ZWJ' || modifier && prev && prev !== 'SURR') {\n            break;\n          }\n        } else if (prev === 'SURR' || prev === 'BMP') {\n          break;\n        }\n\n        offset += 2;\n        prev = modifier ? 'MOD' : 'SURR';\n        charCode = text.charCodeAt(offset); // It's okay to `continue` without checking\n        // because if `charCode` is NaN (which is\n        // the case when out of `text` range), next\n        // `while` loop won't execute and we're done.\n\n        continue;\n      } // If zero width joiner\n\n\n      if (charCode === 0x200d) {\n        offset += 1;\n        prev = 'ZWJ';\n        charCode = text.charCodeAt(offset);\n        continue;\n      }\n\n      if (isBMPEmoji(charCode)) {\n        if (forward && prev === 'VAR' || prev && prev !== 'ZWJ' && prev !== 'VAR') {\n          break;\n        }\n\n        offset += 1;\n        prev = 'BMP';\n        charCode = text.charCodeAt(offset);\n        continue;\n      }\n\n      if (isVariationSelector(charCode)) {\n        if (!forward && prev && prev !== 'ZWJ') {\n          break;\n        }\n\n        offset += 1;\n        prev = 'VAR';\n        charCode = text.charCodeAt(offset);\n        continue;\n      } // Modifier \"fuses\" with what ever character is before that\n      // (even whitespace), need to look ahead if loop gets here.\n\n\n      if (forward) {\n        var nextCharCode = text.charCodeAt(offset + 1);\n\n        if (isModifier(nextCharCode, text, offset + 1)) {\n          offset += 3;\n          prev = 'MOD';\n          charCode = text.charCodeAt(offset);\n          continue;\n        }\n      } else if (prev === 'MOD') {\n        offset += 1;\n        break;\n      } // If while loop ever gets here, we're\n      // done (e.g Latin characters, length 1).\n\n\n      if (prev === null) offset += 1;\n      break;\n    }\n  }\n\n  return offset;\n}\n/**\n * Get the offset to the end of character(s) before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @param {Number} chars\n * @return {Number}\n */\n\n\nfunction getCharOffsetBackward(text, offset) {\n  var chars = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  text = text.slice(0, offset);\n  text = reverse(text);\n  return getCharOffset(text, chars);\n}\n/**\n * Get the offset to the end of character(s) after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @param {Number} chars\n * @return {Number}\n */\n\n\nfunction getCharOffsetForward(text, offset) {\n  var chars = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  text = text.slice(offset);\n  return getCharOffset(text, chars, true);\n}\n/**\n * Get the offset to the end of the first word in `text`.\n *\n * @param {String} text\n * @return {Number}\n */\n\n\nfunction getWordOffset(text) {\n  var length = 0;\n  var i = 0;\n  var started = false;\n  var char = void 0;\n\n  while (char = text.charAt(i)) {\n    var l = getCharLength(char);\n    char = text.slice(i, i + l);\n    var rest = text.slice(i + l);\n\n    if (isWord(char, rest)) {\n      started = true;\n      length += l;\n    } else if (!started) {\n      length += l;\n    } else {\n      break;\n    }\n\n    i += l;\n  }\n\n  return length;\n}\n/**\n * Get the offset to the end of the word before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\n\nfunction getWordOffsetBackward(text, offset) {\n  text = text.slice(0, offset);\n  text = reverse(text);\n  var o = getWordOffset(text);\n  return o;\n}\n/**\n * Get the offset to the end of the word after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\n\nfunction getWordOffsetForward(text, offset) {\n  text = text.slice(offset);\n  var o = getWordOffset(text);\n  return o;\n}\n/**\n * Export.\n *\n * @type {Object}\n */\n\n\nvar TextUtils = {\n  getCharLength: getCharLength,\n  getCharOffset: getCharOffset,\n  getCharOffsetBackward: getCharOffsetBackward,\n  getCharOffsetForward: getCharOffsetForward,\n  getWordOffset: getWordOffset,\n  getWordOffsetBackward: getWordOffsetBackward,\n  getWordOffsetForward: getWordOffsetForward,\n  isSurrogate: isSurrogate,\n  isWord: isWord\n};\n/**\n * Ensure that an expanded selection is deleted first, and return the updated\n * range to account for the deleted part.\n *\n * @param {Editor}\n */\n\nfunction deleteExpandedAtRange(editor, range) {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range);\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var _range = range,\n      start = _range.start,\n      end = _range.end;\n\n  if (document.hasDescendant(start.path)) {\n    range = range.moveToStart();\n  } else {\n    range = range.moveTo(end.path, 0).normalize(document);\n  }\n\n  return range;\n}\n/**\n * Commands.\n *\n * @type {Object}\n */\n\n\nvar Commands$1 = {};\n/**\n * Add a new `mark` to the characters at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Mixed} mark\n */\n\nCommands$1.addMarkAtRange = function (editor, range, mark) {\n  if (range.isCollapsed) return;\n  var value = editor.value;\n  var document = value.document;\n  var start = range.start,\n      end = range.end;\n  var texts = document.getTextsAtRange(range);\n  editor.withoutNormalizing(function () {\n    texts.forEach(function (node) {\n      var key = node.key;\n      var index = 0;\n      var length = node.text.length;\n      if (key === start.key) index = start.offset;\n      if (key === end.key) length = end.offset;\n      if (key === start.key && key === end.key) length = end.offset - start.offset;\n      editor.addMarkByKey(key, index, length, mark);\n    });\n  });\n};\n/**\n * Add a list of `marks` to the characters at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Array<Mixed>} mark\n */\n\n\nCommands$1.addMarksAtRange = function (editor, range, marks) {\n  marks.forEach(function (mark) {\n    return editor.addMarkAtRange(range, mark);\n  });\n};\n/**\n * Delete everything in a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\n\nCommands$1.deleteAtRange = function (editor, range) {\n  // Snapshot the selection, which creates an extra undo save point, so that\n  // when you undo a delete, the expanded selection will be retained.\n  editor.snapshotSelection();\n  var value = editor.value;\n  var start = range.start,\n      end = range.end;\n  var startKey = start.key;\n  var startOffset = start.offset;\n  var endKey = end.key;\n  var endOffset = end.offset;\n  var document = value.document;\n  var isStartVoid = document.hasVoidParent(startKey, editor);\n  var isEndVoid = document.hasVoidParent(endKey, editor);\n  var startBlock = document.getClosestBlock(startKey);\n  var endBlock = document.getClosestBlock(endKey); // Check if we have a \"hanging\" selection case where the even though the\n  // selection extends into the start of the end node, we actually want to\n  // ignore that for UX reasons.\n\n  var isHanging = startOffset === 0 && endOffset === 0 && isStartVoid === false && startKey === startBlock.getFirstText().key && endKey === endBlock.getFirstText().key && startKey !== endKey; // If it's a hanging selection, nudge it back to end in the previous text.\n\n  if (isHanging && isEndVoid) {\n    var prevText = document.getPreviousText(endKey);\n    endKey = prevText.key;\n    endOffset = prevText.text.length;\n    isEndVoid = document.hasVoidParent(endKey, editor);\n  }\n\n  editor.withoutNormalizing(function () {\n    // If the start node is inside a void node, remove the void node and update\n    // the starting point to be right after it, continuously until the start point\n    // is not a void, or until the entire range is handled.\n    while (isStartVoid) {\n      var startVoid = document.getClosestVoid(startKey, editor);\n      var nextText = document.getNextText(startKey);\n      editor.removeNodeByKey(startVoid.key); // If the start and end keys are the same, we're done.\n\n      if (startKey === endKey) return; // If there is no next text node, we're done.\n\n      if (!nextText) return; // Continue...\n\n      document = editor.value.document;\n      startKey = nextText.key;\n      startOffset = 0;\n      isStartVoid = document.hasVoidParent(startKey, editor);\n    } // If the end node is inside a void node, do the same thing but backwards. But\n    // we don't need any aborting checks because if we've gotten this far there\n    // must be a non-void node that will exit the loop.\n\n\n    while (isEndVoid) {\n      var endVoid = document.getClosestVoid(endKey, editor);\n\n      var _prevText = document.getPreviousText(endKey);\n\n      editor.removeNodeByKey(endVoid.key); // Continue...\n\n      document = editor.value.document;\n      endKey = _prevText.key;\n      endOffset = _prevText.text.length;\n      isEndVoid = document.hasVoidParent(endKey, editor);\n    } // If the start and end key are the same, and it was a hanging selection, we\n    // can just remove the entire block.\n\n\n    if (startKey === endKey && isHanging) {\n      editor.removeNodeByKey(startBlock.key);\n      return;\n    } else if (startKey === endKey) {\n      // Otherwise, if it wasn't hanging, we're inside a single text node, so we can\n      // simply remove the text in the range.\n      var index = startOffset;\n      var length = endOffset - startOffset;\n      editor.removeTextByKey(startKey, index, length);\n      return;\n    } else {\n      // Otherwise, we need to recursively remove text and nodes inside the start\n      // block after the start offset and inside the end block before the end\n      // offset. Then remove any blocks that are in between the start and end\n      // blocks. Then finally merge the start and end nodes.\n      startBlock = document.getClosestBlock(startKey);\n      endBlock = document.getClosestBlock(endKey);\n      var startText = document.getNode(startKey);\n      var endText = document.getNode(endKey);\n      var startLength = startText.text.length - startOffset;\n      var endLength = endOffset;\n      var ancestor = document.getCommonAncestor(startKey, endKey);\n      var startChild = ancestor.getFurthestChild(startKey);\n      var endChild = ancestor.getFurthestChild(endKey);\n      var startParent = document.getParent(startBlock.key);\n      var startParentIndex = startParent.nodes.indexOf(startBlock);\n      var endParentIndex = startParent.nodes.indexOf(endBlock);\n      var child = void 0; // Iterate through all of the nodes in the tree after the start text node\n      // but inside the end child, and remove them.\n\n      child = startText;\n\n      while (child.key !== startChild.key) {\n        var parent = document.getParent(child.key);\n\n        var _index = parent.nodes.indexOf(child);\n\n        var afters = parent.nodes.slice(_index + 1);\n        afters.reverse().forEach(function (node) {\n          editor.removeNodeByKey(node.key);\n        });\n        child = parent;\n      } // Remove all of the middle children.\n\n\n      var startChildIndex = ancestor.nodes.indexOf(startChild);\n      var endChildIndex = ancestor.nodes.indexOf(endChild);\n      var middles = ancestor.nodes.slice(startChildIndex + 1, endChildIndex);\n      middles.reverse().forEach(function (node) {\n        editor.removeNodeByKey(node.key);\n      }); // Remove the nodes before the end text node in the tree.\n\n      child = endText;\n\n      while (child.key !== endChild.key) {\n        var _parent = document.getParent(child.key);\n\n        var _index2 = _parent.nodes.indexOf(child);\n\n        var befores = _parent.nodes.slice(0, _index2);\n\n        befores.reverse().forEach(function (node) {\n          editor.removeNodeByKey(node.key);\n        });\n        child = _parent;\n      } // Remove any overlapping text content from the leaf text nodes.\n\n\n      if (startLength !== 0) {\n        editor.removeTextByKey(startKey, startOffset, startLength);\n      }\n\n      if (endLength !== 0) {\n        editor.removeTextByKey(endKey, 0, endOffset);\n      } // If the start and end blocks aren't the same, move and merge the end block\n      // into the start block.\n\n\n      if (startBlock.key !== endBlock.key) {\n        document = editor.value.document;\n        var onlyChildAncestor = void 0;\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = document.ancestors(endBlock.key)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _ref = _step.value;\n\n            var _ref2 = slicedToArray(_ref, 1);\n\n            var node = _ref2[0];\n\n            if (node.nodes.size > 1) {\n              break;\n            } else {\n              onlyChildAncestor = node;\n            }\n          } // Move the end block to be right after the start block.\n\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        if (endParentIndex !== startParentIndex + 1) {\n          editor.moveNodeByKey(endBlock.key, startParent.key, startParentIndex + 1);\n        } // If the selection is hanging, just remove the start block, otherwise\n        // merge the end block into it.\n\n\n        if (isHanging) {\n          editor.removeNodeByKey(startBlock.key);\n        } else {\n          editor.mergeNodeByKey(endBlock.key);\n        } // If nested empty blocks are left over above the end block, remove them.\n\n\n        if (onlyChildAncestor) {\n          editor.removeNodeByKey(onlyChildAncestor.key);\n        }\n      }\n    }\n  });\n};\n/**\n * Delete backward `n` characters at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Number} n (optional)\n */\n\n\nCommands$1.deleteBackwardAtRange = function (editor, range) {\n  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  if (n === 0) return;\n  var value = editor.value;\n  var document = value.document;\n  var _range2 = range,\n      start = _range2.start,\n      focus = _range2.focus; // If the range is expanded, perform a regular delete instead.\n\n  if (range.isExpanded) {\n    editor.deleteAtRange(range);\n    return;\n  }\n\n  var voidParent = document.getClosestVoid(start.path, editor); // If there is a void parent, delete it.\n\n  if (voidParent) {\n    editor.removeNodeByKey(voidParent.key);\n    return;\n  } // If the range is at the start of the document, abort.\n\n\n  if (start.isAtStartOfNode(document)) {\n    return;\n  }\n\n  var block = document.getClosestBlock(start.path); // PERF: If the closest block is empty, remove it. This is just a shortcut,\n  // since merging it would result in the same outcome.\n\n  if (document.nodes.size !== 1 && block && block.text === '' && block.nodes.size === 1) {\n    editor.removeNodeByKey(block.key);\n    return;\n  } // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n\n\n  var text = document.getDescendant(start.path);\n\n  if (start.isAtStartOfNode(text)) {\n    var prev = document.getPreviousText(text.key);\n    var inline = document.getClosestInline(text.key); // If the range is at the start of the inline node, and previous text node\n    // is empty, take the text node before that, or \"prevBlock\" would be the\n    // same node as \"block\"\n\n    if (inline && prev.text === '') {\n      prev = document.getPreviousText(prev.key);\n    }\n\n    var prevBlock = document.getClosestBlock(prev.key);\n    var prevVoid = document.getClosestVoid(prev.key, editor); // If the previous text node has a void parent, remove it.\n\n    if (prevVoid) {\n      editor.removeNodeByKey(prevVoid.key);\n      return;\n    } // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to merge the two blocks together.\n\n\n    if (n === 1 && prevBlock !== block) {\n      range = range.moveAnchorTo(prev.key, prev.text.length);\n      editor.deleteAtRange(range);\n      return;\n    }\n  } // If the focus offset is farther than the number of characters to delete,\n  // just remove the characters backwards inside the current node.\n\n\n  if (n <= focus.offset) {\n    range = range.moveFocusBackward(n);\n    editor.deleteAtRange(range);\n    return;\n  } // Otherwise, we need to see how many nodes backwards to go.\n\n\n  var node = text;\n  var offset = 0;\n  var traversed = focus.offset;\n\n  while (n > traversed) {\n    node = document.getPreviousText(node.key);\n    var next = traversed + node.text.length;\n\n    if (n <= next) {\n      offset = next - n;\n      break;\n    } else {\n      traversed = next;\n    }\n  }\n\n  range = range.moveAnchorTo(node.key, offset);\n  editor.deleteAtRange(range);\n};\n/**\n * Delete backward until the character boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\n\nCommands$1.deleteCharBackwardAtRange = function (editor, range) {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range);\n    return;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var start = range.start;\n  var startBlock = document.getClosestBlock(start.path);\n  var offset = startBlock.getOffset(start.key);\n  var o = offset + start.offset;\n  var text = startBlock.text;\n  var n = TextUtils.getCharOffsetBackward(text, o);\n  editor.deleteBackwardAtRange(range, n);\n};\n/**\n * Delete forward until the character boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\n\nCommands$1.deleteCharForwardAtRange = function (editor, range) {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range);\n    return;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var start = range.start;\n  var startBlock = document.getClosestBlock(start.path);\n  var offset = startBlock.getOffset(start.key);\n  var o = offset + start.offset;\n  var text = startBlock.text;\n  var n = TextUtils.getCharOffsetForward(text, o);\n  editor.deleteForwardAtRange(range, n);\n};\n/**\n * Delete forward `n` characters at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Number} n (optional)\n */\n\n\nCommands$1.deleteForwardAtRange = function (editor, range) {\n  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  if (n === 0) return;\n  var value = editor.value;\n  var document = value.document;\n  var _range3 = range,\n      start = _range3.start,\n      focus = _range3.focus; // If the range is expanded, perform a regular delete instead.\n\n  if (range.isExpanded) {\n    editor.deleteAtRange(range);\n    return;\n  }\n\n  var voidParent = document.getClosestVoid(start.path, editor); // If the node has a void parent, delete it.\n\n  if (voidParent) {\n    editor.removeNodeByKey(voidParent.key);\n    return;\n  }\n\n  var block = document.getClosestBlock(start.path); // If the closest is not void, but empty, remove it\n\n  if (block && !editor.isVoid(block) && block.text === '' && document.nodes.size !== 1) {\n    var nextBlock = document.getNextBlock(block.key);\n    editor.removeNodeByKey(block.key);\n\n    if (nextBlock && nextBlock.key) {\n      editor.moveToStartOfNode(nextBlock);\n    }\n\n    return;\n  } // If the range is at the start of the document, abort.\n\n\n  if (start.isAtEndOfNode(document)) {\n    return;\n  } // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n\n\n  var text = document.getDescendant(start.path);\n\n  if (start.isAtEndOfNode(text)) {\n    var next = document.getNextText(text.key);\n\n    var _nextBlock = document.getClosestBlock(next.key);\n\n    var nextVoid = document.getClosestVoid(next.key, editor); // If the next text node has a void parent, remove it.\n\n    if (nextVoid) {\n      editor.removeNodeByKey(nextVoid.key);\n      return;\n    } // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to merge the two blocks together.\n\n\n    if (n === 1 && _nextBlock !== block) {\n      range = range.moveFocusTo(next.key, 0);\n      editor.deleteAtRange(range);\n      return;\n    }\n  } // If the remaining characters to the end of the node is greater than or equal\n  // to the number of characters to delete, just remove the characters forwards\n  // inside the current node.\n\n\n  if (n <= text.text.length - focus.offset) {\n    range = range.moveFocusForward(n);\n    editor.deleteAtRange(range);\n    return;\n  } // Otherwise, we need to see how many nodes forwards to go.\n\n\n  var node = text;\n  var offset = focus.offset;\n  var traversed = text.text.length - focus.offset;\n\n  while (n > traversed) {\n    node = document.getNextText(node.key);\n\n    var _next = traversed + node.text.length;\n\n    if (n <= _next) {\n      offset = n - traversed;\n      break;\n    } else {\n      traversed = _next;\n    }\n  }\n\n  range = range.moveFocusTo(node.key, offset);\n  editor.deleteAtRange(range);\n};\n/**\n * Delete backward until the line boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\n\nCommands$1.deleteLineBackwardAtRange = function (editor, range) {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range);\n    return;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var start = range.start;\n  var startBlock = document.getClosestBlock(start.path);\n  var offset = startBlock.getOffset(start.key);\n  var o = offset + start.offset;\n  editor.deleteBackwardAtRange(range, o);\n};\n/**\n * Delete forward until the line boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\n\nCommands$1.deleteLineForwardAtRange = function (editor, range) {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range);\n    return;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var start = range.start;\n  var startBlock = document.getClosestBlock(start.path);\n  var offset = startBlock.getOffset(start.key);\n  var o = offset + start.offset;\n  editor.deleteForwardAtRange(range, startBlock.text.length - o);\n};\n/**\n * Delete backward until the word boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\n\nCommands$1.deleteWordBackwardAtRange = function (editor, range) {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range);\n    return;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var start = range.start;\n  var startBlock = document.getClosestBlock(start.path);\n  var offset = startBlock.getOffset(start.key);\n  var o = offset + start.offset;\n  var text = startBlock.text;\n  var n = o === 0 ? 1 : TextUtils.getWordOffsetBackward(text, o);\n  editor.deleteBackwardAtRange(range, n);\n};\n/**\n * Delete forward until the word boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\n\nCommands$1.deleteWordForwardAtRange = function (editor, range) {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range);\n    return;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var start = range.start;\n  var startBlock = document.getClosestBlock(start.path);\n  var offset = startBlock.getOffset(start.key);\n  var o = offset + start.offset;\n  var text = startBlock.text;\n  var wordOffset = TextUtils.getWordOffsetForward(text, o);\n  var n = wordOffset === 0 ? 1 : wordOffset;\n  editor.deleteForwardAtRange(range, n);\n};\n/**\n * Insert a `block` node at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Block|String|Object} block\n */\n\n\nCommands$1.insertBlockAtRange = function (editor, range, block) {\n  range = deleteExpandedAtRange(editor, range);\n  block = Block.create(block);\n  var value = editor.value;\n  var document = value.document;\n  var _range4 = range,\n      start = _range4.start;\n  var startKey = start.key;\n  var startOffset = start.offset;\n  var startBlock = document.getClosestBlock(startKey);\n  var startInline = document.getClosestInline(startKey);\n  var parent = document.getParent(startBlock.key);\n  var index = parent.nodes.indexOf(startBlock);\n  var insertionMode = getInsertionMode(editor, range);\n\n  if (insertionMode === 'before') {\n    editor.insertNodeByKey(parent.key, index, block);\n  } else if (insertionMode === 'behind') {\n    editor.insertNodeByKey(parent.key, index + 1, block);\n  } else {\n    if (startInline && editor.isVoid(startInline)) {\n      var atEnd = start.isAtEndOfNode(startInline);\n      var siblingText = atEnd ? document.getNextText(startKey) : document.getPreviousText(startKey);\n      var splitRange = atEnd ? range.moveToStartOfNode(siblingText) : range.moveToEndOfNode(siblingText);\n      startKey = splitRange.start.key;\n      startOffset = splitRange.start.offset;\n    }\n\n    editor.withoutNormalizing(function () {\n      editor.splitDescendantsByKey(startBlock.key, startKey, startOffset);\n      editor.insertNodeByKey(parent.key, index + 1, block);\n    });\n  }\n};\n/**\n * Check if current block should be split or new block should be added before or behind it.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\n\nvar getInsertionMode = function getInsertionMode(editor, range) {\n  var value = editor.value;\n  var document = value.document;\n  var start = range.start;\n  var startKey = start.key;\n  var startBlock = document.getClosestBlock(startKey);\n  var startInline = document.getClosestInline(startKey);\n\n  if (editor.isVoid(startBlock)) {\n    if (start.isAtEndOfNode(startBlock)) return 'behind';else return 'before';\n  } else if (!startInline && startBlock.text === '') {\n    return 'behind';\n  } else if (start.isAtStartOfNode(startBlock)) {\n    return 'before';\n  } else if (start.isAtEndOfNode(startBlock)) {\n    return 'behind';\n  }\n\n  return 'split';\n};\n/**\n * Insert a `fragment` at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Document} fragment\n */\n\n\nCommands$1.insertFragmentAtRange = function (editor, range, fragment) {\n  editor.withoutNormalizing(function () {\n    range = deleteExpandedAtRange(editor, range); // If the fragment is empty, there's nothing to do after deleting.\n\n    if (!fragment.nodes.size) return; // Regenerate the keys for all of the fragments nodes, so that they're\n    // guaranteed not to collide with the existing keys in the document. Otherwise\n    // they will be regenerated automatically and we won't have an easy way to\n    // reference them.\n\n    fragment = fragment.mapDescendants(function (child) {\n      return child.regenerateKey();\n    }); // Calculate a few things...\n\n    var _range5 = range,\n        start = _range5.start;\n    var value = editor.value;\n    var document = value.document;\n    var startText = document.getDescendant(start.path);\n    var startBlock = document.getClosestBlock(startText.key);\n    var startChild = startBlock.getFurthestChild(startText.key);\n    var isAtStart = start.isAtStartOfNode(startBlock);\n    var parent = document.getParent(startBlock.key);\n    var index = parent.nodes.indexOf(startBlock);\n    var blocks = fragment.getBlocks();\n    var firstChild = fragment.nodes.first();\n    var lastChild = fragment.nodes.last();\n    var firstBlock = blocks.first();\n    var lastBlock = blocks.last();\n    var insertionNode = findInsertionNode(fragment, document, startBlock.key); // If the fragment only contains a void block, use `insertBlock` instead.\n\n    if (firstBlock === lastBlock && editor.isVoid(firstBlock)) {\n      editor.insertBlockAtRange(range, firstBlock);\n      return;\n    } // If inserting the entire fragment and it starts or ends with a single\n    // nested block, e.g. a table, we do not merge it with existing blocks.\n\n\n    if (insertionNode === fragment && (firstChild.hasBlockChildren() || lastChild.hasBlockChildren())) {\n      // check if reversal is necessary or not\n      var insertionMode = getInsertionMode(editor, range);\n      var nodes = insertionMode === 'before' ? fragment.nodes : fragment.nodes.reverse();\n      nodes.forEach(function (node) {\n        editor.insertBlockAtRange(range, node);\n      });\n      return;\n    } // If the first and last block aren't the same, we need to insert all of the\n    // nodes after the insertion node's first block at the index.\n\n\n    if (firstBlock !== lastBlock) {\n      var lonelyParent = insertionNode.getFurthest(firstBlock.key, function (p) {\n        return p.nodes.size === 1;\n      });\n      var lonelyChild = lonelyParent || firstBlock;\n      var startIndex = parent.nodes.indexOf(startBlock);\n      var excludingLonelyChild = insertionNode.removeNode(lonelyChild.key);\n      excludingLonelyChild.nodes.forEach(function (node, i) {\n        var newIndex = startIndex + i + 1;\n        editor.insertNodeByKey(parent.key, newIndex, node);\n      });\n    } // Check if we need to split the node.\n\n\n    if (start.offset !== 0) {\n      editor.splitDescendantsByKey(startChild.key, start.key, start.offset);\n    } // Update our variables with the new value.\n\n\n    document = editor.value.document;\n    startText = document.getDescendant(start.key);\n    startBlock = document.getClosestBlock(start.key);\n    startChild = startBlock.getFurthestChild(startText.key); // If the first and last block aren't the same, we need to move any of the\n    // starting block's children after the split into the last block of the\n    // fragment, which has already been inserted.\n\n    if (firstBlock !== lastBlock) {\n      var nextChild = isAtStart ? startChild : startBlock.getNextSibling(startChild.key);\n      var nextNodes = nextChild ? startBlock.nodes.skipUntil(function (n) {\n        return n.key === nextChild.key;\n      }) : List();\n      var lastIndex = lastBlock.nodes.size;\n      nextNodes.forEach(function (node, i) {\n        var newIndex = lastIndex + i;\n        editor.moveNodeByKey(node.key, lastBlock.key, newIndex);\n      });\n    } // If the starting block is empty, we replace it entirely with the first block\n    // of the fragment, since this leads to a more expected behavior for the user.\n\n\n    if (!editor.isVoid(startBlock) && startBlock.text === '' && !startBlock.findDescendant(function (n) {\n      return editor.isVoid(n);\n    })) {\n      editor.removeNodeByKey(startBlock.key);\n      editor.insertNodeByKey(parent.key, index, firstBlock);\n    } else {\n      // Otherwise, we maintain the starting block, and insert all of the first\n      // block's inline nodes into it at the split point.\n      var inlineChild = startBlock.getFurthestChild(startText.key);\n      var inlineIndex = startBlock.nodes.indexOf(inlineChild);\n      firstBlock.nodes.forEach(function (inline, i) {\n        var o = start.offset === 0 ? 0 : 1;\n        var newIndex = inlineIndex + i + o;\n        editor.insertNodeByKey(startBlock.key, newIndex, inline);\n      });\n    }\n  });\n};\n/**\n * Get the deepest single child block inside `fragment` whose reversed block\n * ancestors match the reversed block ancestors of the `document` starting at\n * the `documentKey`.\n *\n * @param {Document} document\n * @param {string} documentKey\n * @param {Document} fragment\n * @return {Node}\n */\n\n\nvar findInsertionNode = function findInsertionNode(fragment, document, documentKey) {\n  // Find the deepest block in a doc with no siblings.\n  var deepestSingleBlock = function deepestSingleBlock(doc) {\n    var result = doc;\n\n    while (result.nodes.size === 1 && result.nodes.first().object === 'block') {\n      result = result.nodes.first();\n    }\n\n    return result === doc ? null : result;\n  }; // Return whether every block in the `fragmentAncestors` list has the\n  // same type as the block in `documentAncestors` with the same index.\n\n\n  var ancestorTypesMatch = function ancestorTypesMatch(fragmentAncestors, documentAncestors) {\n    return documentAncestors.size >= fragmentAncestors.size && fragmentAncestors.every(function (fragmentNode, i) {\n      return documentAncestors.get(i).type === fragmentNode.type;\n    });\n  }; // Given two reverse lists of ancestors, check if all fragment ancestor types\n  // match the doc ancestors at some position.\n\n\n  var matchingFragmentAncestor = function matchingFragmentAncestor(documentAncestors, fragmentAncestors) {\n    var depthDifference = documentAncestors.size - fragmentAncestors.size; // There is nothing to align if the fragment is deeper than the document.\n\n    if (depthDifference < 0) {\n      return fragment;\n    }\n\n    for (var fragIdx = 0; fragIdx < fragmentAncestors.size; fragIdx++) {\n      // The docIdx loop relaxes our check in that we can still match if there\n      // are node type differences leaf-side.\n      // This is important for example if our fragment inserts multiple siblings\n      // or inserts another type while the tree structure remains the same.\n      for (var docIdx = 0; docIdx <= depthDifference; docIdx++) {\n        if (ancestorTypesMatch(fragmentAncestors.slice(fragIdx), documentAncestors.slice(docIdx))) {\n          return fragmentAncestors.get(fragIdx);\n        }\n      }\n    }\n\n    return fragment;\n  }; // Get the type definitions for all ancestors up from node with key `key`,\n  // except the document object.\n\n\n  var getAncestorBlocks = function getAncestorBlocks(doc, key) {\n    return doc.getAncestors(key).slice(1).push(doc.getNode(key)).reverse();\n  };\n\n  var fragmentStartBlock = deepestSingleBlock(fragment);\n\n  if (!fragmentStartBlock) {\n    return fragment;\n  }\n\n  var documentAncestors = getAncestorBlocks(document, documentKey);\n  var fragmentAncestors = getAncestorBlocks(fragment, fragmentStartBlock.key);\n  return matchingFragmentAncestor(documentAncestors, fragmentAncestors);\n};\n/**\n * Insert an `inline` node at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Inline|String|Object} inline\n */\n\n\nCommands$1.insertInlineAtRange = function (editor, range, inline) {\n  inline = Inline.create(inline);\n  editor.withoutNormalizing(function () {\n    range = deleteExpandedAtRange(editor, range);\n    var value = editor.value;\n    var document = value.document;\n    var _range6 = range,\n        start = _range6.start;\n    var parent = document.getParent(start.path);\n    var startText = document.assertDescendant(start.path);\n    var index = parent.nodes.indexOf(startText);\n\n    if (editor.isVoid(parent)) {\n      return;\n    }\n\n    editor.splitNodeByPath(start.path, start.offset);\n    editor.insertNodeByKey(parent.key, index + 1, inline);\n  });\n};\n/**\n * Insert `text` at a `range`, with optional `marks`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\n\nCommands$1.insertTextAtRange = function (editor, range, text, marks) {\n  editor.withoutNormalizing(function () {\n    range = deleteExpandedAtRange(editor, range);\n    var value = editor.value;\n    var document = value.document;\n    var _range7 = range,\n        start = _range7.start;\n    var offset = start.offset;\n    var parent = document.getParent(start.path);\n\n    if (editor.isVoid(parent)) {\n      return;\n    }\n\n    editor.insertTextByPath(start.path, offset, text, marks);\n  });\n};\n/**\n * Remove an existing `mark` to the characters at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Mark|String} mark (optional)\n */\n\n\nCommands$1.removeMarkAtRange = function (editor, range, mark) {\n  if (range.isCollapsed) return;\n  var value = editor.value;\n  var document = value.document;\n  var texts = document.getTextsAtRange(range);\n  var start = range.start,\n      end = range.end;\n  editor.withoutNormalizing(function () {\n    texts.forEach(function (node) {\n      var key = node.key;\n      var index = 0;\n      var length = node.text.length;\n      if (key === start.key) index = start.offset;\n      if (key === end.key) length = end.offset;\n      if (key === start.key && key === end.key) length = end.offset - start.offset;\n      editor.removeMarkByKey(key, index, length, mark);\n    });\n  });\n};\n/**\n * Set the `properties` of block nodes in a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Object|String} properties\n */\n\n\nCommands$1.setBlocksAtRange = function (editor, range, properties) {\n  var value = editor.value;\n  var document = value.document;\n  var blocks = document.getLeafBlocksAtRange(range);\n  var start = range.start,\n      end = range.end,\n      isCollapsed = range.isCollapsed;\n  var isStartVoid = document.hasVoidParent(start.path, editor);\n  var startBlock = document.getClosestBlock(start.path);\n  var endBlock = document.getClosestBlock(end.key); // Check if we have a \"hanging\" selection case where the even though the\n  // selection extends into the start of the end node, we actually want to\n  // ignore that for UX reasons.\n\n  var isHanging = isCollapsed === false && start.offset === 0 && end.offset === 0 && isStartVoid === false && start.key === startBlock.getFirstText().key && end.key === endBlock.getFirstText().key; // If it's a hanging selection, ignore the last block.\n\n  var sets = isHanging ? blocks.slice(0, -1) : blocks;\n  editor.withoutNormalizing(function () {\n    sets.forEach(function (block) {\n      editor.setNodeByKey(block.key, properties);\n    });\n  });\n};\n/**\n * Set the `properties` of inline nodes in a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Object|String} properties\n */\n\n\nCommands$1.setInlinesAtRange = function (editor, range, properties) {\n  var value = editor.value;\n  var document = value.document;\n  var inlines = document.getLeafInlinesAtRange(range);\n  editor.withoutNormalizing(function () {\n    inlines.forEach(function (inline) {\n      editor.setNodeByKey(inline.key, properties);\n    });\n  });\n};\n/**\n * Split the block nodes at a `range`, to optional `height`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Number} height (optional)\n */\n\n\nCommands$1.splitBlockAtRange = function (editor, range) {\n  var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  range = deleteExpandedAtRange(editor, range);\n  var _range8 = range,\n      start = _range8.start,\n      end = _range8.end;\n  var value = editor.value;\n  var _value = value,\n      document = _value.document;\n  var node = document.assertDescendant(start.path);\n  var parent = document.getClosestBlock(node.key);\n  var h = 0;\n\n  while (parent && parent.object === 'block' && h < height) {\n    node = parent;\n    parent = document.getClosestBlock(parent.key);\n    h++;\n  }\n\n  editor.withoutNormalizing(function () {\n    editor.splitDescendantsByKey(node.key, start.path, start.offset);\n    value = editor.value;\n    document = value.document;\n\n    if (range.isExpanded) {\n      if (range.isBackward) range = range.flip();\n      var nextBlock = document.getNextBlock(node.key);\n      range = range.moveAnchorToStartOfNode(nextBlock);\n      range = range.setFocus(range.focus.setPath(null));\n\n      if (start.path.equals(end.path)) {\n        range = range.moveFocusTo(range.anchor.key, end.offset - start.offset);\n      }\n\n      range = document.resolveRange(range);\n      editor.deleteAtRange(range);\n    }\n  });\n};\n/**\n * Split the inline nodes at a `range`, to optional `height`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Number} height (optional)\n */\n\n\nCommands$1.splitInlineAtRange = function (editor, range) {\n  var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n  range = deleteExpandedAtRange(editor, range);\n  var _range9 = range,\n      start = _range9.start;\n  var value = editor.value;\n  var document = value.document;\n  var node = document.assertDescendant(start.path);\n  var parent = document.getClosestInline(node.key);\n  var h = 0;\n\n  while (parent && parent.object === 'inline' && h < height) {\n    node = parent;\n    parent = document.getClosestInline(parent.key);\n    h++;\n  }\n\n  editor.splitDescendantsByKey(node.key, start.path, start.offset);\n};\n/**\n * Add or remove a `mark` from the characters at `range`, depending on whether\n * it's already there.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Mixed} mark\n */\n\n\nCommands$1.toggleMarkAtRange = function (editor, range, mark) {\n  if (range.isCollapsed) return;\n  mark = Mark.create(mark);\n  var value = editor.value;\n  var document = value.document;\n  var marks = document.getActiveMarksAtRange(range);\n  var exists = marks.some(function (m) {\n    return m.equals(mark);\n  });\n\n  if (exists) {\n    editor.removeMarkAtRange(range, mark);\n  } else {\n    editor.addMarkAtRange(range, mark);\n  }\n};\n/**\n * Unwrap all of the block nodes in a `range` from a block with `properties`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {String|Object} properties\n */\n\n\nCommands$1.unwrapBlockAtRange = function (editor, range, properties) {\n  properties = Node.createProperties(properties);\n  var value = editor.value;\n  var document = value.document;\n  var blocks = document.getLeafBlocksAtRange(range);\n  var wrappers = blocks.map(function (block) {\n    return document.getClosest(block.key, function (parent) {\n      if (parent.object !== 'block') return false;\n      if (properties.type != null && parent.type !== properties.type) return false;\n      if (properties.data != null && !parent.data.isSuperset(properties.data)) return false;\n      return true;\n    });\n  }).filter(function (exists) {\n    return exists;\n  }).toOrderedSet().toList();\n  editor.withoutNormalizing(function () {\n    wrappers.forEach(function (block) {\n      var first = block.nodes.first();\n      var last = block.nodes.last();\n      var parent = editor.value.document.getParent(block.key);\n      var index = parent.nodes.indexOf(block);\n      var children = block.nodes.filter(function (child) {\n        return blocks.some(function (b) {\n          return child === b || child.hasDescendant(b.key);\n        });\n      });\n      var firstMatch = children.first();\n      var lastMatch = children.last();\n\n      if (first === firstMatch && last === lastMatch) {\n        block.nodes.forEach(function (child, i) {\n          editor.moveNodeByKey(child.key, parent.key, index + i);\n        });\n        editor.removeNodeByKey(block.key);\n      } else if (last === lastMatch) {\n        block.nodes.skipUntil(function (n) {\n          return n === firstMatch;\n        }).forEach(function (child, i) {\n          editor.moveNodeByKey(child.key, parent.key, index + 1 + i);\n        });\n      } else if (first === firstMatch) {\n        block.nodes.takeUntil(function (n) {\n          return n === lastMatch;\n        }).push(lastMatch).forEach(function (child, i) {\n          editor.moveNodeByKey(child.key, parent.key, index + i);\n        });\n      } else {\n        var firstText = firstMatch.getFirstText();\n        editor.splitDescendantsByKey(block.key, firstText.key, 0);\n        document = editor.value.document;\n        children.forEach(function (child, i) {\n          if (i === 0) {\n            var extra = child;\n            child = document.getNextBlock(child.key);\n            editor.removeNodeByKey(extra.key);\n          }\n\n          editor.moveNodeByKey(child.key, parent.key, index + 1 + i);\n        });\n      }\n    });\n  });\n};\n/**\n * Unwrap the inline nodes in a `range` from an inline with `properties`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {String|Object} properties\n */\n\n\nCommands$1.unwrapInlineAtRange = function (editor, range, properties) {\n  properties = Node.createProperties(properties);\n  var value = editor.value;\n  var document = value.document;\n  var texts = document.getTextsAtRange(range);\n  var inlines = texts.map(function (text) {\n    return document.getClosest(text.key, function (parent) {\n      if (parent.object !== 'inline') return false;\n      if (properties.type != null && parent.type !== properties.type) return false;\n      if (properties.data != null && !parent.data.isSuperset(properties.data)) return false;\n      return true;\n    });\n  }).filter(function (exists) {\n    return exists;\n  }).toOrderedSet().toList();\n  editor.withoutNormalizing(function () {\n    inlines.forEach(function (inline) {\n      var parent = editor.value.document.getParent(inline.key);\n      var index = parent.nodes.indexOf(inline);\n      inline.nodes.forEach(function (child, i) {\n        editor.moveNodeByKey(child.key, parent.key, index + i);\n      });\n      editor.removeNodeByKey(inline.key);\n    });\n  });\n};\n/**\n * Wrap all of the blocks in a `range` in a new `block`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Block|Object|String} block\n */\n\n\nCommands$1.wrapBlockAtRange = function (editor, range, block) {\n  block = Block.create(block);\n  block = block.set('nodes', block.nodes.clear());\n  var value = editor.value;\n  var document = value.document;\n  var blocks = document.getLeafBlocksAtRange(range);\n  var firstblock = blocks.first();\n  var lastblock = blocks.last();\n  var parent = void 0,\n      siblings = void 0,\n      index = void 0; // If there is only one block in the selection then we know the parent and\n  // siblings.\n\n  if (blocks.length === 1) {\n    parent = document.getParent(firstblock.key);\n    siblings = blocks;\n  } else {\n    // Determine closest shared parent to all blocks in selection.\n    parent = document.getClosest(firstblock.key, function (p1) {\n      return !!document.getClosest(lastblock.key, function (p2) {\n        return p1 === p2;\n      });\n    });\n  } // If no shared parent could be found then the parent is the document.\n\n\n  if (parent == null) parent = document; // Create a list of direct children siblings of parent that fall in the\n  // selection.\n\n  if (siblings == null) {\n    var indexes = parent.nodes.reduce(function (ind, node, i) {\n      if (node === firstblock || node.hasDescendant(firstblock.key)) ind[0] = i;\n      if (node === lastblock || node.hasDescendant(lastblock.key)) ind[1] = i;\n      return ind;\n    }, []);\n    index = indexes[0];\n    siblings = parent.nodes.slice(indexes[0], indexes[1] + 1);\n  } // Get the index to place the new wrapped node at.\n\n\n  if (index == null) {\n    index = parent.nodes.indexOf(siblings.first());\n  }\n\n  editor.withoutNormalizing(function () {\n    // Inject the new block node into the parent.\n    editor.insertNodeByKey(parent.key, index, block); // Move the sibling nodes into the new block node.\n\n    siblings.forEach(function (node, i) {\n      editor.moveNodeByKey(node.key, block.key, i);\n    });\n  });\n};\n/**\n * Wrap the text and inlines in a `range` in a new `inline`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Inline|Object|String} inline\n */\n\n\nCommands$1.wrapInlineAtRange = function (editor, range, inline) {\n  var value = editor.value;\n  var document = value.document;\n  var start = range.start,\n      end = range.end;\n\n  if (range.isCollapsed) {\n    // Wrapping an inline void\n    var inlineParent = document.getClosestInline(start.path);\n\n    if (!inlineParent) {\n      return;\n    }\n\n    if (!editor.isVoid(inlineParent)) {\n      return;\n    }\n\n    return editor.wrapInlineByKey(inlineParent.key, inline);\n  }\n\n  inline = Inline.create(inline);\n  inline = inline.set('nodes', inline.nodes.clear());\n  var blocks = document.getLeafBlocksAtRange(range);\n  var startBlock = document.getClosestBlock(start.path);\n  var endBlock = document.getClosestBlock(end.path);\n  var startInline = document.getClosestInline(start.path);\n  var endInline = document.getClosestInline(end.path);\n  var startChild = startBlock.getFurthestChild(start.key);\n  var endChild = endBlock.getFurthestChild(end.key);\n  editor.withoutNormalizing(function () {\n    if (!startInline || startInline !== endInline) {\n      editor.splitDescendantsByKey(endChild.key, end.key, end.offset);\n      editor.splitDescendantsByKey(startChild.key, start.key, start.offset);\n    }\n\n    document = editor.value.document;\n    startBlock = document.getDescendant(startBlock.key);\n    endBlock = document.getDescendant(endBlock.key);\n    startChild = startBlock.getFurthestChild(start.key);\n    endChild = endBlock.getFurthestChild(end.key);\n    var startIndex = startBlock.nodes.indexOf(startChild);\n    var endIndex = endBlock.nodes.indexOf(endChild);\n\n    if (startInline && startInline === endInline) {\n      var texts = startBlock.getTextsAtRange(range).map(function (text) {\n        if (start.key === text.key && end.key === text.key) {\n          return text.splitText(start.offset)[1].splitText(end.offset - start.offset)[0].regenerateKey();\n        } else if (start.key === text.key) {\n          return text.splitText(start.offset)[1].regenerateKey();\n        } else if (end.key === text.key) {\n          return text.splitText(end.offset)[0].regenerateKey();\n        } else {\n          return text.regenerateKey();\n        }\n      });\n      inline = inline.set('nodes', texts);\n      editor.insertInlineAtRange(range, inline);\n    } else if (startBlock === endBlock) {\n      document = editor.value.document;\n      startBlock = document.getClosestBlock(start.key);\n      startChild = startBlock.getFurthestChild(start.key);\n      var startInner = document.getNextSibling(startChild.key);\n      var startInnerIndex = startBlock.nodes.indexOf(startInner);\n      var endInner = start.key === end.key ? startInner : startBlock.getFurthestChild(end.key);\n      var inlines = startBlock.nodes.skipUntil(function (n) {\n        return n === startInner;\n      }).takeUntil(function (n) {\n        return n === endInner;\n      }).push(endInner);\n      var node = inline.regenerateKey();\n      editor.insertNodeByKey(startBlock.key, startInnerIndex, node);\n      inlines.forEach(function (child, i) {\n        editor.moveNodeByKey(child.key, node.key, i);\n      });\n    } else {\n      var startInlines = startBlock.nodes.slice(startIndex + 1);\n      var endInlines = endBlock.nodes.slice(0, endIndex + 1);\n      var startNode = inline.regenerateKey();\n      var endNode = inline.regenerateKey();\n      editor.insertNodeByKey(startBlock.key, startIndex + 1, startNode);\n      editor.insertNodeByKey(endBlock.key, endIndex, endNode);\n      startInlines.forEach(function (child, i) {\n        editor.moveNodeByKey(child.key, startNode.key, i);\n      });\n      endInlines.forEach(function (child, i) {\n        editor.moveNodeByKey(child.key, endNode.key, i);\n      });\n      blocks.slice(1, -1).forEach(function (block) {\n        var node = inline.regenerateKey();\n        editor.insertNodeByKey(block.key, 0, node);\n        block.nodes.forEach(function (child, i) {\n          editor.moveNodeByKey(child.key, node.key, i);\n        });\n      });\n    }\n  });\n};\n/**\n * Wrap the text in a `range` in a prefix/suffix.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {String} prefix\n * @param {String} suffix (optional)\n */\n\n\nCommands$1.wrapTextAtRange = function (editor, range, prefix) {\n  var suffix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : prefix;\n  var start = range.start,\n      end = range.end;\n  var startRange = range.moveToStart();\n  var endRange = range.moveToEnd();\n\n  if (start.path.equals(end.path)) {\n    endRange = endRange.moveForward(prefix.length);\n  }\n\n  editor.withoutNormalizing(function () {\n    editor.insertTextAtRange(startRange, prefix);\n    editor.insertTextAtRange(endRange, suffix);\n  });\n};\n/**\n * Commands.\n *\n * @type {Object}\n */\n\n\nvar Commands$2 = {};\n/**\n * Add mark to text at `offset` and `length` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mixed} mark\n */\n\nCommands$2.addMarkByPath = function (editor, path, offset, length, mark) {\n  mark = Mark.create(mark);\n  editor.addMarksByPath(path, offset, length, [mark]);\n};\n\nCommands$2.addMarksByPath = function (editor, path, offset, length, marks) {\n  marks = Mark.createSet(marks);\n\n  if (!marks.size) {\n    return;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var node = document.assertNode(path);\n  editor.withoutNormalizing(function () {\n    // If it ends before the end of the node, we'll need to split to create a new\n    // text with different marks.\n    if (offset + length < node.text.length) {\n      editor.splitNodeByPath(path, offset + length);\n    } // Same thing if it starts after the start. But in that case, we need to\n    // update our path and offset to point to the new start.\n\n\n    if (offset > 0) {\n      editor.splitNodeByPath(path, offset);\n      path = PathUtils.increment(path);\n      offset = 0;\n    }\n\n    marks.forEach(function (mark) {\n      editor.applyOperation({\n        type: 'add_mark',\n        path: path,\n        mark: Mark.create(mark)\n      });\n    });\n  });\n};\n/**\n * Sets specific set of marks on the path\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Array<Object|Mark>} marks\n */\n\n\nCommands$2.replaceMarksByPath = function (editor, path, offset, length, marks) {\n  var marksSet = Mark.createSet(marks);\n  var value = editor.value;\n  var document = value.document;\n  var node = document.assertNode(path);\n\n  if (node.marks.equals(marksSet)) {\n    return;\n  }\n\n  editor.withoutNormalizing(function () {\n    // If it ends before the end of the node, we'll need to split to create a new\n    // text with different marks.\n    if (offset + length < node.text.length) {\n      editor.splitNodeByPath(path, offset + length);\n    } // Same thing if it starts after the start. But in that case, we need to\n    // update our path and offset to point to the new start.\n\n\n    if (offset > 0) {\n      editor.splitNodeByPath(path, offset);\n      path = PathUtils.increment(path);\n      offset = 0;\n    }\n\n    var marksToApply = marksSet.subtract(node.marks);\n    var marksToRemove = node.marks.subtract(marksSet);\n    marksToRemove.forEach(function (mark) {\n      editor.applyOperation({\n        type: 'remove_mark',\n        path: path,\n        mark: Mark.create(mark)\n      });\n    });\n    marksToApply.forEach(function (mark) {\n      editor.applyOperation({\n        type: 'add_mark',\n        path: path,\n        mark: Mark.create(mark)\n      });\n    });\n  });\n};\n/**\n * Insert a `fragment` at `index` in a node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} index\n * @param {Fragment} fragment\n */\n\n\nCommands$2.insertFragmentByPath = function (editor, path, index, fragment) {\n  fragment.nodes.forEach(function (node, i) {\n    editor.insertNodeByPath(path, index + i, node);\n  });\n};\n/**\n * Insert a `node` at `index` in a node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} index\n * @param {Node} node\n */\n\n\nCommands$2.insertNodeByPath = function (editor, path, index, node) {\n  editor.applyOperation({\n    type: 'insert_node',\n    path: path.concat(index),\n    node: node\n  });\n};\n/**\n * Insert `text` at `offset` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\n\nCommands$2.insertTextByPath = function (editor, path, offset, text, marks) {\n  var value = editor.value;\n  var annotations = value.annotations,\n      document = value.document;\n  document.assertNode(path);\n  editor.withoutNormalizing(function () {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = annotations.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var annotation = _step.value;\n        var start = annotation.start,\n            end = annotation.end;\n        var isAtomic = editor.isAtomic(annotation);\n\n        if (!isAtomic) {\n          continue;\n        }\n\n        if (!start.path.equals(path)) {\n          continue;\n        }\n\n        if (start.offset < offset && (!end.path.equals(path) || end.offset > offset)) {\n          editor.removeAnnotation(annotation);\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    editor.applyOperation({\n      type: 'insert_text',\n      path: path,\n      offset: offset,\n      text: text\n    });\n\n    if (marks) {\n      editor.replaceMarksByPath(path, offset, text.length, marks);\n    }\n  });\n};\n/**\n * Merge a node by `path` with the previous node.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\n\nCommands$2.mergeNodeByPath = function (editor, path) {\n  var value = editor.value;\n  var document = value.document;\n  var original = document.getDescendant(path);\n  var previous = document.getPreviousSibling(path);\n\n  if (!previous) {\n    throw new Error('Unable to merge node with path \"' + path + '\", because it has no previous sibling.');\n  }\n\n  var position = previous.object === 'text' ? previous.text.length : previous.nodes.size;\n  editor.applyOperation({\n    type: 'merge_node',\n    path: path,\n    position: position,\n    // for undos to succeed we only need the type and data because\n    // these are the only properties that get changed in the merge operation\n    properties: {\n      type: original.type,\n      data: original.data\n    },\n    target: null\n  });\n};\n/**\n * Move a node by `path` to a new parent by `newParentPath` and `newIndex`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {String} newParentPath\n * @param {Number} newIndex\n */\n\n\nCommands$2.moveNodeByPath = function (editor, path, newParentPath, newIndex) {\n  // If the operation path and newParentPath are the same,\n  // this should be considered a NOOP\n  if (PathUtils.isEqual(path, newParentPath)) {\n    return editor;\n  }\n\n  var newPath = newParentPath.concat(newIndex);\n\n  if (PathUtils.isEqual(path, newPath)) {\n    return editor;\n  }\n\n  editor.applyOperation({\n    type: 'move_node',\n    path: path,\n    newPath: newPath\n  });\n};\n/**\n * Remove mark from text at `offset` and `length` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n */\n\n\nCommands$2.removeMarkByPath = function (editor, path, offset, length, mark) {\n  mark = Mark.create(mark);\n  editor.removeMarksByPath(path, offset, length, [mark]);\n};\n\nCommands$2.removeMarksByPath = function (editor, path, offset, length, marks) {\n  marks = Mark.createSet(marks);\n\n  if (!marks.size) {\n    return;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var node = document.assertNode(path);\n\n  if (marks.intersect(node.marks).isEmpty()) {\n    return;\n  }\n\n  editor.withoutNormalizing(function () {\n    // If it ends before the end of the node, we'll need to split to create a new\n    // text with different marks.\n    if (offset + length < node.text.length) {\n      editor.splitNodeByPath(path, offset + length);\n    } // Same thing if it starts after the start. But in that case, we need to\n    // update our path and offset to point to the new start.\n\n\n    if (offset > 0) {\n      editor.splitNodeByPath(path, offset);\n      path = PathUtils.increment(path);\n      offset = 0;\n    }\n\n    marks.forEach(function (mark) {\n      editor.applyOperation({\n        type: 'remove_mark',\n        path: path,\n        offset: offset,\n        length: length,\n        mark: mark\n      });\n    });\n  });\n};\n/**\n * Remove all `marks` from node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\n\nCommands$2.removeAllMarksByPath = function (editor, path) {\n  var state = editor.state;\n  var document = state.document;\n  var node = document.assertNode(path);\n  editor.withoutNormalizing(function () {\n    if (node.object === 'text') {\n      editor.removeMarksByPath(path, 0, node.text.length, node.marks);\n      return;\n    }\n\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = node.texts()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var _ref = _step2.value;\n\n        var _ref2 = slicedToArray(_ref, 2);\n\n        var n = _ref2[0];\n        var p = _ref2[1];\n        var pth = path.concat(p);\n        editor.removeMarksByPath(pth, 0, n.text.length, n.marks);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  });\n};\n/**\n * Remove a node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\n\nCommands$2.removeNodeByPath = function (editor, path) {\n  var value = editor.value;\n  var document = value.document;\n  var node = document.assertNode(path);\n  editor.applyOperation({\n    type: 'remove_node',\n    path: path,\n    node: node\n  });\n};\n/**\n * Remove text at `offset` and `length` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n */\n\n\nCommands$2.removeTextByPath = function (editor, path, offset, length) {\n  var value = editor.value;\n  var document = value.document,\n      annotations = value.annotations;\n  var node = document.assertNode(path);\n  var text = node.text.slice(offset, offset + length);\n  editor.withoutNormalizing(function () {\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = annotations.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var annotation = _step3.value;\n        var start = annotation.start,\n            end = annotation.end;\n        var isAtomic = editor.isAtomic(annotation);\n\n        if (!isAtomic) {\n          continue;\n        }\n\n        if (!start.path.equals(path)) {\n          continue;\n        }\n\n        if (start.offset < offset && (!end.path.equals(path) || end.offset > offset)) {\n          editor.removeAnnotation(annotation);\n        }\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    editor.applyOperation({\n      type: 'remove_text',\n      path: path,\n      offset: offset,\n      text: text\n    });\n  });\n};\n/**\n`* Replace a `node` with another `node`\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Object|Node} node\n */\n\n\nCommands$2.replaceNodeByPath = function (editor, path, newNode) {\n  newNode = Node.create(newNode);\n  var index = path.last();\n  var parentPath = PathUtils.lift(path);\n  editor.withoutNormalizing(function () {\n    editor.removeNodeByPath(path);\n    editor.insertNodeByPath(parentPath, index, newNode);\n  });\n};\n/**\n * Replace a `length` of text at `offset` with new `text` and optional `marks`.\n *\n * @param {Editor} editor\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {string} text\n * @param {Set<Mark>} marks (optional)\n */\n\n\nCommands$2.replaceTextByPath = function (editor, path, offset, length, text, marks) {\n  editor.withoutNormalizing(function () {\n    editor.removeTextByPath(path, offset, length);\n    editor.insertTextByPath(path, offset, text, marks);\n  });\n};\n/**\n * Set `newProperties` on mark on text at `offset` and `length` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Object|Mark} properties\n * @param {Object} newProperties\n */\n\n\nCommands$2.setMarkByPath = function (editor, path, offset, length, properties, newProperties) {\n  properties = Mark.create(properties);\n  newProperties = Mark.createProperties(newProperties);\n  var value = editor.value;\n  var document = value.document;\n  var node = document.assertNode(path);\n  editor.withoutNormalizing(function () {\n    // If it ends before the end of the node, we'll need to split to create a new\n    // text with different marks.\n    if (offset + length < node.text.length) {\n      editor.splitNodeByPath(path, offset + length);\n    } // Same thing if it starts after the start. But in that case, we need to\n    // update our path and offset to point to the new start.\n\n\n    if (offset > 0) {\n      editor.splitNodeByPath(path, offset);\n      path = PathUtils.increment(path);\n      offset = 0;\n    }\n\n    editor.applyOperation({\n      type: 'set_mark',\n      path: path,\n      properties: properties,\n      newProperties: newProperties\n    });\n  });\n};\n/**\n * Set `properties` on a node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Object|String} newProperties\n */\n\n\nCommands$2.setNodeByPath = function (editor, path, newProperties) {\n  var value = editor.value;\n  var document = value.document;\n  var node = document.assertNode(path);\n  newProperties = Node.createProperties(newProperties);\n  var prevProperties = pick(node, Object.keys(newProperties));\n  editor.applyOperation({\n    type: 'set_node',\n    path: path,\n    properties: prevProperties,\n    newProperties: newProperties\n  });\n};\n/**\n * Insert `text` at `offset` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\n\nCommands$2.setTextByPath = function (editor, path, text, marks) {\n  var value = editor.value;\n  var document = value.document;\n  var node = document.assertNode(path);\n  var end = node.text.length;\n  editor.replaceTextByPath(path, 0, end, text, marks);\n};\n/**\n * Split a node by `path` at `position`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} position\n * @param {Object} options\n */\n\n\nCommands$2.splitNodeByPath = function (editor, path, position) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$target = options.target,\n      target = _options$target === undefined ? null : _options$target;\n  var value = editor.value;\n  var document = value.document;\n  var node = document.getDescendant(path);\n  editor.applyOperation({\n    type: 'split_node',\n    path: path,\n    position: position,\n    target: target,\n    properties: {\n      type: node.type,\n      data: node.data\n    }\n  });\n};\n/**\n * Split a node deeply down the tree by `path`, `textPath` and `textOffset`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Array} textPath\n * @param {Number} textOffset\n */\n\n\nCommands$2.splitDescendantsByPath = function (editor, path, textPath, textOffset) {\n  if (path.equals(textPath)) {\n    editor.splitNodeByPath(textPath, textOffset);\n    return;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var index = textOffset;\n  var lastPath = textPath;\n  editor.withoutNormalizing(function () {\n    editor.splitNodeByKey(textPath, textOffset);\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = document.ancestors(textPath)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var _ref3 = _step4.value;\n\n        var _ref4 = slicedToArray(_ref3, 2);\n\n        var ancestorPath = _ref4[1];\n        var target = index;\n        index = lastPath.last() + 1;\n        lastPath = ancestorPath;\n        editor.splitNodeByPath(ancestorPath, index, {\n          target: target\n        });\n\n        if (ancestorPath.equals(path)) {\n          break;\n        }\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n  });\n};\n/**\n * Unwrap content from an inline parent with `properties`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Object|String} properties\n */\n\n\nCommands$2.unwrapInlineByPath = function (editor, path, properties) {\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n  var node = document.assertNode(path);\n  var first = node.getFirstText();\n  var last = node.getLastText();\n  var range = selection.moveToRangeOfNode(first, last);\n  editor.unwrapInlineAtRange(range, properties);\n};\n/**\n * Unwrap content from a block parent with `properties`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Object|String} properties\n */\n\n\nCommands$2.unwrapBlockByPath = function (editor, path, properties) {\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n  var node = document.assertNode(path);\n  var first = node.getFirstText();\n  var last = node.getLastText();\n  var range = selection.moveToRangeOfNode(first, last);\n  editor.unwrapBlockAtRange(range, properties);\n};\n/**\n * Unwrap a single node from its parent.\n *\n * If the node is surrounded with siblings, its parent will be\n * split. If the node is the only child, the parent is removed, and\n * simply replaced by the node itself.  Cannot unwrap a root node.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\n\nCommands$2.unwrapNodeByPath = function (editor, path) {\n  var value = editor.value;\n  var document = value.document;\n  document.assertNode(path);\n  var parentPath = PathUtils.lift(path);\n  var parent = document.assertNode(parentPath);\n  var index = path.last();\n  var parentIndex = parentPath.last();\n  var grandPath = PathUtils.lift(parentPath);\n  var isFirst = index === 0;\n  var isLast = index === parent.nodes.size - 1;\n  editor.withoutNormalizing(function () {\n    if (parent.nodes.size === 1) {\n      editor.moveNodeByPath(path, grandPath, parentIndex + 1);\n      editor.removeNodeByPath(parentPath);\n    } else if (isFirst) {\n      editor.moveNodeByPath(path, grandPath, parentIndex);\n    } else if (isLast) {\n      editor.moveNodeByPath(path, grandPath, parentIndex + 1);\n    } else {\n      var updatedPath = PathUtils.increment(path, 1, parentPath.size - 1);\n      updatedPath = updatedPath.set(updatedPath.size - 1, 0);\n      editor.splitNodeByPath(parentPath, index);\n      editor.moveNodeByPath(updatedPath, grandPath, parentIndex + 1);\n    }\n  });\n};\n/**\n * Unwrap all of the children of a node, by removing the node and replacing it\n * with the children in the tree.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\n\nCommands$2.unwrapChildrenByPath = function (editor, path) {\n  path = PathUtils.create(path);\n  var value = editor.value;\n  var document = value.document;\n  var node = document.assertNode(path);\n  var parentPath = PathUtils.lift(path);\n  var index = path.last();\n  var nodes = node.nodes;\n  editor.withoutNormalizing(function () {\n    nodes.reverse().forEach(function (child, i) {\n      var childIndex = nodes.size - i - 1;\n      var childPath = path.push(childIndex);\n      editor.moveNodeByPath(childPath, parentPath, index + 1);\n    });\n    editor.removeNodeByPath(path);\n  });\n};\n/**\n * Wrap a node in a block with `properties`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Block|Object|String} block\n */\n\n\nCommands$2.wrapBlockByPath = function (editor, path, block) {\n  block = Block.create(block);\n  block = block.set('nodes', block.nodes.clear());\n  var parentPath = PathUtils.lift(path);\n  var index = path.last();\n  var newPath = PathUtils.increment(path);\n  editor.withoutNormalizing(function () {\n    editor.insertNodeByPath(parentPath, index, block);\n    editor.moveNodeByPath(newPath, path, 0);\n  });\n};\n/**\n * Wrap a node in an inline with `properties`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Block|Object|String} inline\n */\n\n\nCommands$2.wrapInlineByPath = function (editor, path, inline) {\n  inline = Inline.create(inline);\n  inline = inline.set('nodes', inline.nodes.clear());\n  var parentPath = PathUtils.lift(path);\n  var index = path.last();\n  var newPath = PathUtils.increment(path);\n  editor.withoutNormalizing(function () {\n    editor.insertNodeByPath(parentPath, index, inline);\n    editor.moveNodeByPath(newPath, path, 0);\n  });\n};\n/**\n * Wrap a node by `path` with `node`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Node|Object} node\n */\n\n\nCommands$2.wrapNodeByPath = function (editor, path, node) {\n  node = Node.create(node);\n\n  if (node.object === 'block') {\n    editor.wrapBlockByPath(path, node);\n  } else if (node.object === 'inline') {\n    editor.wrapInlineByPath(path, node);\n  }\n};\n/**\n * Mix in `*ByKey` variants.\n */\n\n\nvar COMMANDS = ['addMark', 'insertFragment', 'insertNode', 'insertText', 'mergeNode', 'removeAllMarks', 'removeMark', 'removeNode', 'removeText', 'replaceMarks', 'replaceNode', 'replaceText', 'setMark', 'setNode', 'setText', 'splitNode', 'unwrapBlock', 'unwrapChildren', 'unwrapInline', 'unwrapNode', 'wrapBlock', 'wrapInline', 'wrapNode'];\n\nvar _loop = function _loop(method) {\n  Commands$2[method + 'ByKey'] = function (editor, key) {\n    for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      args[_key3 - 2] = arguments[_key3];\n    }\n\n    var value = editor.value;\n    var document = value.document;\n    var path = document.assertPath(key);\n    editor[method + 'ByPath'].apply(editor, [path].concat(args));\n  };\n};\n\nvar _iteratorNormalCompletion5 = true;\nvar _didIteratorError5 = false;\nvar _iteratorError5 = undefined;\n\ntry {\n  for (var _iterator5 = COMMANDS[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n    var method = _step5.value;\n\n    _loop(method);\n  } // Moving nodes takes two keys, so it's slightly different.\n\n} catch (err) {\n  _didIteratorError5 = true;\n  _iteratorError5 = err;\n} finally {\n  try {\n    if (!_iteratorNormalCompletion5 && _iterator5.return) {\n      _iterator5.return();\n    }\n  } finally {\n    if (_didIteratorError5) {\n      throw _iteratorError5;\n    }\n  }\n}\n\nCommands$2.moveNodeByKey = function (editor, key, newKey) {\n  for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    args[_key - 3] = arguments[_key];\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var path = document.assertPath(key);\n  var newPath = document.assertPath(newKey);\n  editor.moveNodeByPath.apply(editor, [path, newPath].concat(args));\n}; // Splitting descendants takes two keys, so it's slightly different.\n\n\nCommands$2.splitDescendantsByKey = function (editor, key, textKey) {\n  for (var _len2 = arguments.length, args = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n    args[_key2 - 3] = arguments[_key2];\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var path = document.assertPath(key);\n  var textPath = document.assertPath(textKey);\n  editor.splitDescendantsByPath.apply(editor, [path, textPath].concat(args));\n};\n/**\n * Commands.\n *\n * @type {Object}\n */\n\n\nvar Commands$3 = {};\n/**\n * Save an `operation` into the history.\n *\n * @param {Editor} editor\n * @param {Object} operation\n */\n\nCommands$3.save = function (editor, operation) {\n  var operations = editor.operations,\n      value = editor.value;\n  var data = value.data;\n  var _editor$tmp = editor.tmp,\n      save = _editor$tmp.save,\n      merge = _editor$tmp.merge;\n  if (save === false || !isValidOperation(operation)) return;\n  var undos = data.get('undos') || List();\n  var lastBatch = undos.last();\n  var lastOperation = lastBatch && lastBatch.last(); // If `merge` is non-commital, and this is not the first operation in a new\n  // editor, then merge, otherwise merge based on the last operation.\n\n  if (merge == null) {\n    if (operations.size !== 0) {\n      merge = true;\n    } else {\n      merge = shouldMerge(operation, lastOperation);\n    }\n  } // If the `merge` flag is true, add the operation to the last batch.\n\n\n  if (merge && lastBatch) {\n    var batch = lastBatch.push(operation);\n    undos = undos.pop();\n    undos = undos.push(batch);\n  } else {\n    // Otherwise, create a new batch with the operation.\n    var _batch = List([operation]);\n\n    undos = undos.push(_batch);\n  } // Constrain the history to 100 entries for memory's sake.\n\n\n  if (undos.size > 100) {\n    undos = undos.takeLast(100);\n  } // Clear the redos and update the history.\n\n\n  editor.withoutSaving(function () {\n    var redos = List();\n    var newData = data.set('undos', undos).set('redos', redos);\n    editor.setData(newData);\n  });\n};\n/**\n * Redo to the next value in the history.\n *\n * @param {Editor} editor\n */\n\n\nCommands$3.redo = function (editor) {\n  var value = editor.value;\n  var data = value.data;\n  var redos = data.get('redos') || List();\n  var undos = data.get('undos') || List();\n  var batch = redos.last();\n  if (!batch) return;\n  editor.withoutSaving(function () {\n    editor.withoutNormalizing(function () {\n      // Replay the batch of operations.\n      batch.forEach(function (op) {\n        var _op = op,\n            type = _op.type,\n            newProperties = _op.newProperties; // When the operation mutates the selection, omit its `isFocused` value to\n        // prevent the editor focus from changing during redoing.\n\n        if (type === 'set_selection') {\n          op = op.set('newProperties', omit(newProperties, 'isFocused'));\n        }\n\n        editor.applyOperation(op);\n      }); // Shift the next value into the undo stack.\n\n      redos = redos.pop();\n      undos = undos.push(batch);\n      var newData = data.set('undos', undos).set('redos', redos);\n      editor.setData(newData);\n    });\n  });\n};\n/**\n * Undo the previous operations in the history.\n *\n * @param {Editor} editor\n */\n\n\nCommands$3.undo = function (editor) {\n  var value = editor.value;\n  var data = value.data;\n  var redos = data.get('redos') || List();\n  var undos = data.get('undos') || List();\n  var batch = undos.last();\n  if (!batch) return;\n  editor.withoutSaving(function () {\n    editor.withoutNormalizing(function () {\n      // Replay the inverse of the previous operations.\n      batch.slice().reverse().map(function (op) {\n        return op.invert();\n      }).forEach(function (inverse) {\n        var _inverse = inverse,\n            type = _inverse.type,\n            newProperties = _inverse.newProperties; // When the operation mutates the selection, omit its `isFocused` value to\n        // prevent the editor focus from changing during undoing.\n\n        if (type === 'set_selection') {\n          inverse = inverse.set('newProperties', omit(newProperties, 'isFocused'));\n        }\n\n        editor.applyOperation(inverse);\n      }); // Shift the previous operations into the redo stack.\n\n      redos = redos.push(batch);\n      undos = undos.pop();\n      var newData = data.set('undos', undos).set('redos', redos);\n      editor.setData(newData);\n    });\n  });\n};\n/**\n * Apply a series of changes inside a synchronous `fn`, without merging any of\n * the new operations into previous save point in the history.\n *\n * @param {Editor} editor\n * @param {Function} fn\n */\n\n\nCommands$3.withoutMerging = function (editor, fn) {\n  var value = editor.tmp.merge;\n  editor.tmp.merge = false;\n  fn(editor);\n  editor.tmp.merge = value;\n};\n/**\n * Apply a series of changes inside a synchronous `fn`, without saving any of\n * their operations into the history.\n *\n * @param {Editor} editor\n * @param {Function} fn\n */\n\n\nCommands$3.withoutSaving = function (editor, fn) {\n  var value = editor.tmp.save;\n  editor.tmp.save = false;\n  fn(editor);\n  editor.tmp.save = value;\n};\n/**\n * Check whether to merge a new operation `o` into the previous operation `p`.\n *\n * @param {Object} o\n * @param {Object} p\n * @return {Boolean}\n */\n\n\nfunction shouldMerge(o, p) {\n  if (!p) return false;\n  var merge = o.type === 'set_selection' && p.type === 'set_selection' || o.type === 'insert_text' && p.type === 'insert_text' && o.offset === p.offset + p.text.length && o.path.equals(p.path) || o.type === 'remove_text' && p.type === 'remove_text' && o.offset + o.text.length === p.offset && o.path.equals(p.path);\n  return merge;\n}\n/**\n * Check weather an operation needs to be saved to the history\n * @param {Object} o - operation\n * @returns {Boolean}\n */\n\n\nfunction isValidOperation(o) {\n  if (o.type === 'set_selection') {\n    var _o$newProperties = o.newProperties,\n        isFocused = _o$newProperties.isFocused,\n        anchor = _o$newProperties.anchor,\n        focus = _o$newProperties.focus; // this is blur/focus operation, dont need to store it into the history\n\n    if (isFocused !== undefined && !anchor && !focus) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar Commands$4 = {};\n\nCommands$4.blur = function (editor) {\n  editor.select({\n    isFocused: false\n  });\n};\n\nCommands$4.deselect = function (editor) {\n  var range = Selection.create();\n  editor.select(range);\n};\n\nCommands$4.focus = function (editor) {\n  editor.select({\n    isFocused: true\n  });\n};\n\nCommands$4.flip = function (editor) {\n  editor.command(proxy, 'flip');\n};\n\nCommands$4.moveAnchorBackward = function (editor) {\n  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  editor.command.apply(editor, [pointBackward, 'anchor'].concat(args));\n};\n\nCommands$4.moveAnchorWordBackward = function (editor) {\n  for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n\n  editor.command.apply(editor, [pointWordBackward, 'anchor'].concat(args));\n};\n\nCommands$4.moveAnchorForward = function (editor) {\n  for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    args[_key3 - 1] = arguments[_key3];\n  }\n\n  editor.command.apply(editor, [pointForward, 'anchor'].concat(args));\n};\n\nCommands$4.moveAnchorWordForward = function (editor) {\n  for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    args[_key4 - 1] = arguments[_key4];\n  }\n\n  editor.command.apply(editor, [pointWordForward, 'anchor'].concat(args));\n};\n\nCommands$4.moveAnchorTo = function (editor) {\n  for (var _len5 = arguments.length, args = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n    args[_key5 - 1] = arguments[_key5];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveAnchorTo'].concat(args));\n};\n\nCommands$4.moveAnchorToEndOfBlock = function (editor) {\n  editor.command(pointEdgeObject, 'anchor', 'end', 'block');\n};\n\nCommands$4.moveAnchorToEndOfInline = function (editor) {\n  editor.command(pointEdgeObject, 'anchor', 'end', 'inline');\n};\n\nCommands$4.moveAnchorToEndOfDocument = function (editor) {\n  editor.moveAnchorToEndOfNode(editor.value.document).moveToAnchor();\n};\n\nCommands$4.moveAnchorToEndOfNextBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'next', 'block');\n};\n\nCommands$4.moveAnchorToEndOfNextInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'next', 'inline');\n};\n\nCommands$4.moveAnchorToEndOfNextText = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'next', 'text');\n};\n\nCommands$4.moveAnchorToEndOfNode = function (editor) {\n  for (var _len6 = arguments.length, args = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n    args[_key6 - 1] = arguments[_key6];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveAnchorToEndOfNode'].concat(args));\n};\n\nCommands$4.moveAnchorToEndOfPreviousBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'previous', 'block');\n};\n\nCommands$4.moveAnchorToEndOfPreviousInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'previous', 'inline');\n};\n\nCommands$4.moveAnchorToEndOfPreviousText = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'previous', 'text');\n};\n\nCommands$4.moveAnchorToEndOfText = function (editor) {\n  editor.command(pointEdgeObject, 'anchor', 'end', 'text');\n};\n\nCommands$4.moveAnchorToStartOfBlock = function (editor) {\n  editor.command(pointEdgeObject, 'anchor', 'start', 'block');\n};\n\nCommands$4.moveAnchorToStartOfDocument = function (editor) {\n  editor.moveAnchorToStartOfNode(editor.value.document).moveToAnchor();\n};\n\nCommands$4.moveAnchorToStartOfInline = function (editor) {\n  editor.command(pointEdgeObject, 'anchor', 'start', 'inline');\n};\n\nCommands$4.moveAnchorToStartOfNextBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'next', 'block');\n};\n\nCommands$4.moveAnchorToStartOfNextInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'next', 'inline');\n};\n\nCommands$4.moveAnchorToStartOfNextText = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'next', 'text');\n};\n\nCommands$4.moveAnchorToStartOfNode = function (editor) {\n  for (var _len7 = arguments.length, args = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n    args[_key7 - 1] = arguments[_key7];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveAnchorToStartOfNode'].concat(args));\n};\n\nCommands$4.moveAnchorToStartOfPreviousBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'previous', 'block');\n};\n\nCommands$4.moveAnchorToStartOfPreviousInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'previous', 'inline');\n};\n\nCommands$4.moveAnchorToStartOfPreviousText = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'previous', 'text');\n};\n\nCommands$4.moveAnchorToStartOfText = function (editor) {\n  editor.command(pointEdgeObject, 'anchor', 'start', 'text');\n};\n\nCommands$4.moveBackward = function (editor) {\n  var chars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  if (chars === 0) return;\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n  var start = selection.start;\n  var startBlock = document.getClosestBlock(start.key);\n  var o = startBlock.getOffset(start.key);\n  var offset = o + start.offset;\n  var text = startBlock.text;\n  var charsOffset = TextUtils.getCharOffsetBackward(text, offset, chars);\n  editor.moveAnchorBackward(charsOffset).moveFocusBackward(charsOffset);\n};\n\nCommands$4.moveWordBackward = function (editor) {\n  for (var _len8 = arguments.length, args = Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n    args[_key8 - 1] = arguments[_key8];\n  }\n\n  editor.moveFocusWordBackward.apply(editor, args).moveToFocus();\n};\n\nCommands$4.moveEndBackward = function (editor) {\n  for (var _len9 = arguments.length, args = Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\n    args[_key9 - 1] = arguments[_key9];\n  }\n\n  editor.command.apply(editor, [pointBackward, 'end'].concat(args));\n};\n\nCommands$4.moveEndWordBackward = function (editor) {\n  for (var _len10 = arguments.length, args = Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {\n    args[_key10 - 1] = arguments[_key10];\n  }\n\n  editor.command.apply(editor, [pointWordBackward, 'end'].concat(args));\n};\n\nCommands$4.moveEndForward = function (editor) {\n  for (var _len11 = arguments.length, args = Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\n    args[_key11 - 1] = arguments[_key11];\n  }\n\n  editor.command.apply(editor, [pointForward, 'end'].concat(args));\n};\n\nCommands$4.moveEndWordForward = function (editor) {\n  for (var _len12 = arguments.length, args = Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {\n    args[_key12 - 1] = arguments[_key12];\n  }\n\n  editor.command.apply(editor, [pointWordForward, 'end'].concat(args));\n};\n\nCommands$4.moveEndTo = function (editor) {\n  for (var _len13 = arguments.length, args = Array(_len13 > 1 ? _len13 - 1 : 0), _key13 = 1; _key13 < _len13; _key13++) {\n    args[_key13 - 1] = arguments[_key13];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveEndTo'].concat(args));\n};\n\nCommands$4.moveEndToEndOfBlock = function (editor) {\n  editor.command(pointEdgeObject, 'end', 'end', 'block');\n};\n\nCommands$4.moveEndToEndOfDocument = function (editor) {\n  editor.moveEndToEndOfNode(editor.value.document).moveToEnd();\n};\n\nCommands$4.moveEndToEndOfInline = function (editor) {\n  editor.command(pointEdgeObject, 'end', 'end', 'inline');\n};\n\nCommands$4.moveEndToEndOfNextBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'next', 'block');\n};\n\nCommands$4.moveEndToEndOfNextInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'next', 'inline');\n};\n\nCommands$4.moveEndToEndOfNextText = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'next', 'text');\n};\n\nCommands$4.moveEndToEndOfNode = function (editor) {\n  for (var _len14 = arguments.length, args = Array(_len14 > 1 ? _len14 - 1 : 0), _key14 = 1; _key14 < _len14; _key14++) {\n    args[_key14 - 1] = arguments[_key14];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveEndToEndOfNode'].concat(args));\n};\n\nCommands$4.moveEndToEndOfPreviousBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'previous', 'block');\n};\n\nCommands$4.moveEndToEndOfPreviousInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'previous', 'inline');\n};\n\nCommands$4.moveEndToEndOfPreviousText = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'previous', 'text');\n};\n\nCommands$4.moveEndToEndOfText = function (editor) {\n  editor.command(pointEdgeObject, 'end', 'end', 'text');\n};\n\nCommands$4.moveEndToStartOfBlock = function (editor) {\n  editor.command(pointEdgeObject, 'end', 'start', 'block');\n};\n\nCommands$4.moveEndToStartOfDocument = function (editor) {\n  editor.moveEndToStartOfNode(editor.value.document).moveToEnd();\n};\n\nCommands$4.moveEndToStartOfInline = function (editor) {\n  editor.command(pointEdgeObject, 'end', 'start', 'inline');\n};\n\nCommands$4.moveEndToStartOfNextBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'next', 'block');\n};\n\nCommands$4.moveEndToStartOfNextInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'next', 'inline');\n};\n\nCommands$4.moveEndToStartOfNextText = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'next', 'text');\n};\n\nCommands$4.moveEndToStartOfNode = function (editor) {\n  for (var _len15 = arguments.length, args = Array(_len15 > 1 ? _len15 - 1 : 0), _key15 = 1; _key15 < _len15; _key15++) {\n    args[_key15 - 1] = arguments[_key15];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveEndToStartOfNode'].concat(args));\n};\n\nCommands$4.moveEndToStartOfPreviousBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'previous', 'block');\n};\n\nCommands$4.moveEndToStartOfPreviousInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'previous', 'inline');\n};\n\nCommands$4.moveEndToStartOfPreviousText = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'previous', 'text');\n};\n\nCommands$4.moveEndToStartOfText = function (editor) {\n  editor.command(pointEdgeObject, 'end', 'start', 'text');\n};\n\nCommands$4.moveFocusBackward = function (editor) {\n  for (var _len16 = arguments.length, args = Array(_len16 > 1 ? _len16 - 1 : 0), _key16 = 1; _key16 < _len16; _key16++) {\n    args[_key16 - 1] = arguments[_key16];\n  }\n\n  editor.command.apply(editor, [pointBackward, 'focus'].concat(args));\n};\n\nCommands$4.moveFocusWordBackward = function (editor) {\n  for (var _len17 = arguments.length, args = Array(_len17 > 1 ? _len17 - 1 : 0), _key17 = 1; _key17 < _len17; _key17++) {\n    args[_key17 - 1] = arguments[_key17];\n  }\n\n  editor.command.apply(editor, [pointWordBackward, 'focus'].concat(args));\n};\n\nCommands$4.moveFocusForward = function (editor) {\n  for (var _len18 = arguments.length, args = Array(_len18 > 1 ? _len18 - 1 : 0), _key18 = 1; _key18 < _len18; _key18++) {\n    args[_key18 - 1] = arguments[_key18];\n  }\n\n  editor.command.apply(editor, [pointForward, 'focus'].concat(args));\n};\n\nCommands$4.moveFocusWordForward = function (editor) {\n  for (var _len19 = arguments.length, args = Array(_len19 > 1 ? _len19 - 1 : 0), _key19 = 1; _key19 < _len19; _key19++) {\n    args[_key19 - 1] = arguments[_key19];\n  }\n\n  editor.command.apply(editor, [pointWordForward, 'focus'].concat(args));\n};\n\nCommands$4.moveFocusTo = function (editor) {\n  for (var _len20 = arguments.length, args = Array(_len20 > 1 ? _len20 - 1 : 0), _key20 = 1; _key20 < _len20; _key20++) {\n    args[_key20 - 1] = arguments[_key20];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveFocusTo'].concat(args));\n};\n\nCommands$4.moveFocusToEndOfBlock = function (editor) {\n  editor.command(pointEdgeObject, 'focus', 'end', 'block');\n};\n\nCommands$4.moveFocusToEndOfDocument = function (editor) {\n  editor.moveFocusToEndOfNode(editor.value.document).moveToFocus();\n};\n\nCommands$4.moveFocusToEndOfInline = function (editor) {\n  editor.command(pointEdgeObject, 'focus', 'end', 'inline');\n};\n\nCommands$4.moveFocusToEndOfNextBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'next', 'block');\n};\n\nCommands$4.moveFocusToEndOfNextInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'next', 'inline');\n};\n\nCommands$4.moveFocusToEndOfNextText = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'next', 'text');\n};\n\nCommands$4.moveFocusToEndOfNode = function (editor) {\n  for (var _len21 = arguments.length, args = Array(_len21 > 1 ? _len21 - 1 : 0), _key21 = 1; _key21 < _len21; _key21++) {\n    args[_key21 - 1] = arguments[_key21];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveFocusToEndOfNode'].concat(args));\n};\n\nCommands$4.moveFocusToEndOfPreviousBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'previous', 'block');\n};\n\nCommands$4.moveFocusToEndOfPreviousInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'previous', 'inline');\n};\n\nCommands$4.moveFocusToEndOfPreviousText = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'previous', 'text');\n};\n\nCommands$4.moveFocusToEndOfText = function (editor) {\n  editor.command(pointEdgeObject, 'focus', 'end', 'text');\n};\n\nCommands$4.moveFocusToStartOfBlock = function (editor) {\n  editor.command(pointEdgeObject, 'focus', 'start', 'block');\n};\n\nCommands$4.moveFocusToStartOfDocument = function (editor) {\n  editor.moveFocusToStartOfNode(editor.value.document).moveToFocus();\n};\n\nCommands$4.moveFocusToStartOfInline = function (editor) {\n  editor.command(pointEdgeObject, 'focus', 'start', 'inline');\n};\n\nCommands$4.moveFocusToStartOfNextBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'next', 'block');\n};\n\nCommands$4.moveFocusToStartOfNextInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'next', 'inline');\n};\n\nCommands$4.moveFocusToStartOfNextText = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'next', 'text');\n};\n\nCommands$4.moveFocusToStartOfNode = function (editor) {\n  for (var _len22 = arguments.length, args = Array(_len22 > 1 ? _len22 - 1 : 0), _key22 = 1; _key22 < _len22; _key22++) {\n    args[_key22 - 1] = arguments[_key22];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveFocusToStartOfNode'].concat(args));\n};\n\nCommands$4.moveFocusToStartOfPreviousBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'previous', 'block');\n};\n\nCommands$4.moveFocusToStartOfPreviousInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'previous', 'inline');\n};\n\nCommands$4.moveFocusToStartOfPreviousText = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'previous', 'text');\n};\n\nCommands$4.moveFocusToStartOfText = function (editor) {\n  editor.command(pointEdgeObject, 'focus', 'start', 'text');\n};\n\nCommands$4.moveForward = function (editor) {\n  var chars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  if (chars === 0) return;\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n  var start = selection.start;\n  var startBlock = document.getClosestBlock(start.path);\n  var o = startBlock.getOffset(start.key);\n  var offset = o + start.offset;\n  var text = startBlock.text;\n  var charsOffset = TextUtils.getCharOffsetForward(text, offset, chars);\n  editor.moveAnchorForward(charsOffset).moveFocusForward(charsOffset);\n};\n\nCommands$4.moveWordForward = function (editor) {\n  var _editor$moveFocusWord;\n\n  for (var _len23 = arguments.length, args = Array(_len23 > 1 ? _len23 - 1 : 0), _key23 = 1; _key23 < _len23; _key23++) {\n    args[_key23 - 1] = arguments[_key23];\n  }\n\n  (_editor$moveFocusWord = editor.moveFocusWordForward.apply(editor, args)).moveToFocus.apply(_editor$moveFocusWord, args);\n};\n\nCommands$4.moveStartBackward = function (editor) {\n  for (var _len24 = arguments.length, args = Array(_len24 > 1 ? _len24 - 1 : 0), _key24 = 1; _key24 < _len24; _key24++) {\n    args[_key24 - 1] = arguments[_key24];\n  }\n\n  editor.command.apply(editor, [pointBackward, 'start'].concat(args));\n};\n\nCommands$4.moveStartWordBackward = function (editor) {\n  for (var _len25 = arguments.length, args = Array(_len25 > 1 ? _len25 - 1 : 0), _key25 = 1; _key25 < _len25; _key25++) {\n    args[_key25 - 1] = arguments[_key25];\n  }\n\n  editor.command.apply(editor, [pointWordBackward, 'start'].concat(args));\n};\n\nCommands$4.moveStartForward = function (editor) {\n  for (var _len26 = arguments.length, args = Array(_len26 > 1 ? _len26 - 1 : 0), _key26 = 1; _key26 < _len26; _key26++) {\n    args[_key26 - 1] = arguments[_key26];\n  }\n\n  editor.command.apply(editor, [pointForward, 'start'].concat(args));\n};\n\nCommands$4.moveStartWordForward = function (editor) {\n  for (var _len27 = arguments.length, args = Array(_len27 > 1 ? _len27 - 1 : 0), _key27 = 1; _key27 < _len27; _key27++) {\n    args[_key27 - 1] = arguments[_key27];\n  }\n\n  editor.command.apply(editor, [pointWordForward, 'start'].concat(args));\n};\n\nCommands$4.moveStartTo = function (editor) {\n  for (var _len28 = arguments.length, args = Array(_len28 > 1 ? _len28 - 1 : 0), _key28 = 1; _key28 < _len28; _key28++) {\n    args[_key28 - 1] = arguments[_key28];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveStartTo'].concat(args));\n};\n\nCommands$4.moveStartToEndOfBlock = function (editor) {\n  editor.command(pointEdgeObject, 'start', 'end', 'block');\n};\n\nCommands$4.moveStartToEndOfDocument = function (editor) {\n  editor.moveStartToEndOfNode(editor.value.document).moveToStart();\n};\n\nCommands$4.moveStartToEndOfInline = function (editor) {\n  editor.command(pointEdgeObject, 'start', 'end', 'inline');\n};\n\nCommands$4.moveStartToEndOfNextBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'next', 'block');\n};\n\nCommands$4.moveStartToEndOfNextInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'next', 'inline');\n};\n\nCommands$4.moveStartToEndOfNextText = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'next', 'text');\n};\n\nCommands$4.moveStartToEndOfNode = function (editor) {\n  for (var _len29 = arguments.length, args = Array(_len29 > 1 ? _len29 - 1 : 0), _key29 = 1; _key29 < _len29; _key29++) {\n    args[_key29 - 1] = arguments[_key29];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveStartToEndOfNode'].concat(args));\n};\n\nCommands$4.moveStartToEndOfPreviousBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'previous', 'block');\n};\n\nCommands$4.moveStartToEndOfPreviousInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'previous', 'inline');\n};\n\nCommands$4.moveStartToEndOfPreviousText = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'previous', 'text');\n};\n\nCommands$4.moveStartToEndOfText = function (editor) {\n  editor.command(pointEdgeObject, 'start', 'end', 'text');\n};\n\nCommands$4.moveStartToStartOfBlock = function (editor) {\n  editor.command(pointEdgeObject, 'start', 'start', 'block');\n};\n\nCommands$4.moveStartToStartOfDocument = function (editor) {\n  editor.moveStartToStartOfNode(editor.value.document).moveToStart();\n};\n\nCommands$4.moveStartToStartOfInline = function (editor) {\n  editor.command(pointEdgeObject, 'start', 'start', 'inline');\n};\n\nCommands$4.moveStartToStartOfNextBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'next', 'block');\n};\n\nCommands$4.moveStartToStartOfNextInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'next', 'inline');\n};\n\nCommands$4.moveStartToStartOfNextText = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'next', 'text');\n};\n\nCommands$4.moveStartToStartOfNode = function (editor) {\n  for (var _len30 = arguments.length, args = Array(_len30 > 1 ? _len30 - 1 : 0), _key30 = 1; _key30 < _len30; _key30++) {\n    args[_key30 - 1] = arguments[_key30];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveStartToStartOfNode'].concat(args));\n};\n\nCommands$4.moveStartToStartOfPreviousBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'previous', 'block');\n};\n\nCommands$4.moveStartToStartOfPreviousInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'previous', 'inline');\n};\n\nCommands$4.moveStartToStartOfPreviousText = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'previous', 'text');\n};\n\nCommands$4.moveStartToStartOfText = function (editor) {\n  editor.command(pointEdgeObject, 'start', 'start', 'text');\n};\n\nCommands$4.moveTo = function (editor) {\n  for (var _len31 = arguments.length, args = Array(_len31 > 1 ? _len31 - 1 : 0), _key31 = 1; _key31 < _len31; _key31++) {\n    args[_key31 - 1] = arguments[_key31];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveTo'].concat(args));\n};\n\nCommands$4.moveToAnchor = function (editor) {\n  editor.command(proxy, 'moveToAnchor');\n};\n\nCommands$4.moveToEnd = function (editor) {\n  editor.command(proxy, 'moveToEnd');\n};\n\nCommands$4.moveToEndOfBlock = function (editor) {\n  editor.moveEndToEndOfBlock().moveToEnd();\n};\n\nCommands$4.moveToEndOfDocument = function (editor) {\n  editor.moveEndToEndOfNode(editor.value.document).moveToEnd();\n};\n\nCommands$4.moveToEndOfInline = function (editor) {\n  editor.moveEndToEndOfInline().moveToEnd();\n};\n\nCommands$4.moveToEndOfNextBlock = function (editor) {\n  editor.moveEndToEndOfNextBlock().moveToEnd();\n};\n\nCommands$4.moveToEndOfNextInline = function (editor) {\n  editor.moveEndToEndOfNextInline().moveToEnd();\n};\n\nCommands$4.moveToEndOfNextText = function (editor) {\n  editor.moveEndToEndOfNextText().moveToEnd();\n};\n\nCommands$4.moveToEndOfNode = function (editor) {\n  for (var _len32 = arguments.length, args = Array(_len32 > 1 ? _len32 - 1 : 0), _key32 = 1; _key32 < _len32; _key32++) {\n    args[_key32 - 1] = arguments[_key32];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveToEndOfNode'].concat(args));\n};\n\nCommands$4.moveToEndOfPreviousBlock = function (editor) {\n  editor.moveStartToEndOfPreviousBlock().moveToStart();\n};\n\nCommands$4.moveToEndOfPreviousInline = function (editor) {\n  editor.moveStartToEndOfPreviousInline().moveToStart();\n};\n\nCommands$4.moveToEndOfPreviousText = function (editor) {\n  editor.moveStartToEndOfPreviousText().moveToStart();\n};\n\nCommands$4.moveToEndOfText = function (editor) {\n  editor.moveEndToEndOfText().moveToEnd();\n};\n\nCommands$4.moveToFocus = function (editor) {\n  editor.command(proxy, 'moveToFocus');\n};\n\nCommands$4.moveToRangeOfDocument = function (editor) {\n  editor.moveToRangeOfNode(editor.value.document);\n};\n\nCommands$4.moveToRangeOfNode = function (editor) {\n  for (var _len33 = arguments.length, args = Array(_len33 > 1 ? _len33 - 1 : 0), _key33 = 1; _key33 < _len33; _key33++) {\n    args[_key33 - 1] = arguments[_key33];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveToRangeOfNode'].concat(args));\n};\n\nCommands$4.moveToStart = function (editor) {\n  editor.command(proxy, 'moveToStart');\n};\n\nCommands$4.moveToStartOfBlock = function (editor) {\n  editor.moveStartToStartOfBlock().moveToStart();\n};\n\nCommands$4.moveToStartOfDocument = function (editor) {\n  editor.moveStartToStartOfNode(editor.value.document).moveToStart();\n};\n\nCommands$4.moveToStartOfInline = function (editor) {\n  editor.moveStartToStartOfInline().moveToStart();\n};\n\nCommands$4.moveToStartOfNextBlock = function (editor) {\n  editor.moveEndToStartOfNextBlock().moveToEnd();\n};\n\nCommands$4.moveToStartOfNextInline = function (editor) {\n  editor.moveEndToStartOfNextInline().moveToEnd();\n};\n\nCommands$4.moveToStartOfNextText = function (editor) {\n  editor.moveEndToStartOfNextText().moveToEnd();\n};\n\nCommands$4.moveToStartOfNode = function (editor) {\n  for (var _len34 = arguments.length, args = Array(_len34 > 1 ? _len34 - 1 : 0), _key34 = 1; _key34 < _len34; _key34++) {\n    args[_key34 - 1] = arguments[_key34];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveToStartOfNode'].concat(args));\n};\n\nCommands$4.moveToStartOfPreviousBlock = function (editor) {\n  editor.moveStartToStartOfPreviousBlock().moveToStart();\n};\n\nCommands$4.moveToStartOfPreviousInline = function (editor) {\n  editor.moveStartToStartOfPreviousInline().moveToStart();\n};\n\nCommands$4.moveToStartOfPreviousText = function (editor) {\n  editor.moveStartToStartOfPreviousText().moveToStart();\n};\n\nCommands$4.moveToStartOfText = function (editor) {\n  editor.moveStartToStartOfText().moveToStart();\n};\n\nCommands$4.select = function (editor, properties) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  properties = Selection.createProperties(properties);\n  var _options$snapshot = options.snapshot,\n      snapshot = _options$snapshot === undefined ? false : _options$snapshot;\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n  var newProperties = {};\n  var next = selection.setProperties(properties);\n  next = document.resolveSelection(next); // Re-compute the properties, to ensure that we get their normalized values.\n\n  properties = pick(next, Object.keys(properties)); // Remove any properties that are already equal to the current selection. And\n  // create a dictionary of the previous values for all of the properties that\n  // are being changed, for the inverse operation.\n\n  for (var k in properties) {\n    if (snapshot === true || !is(properties[k], selection[k])) {\n      newProperties[k] = properties[k];\n    }\n  } // If the selection moves, clear any marks, unless the new selection\n  // properties change the marks in some way.\n\n\n  if (selection.marks && !newProperties.marks && (newProperties.anchor || newProperties.focus)) {\n    newProperties.marks = null;\n  } // If there are no new properties to set, abort to avoid extra operations.\n\n\n  if (Object.keys(newProperties).length === 0) {\n    return;\n  } // TODO: for some reason toJSON() is required here (it breaks selections between blocks)? - 2018-10-10\n\n\n  var prevProperties = pick(selection.toJSON(), Object.keys(newProperties));\n  editor.applyOperation({\n    type: 'set_selection',\n    value: value,\n    properties: prevProperties,\n    newProperties: newProperties\n  }, snapshot ? {\n    skip: false,\n    merge: false\n  } : {});\n};\n\nCommands$4.setAnchor = function (editor) {\n  for (var _len35 = arguments.length, args = Array(_len35 > 1 ? _len35 - 1 : 0), _key35 = 1; _key35 < _len35; _key35++) {\n    args[_key35 - 1] = arguments[_key35];\n  }\n\n  editor.command.apply(editor, [proxy, 'setAnchor'].concat(args));\n};\n\nCommands$4.setEnd = function (editor) {\n  for (var _len36 = arguments.length, args = Array(_len36 > 1 ? _len36 - 1 : 0), _key36 = 1; _key36 < _len36; _key36++) {\n    args[_key36 - 1] = arguments[_key36];\n  }\n\n  editor.command.apply(editor, [proxy, 'setEnd'].concat(args));\n};\n\nCommands$4.setFocus = function (editor) {\n  for (var _len37 = arguments.length, args = Array(_len37 > 1 ? _len37 - 1 : 0), _key37 = 1; _key37 < _len37; _key37++) {\n    args[_key37 - 1] = arguments[_key37];\n  }\n\n  editor.command.apply(editor, [proxy, 'setFocus'].concat(args));\n};\n\nCommands$4.setStart = function (editor) {\n  for (var _len38 = arguments.length, args = Array(_len38 > 1 ? _len38 - 1 : 0), _key38 = 1; _key38 < _len38; _key38++) {\n    args[_key38 - 1] = arguments[_key38];\n  }\n\n  editor.command.apply(editor, [proxy, 'setStart'].concat(args));\n};\n\nCommands$4.snapshotSelection = function (editor) {\n  editor.withoutMerging(function () {\n    editor.select(editor.value.selection, {\n      snapshot: true\n    });\n  });\n};\n/**\n * Helpers.\n */\n\n\nfunction proxy(editor, method) {\n  var _editor$value$selecti;\n\n  for (var _len39 = arguments.length, args = Array(_len39 > 2 ? _len39 - 2 : 0), _key39 = 2; _key39 < _len39; _key39++) {\n    args[_key39 - 2] = arguments[_key39];\n  }\n\n  var range = (_editor$value$selecti = editor.value.selection)[method].apply(_editor$value$selecti, args);\n\n  editor.select(range);\n}\n\nfunction pointEdgeObject(editor, point, edge, object) {\n  var Point = point.slice(0, 1).toUpperCase() + point.slice(1);\n  var Edge = edge.slice(0, 1).toUpperCase() + edge.slice(1);\n  var Object = object.slice(0, 1).toUpperCase() + object.slice(1);\n  var method = 'move' + Point + 'To' + Edge + 'OfNode';\n  var getNode = object === 'text' ? 'getNode' : 'getClosest' + Object;\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n  var p = selection[point];\n  var node = document[getNode](p.key);\n  if (!node) return;\n  editor[method](node);\n}\n\nfunction pointEdgeSideObject(editor, point, edge, side, object) {\n  var Point = point.slice(0, 1).toUpperCase() + point.slice(1);\n  var Edge = edge.slice(0, 1).toUpperCase() + edge.slice(1);\n  var Side = side.slice(0, 1).toUpperCase() + side.slice(1);\n  var Object = object.slice(0, 1).toUpperCase() + object.slice(1);\n  var method = 'move' + Point + 'To' + Edge + 'OfNode';\n  var getNode = object === 'text' ? 'getNode' : 'getClosest' + Object;\n  var getDirectionNode = 'get' + Side + Object;\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n  var p = selection[point];\n  var node = document[getNode](p.key);\n  if (!node) return;\n  var target = document[getDirectionNode](node.key);\n  if (!target) return;\n  editor[method](target);\n}\n\nfunction pointBackward(editor, point) {\n  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  if (n === 0) return;\n  if (n < 0) return pointForward(editor, point, -n);\n  var Point = point.slice(0, 1).toUpperCase() + point.slice(1);\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n  var p = selection[point];\n  var hasVoidParent = document.hasVoidParent(p.path, editor); // what is this?\n\n  if (!hasVoidParent && p.offset - n >= 0) {\n    var range = selection['move' + Point + 'Backward'](n);\n    editor.select(range);\n    return;\n  }\n\n  var previous = document.getPreviousText(p.path);\n  if (!previous) return;\n  var block = document.getClosestBlock(p.path);\n  var isInBlock = block.hasNode(previous.key);\n  var isPreviousInVoid = previous && document.hasVoidParent(previous.key, editor);\n  editor['move' + Point + 'ToEndOfNode'](previous); // when is this called?\n\n  if (!hasVoidParent && !isPreviousInVoid && isInBlock) {\n    var _range = editor.value.selection['move' + Point + 'Backward'](n);\n\n    editor.select(_range);\n  }\n}\n\nfunction pointForward(editor, point) {\n  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  if (n === 0) return;\n  if (n < 0) return pointBackward(editor, point, -n);\n  var Point = point.slice(0, 1).toUpperCase() + point.slice(1);\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n  var p = selection[point];\n  var text = document.getNode(p.path);\n  var hasVoidParent = document.hasVoidParent(p.path, editor); // what is this?\n\n  if (!hasVoidParent && p.offset + n <= text.text.length) {\n    var range = selection['move' + Point + 'Forward'](n);\n    editor.select(range);\n    return;\n  }\n\n  var next = document.getNextText(p.path);\n  if (!next) return;\n  var block = document.getClosestBlock(p.path);\n  var isInBlock = block.hasNode(next.key);\n  var isNextInVoid = document.hasVoidParent(next.key, editor);\n  editor['move' + Point + 'ToStartOfNode'](next); // when is this called?\n\n  if (!hasVoidParent && !isNextInVoid && isInBlock) {\n    var _range2 = editor.value.selection['move' + Point + 'Forward'](n);\n\n    editor.select(_range2);\n  }\n}\n\nfunction pointWordBackward(editor, pointName) {\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n  var point = selection[pointName];\n  var block = document.getClosestBlock(point.key);\n  var offset = block.getOffset(point.key);\n  var o = offset + point.offset;\n  var text = block.text;\n  var n = TextUtils.getWordOffsetBackward(text, o);\n  editor.command(pointBackward, pointName, n > 0 ? n : 1);\n}\n\nfunction pointWordForward(editor, pointName) {\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n  var point = selection[pointName];\n  var block = document.getClosestBlock(point.key);\n  var offset = block.getOffset(point.key);\n  var o = offset + point.offset;\n  var text = block.text;\n  var n = TextUtils.getWordOffsetForward(text, o);\n  editor.command(pointForward, pointName, n > 0 ? n : 1);\n}\n/**\n * Commands.\n *\n * @type {Object}\n */\n\n\nvar Commands$5 = {};\n/**\n * Set `properties` on the value.\n *\n * @param {Editor} editor\n * @param {Object|Value} properties\n */\n\nCommands$5.setData = function (editor) {\n  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var value = editor.value;\n  var newProperties = Value.createProperties({\n    data: data\n  });\n  var prevProperties = pick(value, Object.keys(newProperties));\n  editor.applyOperation({\n    type: 'set_value',\n    properties: prevProperties,\n    newProperties: newProperties\n  });\n};\n\nCommands$5.addAnnotation = function (editor, annotation) {\n  annotation = Annotation.create(annotation);\n  editor.applyOperation({\n    type: 'add_annotation',\n    annotation: annotation\n  });\n};\n\nCommands$5.removeAnnotation = function (editor, annotation) {\n  annotation = Annotation.create(annotation);\n  editor.applyOperation({\n    type: 'remove_annotation',\n    annotation: annotation\n  });\n};\n\nCommands$5.setAnnotation = function (editor, annotation, newProperties) {\n  annotation = Annotation.create(annotation);\n  newProperties = Annotation.createProperties(newProperties);\n  editor.applyOperation({\n    type: 'set_annotation',\n    properties: annotation,\n    newProperties: newProperties\n  });\n};\n\nCommands$5.setAnnotations = function (editor) {\n  var annotations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var value = editor.value;\n  var newProperties = Value.createProperties({\n    annotations: annotations\n  });\n  var prevProperties = pick(value, Object.keys(newProperties));\n  editor.applyOperation({\n    type: 'set_value',\n    properties: prevProperties,\n    newProperties: newProperties\n  });\n};\n/**\n * A plugin that adds a set of queries to the editor.\n *\n * @param {Object} queries\n * @return {Object}\n */\n\n\nfunction QueriesPlugin() {\n  var queries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  /**\n   * On construct, register all the queries.\n   *\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onConstruct(editor, next) {\n    for (var query in queries) {\n      editor.registerQuery(query);\n    }\n\n    return next();\n  }\n  /**\n   * On query, if it exists in our list of queries, call it.\n   *\n   * @param {Object} query\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n\n  function onQuery(query, editor, next) {\n    var type = query.type,\n        args = query.args;\n    var fn = queries[type];\n    if (!fn) return next();\n    var ret = fn.apply(undefined, [editor].concat(toConsumableArray(args)));\n    return ret === undefined ? next() : ret;\n  }\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n\n  return {\n    onConstruct: onConstruct,\n    onQuery: onQuery\n  };\n}\n/**\n * Define a Slate error.\n *\n * @type {SlateError}\n */\n\n\nvar SlateError = function (_Error) {\n  inherits(SlateError, _Error);\n\n  function SlateError(code) {\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, SlateError);\n\n    var _this = possibleConstructorReturn(this, (SlateError.__proto__ || Object.getPrototypeOf(SlateError)).call(this, code));\n\n    _this.code = code;\n\n    for (var key in attrs) {\n      _this[key] = attrs[key];\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(_this, _this.constructor);\n    } else {\n      _this.stack = new Error().stack;\n    }\n\n    return _this;\n  }\n\n  return SlateError;\n}(Error);\n/**\n * Create a plugin from a `schema` definition.\n *\n * @param {Object} schema\n * @return {Object}\n */\n\n\nfunction SchemaPlugin(schema) {\n  var rules = schema.rules,\n      document = schema.document,\n      blocks = schema.blocks,\n      inlines = schema.inlines,\n      marks = schema.marks,\n      annotations = schema.annotations,\n      decorations = schema.decorations;\n  var schemaRules = [];\n\n  if (rules) {\n    schemaRules = schemaRules.concat(rules);\n  }\n\n  if (document) {\n    schemaRules.push(_extends({\n      match: [{\n        object: 'document'\n      }]\n    }, document));\n  }\n\n  if (blocks) {\n    for (var key in blocks) {\n      schemaRules.push(_extends({\n        match: [{\n          object: 'block',\n          type: key\n        }]\n      }, blocks[key]));\n    }\n  }\n\n  if (inlines) {\n    for (var _key in inlines) {\n      schemaRules.push(_extends({\n        match: [{\n          object: 'inline',\n          type: _key\n        }]\n      }, inlines[_key]));\n    }\n  }\n\n  if (marks) {\n    for (var _key2 in marks) {\n      schemaRules.push(_extends({\n        match: [{\n          object: 'mark',\n          type: _key2\n        }]\n      }, marks[_key2]));\n    }\n  }\n\n  if (annotations) {\n    for (var _key3 in annotations) {\n      schemaRules.push(_extends({\n        match: [{\n          object: 'annotation',\n          type: _key3\n        }]\n      }, annotations[_key3]));\n    }\n  }\n\n  if (decorations) {\n    for (var _key4 in decorations) {\n      schemaRules.push(_extends({\n        match: [{\n          object: 'decoration',\n          type: _key4\n        }]\n      }, decorations[_key4]));\n    }\n  }\n  /**\n   * Check if a `format` is atomic based on the schema rules.\n   *\n   * @param {Editor} editor\n   * @param {Format} format\n   * @return {Boolean}\n   */\n\n\n  function isAtomic(editor, format) {\n    var rule = schemaRules.find(function (r) {\n      return 'isAtomic' in r && testRules(format, r.match);\n    });\n    return rule && rule.isAtomic;\n  }\n  /**\n   * Check if a `node` is void based on the schema rules.\n   *\n   * @param {Editor} editor\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n\n  function isVoid(editor, node) {\n    var rule = schemaRules.find(function (r) {\n      return 'isVoid' in r && testRules(node, r.match);\n    });\n    return rule && rule.isVoid;\n  }\n  /**\n   * Normalize a `node` with the schema rules, returning a function that will\n   * fix the invalid node, or void if the node is valid.\n   *\n   * @param {Node} node\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Function|Void}\n   */\n\n\n  function normalizeNode(node, editor, next) {\n    var error = validateNode(node, editor, function () {});\n    if (!error) return next();\n    return function () {\n      var rule = error.rule;\n      var size = editor.operations.size; // First run the user-provided `normalize` function if one exists...\n\n      if (rule.normalize) {\n        rule.normalize(editor, error);\n      } // If the `normalize` function did not add any operations to the editor\n      // object, it can't have normalized, so run the default one.\n\n\n      if (editor.operations.size === size) {\n        defaultNormalize(editor, error);\n      }\n    };\n  }\n  /**\n   * Validate a `node` with the schema rules, returning a `SlateError` if it's\n   * invalid.\n   *\n   * @param {Node} node\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Error|Void}\n   */\n\n\n  function validateNode(node, editor, next) {\n    var matches = schemaRules.filter(function (r) {\n      return testRules(node, r.match);\n    });\n    var failure = validateRules(node, matches, schemaRules, {\n      every: true\n    });\n    if (!failure) return next();\n    var error = new SlateError(failure.code, failure);\n    return error;\n  }\n  /**\n   * On schema-related queries, respond if we can.\n   *\n   * @param {Object} query\n   * @param {Function} next\n   */\n\n\n  var queries = QueriesPlugin({\n    isAtomic: isAtomic,\n    isVoid: isVoid\n  });\n  /**\n   * Return the plugins.\n   *\n   * @type {Object}\n   */\n\n  return [{\n    normalizeNode: normalizeNode,\n    validateNode: validateNode\n  }, queries];\n}\n/**\n * Normalize an invalid value with `error` with default remedies.\n *\n * @param {Editor} editor\n * @param {SlateError} error\n */\n\n\nfunction defaultNormalize(editor, error) {\n  var code = error.code,\n      node = error.node,\n      child = error.child,\n      next = error.next,\n      previous = error.previous,\n      key = error.key,\n      mark = error.mark;\n\n  switch (code) {\n    case 'child_max_invalid':\n    case 'child_object_invalid':\n    case 'child_type_invalid':\n    case 'child_unknown':\n    case 'first_child_object_invalid':\n    case 'first_child_type_invalid':\n    case 'last_child_object_invalid':\n    case 'last_child_type_invalid':\n      {\n        return child.object === 'text' && node.object === 'block' && node.nodes.size === 1 ? editor.removeNodeByKey(node.key) : editor.removeNodeByKey(child.key);\n      }\n\n    case 'previous_sibling_object_invalid':\n    case 'previous_sibling_type_invalid':\n      {\n        return previous.object === 'text' && node.object === 'block' && node.nodes.size === 1 ? editor.removeNodeByKey(node.key) : editor.removeNodeByKey(previous.key);\n      }\n\n    case 'next_sibling_object_invalid':\n    case 'next_sibling_type_invalid':\n      {\n        return next.object === 'text' && node.object === 'block' && node.nodes.size === 1 ? editor.removeNodeByKey(node.key) : editor.removeNodeByKey(next.key);\n      }\n\n    case 'child_min_invalid':\n    case 'node_text_invalid':\n    case 'parent_object_invalid':\n    case 'parent_type_invalid':\n      {\n        return node.object === 'document' ? node.nodes.forEach(function (n) {\n          return editor.removeNodeByKey(n.key);\n        }) : editor.removeNodeByKey(node.key);\n      }\n\n    case 'node_data_invalid':\n      {\n        return node.data.get(key) === undefined && node.object !== 'document' ? editor.removeNodeByKey(node.key) : editor.setNodeByKey(node.key, {\n          data: node.data.delete(key)\n        });\n      }\n\n    case 'node_mark_invalid':\n      {\n        return node.getTexts().forEach(function (t) {\n          return editor.removeMarkByKey(t.key, 0, t.text.length, mark);\n        });\n      }\n\n    default:\n      {\n        return editor.removeNodeByKey(node.key);\n      }\n  }\n}\n/**\n * Check that an `object` matches one of a set of `rules`.\n *\n * @param {Mixed} object\n * @param {Object|Array} rules\n * @return {Boolean}\n */\n\n\nfunction testRules(object, rules) {\n  var error = validateRules(object, rules);\n  return !error;\n}\n/**\n * Validate that a `object` matches a `rule` object or array.\n *\n * @param {Mixed} object\n * @param {Object|Array} rule\n * @param {Array|Void} rules\n * @return {Error|Void}\n */\n\n\nfunction validateRules(object, rule, rules) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$every = options.every,\n      every = _options$every === undefined ? false : _options$every,\n      _options$match = options.match,\n      match = _options$match === undefined ? null : _options$match;\n\n  if (typeof rule === 'function') {\n    var valid = rule(object, match);\n    return valid ? null : fail('node_invalid', {\n      rule: rule,\n      node: object\n    });\n  }\n\n  if (Array.isArray(rule)) {\n    var array = rule.length ? rule : [{}];\n    var first = void 0;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = array[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var r = _step.value;\n\n        var _error = validateRules(object, r, rules);\n\n        first = first || _error;\n        if (every && _error) return _error;\n        if (!every && !_error) return;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return first;\n  }\n\n  var error = validateObject(object, rule) || validateType(object, rule) || validateData(object, rule) || validateMarks(object, rule) || validateText(object, rule) || validateFirst(object, rule) || validateLast(object, rule) || validateNodes(object, rule, rules);\n  return error;\n}\n\nfunction validateObject(node, rule) {\n  if (rule.object == null) return;\n  if (rule.object === node.object) return;\n  if (typeof rule.object === 'function' && rule.object(node.object)) return;\n  return fail('node_object_invalid', {\n    rule: rule,\n    node: node\n  });\n}\n\nfunction validateType(node, rule) {\n  if (rule.type == null) return;\n  if (rule.type === node.type) return;\n  if (typeof rule.type === 'function' && rule.type(node.type)) return;\n  return fail('node_type_invalid', {\n    rule: rule,\n    node: node\n  });\n}\n\nfunction validateData(node, rule) {\n  if (rule.data == null) return;\n  if (node.data == null) return;\n\n  if (typeof rule.data === 'function') {\n    if (rule.data(node.data)) return;\n    return fail('node_data_invalid', {\n      rule: rule,\n      node: node\n    });\n  }\n\n  for (var key in rule.data) {\n    var fn = rule.data[key];\n    var value = node.data && node.data.get(key);\n    var valid = typeof fn === 'function' ? fn(value) : fn === value;\n    if (valid) continue;\n    return fail('node_data_invalid', {\n      rule: rule,\n      node: node,\n      key: key,\n      value: value\n    });\n  }\n}\n\nfunction validateMarks(node, rule) {\n  if (rule.marks == null) return;\n  var marks = node.object === 'text' ? node.marks.toArray() : node.getMarks().toArray();\n\n  var _loop = function _loop(mark) {\n    var valid = rule.marks.some(function (def) {\n      return typeof def.type === 'function' ? def.type(mark.type) : def.type === mark.type;\n    });\n    if (valid) return 'continue';\n    return {\n      v: fail('node_mark_invalid', {\n        rule: rule,\n        node: node,\n        mark: mark\n      })\n    };\n  };\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = marks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var mark = _step2.value;\n\n      var _ret = _loop(mark);\n\n      switch (_ret) {\n        case 'continue':\n          continue;\n\n        default:\n          if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n}\n\nfunction validateText(node, rule) {\n  if (rule.text == null) return;\n  var text = node.text;\n  var valid = typeof rule.text === 'function' ? rule.text(text) : rule.text.test(text);\n  if (valid) return;\n  return fail('node_text_invalid', {\n    rule: rule,\n    node: node,\n    text: text\n  });\n}\n\nfunction validateFirst(node, rule) {\n  if (rule.first == null) return;\n  var first = node.nodes.first();\n  if (!first) return;\n  var error = validateRules(first, rule.first);\n  if (!error) return;\n  error.rule = rule;\n  error.node = node;\n  error.child = first;\n  error.code = error.code.replace('node_', 'first_child_');\n  return error;\n}\n\nfunction validateLast(node, rule) {\n  if (rule.last == null) return;\n  var last = node.nodes.last();\n  if (!last) return;\n  var error = validateRules(last, rule.last);\n  if (!error) return;\n  error.rule = rule;\n  error.node = node;\n  error.child = last;\n  error.code = error.code.replace('node_', 'last_child_');\n  return error;\n}\n\nfunction validateNodes(node, rule) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  if (node.nodes == null) return;\n  var children = node.nodes;\n  var defs = rule.nodes != null ? rule.nodes.slice() : [];\n  var count = 0;\n  var lastCount = 0;\n  var min = null;\n  var index = -1;\n  var def = null;\n  var max = null;\n  var child = null;\n  var previous = null;\n  var next = null;\n\n  function nextDef() {\n    if (defs.length === 0) return false;\n    def = defs.shift();\n    lastCount = count;\n    count = 0;\n    min = def.min || null;\n    max = def.max || null;\n    return true;\n  }\n\n  function nextChild() {\n    index += 1;\n    previous = index ? children.get(index - 1) : null;\n    child = children.get(index);\n    next = children.get(index + 1);\n    if (!child) return false;\n    lastCount = count;\n    count += 1;\n    return true;\n  }\n\n  function rewind() {\n    if (index > 0) {\n      index -= 1;\n      count = lastCount;\n    }\n  }\n\n  if (rule.nodes != null) {\n    nextDef();\n  }\n\n  while (nextChild()) {\n    var err = validateParent(node, child, rules) || validatePrevious(node, child, previous, index, rules) || validateNext(node, child, next, index, rules);\n    if (err) return err;\n\n    if (rule.nodes != null) {\n      if (!def) {\n        return fail('child_unknown', {\n          rule: rule,\n          node: node,\n          child: child,\n          index: index\n        });\n      }\n\n      if (def.match) {\n        var error = validateRules(child, def.match);\n\n        if (error) {\n          // Since we want to report overflow on last matching child we don't\n          // immediately check for count > max, but instead do so once we find\n          // a child that doesn't match.\n          if (max != null && count - 1 > max) {\n            rewind();\n            return fail('child_max_invalid', {\n              rule: rule,\n              node: node,\n              index: index,\n              child: children.get(index),\n              count: count,\n              limit: max\n            });\n          }\n\n          var lastMin = min; // If there are more groups after this one then child might actually\n          // be valid.\n\n          if (nextDef()) {\n            // If we've already satisfied the minimum for the current group,\n            // then we can rewind and proceed to the next group.\n            if (lastCount - 1 >= lastMin) {\n              index -= 1;\n              continue;\n            } // Otherwise we know that current value is underflowing. There are\n            // three possible causes for this...\n            // 1. There might just not be enough elements for current group, and\n            // current child is in fact the first of the next group. If so, the\n            // next def will not report errors, in which case we can rewind and\n            // report an minimum error.\n\n\n            if (validateRules(child, def.match) == null) {\n              rewind();\n              return fail('child_min_invalid', {\n                rule: rule,\n                node: node,\n                index: index,\n                count: lastCount - 1,\n                limit: lastMin\n              });\n            } // 2. The current group is underflowing, but there is also an\n            // invalid child before the next group.\n            // 3. Or the current group is not underflowing but it appears so\n            // because there's an invalid child between its members.\n            // It's either the second or third case. If it's the second then\n            // we could report an underflow, but presence of an invalid child\n            // is arguably more important, so we report it first. It also lets\n            // us avoid checking for which case exactly is it.\n\n\n            error.rule = rule;\n            error.node = node;\n            error.child = child;\n            error.index = index;\n            error.code = error.code.replace('node_', 'child_');\n            return error;\n          } // Otherwise either we exhausted the last group, in which case it's\n          // an unknown child, ...\n\n\n          if (max != null && count > max) {\n            return fail('child_unknown', {\n              rule: rule,\n              node: node,\n              child: child,\n              index: index\n            });\n          } // ... or it's an invalid child for the last group.\n\n\n          error.rule = rule;\n          error.node = node;\n          error.child = child;\n          error.index = index;\n          error.code = error.code.replace('node_', 'child_');\n          return error;\n        }\n      }\n    }\n  } // Since we want to report overflow on last matching child we don't\n  // immediately check for count > max, but do so after processing all nodes.\n\n\n  if (max != null && count > max) {\n    return fail('child_max_invalid', {\n      rule: rule,\n      node: node,\n      index: index - 1,\n      count: count,\n      child: children.get(index - 1),\n      limit: max\n    });\n  }\n\n  if (rule.nodes != null) {\n    do {\n      if (count < min) {\n        return fail('child_min_invalid', {\n          rule: rule,\n          node: node,\n          index: index,\n          count: count,\n          limit: min\n        });\n      }\n    } while (nextDef());\n  }\n}\n\nfunction validateParent(node, child, rules) {\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = rules[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var rule = _step3.value;\n      if (rule.parent == null) continue;\n      if (!testRules(child, rule.match)) continue;\n      var error = validateRules(node, rule.parent);\n      if (!error) continue;\n      error.rule = rule;\n      error.parent = node;\n      error.node = child;\n      error.code = error.code.replace('node_', 'parent_');\n      return error;\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n}\n\nfunction validatePrevious(node, child, previous, index, rules) {\n  if (!previous) return;\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = rules[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var rule = _step4.value;\n      if (rule.previous == null) continue;\n      if (!testRules(child, rule.match)) continue;\n      var error = validateRules(previous, rule.previous);\n      if (!error) continue;\n      error.rule = rule;\n      error.node = node;\n      error.child = child;\n      error.index = index;\n      error.previous = previous;\n      error.code = error.code.replace('node_', 'previous_sibling_');\n      return error;\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n}\n\nfunction validateNext(node, child, next, index, rules) {\n  if (!next) return;\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = rules[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var rule = _step5.value;\n      if (rule.next == null) continue;\n      if (!testRules(child, rule.match)) continue;\n      var error = validateRules(next, rule.next, [], {\n        match: child\n      });\n      if (!error) continue;\n      error.rule = rule;\n      error.node = node;\n      error.child = child;\n      error.index = index;\n      error.next = next;\n      error.code = error.code.replace('node_', 'next_sibling_');\n      return error;\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n}\n/**\n * Create an interim failure object with `code` and `attrs`.\n *\n * @param {String} code\n * @param {Object} attrs\n * @return {Object}\n */\n\n\nfunction fail(code, attrs) {\n  return _extends({\n    code: code\n  }, attrs);\n}\n/**\n * Ensure that an expanded selection is deleted first using the `editor.delete`\n * command. This guarantees that it uses the proper semantic \"intent\" instead of\n * using `deleteAtRange` under the covers and skipping `delete`.\n *\n * @param {Editor}\n */\n\n\nfunction deleteExpanded(editor) {\n  var value = editor.value;\n  var selection = value.selection;\n\n  if (selection.isExpanded) {\n    editor.delete();\n  }\n}\n/**\n * Commands.\n *\n * @type {Object}\n */\n\n\nvar Commands$6 = {};\n/**\n * Add a `mark` to the characters in the current selection.\n *\n * @param {Editor} editor\n * @param {Mark} mark\n */\n\nCommands$6.addMark = function (editor, mark) {\n  mark = Mark.create(mark);\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n\n  if (selection.isExpanded) {\n    editor.addMarkAtRange(selection, mark);\n  } else if (selection.marks) {\n    var marks = selection.marks.add(mark);\n    var sel = selection.set('marks', marks);\n    editor.select(sel);\n  } else {\n    var _marks = document.getActiveMarksAtRange(selection).add(mark);\n\n    var _sel = selection.set('marks', _marks);\n\n    editor.select(_sel);\n  }\n};\n/**\n * Add a list of `marks` to the characters in the current selection.\n *\n * @param {Editor} editor\n * @param {Set<Mark>|Array<Object>} marks\n */\n\n\nCommands$6.addMarks = function (editor, marks) {\n  marks.forEach(function (mark) {\n    return editor.addMark(mark);\n  });\n};\n/**\n * Delete at the current selection.\n *\n * @param {Editor} editor\n */\n\n\nCommands$6.delete = function (editor) {\n  var value = editor.value;\n  var selection = value.selection;\n  editor.deleteAtRange(selection); // COMPAT: Ensure that the selection is collapsed, because in certain cases\n  // when deleting across inline nodes, when splitting the inline node the end\n  // point of the selection will end up after the split point.\n\n  editor.moveToFocus();\n};\n/**\n * Delete backward `n` characters.\n *\n * @param {Editor} editor\n * @param {Number} n (optional)\n */\n\n\nCommands$6.deleteBackward = function (editor) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var value = editor.value;\n  var selection = value.selection;\n\n  if (selection.isExpanded) {\n    editor.delete();\n  } else {\n    editor.deleteBackwardAtRange(selection, n);\n  }\n};\n/**\n * Delete backward one character.\n *\n * @param {Editor} editor\n */\n\n\nCommands$6.deleteCharBackward = function (editor) {\n  var value = editor.value;\n  var selection = value.selection;\n\n  if (selection.isExpanded) {\n    editor.delete();\n  } else {\n    editor.deleteCharBackwardAtRange(selection);\n  }\n};\n/**\n * Delete backward one line.\n *\n * @param {Editor} editor\n */\n\n\nCommands$6.deleteLineBackward = function (editor) {\n  var value = editor.value;\n  var selection = value.selection;\n\n  if (selection.isExpanded) {\n    editor.delete();\n  } else {\n    editor.deleteLineBackwardAtRange(selection);\n  }\n};\n/**\n * Delete backward one word.\n *\n * @param {Editor} editor\n */\n\n\nCommands$6.deleteWordBackward = function (editor) {\n  var value = editor.value;\n  var selection = value.selection;\n\n  if (selection.isExpanded) {\n    editor.delete();\n  } else {\n    editor.deleteWordBackwardAtRange(selection);\n  }\n};\n/**\n * Delete backward `n` characters.\n *\n * @param {Editor} editor\n * @param {Number} n (optional)\n */\n\n\nCommands$6.deleteForward = function (editor) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var value = editor.value;\n  var selection = value.selection;\n\n  if (selection.isExpanded) {\n    editor.delete();\n  } else {\n    editor.deleteForwardAtRange(selection, n);\n  }\n};\n/**\n * Delete backward one character.\n *\n * @param {Editor} editor\n */\n\n\nCommands$6.deleteCharForward = function (editor) {\n  var value = editor.value;\n  var selection = value.selection;\n\n  if (selection.isExpanded) {\n    editor.delete();\n  } else {\n    editor.deleteCharForwardAtRange(selection);\n  }\n};\n/**\n * Delete backward one line.\n *\n * @param {Editor} editor\n */\n\n\nCommands$6.deleteLineForward = function (editor) {\n  var value = editor.value;\n  var selection = value.selection;\n\n  if (selection.isExpanded) {\n    editor.delete();\n  } else {\n    editor.deleteLineForwardAtRange(selection);\n  }\n};\n/**\n * Delete backward one word.\n *\n * @param {Editor} editor\n */\n\n\nCommands$6.deleteWordForward = function (editor) {\n  var value = editor.value;\n  var selection = value.selection;\n\n  if (selection.isExpanded) {\n    editor.delete();\n  } else {\n    editor.deleteWordForwardAtRange(selection);\n  }\n};\n/**\n * Insert a `block` at the current selection.\n *\n * @param {Editor} editor\n * @param {String|Object|Block} block\n */\n\n\nCommands$6.insertBlock = function (editor, block) {\n  deleteExpanded(editor);\n  block = Block.create(block);\n  var value = editor.value;\n  var selection = value.selection;\n  editor.insertBlockAtRange(selection, block); // If the node was successfully inserted, update the selection.\n\n  var node = editor.value.document.getNode(block.key);\n  if (node) editor.moveToEndOfNode(node);\n};\n/**\n * Insert a `fragment` at the current selection.\n *\n * @param {Editor} editor\n * @param {Document} fragment\n */\n\n\nCommands$6.insertFragment = function (editor, fragment) {\n  if (!fragment.nodes.size) return;\n  deleteExpanded(editor);\n  var value = editor.value;\n  var _value = value,\n      document = _value.document,\n      selection = _value.selection;\n  var start = selection.start;\n  var keys = Array.from(document.texts(), function (_ref) {\n    var _ref2 = slicedToArray(_ref, 1),\n        text = _ref2[0];\n\n    return text.key;\n  });\n  editor.insertFragmentAtRange(selection, fragment);\n  value = editor.value;\n  document = value.document;\n  var newTexts = document.getTexts().filter(function (n) {\n    return !keys.includes(n.key);\n  });\n  if (newTexts.size === 0) return;\n  var fragmentLength = fragment.text.length; // Either startText is still here, or we want the first un-previously known text\n\n  var startText = document.getNode(start.key) || newTexts.first(); // We want the last un-previously known text\n\n  var endText = newTexts.last() || startText;\n\n  if (startText === endText) {\n    editor.moveTo(endText.key, fragmentLength);\n    return;\n  } // Everything will be calculated relative to the first common ancestor to optimize speed\n\n\n  var parent = document.getCommonAncestor(startText.key, endText.key);\n  var startOffset = parent.getOffset(startText.key) + (start.key === startText.key ? start.offset : 0); // endText might not be the last un-previously known text node, so we precisely pick it by offset\n\n  endText = parent.getTextAtOffset(startOffset + fragmentLength - 1) || endText;\n  editor.moveTo(endText.key, startOffset + fragmentLength - parent.getOffset(endText.key));\n};\n/**\n * Insert an `inline` at the current selection.\n *\n * @param {Editor} editor\n * @param {String|Object|Inline} inline\n */\n\n\nCommands$6.insertInline = function (editor, inline) {\n  deleteExpanded(editor);\n  inline = Inline.create(inline);\n  var value = editor.value;\n  var selection = value.selection;\n  editor.insertInlineAtRange(selection, inline); // If the node was successfully inserted, update the selection.\n\n  var node = editor.value.document.getNode(inline.key);\n  if (node) editor.moveToEndOfNode(node);\n};\n/**\n * Insert a string of `text` with optional `marks` at the current selection.\n *\n * @param {Editor} editor\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\n\nCommands$6.insertText = function (editor, text, marks) {\n  deleteExpanded(editor);\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n  marks = marks || selection.marks || document.getInsertMarksAtRange(selection);\n  editor.withoutNormalizing(function () {\n    editor.insertTextAtRange(selection, text, marks); // If the text was successfully inserted, and the selection had marks on it,\n    // unset the selection's marks.\n\n    if (selection.marks && document !== editor.value.document) {\n      editor.select({\n        marks: null\n      });\n    }\n  });\n};\n/**\n * Remove a `mark` from the characters in the current selection.\n *\n * @param {Editor} editor\n * @param {Mark} mark\n */\n\n\nCommands$6.removeMark = function (editor, mark) {\n  mark = Mark.create(mark);\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n\n  if (selection.isExpanded) {\n    editor.removeMarkAtRange(selection, mark);\n  } else if (selection.marks) {\n    var marks = selection.marks.remove(mark);\n    var sel = selection.set('marks', marks);\n    editor.select(sel);\n  } else {\n    var _marks2 = document.getActiveMarksAtRange(selection).remove(mark);\n\n    var _sel2 = selection.set('marks', _marks2);\n\n    editor.select(_sel2);\n  }\n};\n/**\n * Replace an `oldMark` with a `newMark` in the characters in the current selection.\n *\n * @param {Editor} editor\n * @param {Mark} oldMark\n * @param {Mark} newMark\n */\n\n\nCommands$6.replaceMark = function (editor, oldMark, newMark) {\n  editor.removeMark(oldMark);\n  editor.addMark(newMark);\n};\n/**\n * Set the `properties` of block nodes.\n *\n * @param {Editor} editor\n * @param {Object|String} properties\n */\n\n\nCommands$6.setBlocks = function (editor, properties) {\n  var value = editor.value;\n  var selection = value.selection;\n  editor.setBlocksAtRange(selection, properties);\n};\n/**\n * Set the `properties` of inline nodes.\n *\n * @param {Editor} editor\n * @param {Object|String} properties\n */\n\n\nCommands$6.setInlines = function (editor, properties) {\n  var value = editor.value;\n  var selection = value.selection;\n  editor.setInlinesAtRange(selection, properties);\n};\n/**\n * Split the block node at the current selection, to optional `depth`.\n *\n * @param {Editor} editor\n * @param {Number} depth (optional)\n */\n\n\nCommands$6.splitBlock = function (editor) {\n  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  deleteExpanded(editor);\n  var value = editor.value;\n  var selection = value.selection,\n      document = value.document;\n  var marks = selection.marks || document.getInsertMarksAtRange(selection);\n  editor.splitBlockAtRange(selection, depth).moveToEnd();\n\n  if (marks && marks.size !== 0) {\n    editor.select({\n      marks: marks\n    });\n  }\n};\n/**\n * Split the inline nodes to optional `height`.\n *\n * @param {Editor} editor\n * @param {Number} height (optional)\n */\n\n\nCommands$6.splitInline = function (editor, height) {\n  deleteExpanded(editor);\n  var value = editor.value;\n  var selection = value.selection;\n  editor.splitInlineAtRange(selection, height);\n};\n/**\n * Add or remove a `mark` from the characters in the current selection,\n * depending on whether it's already there.\n *\n * @param {Editor} editor\n * @param {Mark} mark\n */\n\n\nCommands$6.toggleMark = function (editor, mark) {\n  mark = Mark.create(mark);\n  var value = editor.value;\n  var exists = value.activeMarks.has(mark);\n\n  if (exists) {\n    editor.removeMark(mark);\n  } else {\n    editor.addMark(mark);\n  }\n};\n/**\n * Unwrap nodes from a block with `properties`.\n *\n * @param {Editor} editor\n * @param {String|Object} properties\n */\n\n\nCommands$6.unwrapBlock = function (editor, properties) {\n  var value = editor.value;\n  var selection = value.selection;\n  editor.unwrapBlockAtRange(selection, properties);\n};\n/**\n * Unwrap nodes from an inline with `properties`.\n *\n * @param {Editor} editor\n * @param {String|Object} properties\n */\n\n\nCommands$6.unwrapInline = function (editor, properties) {\n  var value = editor.value;\n  var selection = value.selection;\n  editor.unwrapInlineAtRange(selection, properties);\n};\n/**\n * Wrap nodes in a new `block`.\n *\n * @param {Editor} editor\n * @param {Block|Object|String} block\n */\n\n\nCommands$6.wrapBlock = function (editor, block) {\n  var value = editor.value;\n  var selection = value.selection;\n  editor.wrapBlockAtRange(selection, block);\n};\n/**\n * Wrap nodes in a new `inline`.\n *\n * @param {Editor} editor\n * @param {Inline|Object|String} inline\n */\n\n\nCommands$6.wrapInline = function (editor, inline) {\n  var value = editor.value;\n  var selection = value.selection;\n  editor.wrapInlineAtRange(selection, inline);\n};\n/**\n * Wrap the current selection with prefix/suffix.\n *\n * @param {Editor} editor\n * @param {String} prefix\n * @param {String} suffix\n */\n\n\nCommands$6.wrapText = function (editor, prefix) {\n  var suffix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : prefix;\n  var value = editor.value;\n  var selection = value.selection;\n  editor.wrapTextAtRange(selection, prefix, suffix); // If the selection was collapsed, it will have moved the start offset too.\n\n  if (selection.isCollapsed) {\n    editor.moveStartBackward(prefix.length);\n  } // Adding the suffix will have pushed the end of the selection further on, so\n  // we need to move it back to account for this.\n\n\n  editor.moveEndBackward(suffix.length); // There's a chance that the selection points moved \"through\" each other,\n  // resulting in a now-incorrect selection direction.\n\n  if (selection.isForward !== editor.value.selection.isForward) {\n    editor.flip();\n  }\n};\n/**\n * A plugin that defines the core Slate logic.\n *\n * @param {Object} options\n * @return {Object}\n */\n\n\nfunction CorePlugin() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _options$plugins = options.plugins,\n      plugins = _options$plugins === undefined ? [] : _options$plugins;\n  /**\n   * The core Slate commands.\n   *\n   * @type {Object}\n   */\n\n  var commands = CommandsPlugin(_extends({}, Commands$1, Commands$2, Commands$3, Commands$4, Commands$5, Commands$6));\n  /**\n   * The core Slate queries.\n   *\n   * @type {Object}\n   */\n\n  var queries = QueriesPlugin({\n    isAtomic: function isAtomic() {\n      return false;\n    },\n    isVoid: function isVoid() {\n      return false;\n    }\n  });\n  /**\n   * The core Slate schema.\n   *\n   * @type {Object}\n   */\n\n  var schema = SchemaPlugin({\n    rules: [// Only allow block nodes in documents.\n    {\n      match: {\n        object: 'document'\n      },\n      nodes: [{\n        match: {\n          object: 'block'\n        }\n      }]\n    }, // Only allow block nodes or inline and text nodes in blocks.\n    {\n      match: {\n        object: 'block',\n        first: {\n          object: 'block'\n        }\n      },\n      nodes: [{\n        match: {\n          object: 'block'\n        }\n      }]\n    }, {\n      match: {\n        object: 'block',\n        first: [{\n          object: 'inline'\n        }, {\n          object: 'text'\n        }]\n      },\n      nodes: [{\n        match: [{\n          object: 'inline'\n        }, {\n          object: 'text'\n        }]\n      }]\n    }, // Only allow inline and text nodes in inlines.\n    {\n      match: {\n        object: 'inline'\n      },\n      nodes: [{\n        match: [{\n          object: 'inline'\n        }, {\n          object: 'text'\n        }]\n      }]\n    }, // Ensure that block and inline nodes have at least one text child.\n    {\n      match: [{\n        object: 'block'\n      }, {\n        object: 'inline'\n      }],\n      nodes: [{\n        min: 1\n      }],\n      normalize: function normalize(editor, error) {\n        var code = error.code,\n            node = error.node;\n\n        if (code === 'child_min_invalid' && node.nodes.isEmpty()) {\n          editor.insertNodeByKey(node.key, 0, Text.create());\n        }\n      }\n    }, // Ensure that inline nodes are surrounded by text nodes.\n    {\n      match: {\n        object: 'block'\n      },\n      first: [{\n        object: 'block'\n      }, {\n        object: 'text'\n      }],\n      last: [{\n        object: 'block'\n      }, {\n        object: 'text'\n      }],\n      normalize: function normalize(editor, error) {\n        var code = error.code,\n            node = error.node;\n        var text = Text.create();\n        var i = void 0;\n\n        if (code === 'first_child_object_invalid') {\n          i = 0;\n        } else if (code === 'last_child_object_invalid') {\n          i = node.nodes.size;\n        } else {\n          return;\n        }\n\n        editor.insertNodeByKey(node.key, i, text);\n      }\n    }, {\n      match: {\n        object: 'inline'\n      },\n      first: [{\n        object: 'block'\n      }, {\n        object: 'text'\n      }],\n      last: [{\n        object: 'block'\n      }, {\n        object: 'text'\n      }],\n      previous: [{\n        object: 'block'\n      }, {\n        object: 'text'\n      }],\n      next: [{\n        object: 'block'\n      }, {\n        object: 'text'\n      }],\n      normalize: function normalize(editor, error) {\n        var code = error.code,\n            node = error.node,\n            index = error.index;\n        var text = Text.create();\n        var i = void 0;\n\n        if (code === 'first_child_object_invalid') {\n          i = 0;\n        } else if (code === 'last_child_object_invalid') {\n          i = node.nodes.size;\n        } else if (code === 'previous_sibling_object_invalid') {\n          i = index;\n        } else if (code === 'next_sibling_object_invalid') {\n          i = index + 1;\n        } else {\n          return;\n        }\n\n        editor.insertNodeByKey(node.key, i, text);\n      }\n    }, // Merge adjacent text nodes with the same marks.\n    {\n      match: {\n        object: 'text'\n      },\n      next: function next(_next, match) {\n        return _next.object !== 'text' || !match.marks.equals(_next.marks);\n      },\n      normalize: function normalize(editor, error) {\n        var code = error.code,\n            next = error.next;\n\n        if (code === 'next_sibling_invalid') {\n          editor.mergeNodeByKey(next.key);\n        }\n      }\n    }, // Remove extra adjacent empty text nodes.\n    {\n      match: {\n        object: 'text'\n      },\n      previous: function previous(prev) {\n        return prev.object !== 'text' || prev.text !== '';\n      },\n      next: function next(_next2) {\n        return _next2.object !== 'text' || _next2.text !== '';\n      },\n      normalize: function normalize(editor, error) {\n        var code = error.code,\n            next = error.next,\n            previous = error.previous;\n\n        if (code === 'next_sibling_invalid') {\n          editor.removeNodeByKey(next.key);\n        } else if (code === 'previous_sibling_invalid') {\n          editor.removeNodeByKey(previous.key);\n        }\n      }\n    }]\n  });\n  /**\n   * Return the plugins.\n   *\n   * @type {Array}\n   */\n\n  return [schema].concat(toConsumableArray(plugins), [commands, queries]);\n}\n/**\n * Debug.\n *\n * @type {Function}\n */\n\n\nvar debug$2 = Debug('slate:editor');\n/**\n * Editor.\n *\n * @type {Editor}\n */\n\nvar Editor = function () {\n  /**\n   * Create a new `Editor` with `attrs`.\n   *\n   * @param {Object} attrs\n   * @param {Object} options\n   */\n  function Editor() {\n    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, Editor);\n    var _options$controller = options.controller,\n        controller = _options$controller === undefined ? this : _options$controller,\n        _options$construct = options.construct,\n        construct = _options$construct === undefined ? true : _options$construct;\n    var _attrs$onChange = attrs.onChange,\n        onChange = _attrs$onChange === undefined ? function () {} : _attrs$onChange,\n        _attrs$plugins = attrs.plugins,\n        plugins = _attrs$plugins === undefined ? [] : _attrs$plugins,\n        _attrs$readOnly = attrs.readOnly,\n        readOnly = _attrs$readOnly === undefined ? false : _attrs$readOnly,\n        _attrs$value = attrs.value,\n        value = _attrs$value === undefined ? Value.create() : _attrs$value;\n    this.controller = controller;\n    this.middleware = {};\n    this.onChange = onChange;\n    this.operations = List();\n    this.readOnly = null;\n    this.value = null;\n    this.tmp = {\n      dirty: [],\n      flushing: false,\n      merge: null,\n      normalize: true,\n      save: true\n    };\n    var core = CorePlugin({\n      plugins: plugins\n    });\n    registerPlugin(this, core);\n\n    if (construct) {\n      this.run('onConstruct');\n      this.setReadOnly(readOnly);\n      this.setValue(value, options);\n    }\n  }\n  /**\n   * Apply an `operation` to the editor, updating its value.\n   *\n   * @param {Operation|Object} operation\n   * @return {Editor}\n   */\n\n\n  createClass(Editor, [{\n    key: 'applyOperation',\n    value: function applyOperation(operation) {\n      var _this = this;\n\n      var operations = this.operations,\n          controller = this.controller;\n      var value = this.value; // Add in the current `value` in case the operation was serialized.\n\n      if (isPlainObject(operation)) {\n        operation = _extends({}, operation, {\n          value: value\n        });\n      }\n\n      operation = Operation.create(operation); // Save the operation into the history. Since `save` is a command, we need\n      // to do it without normalizing, since it would have side effects.\n\n      this.withoutNormalizing(function () {\n        controller.save(operation);\n        value = _this.value;\n      }); // Apply the operation to the value.\n\n      debug$2('apply', {\n        operation: operation\n      });\n      this.value = operation.apply(value);\n      this.operations = operations.push(operation); // Get the paths of the affected nodes, and mark them as dirty.\n\n      var newDirtyPaths = getDirtyPaths(operation);\n      var dirty = this.tmp.dirty.map(function (path) {\n        path = PathUtils.create(path);\n        var transformed = PathUtils.transform(path, operation);\n        return transformed.toArray();\n      });\n      var pathIndex = {};\n      var dirtyPaths = Array.prototype.concat.apply(newDirtyPaths, dirty);\n      this.tmp.dirty = []; // PERF: De-dupe the paths so we don't do extra normalization.\n\n      dirtyPaths.forEach(function (dirtyPath) {\n        var key = dirtyPath.join(',');\n\n        if (!pathIndex[key]) {\n          _this.tmp.dirty.push(dirtyPath);\n        }\n\n        pathIndex[key] = true;\n      }); // If we're not already, queue the flushing process on the next tick.\n\n      if (!this.tmp.flushing) {\n        this.tmp.flushing = true;\n        Promise.resolve().then(function () {\n          return _this.flush();\n        });\n      }\n\n      return controller;\n    }\n    /**\n     * Flush the editor's current change.\n     *\n     * @return {Editor}\n     */\n\n  }, {\n    key: 'flush',\n    value: function flush() {\n      this.run('onChange');\n      var value = this.value,\n          operations = this.operations,\n          controller = this.controller;\n      var change = {\n        value: value,\n        operations: operations\n      };\n      this.operations = List();\n      this.tmp.flushing = false;\n      this.onChange(change);\n      return controller;\n    }\n    /**\n     * Trigger a command by `type` with `...args`.\n     *\n     * @param {String|Function} type\n     * @param {Any} ...args\n     * @return {Editor}\n     */\n\n  }, {\n    key: 'command',\n    value: function command(type) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      var controller = this.controller;\n\n      if (typeof type === 'function') {\n        type.apply(undefined, [controller].concat(args));\n        normalizeDirtyPaths(this);\n        return controller;\n      }\n\n      debug$2('command', {\n        type: type,\n        args: args\n      });\n      var obj = {\n        type: type,\n        args: args\n      };\n      this.run('onCommand', obj);\n      normalizeDirtyPaths(this);\n      return controller;\n    }\n    /**\n     * Checks if a command by `type` has been registered.\n     *\n     * @param {String} type\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasCommand',\n    value: function hasCommand(type) {\n      var controller = this.controller;\n      var has = type in controller && controller[type].__command;\n      return has;\n    }\n    /**\n     * Checks if a query by `type` has been registered.\n     *\n     * @param {String} type\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasQuery',\n    value: function hasQuery(type) {\n      var controller = this.controller;\n      var has = type in controller && controller[type].__query;\n      return has;\n    }\n    /**\n     * Normalize all of the nodes in the document from scratch.\n     *\n     * @return {Editor}\n     */\n\n  }, {\n    key: 'normalize',\n    value: function normalize() {\n      var value = this.value,\n          controller = this.controller;\n      var document = value.document;\n      var table = document.getKeysToPathsTable();\n      var paths = Object.values(table).map(PathUtils.create);\n      this.tmp.dirty = this.tmp.dirty.concat(paths);\n      normalizeDirtyPaths(this);\n      var selection = value.selection;\n      document = value.document;\n\n      if (selection.isUnset && document.nodes.size) {\n        controller.moveToStartOfDocument();\n      }\n\n      return controller;\n    }\n    /**\n     * Ask a query by `type` with `...args`.\n     *\n     * @param {String|Function} type\n     * @param {Any} ...args\n     * @return {Any}\n     */\n\n  }, {\n    key: 'query',\n    value: function query(type) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      var controller = this.controller;\n\n      if (typeof type === 'function') {\n        return type.apply(undefined, [controller].concat(args));\n      }\n\n      debug$2('query', {\n        type: type,\n        args: args\n      });\n      var obj = {\n        type: type,\n        args: args\n      };\n      return this.run('onQuery', obj);\n    }\n    /**\n     * Register a command `type` with the editor.\n     *\n     * @param {String} type\n     * @return {Editor}\n     */\n\n  }, {\n    key: 'registerCommand',\n    value: function registerCommand(type) {\n      var _this2 = this;\n\n      var controller = this.controller;\n\n      if (type in controller && controller[type].__command) {\n        return controller;\n      }\n\n      invariant(!(type in controller), 'You cannot register a `' + type + '` command because it would overwrite an existing property of the `Editor`.');\n\n      var method = function method() {\n        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n\n        return _this2.command.apply(_this2, [type].concat(args));\n      };\n\n      controller[type] = method;\n      method.__command = true;\n      return controller;\n    }\n    /**\n     * Register a query `type` with the editor.\n     *\n     * @param {String} type\n     * @return {Editor}\n     */\n\n  }, {\n    key: 'registerQuery',\n    value: function registerQuery(type) {\n      var _this3 = this;\n\n      var controller = this.controller;\n\n      if (type in controller && controller[type].__query) {\n        return controller;\n      }\n\n      invariant(!(type in controller), 'You cannot register a `' + type + '` query because it would overwrite an existing property of the `Editor`.');\n\n      var method = function method() {\n        for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n          args[_key4] = arguments[_key4];\n        }\n\n        return _this3.query.apply(_this3, [type].concat(args));\n      };\n\n      controller[type] = method;\n      method.__query = true;\n      return controller;\n    }\n    /**\n     * Run through the middleware stack by `key` with `args`.\n     *\n     * @param {String} key\n     * @param {Any} ...args\n     * @return {Any}\n     */\n\n  }, {\n    key: 'run',\n    value: function run(key) {\n      for (var _len5 = arguments.length, args = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        args[_key5 - 1] = arguments[_key5];\n      }\n\n      var controller = this.controller,\n          middleware = this.middleware;\n      var fns = middleware[key] || [];\n      var i = 0;\n\n      function next() {\n        var fn = fns[i++];\n        if (!fn) return;\n\n        for (var _len6 = arguments.length, overrides = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n          overrides[_key6] = arguments[_key6];\n        }\n\n        if (overrides.length) {\n          args = overrides;\n        }\n\n        var ret = fn.apply(undefined, toConsumableArray(args).concat([controller, next]));\n        return ret;\n      }\n\n      Object.defineProperty(next, 'change', {\n        get: function get$$1() {\n          invariant(false, 'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.');\n        }\n      });\n      Object.defineProperty(next, 'onChange', {\n        get: function get$$1() {\n          invariant(false, 'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.');\n        }\n      });\n      Object.defineProperty(next, 'props', {\n        get: function get$$1() {\n          invariant(false, 'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.');\n        }\n      });\n      Object.defineProperty(next, 'schema', {\n        get: function get$$1() {\n          invariant(false, 'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.');\n        }\n      });\n      Object.defineProperty(next, 'stack', {\n        get: function get$$1() {\n          invariant(false, 'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.');\n        }\n      });\n      return next();\n    }\n    /**\n     * Set the `readOnly` flag.\n     *\n     * @param {Boolean} readOnly\n     * @return {Editor}\n     */\n\n  }, {\n    key: 'setReadOnly',\n    value: function setReadOnly(readOnly) {\n      this.readOnly = readOnly;\n      return this;\n    }\n    /**\n     * Set the editor's `value`.\n     *\n     * @param {Value} value\n     * @param {Options} options\n     * @return {Editor}\n     */\n\n  }, {\n    key: 'setValue',\n    value: function setValue(value) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _options$normalize = options.normalize,\n          normalize = _options$normalize === undefined ? value !== this.value : _options$normalize;\n      this.value = value;\n\n      if (normalize) {\n        this.normalize();\n      }\n\n      return this;\n    }\n    /**\n     * Apply a series of changes inside a synchronous `fn`, deferring\n     * normalization until after the function has finished executing.\n     *\n     * @param {Function} fn\n     * @return {Editor}\n     */\n\n  }, {\n    key: 'withoutNormalizing',\n    value: function withoutNormalizing(fn) {\n      var controller = this.controller;\n      var value = this.tmp.normalize;\n      this.tmp.normalize = false;\n      fn(controller);\n      this.tmp.normalize = value;\n      normalizeDirtyPaths(this);\n      return controller;\n    }\n    /**\n     * Deprecated.\n     */\n\n  }, {\n    key: 'change',\n    value: function change(fn) {\n      warning(false, 'As of Slate 0.43 the `change` object has been replaced with `editor`, so the `editor.change()` method is deprecated.`');\n\n      for (var _len7 = arguments.length, args = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n        args[_key7 - 1] = arguments[_key7];\n      }\n\n      fn.apply(undefined, [this.controller].concat(args));\n    }\n  }, {\n    key: 'call',\n    value: function call(fn) {\n      warning(false, 'As of Slate 0.43 the `editor.call(fn)` method has been deprecated, please use `editor.command(fn)` instead.');\n\n      for (var _len8 = arguments.length, args = Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n        args[_key8 - 1] = arguments[_key8];\n      }\n\n      fn.apply(undefined, [this.controller].concat(args));\n      return this.controller;\n    }\n  }, {\n    key: 'applyOperations',\n    value: function applyOperations(operations) {\n      var _this4 = this;\n\n      warning(false, 'As of Slate 0.43 the `applyOperations` method is deprecated, please apply each operation in a loop instead.');\n      operations.forEach(function (op) {\n        return _this4.applyOperation(op);\n      });\n      return this.controller;\n    }\n  }, {\n    key: 'setOperationFlag',\n    value: function setOperationFlag(key, value) {\n      warning(false, 'As of slate@0.41 the `change.setOperationFlag` method has been deprecated.');\n      this.tmp[key] = value;\n      return this;\n    }\n  }, {\n    key: 'getFlag',\n    value: function getFlag(key) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      warning(false, 'As of slate@0.41 the `change.getFlag` method has been deprecated.');\n      return options[key] !== undefined ? options[key] : this.tmp[key];\n    }\n  }, {\n    key: 'unsetOperationFlag',\n    value: function unsetOperationFlag(key) {\n      warning(false, 'As of slate@0.41 the `change.unsetOperationFlag` method has been deprecated.');\n      delete this.tmp[key];\n      return this;\n    }\n  }, {\n    key: 'withoutNormalization',\n    value: function withoutNormalization(fn) {\n      warning(false, 'As of slate@0.41 the `change.withoutNormalization` helper has been renamed to `change.withoutNormalizing`.');\n      return this.withoutNormalizing(fn);\n    }\n  }, {\n    key: 'editor',\n    get: function get$$1() {\n      warning(false, \"As of Slate 0.43 the `change` object has been replaced with `editor`, so you don't need to access `change.editor`.\");\n      return this.controller;\n    }\n  }]);\n  return Editor;\n}();\n/**\n * Get the \"dirty\" paths for a given `operation`.\n *\n * @param {Operation} operation\n * @return {Array}\n */\n\n\nfunction getDirtyPaths(operation) {\n  var type = operation.type,\n      node = operation.node,\n      path = operation.path,\n      newPath = operation.newPath;\n\n  switch (type) {\n    case 'add_mark':\n    case 'insert_text':\n    case 'remove_mark':\n    case 'remove_text':\n    case 'set_mark':\n    case 'set_node':\n      {\n        var ancestors = PathUtils.getAncestors(path).toArray();\n        return [].concat(toConsumableArray(ancestors), [path]);\n      }\n\n    case 'insert_node':\n      {\n        var table = node.getKeysToPathsTable();\n        var paths = Object.values(table).map(function (p) {\n          return path.concat(p);\n        });\n\n        var _ancestors = PathUtils.getAncestors(path).toArray();\n\n        return [].concat(toConsumableArray(_ancestors), [path], toConsumableArray(paths));\n      }\n\n    case 'split_node':\n      {\n        var _ancestors2 = PathUtils.getAncestors(path).toArray();\n\n        var nextPath = PathUtils.increment(path);\n        return [].concat(toConsumableArray(_ancestors2), [path, nextPath]);\n      }\n\n    case 'merge_node':\n      {\n        var _ancestors3 = PathUtils.getAncestors(path).toArray();\n\n        var previousPath = PathUtils.decrement(path);\n        return [].concat(toConsumableArray(_ancestors3), [previousPath]);\n      }\n\n    case 'move_node':\n      {\n        if (PathUtils.isEqual(path, newPath)) {\n          return [];\n        }\n\n        var oldAncestors = PathUtils.getAncestors(path).reduce(function (arr, p) {\n          arr.push.apply(arr, toConsumableArray(PathUtils.transform(p, operation).toArray()));\n          return arr;\n        }, []);\n        var newAncestors = PathUtils.getAncestors(newPath).reduce(function (arr, p) {\n          arr.push.apply(arr, toConsumableArray(PathUtils.transform(p, operation).toArray()));\n          return arr;\n        }, []);\n        return [].concat(toConsumableArray(oldAncestors), toConsumableArray(newAncestors));\n      }\n\n    case 'remove_node':\n      {\n        var _ancestors4 = PathUtils.getAncestors(path).toArray();\n\n        return [].concat(toConsumableArray(_ancestors4));\n      }\n\n    default:\n      {\n        return [];\n      }\n  }\n}\n/**\n * Normalize any new \"dirty\" paths that have been added to the change.\n *\n * @param {Editor}\n */\n\n\nfunction normalizeDirtyPaths(editor) {\n  if (!editor.tmp.normalize) {\n    return;\n  }\n\n  if (!editor.tmp.dirty.length) {\n    return;\n  }\n\n  editor.withoutNormalizing(function () {\n    while (editor.tmp.dirty.length) {\n      var path = editor.tmp.dirty.pop();\n      normalizeNodeByPath(editor, path);\n    }\n  });\n}\n/**\n * Normalize the node at a specific `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\n\nfunction normalizeNodeByPath(editor, path) {\n  var controller = editor.controller;\n  var value = editor.value;\n  var _value = value,\n      document = _value.document;\n  var node = document.assertNode(path);\n  var iterations = 0;\n  var max = 100 + (node.object === 'text' ? 1 : node.nodes.size);\n\n  while (node) {\n    var fn = node.normalize(controller);\n\n    if (!fn) {\n      break;\n    } // Run the normalize `fn` to fix the node.\n\n\n    fn(controller); // Attempt to re-find the node by path, or by key if it has changed\n    // locations in the tree continue iterating.\n\n    value = editor.value;\n    document = value.document;\n    var _node = node,\n        key = _node.key;\n    var found = document.getDescendant(path);\n\n    if (found && found.key === key) {\n      node = found;\n    } else {\n      found = document.getDescendant(key);\n\n      if (found) {\n        node = found;\n        path = document.getPath(key);\n      } else {\n        // If it no longer exists by key, it was removed, so we're done.\n        break;\n      }\n    } // Increment the iterations counter, and check to make sure that we haven't\n    // exceeded the max. Without this check, it's easy for the `normalize`\n    // function of a schema rule to be written incorrectly and for an infinite\n    // invalid loop to occur.\n\n\n    iterations++;\n\n    if (iterations > max) {\n      throw new Error('A schema rule could not be normalized after sufficient iterations. This is usually due to a `rule.normalize` or `plugin.normalizeNode` function of a schema being incorrectly written, causing an infinite loop.');\n    }\n  }\n}\n/**\n * Register a `plugin` with the editor.\n *\n * @param {Editor} editor\n * @param {Object|Array|Null} plugin\n */\n\n\nfunction registerPlugin(editor, plugin) {\n  if (Array.isArray(plugin)) {\n    plugin.forEach(function (p) {\n      return registerPlugin(editor, p);\n    });\n    return;\n  }\n\n  if (plugin == null) {\n    return;\n  }\n\n  var commands = plugin.commands,\n      queries = plugin.queries,\n      schema = plugin.schema,\n      rest = objectWithoutProperties(plugin, ['commands', 'queries', 'schema']);\n\n  if (commands) {\n    var commandsPlugin = CommandsPlugin(commands);\n    registerPlugin(editor, commandsPlugin);\n  }\n\n  if (queries) {\n    var queriesPlugin = QueriesPlugin(queries);\n    registerPlugin(editor, queriesPlugin);\n  }\n\n  if (schema) {\n    var schemaPlugin = SchemaPlugin(schema);\n    registerPlugin(editor, schemaPlugin);\n  }\n\n  for (var key in rest) {\n    var fn = rest[key];\n    var middleware = editor.middleware[key] = editor.middleware[key] || [];\n    middleware.push(fn);\n  }\n}\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\n\nvar DEFAULTS$13 = {\n  marks: undefined,\n  text: undefined\n  /**\n   * Leaf.\n   *\n   * @type {Leaf}\n   */\n\n};\n\nvar Leaf$1 = function (_Record) {\n  inherits(Leaf, _Record);\n\n  function Leaf() {\n    classCallCheck(this, Leaf);\n    return possibleConstructorReturn(this, (Leaf.__proto__ || Object.getPrototypeOf(Leaf)).apply(this, arguments));\n  }\n\n  createClass(Leaf, [{\n    key: 'updateMark',\n\n    /**\n     * Update a `mark` at leaf, replace with newMark\n     *\n     * @param {Mark} mark\n     * @param {Mark} newMark\n     * @returns {Leaf}\n     */\n    value: function updateMark(mark, newMark) {\n      var marks = this.marks;\n      if (newMark.equals(mark)) return this;\n      if (!marks.has(mark)) return this;\n      var newMarks = marks.withMutations(function (collection) {\n        collection.remove(mark).add(newMark);\n      });\n      return this.set('marks', newMarks);\n    }\n    /**\n     * Add a `mark` to the leaf.\n     *\n     * @param {Mark} mark\n     * @returns {Text}\n     */\n\n  }, {\n    key: 'addMark',\n    value: function addMark(mark) {\n      var marks = this.marks;\n      return this.set('marks', marks.add(mark));\n    }\n    /**\n     * Add a `set` of marks to the leaf.\n     *\n     * @param {Set<Mark>} set\n     * @returns {Text}\n     */\n\n  }, {\n    key: 'addMarks',\n    value: function addMarks(set$$1) {\n      var marks = this.marks;\n      return this.set('marks', marks.union(set$$1));\n    }\n    /**\n     * Insert a text `string` into the leaf at `offset`.\n     *\n     * @param {Number} offset\n     * @param {String} string\n     * @return {Leaf}\n     */\n\n  }, {\n    key: 'insertText',\n    value: function insertText(offset, string) {\n      var text = this.text;\n      var next = text.slice(0, offset) + string + text.slice(offset);\n      return this.set('text', next);\n    }\n    /**\n     * Remove a `mark` from the leaf.\n     *\n     * @param {Mark} mark\n     * @returns {Text}\n     */\n\n  }, {\n    key: 'removeMark',\n    value: function removeMark(mark) {\n      var marks = this.marks;\n      return this.set('marks', marks.remove(mark));\n    }\n    /**\n     * Return a JSON representation of the leaf.\n     *\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var object = {\n        object: this.object,\n        text: this.text,\n        marks: this.marks.toArray().map(function (m) {\n          return m.toJSON();\n        })\n      };\n      return object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Leaf` with `attrs`.\n     *\n     * @param {Object|Leaf} attrs\n     * @return {Leaf}\n     */\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      warning(false, 'As of slate@0.47 the `Leaf` model is deprecated.');\n\n      if (Leaf.isLeaf(attrs)) {\n        return attrs;\n      }\n\n      if (typeof attrs === 'string') {\n        attrs = {\n          text: attrs\n        };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Leaf.fromJSON(attrs);\n      }\n\n      throw new Error('`Leaf.create` only accepts objects, strings or leaves, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a valid List of `Leaf` from `leaves`\n     *\n     * @param {List<Leaf>} leaves\n     * @return {List<Leaf>}\n     */\n\n  }, {\n    key: 'createLeaves',\n    value: function createLeaves(leaves) {\n      if (leaves.size <= 1) return leaves;\n      var invalid = false; // TODO: we can make this faster with [List] and then flatten\n\n      var result = List().withMutations(function (cache) {\n        // Search from the leaves left end to find invalid node;\n        leaves.findLast(function (leaf, index) {\n          var firstLeaf = cache.first(); // If the first leaf of cache exist, check whether the first leaf is connectable with the current leaf\n\n          if (firstLeaf) {\n            // If marks equals, then the two leaves can be connected\n            if (firstLeaf.marks.equals(leaf.marks)) {\n              invalid = true;\n              cache.set(0, firstLeaf.set('text', '' + leaf.text + firstLeaf.text));\n              return;\n            } // If the cached leaf is empty, drop the empty leaf with the upcoming leaf\n\n\n            if (firstLeaf.text === '') {\n              invalid = true;\n              cache.set(0, leaf);\n              return;\n            } // If the current leaf is empty, drop the leaf\n\n\n            if (leaf.text === '') {\n              invalid = true;\n              return;\n            }\n          }\n\n          cache.unshift(leaf);\n        });\n      });\n      if (!invalid) return leaves;\n      return result;\n    }\n    /**\n     * Split a list of leaves to two lists; if the leaves are valid leaves, the returned leaves are also valid\n     * Corner Cases:\n     *   1. if offset is smaller than 0, then return [List(), leaves]\n     *   2. if offset is bigger than the text length, then return [leaves, List()]\n     *\n     * @param {List<Leaf> leaves\n     * @return {Array<List<Leaf>>}\n     */\n\n  }, {\n    key: 'splitLeaves',\n    value: function splitLeaves(leaves, offset) {\n      if (offset < 0) return [List(), leaves];\n\n      if (leaves.size === 0) {\n        return [List(), List()];\n      }\n\n      var endOffset = 0;\n      var index = -1;\n      var left = void 0,\n          right = void 0;\n      leaves.find(function (leaf) {\n        index++;\n        var startOffset = endOffset;\n        var text = leaf.text;\n        endOffset += text.length;\n        if (endOffset < offset) return false;\n        if (startOffset > offset) return false;\n        var length = offset - startOffset;\n        left = leaf.set('text', text.slice(0, length));\n        right = leaf.set('text', text.slice(length));\n        return true;\n      });\n      if (!left) return [leaves, List()];\n\n      if (left.text === '') {\n        if (index === 0) {\n          return [List.of(left), leaves];\n        }\n\n        return [leaves.take(index), leaves.skip(index)];\n      }\n\n      if (right.text === '') {\n        if (index === leaves.size - 1) {\n          return [leaves, List.of(right)];\n        }\n\n        return [leaves.take(index + 1), leaves.skip(index + 1)];\n      }\n\n      return [leaves.take(index).push(left), leaves.skip(index + 1).unshift(right)];\n    }\n    /**\n     * Create a `Leaf` list from `attrs`.\n     *\n     * @param {Array<Leaf|Object>|List<Leaf|Object>} attrs\n     * @return {List<Leaf>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (List.isList(attrs) || Array.isArray(attrs)) {\n        var list = new List(attrs.map(Leaf.create));\n        return list;\n      }\n\n      throw new Error('`Leaf.createList` only accepts arrays or lists, but you passed it: ' + attrs);\n    }\n    /**\n     * Create a `Leaf` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Leaf}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var _object$text = object.text,\n          text = _object$text === undefined ? '' : _object$text,\n          _object$marks = object.marks,\n          marks = _object$marks === undefined ? [] : _object$marks;\n      var leaf = new Leaf({\n        text: text,\n        marks: Set(marks.map(Mark.fromJSON))\n      });\n      return leaf;\n    }\n    /**\n     * Check if `any` is a list of leaves.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isLeafList',\n    value: function isLeafList(any) {\n      return List.isList(any) && any.every(function (item) {\n        return Leaf.isLeaf(item);\n      });\n    }\n  }]);\n  return Leaf;\n}(Record(DEFAULTS$13));\n/**\n * Mix in an `Interface` to a `Class`.\n *\n * @param {Class} Interface\n * @param {Class} Class\n */\n\n\nfunction mixin(Interface, Classes) {\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = Classes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var Class = _step.value; // Copy static properties from the interface.\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = Object.getOwnPropertyNames(Interface)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var name = _step2.value;\n          if (Class.hasOwnProperty(name)) continue;\n          var desc = Object.getOwnPropertyDescriptor(Interface, name);\n          Object.defineProperty(Class, name, desc);\n        } // Copy instance properties from the interface.\n\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = Object.getOwnPropertyNames(Interface.prototype)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _name = _step3.value;\n          if (Class.prototype.hasOwnProperty(_name)) continue;\n          var desc = Object.getOwnPropertyDescriptor(Interface.prototype, _name);\n          Object.defineProperty(Class.prototype, _name, desc);\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}\n/**\n * A factory for the interface that all Slate objects implement.\n *\n * @type {Function}\n */\n\n\nfunction create$2(type) {\n  var TYPE = TYPES[type];\n  var camel = '' + type.charAt(0).toUpperCase() + type.slice(1);\n  var is$$1 = 'is' + camel;\n\n  var ObjectInterface = function () {\n    function ObjectInterface() {\n      classCallCheck(this, ObjectInterface);\n    }\n\n    createClass(ObjectInterface, [{\n      key: 'object',\n\n      /**\n       * Return the type of the object.\n       *\n       * @return {String}\n       */\n      get: function get$$1() {\n        return type;\n      }\n    }]);\n    return ObjectInterface;\n  }();\n\n  ObjectInterface[is$$1] = isObject.bind(null, type);\n  ObjectInterface.prototype[TYPE] = true;\n  return ObjectInterface;\n}\n/**\n * Mix in the object interfaces.\n */\n\n\nObject.entries({\n  Annotation: Annotation,\n  Block: Block,\n  Change: Change,\n  Decoration: Decoration,\n  Document: Document,\n  Editor: Editor,\n  Inline: Inline,\n  Leaf: Leaf$1,\n  Mark: Mark,\n  Node: Node,\n  Operation: Operation,\n  Point: Point,\n  Range: Range,\n  Selection: Selection,\n  Text: Text,\n  Value: Value\n}).forEach(function (_ref) {\n  var _ref2 = slicedToArray(_ref, 2),\n      camel = _ref2[0],\n      obj = _ref2[1];\n\n  return mixin(create$2(camel.toLowerCase()), [obj]);\n});\n/**\n * The interface that all Slate models implement.\n *\n * @type {Class}\n */\n\nvar ModelInterface = function () {\n  function ModelInterface() {\n    classCallCheck(this, ModelInterface);\n  }\n\n  createClass(ModelInterface, [{\n    key: 'toJS',\n\n    /**\n     * Alias `toJS`.\n     */\n    value: function toJS() {\n      return this.toJSON.apply(this, arguments);\n    }\n  }], [{\n    key: 'fromJS',\n\n    /**\n     * Alias `fromJS`.\n     */\n    value: function fromJS() {\n      return this.fromJSON.apply(this, arguments);\n    }\n  }]);\n  return ModelInterface;\n}();\n/**\n * Mix in the common interface.\n *\n * @param {Record}\n */\n\n\nmixin(ModelInterface, [Annotation, Block, Decoration, Document, Inline, Leaf$1, Mark, Node, Operation, Point, Range, Selection, Text, Value]);\n/* global WeakMap, Map, Symbol */\n\n/**\n * GLOBAL: True if memoization should is enabled.\n *\n * @type {Boolean}\n */\n\nvar ENABLED = true;\n/**\n * The leaf node of a cache tree. Used to support variable argument length. A\n * unique object, so that native Maps will key it by reference.\n *\n * @type {Symbol}\n */\n\nvar LEAF = Symbol('LEAF');\n/**\n * The node of a cache tree for a WeakMap to store cache visited by objects\n *\n * @type {Symbol}\n */\n\nvar STORE_KEY = Symbol('STORE_KEY');\n/**\n * Values to represent a memoized undefined and null value. Allows efficient value\n * retrieval using Map.get only.\n *\n * @type {Symbol}\n */\n\nvar UNDEFINED = Symbol('undefined');\nvar NULL = Symbol('null');\n/**\n * Default value for unset keys in native Maps\n *\n * @type {Undefined}\n */\n\nvar UNSET = undefined;\n/**\n * Global Store for all cached values\n *\n * @type {WeakMap}\n */\n\nvar memoizeStore = new WeakMap();\n/**\n * Memoize all of the `properties` on a `object`.\n *\n * @param {Object} object\n * @param {Array} properties\n * @return {Record}\n */\n\nfunction memoize(object, properties) {\n  var _loop = function _loop(property) {\n    var original = object[property];\n\n    if (!original) {\n      throw new Error('Object does not have a property named \"' + property + '\".');\n    }\n\n    object[property] = function () {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      } // If memoization is disabled, call into the original method.\n\n\n      if (!ENABLED) return original.apply(this, args);\n\n      if (!memoizeStore.has(this)) {\n        memoizeStore.set(this, {\n          noArgs: {},\n          hasArgs: {}\n        });\n      }\n\n      var _memoizeStore$get = memoizeStore.get(this),\n          noArgs = _memoizeStore$get.noArgs,\n          hasArgs = _memoizeStore$get.hasArgs;\n\n      var takesArguments = args.length !== 0;\n      var cachedValue = void 0;\n      var keys = void 0;\n\n      if (takesArguments) {\n        keys = [property].concat(args);\n        cachedValue = getIn(hasArgs, keys);\n      } else {\n        cachedValue = noArgs[property];\n      } // If we've got a result already, return it.\n\n\n      if (cachedValue !== UNSET) {\n        return cachedValue === UNDEFINED ? undefined : cachedValue;\n      } // Otherwise calculate what it should be once and cache it.\n\n\n      var value = original.apply(this, args);\n      var v = value === undefined ? UNDEFINED : value;\n\n      if (takesArguments) {\n        setIn(hasArgs, keys, v);\n      } else {\n        noArgs[property] = v;\n      }\n\n      return value;\n    };\n  };\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var property = _step.value;\n\n      _loop(property);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}\n/**\n * Get a value at a key path in a tree of Map.\n *\n * If not set, returns UNSET.\n * If the set value is undefined, returns UNDEFINED.\n *\n * @param {Map} map\n * @param {Array} keys\n * @return {Any|UNSET|UNDEFINED}\n */\n\n\nfunction getIn(map, keys) {\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var key = _step2.value;\n\n      if (key === undefined) {\n        key = UNDEFINED;\n      } else if (key == null) {\n        key = NULL;\n      }\n\n      if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {\n        map = map[STORE_KEY] && map[STORE_KEY].get(key);\n      } else {\n        map = map[key];\n      }\n\n      if (map === UNSET) return UNSET;\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return map[LEAF];\n}\n/**\n * Set a value at a key path in a tree of Map, creating Maps on the go.\n *\n * @param {Map} map\n * @param {Array} keys\n * @param {Any} value\n * @return {Map}\n */\n\n\nfunction setIn(map, keys, value) {\n  var child = map;\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = keys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var key = _step3.value;\n\n      if (key === undefined) {\n        key = UNDEFINED;\n      } else if (key == null) {\n        key = NULL;\n      }\n\n      if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) !== 'object') {\n        if (!child[key]) {\n          child[key] = {};\n        }\n\n        child = child[key];\n        continue;\n      }\n\n      if (!child[STORE_KEY]) {\n        child[STORE_KEY] = new WeakMap();\n      }\n\n      if (!child[STORE_KEY].has(key)) {\n        var newChild = {};\n        child[STORE_KEY].set(key, newChild);\n        child = newChild;\n        continue;\n      }\n\n      child = child[STORE_KEY].get(key);\n    } // The whole path has been created, so set the value to the bottom most map.\n\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  child[LEAF] = value;\n  return map;\n}\n/**\n * In DEV mode, clears the previously memoized values, globally.\n *\n * @return {Void}\n */\n\n\nfunction resetMemoization() {\n  memoizeStore = new WeakMap();\n}\n/**\n * In DEV mode, enable or disable the use of memoize values, globally.\n *\n * @param {Boolean} enabled\n * @return {Void}\n */\n\n\nfunction useMemoization(enabled) {\n  ENABLED = enabled;\n}\n/**\n * The interface that `Document`, `Block` and `Inline` all implement, to make\n * working with the recursive node tree easier.\n *\n * @type {Class}\n */\n\n\nvar NodeInterface = function () {\n  function NodeInterface() {\n    classCallCheck(this, NodeInterface);\n  }\n\n  createClass(NodeInterface, [{\n    key: 'getFirstText',\n\n    /**\n     * Get the first text node of a node, or the node itself.\n     *\n     * @return {Node|Null}\n     */\n    value: function getFirstText() {\n      if (this.object === 'text') {\n        return this;\n      }\n\n      var descendant = null;\n      var found = this.nodes.find(function (node) {\n        if (node.object === 'text') return true;\n        descendant = node.getFirstText();\n        return !!descendant;\n      });\n      return descendant || found;\n    }\n    /**\n     * Get an object mapping all the keys in the node to their paths.\n     *\n     * @return {Object}\n     */\n\n  }, {\n    key: 'getKeysToPathsTable',\n    value: function getKeysToPathsTable() {\n      var ret = defineProperty({}, this.key, []);\n\n      if (this.nodes) {\n        this.nodes.forEach(function (node, i) {\n          var nested = node.getKeysToPathsTable();\n\n          for (var key in nested) {\n            var path = nested[key];\n            warning(!(key in ret), 'A node with a duplicate key of \"' + key + '\" was found! Duplicate keys are not allowed, you should use `node.regenerateKey` before inserting if you are reusing an existing node.');\n            ret[key] = [i].concat(toConsumableArray(path));\n          }\n        });\n      }\n\n      return ret;\n    }\n    /**\n     * Get the last text node of a node, or the node itself.\n     *\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getLastText',\n    value: function getLastText() {\n      if (this.object === 'text') {\n        return this;\n      }\n\n      var descendant = null;\n      var found = this.nodes.findLast(function (node) {\n        if (node.object === 'text') return true;\n        descendant = node.getLastText();\n        return descendant;\n      });\n      return descendant || found;\n    }\n    /**\n     * Get a node in the tree, or the node itself.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNode',\n    value: function getNode(path) {\n      path = this.resolvePath(path);\n      if (!path) return null;\n      if (this.object === 'text' && path.size) return null;\n      var node = path.size ? this.getDescendant(path) : this;\n      return node;\n    }\n    /**\n     * Find the path to a node.\n     *\n     * @param {String|List} key\n     * @return {List}\n     */\n\n  }, {\n    key: 'getPath',\n    value: function getPath(key) {\n      // COMPAT: Handle passing in a path, to match other methods.\n      if (List.isList(key)) {\n        return key;\n      } // COMPAT: Handle a node object by iterating the descendants tree, so that\n      // we avoid using keys for the future.\n\n\n      if (Node.isNode(key) && this.descendants) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this.descendants()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _ref = _step.value;\n\n            var _ref2 = slicedToArray(_ref, 2);\n\n            var node = _ref2[0];\n            var _path = _ref2[1];\n            if (key === node) return _path;\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      var dict = this.getKeysToPathsTable();\n      var path = dict[key];\n      return path ? List(path) : null;\n    }\n    /**\n     * Get the concatenated text string of a node.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'getText',\n    value: function getText() {\n      if (this.object === 'text') {\n        return this.text;\n      }\n\n      var text = this.nodes.reduce(function (memo, c) {\n        return memo + c.text;\n      }, '');\n      return text;\n    }\n    /**\n     * Check if a node exists.\n     *\n     * @param {List|String} path\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasNode',\n    value: function hasNode(path) {\n      var node = this.getNode(path);\n      return !!node;\n    }\n    /**\n     * Normalize the text node with an `editor`.\n     *\n     * @param {Editor} editor\n     * @return {Function|Void}\n     */\n\n  }, {\n    key: 'normalize',\n    value: function normalize(editor) {\n      var normalizer = editor.run('normalizeNode', this);\n      return normalizer;\n    }\n    /**\n     * Regenerate the node's key.\n     *\n     * @return {Node}\n     */\n\n  }, {\n    key: 'regenerateKey',\n    value: function regenerateKey() {\n      var key = KeyUtils.create();\n      var node = this.set('key', key);\n      return node;\n    }\n    /**\n     * Resolve a path from a path list or key string.\n     *\n     * An `index` can be provided, in which case paths created from a key string\n     * will have the index pushed onto them. This is helpful in cases where you\n     * want to accept either a `path` or a `key, index` combination for targeting\n     * a location in the tree that doesn't exist yet, like when inserting.\n     *\n     * @param {List|String} value\n     * @param {Number} index\n     * @return {List}\n     */\n\n  }, {\n    key: 'resolvePath',\n    value: function resolvePath(path, index) {\n      if (typeof path === 'string') {\n        path = this.getPath(path);\n\n        if (index != null) {\n          path = path.concat(index);\n        }\n      } else {\n        path = PathUtils.create(path);\n      }\n\n      return path;\n    }\n    /**\n     * Validate the node with an `editor`.\n     *\n     * @param {Editor} editor\n     * @return {Error|Void}\n     */\n\n  }, {\n    key: 'validate',\n    value: function validate(editor) {\n      var error = editor.run('validateNode', this);\n      return error;\n    }\n  }]);\n  return NodeInterface;\n}();\n/**\n * Memoize read methods.\n */\n\n\nmemoize(NodeInterface.prototype, ['getFirstText', 'getKeysToPathsTable', 'getLastText', 'getText', 'normalize', 'validate']);\n/**\n * Mix in the node interface.\n */\n\nmixin(NodeInterface, [Block, Document, Inline, Text]);\nvar global$1 = typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {};\n\nfunction identity() {\n  return true;\n}\n/**\n * The interface that `Document`, `Block` and `Inline` all implement, to make\n * working with the recursive node tree easier.\n *\n * @type {Class}\n */\n\n\nvar ElementInterface = function () {\n  function ElementInterface() {\n    classCallCheck(this, ElementInterface);\n  }\n\n  createClass(ElementInterface, [{\n    key: 'addMark',\n\n    /**\n     * Add `mark` to text at `path`.\n     *\n     * @param {List|String} path\n     * @param {Mark} mark\n     * @return {Node}\n     */\n    value: function addMark(path, mark) {\n      path = this.resolvePath(path);\n      var node = this.assertDescendant(path);\n      node = node.addMark(mark);\n      var ret = this.replaceNode(path, node);\n      return ret;\n    }\n    /**\n     * Create an iteratable for all of the ancestors of the node.\n     *\n     * @return {Iterable}\n     */\n\n  }, {\n    key: 'ancestors',\n    value: function ancestors(path) {\n      var iterable = this.createIterable({\n        path: path,\n        direction: null,\n        downward: false,\n        includeTargetAncestors: true,\n        includeRoot: true\n      });\n      return iterable;\n    }\n    /**\n     * Create an iteratable for all of the blocks of a node with `options`.\n     *\n     * @param {Options}\n     * @return {Iterable}\n     */\n\n  }, {\n    key: 'blocks',\n    value: function blocks() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var onlyLeaves = options.onlyLeaves,\n          onlyRoots = options.onlyRoots,\n          onlyTypes = options.onlyTypes,\n          _match = options.match,\n          rest = objectWithoutProperties(options, ['onlyLeaves', 'onlyRoots', 'onlyTypes', 'match']);\n      var iterable = this.descendants(_extends({\n        includeDocument: false,\n        includeInlines: false,\n        includeTexts: false\n      }, rest, {\n        match: function match(node, path) {\n          if (onlyTypes && !onlyTypes.includes(node.type)) {\n            return false;\n          } else if (onlyRoots && path.size !== 1) {\n            return false;\n          } else if (onlyLeaves && !node.isLeafBlock()) {\n            return false;\n          } else if (_match && !_match(node, path)) {\n            return false;\n          } else {\n            return true;\n          }\n        }\n      }));\n      return iterable;\n    }\n    /**\n     * Create an annotation with `properties` relative to the node.\n     *\n     * @param {Object|Annotation} properties\n     * @return {Annotation}\n     */\n\n  }, {\n    key: 'createAnnotation',\n    value: function createAnnotation(properties) {\n      properties = Annotation.createProperties(properties);\n      var annotation = this.resolveAnnotation(properties);\n      return annotation;\n    }\n    /**\n     * Create a decoration with `properties` relative to the node.\n     *\n     * @param {Object|Decoration} properties\n     * @return {Decoration}\n     */\n\n  }, {\n    key: 'createDecoration',\n    value: function createDecoration(properties) {\n      properties = Decoration.createProperties(properties);\n      var decoration = this.resolveDecoration(properties);\n      return decoration;\n    }\n    /**\n     * Create an iteratable function starting at `target` path with `options`.\n     *\n     * @param {Object} options (optional)\n     * @return {Function}\n     */\n\n  }, {\n    key: 'createIterable',\n    value: function createIterable() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _options$direction = options.direction,\n          direction = _options$direction === undefined ? 'forward' : _options$direction,\n          _options$downward = options.downward,\n          downward = _options$downward === undefined ? true : _options$downward,\n          _options$upward = options.upward,\n          upward = _options$upward === undefined ? true : _options$upward,\n          _options$includeBlock = options.includeBlocks,\n          includeBlocks = _options$includeBlock === undefined ? true : _options$includeBlock,\n          _options$includeDocum = options.includeDocument,\n          includeDocument = _options$includeDocum === undefined ? true : _options$includeDocum,\n          _options$includeInlin = options.includeInlines,\n          includeInlines = _options$includeInlin === undefined ? true : _options$includeInlin,\n          _options$includeRoot = options.includeRoot,\n          includeRoot = _options$includeRoot === undefined ? false : _options$includeRoot,\n          _options$includeTarge = options.includeTarget,\n          includeTarget = _options$includeTarge === undefined ? !!options.range : _options$includeTarge,\n          _options$includeTarge2 = options.includeTargetAncestors,\n          includeTargetAncestors = _options$includeTarge2 === undefined ? false : _options$includeTarge2,\n          _options$includeTexts = options.includeTexts,\n          includeTexts = _options$includeTexts === undefined ? true : _options$includeTexts,\n          _options$match = options.match,\n          match = _options$match === undefined ? null : _options$match;\n      var root = this;\n      var targetPath = null;\n      var targetRange = null; // You can iterate over either a range or a path, but not both.\n\n      if (options.range) {\n        targetRange = root.resolveRange(options.range);\n        targetPath = root.resolvePath(targetRange.start.path);\n      } else if (options.path) {\n        targetPath = root.resolvePath(options.path);\n      }\n\n      var targetNode = targetPath && root.assertNode(targetPath);\n      var NativeSet = typeof window === 'undefined' ? global$1.Set : window.Set; // Return an object that implements the iterable interface.\n\n      return defineProperty({}, Symbol.iterator, function () {\n        var visited = new NativeSet();\n        var startPath = targetRange && targetRange.start.path;\n        var endPath = targetRange && targetRange.end.path;\n        var path = targetPath;\n        var node = targetNode;\n        var includedTarget = false;\n        var includedStart = false;\n        var includingStart = false;\n\n        var result = function result() {\n          // When these are nulled out we've finished iterating.\n          if (!path || !node) {\n            return {\n              done: true\n            };\n          } // We often don't want to include the root node itself.\n\n\n          if (!includeRoot && node === root) {\n            return next();\n          }\n\n          if (!includeBlocks && node.object === 'block') {\n            return next();\n          }\n\n          if (!includeDocument && node.object === 'document') {\n            return next();\n          }\n\n          if (!includeInlines && node.object === 'inline') {\n            return next();\n          }\n\n          if (!includeTexts && node.object === 'text') {\n            return next();\n          }\n\n          if (match && !match(node, path)) {\n            return next();\n          }\n\n          return {\n            value: [node, path],\n            done: false\n          };\n        };\n\n        var next = function next() {\n          if (!path || !node) {\n            return result();\n          } // When iterating over a range, we need to include the specific\n          // ancestors in the start path of the range manually.\n\n\n          if (startPath && !includedStart) {\n            if (!includingStart) {\n              includingStart = true;\n              path = PathUtils.create([]);\n              node = root;\n              return result();\n            }\n\n            if (path.size === startPath.size - 1) {\n              includedStart = true;\n              path = targetPath;\n              node = targetNode;\n              return next();\n            }\n\n            path = startPath.slice(0, path.size + 1);\n            node = root.assertNode(path);\n            return result();\n          } // Sometimes we want to include the target itself.\n\n\n          if (includeTarget && !includedTarget) {\n            includedTarget = true;\n            return result();\n          } // When iterating over a range, if we get to the end path then exit.\n\n\n          if (endPath && path.equals(endPath)) {\n            node = null;\n            path = null;\n            return next();\n          } // If we're allowed to go downward, and we haven't decsended yet, do so.\n\n\n          if (downward && node.nodes && node.nodes.size && !visited.has(node)) {\n            visited.add(node);\n            var nextIndex = direction === 'forward' ? 0 : node.nodes.size - 1;\n            path = path.push(nextIndex);\n            node = root.assertNode(path);\n            return result();\n          } // If we're going forward...\n\n\n          if (direction === 'forward') {\n            var newPath = PathUtils.increment(path);\n            var newNode = root.getNode(newPath);\n\n            if (newNode) {\n              path = newPath;\n              node = newNode;\n              return result();\n            }\n          } // If we're going backward...\n\n\n          if (direction === 'backward' && path.last() !== 0) {\n            var _newPath = PathUtils.decrement(path);\n\n            var _newNode = root.getNode(_newPath);\n\n            if (_newNode) {\n              path = _newPath;\n              node = _newNode;\n              return result();\n            }\n          } // If we're going upward...\n\n\n          if (upward && path.size) {\n            path = PathUtils.lift(path);\n            node = root.assertNode(path); // Sometimes we'll have already visited the node on the way down\n            // so we don't want to double count it.\n\n            if (visited.has(node)) {\n              return next();\n            }\n\n            visited.add(node); // If ancestors of the target node shouldn't be included, skip them.\n\n            if (!includeTargetAncestors) {\n              return next();\n            } else {\n              return result();\n            }\n          }\n\n          path = null;\n          node = null;\n          return next();\n        };\n\n        return {\n          next: next\n        };\n      });\n    }\n    /**\n     * Create a point with `properties` relative to the node.\n     *\n     * @param {Object|Point} properties\n     * @return {Range}\n     */\n\n  }, {\n    key: 'createPoint',\n    value: function createPoint(properties) {\n      properties = Point.createProperties(properties);\n      var point = this.resolvePoint(properties);\n      return point;\n    }\n    /**\n     * Create a range with `properties` relative to the node.\n     *\n     * @param {Object|Range} properties\n     * @return {Range}\n     */\n\n  }, {\n    key: 'createRange',\n    value: function createRange(properties) {\n      properties = Range.createProperties(properties);\n      var range = this.resolveRange(properties);\n      return range;\n    }\n    /**\n     * Create a selection with `properties` relative to the node.\n     *\n     * @param {Object|Selection} properties\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'createSelection',\n    value: function createSelection(properties) {\n      properties = Selection.createProperties(properties);\n      var selection = this.resolveSelection(properties);\n      return selection;\n    }\n    /**\n     * Create an iteratable for all of the descendants of the node.\n     *\n     * @param {Object} options\n     * @return {Iterable}\n     */\n\n  }, {\n    key: 'descendants',\n    value: function descendants(options) {\n      var iterable = this.createIterable(_extends({\n        path: []\n      }, options));\n      return iterable;\n    }\n    /**\n     * Find all of the descendants that match a `predicate`.\n     *\n     * @param {Function} predicate\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'filterDescendants',\n    value: function filterDescendants() {\n      var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;\n      var matches = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.descendants()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _ref2 = _step.value;\n\n          var _ref3 = slicedToArray(_ref2, 2);\n\n          var node = _ref3[0];\n          var path = _ref3[1];\n\n          if (predicate(node, path)) {\n            matches.push(node);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return List(matches);\n    }\n    /**\n     * Find the first descendant that matches a `predicate`.\n     *\n     * @param {Function} predicate\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'findDescendant',\n    value: function findDescendant() {\n      var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.descendants()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _ref4 = _step2.value;\n\n          var _ref5 = slicedToArray(_ref4, 2);\n\n          var node = _ref5[0];\n          var path = _ref5[1];\n\n          if (predicate(node, path)) {\n            return node;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Iterate over all descendants, breaking if `predicate` returns false.\n     *\n     * @param {Function} predicate\n     */\n\n  }, {\n    key: 'forEachDescendant',\n    value: function forEachDescendant() {\n      var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this.descendants()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _next = _step3.value;\n          var ret = predicate.apply(undefined, toConsumableArray(_next));\n\n          if (ret === false) {\n            return;\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n    /**\n     * Get a set of the active marks in a `range`. Active marks are marks that are\n     * on every text node in a given range. This is a common distinction for\n     * highlighting toolbar buttons for example.\n     *\n     * TODO: this method needs to be cleaned up, it's very hard to follow and\n     * probably doing unnecessary work.\n     *\n     * @param {Range} range\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'getActiveMarksAtRange',\n    value: function getActiveMarksAtRange(range) {\n      range = this.resolveRange(range);\n\n      if (range.isUnset) {\n        return Set();\n      }\n\n      if (range.isCollapsed) {\n        var _range = range,\n            _start = _range.start;\n        return this.getInsertMarksAtPoint(_start);\n      }\n\n      var _range2 = range,\n          start = _range2.start,\n          end = _range2.end;\n      var startPath = start.path;\n      var startOffset = start.offset;\n      var endPath = end.path;\n      var endOffset = end.offset;\n      var startText = this.getDescendant(startPath);\n      var endText = this.getDescendant(endPath);\n\n      if (!startPath.equals(endPath)) {\n        while (!startPath.equals(endPath) && endOffset === 0) {\n          var _texts = this.texts({\n            path: endPath,\n            direction: 'backward'\n          });\n\n          var _texts2 = slicedToArray(_texts, 1);\n\n          var _texts2$ = slicedToArray(_texts2[0], 2);\n\n          endText = _texts2$[0];\n          endPath = _texts2$[1];\n          endOffset = endText.text.length;\n        }\n\n        while (!startPath.equals(endPath) && startOffset === startText.text.length) {\n          var _texts3 = this.texts({\n            path: startPath\n          });\n\n          var _texts4 = slicedToArray(_texts3, 1);\n\n          var _texts4$ = slicedToArray(_texts4[0], 2);\n\n          startText = _texts4$[0];\n          startPath = _texts4$[1];\n          startOffset = 0;\n        }\n      }\n\n      if (startPath.equals(endPath)) {\n        return startText.marks;\n      }\n\n      var startMarks = startText.marks; // PERF: if start marks is empty we can return early.\n\n      if (startMarks.size === 0) {\n        return Set();\n      }\n\n      var endMarks = endText.marks;\n      var marks = startMarks.intersect(endMarks); // If marks is already empty, the active marks is empty\n\n      if (marks.size === 0) {\n        return marks;\n      }\n\n      var _texts5 = this.texts({\n        path: startPath\n      });\n\n      var _texts6 = slicedToArray(_texts5, 1);\n\n      var _texts6$ = slicedToArray(_texts6[0], 2);\n\n      startText = _texts6$[0];\n      startPath = _texts6$[1];\n\n      while (!startPath.equals(endPath)) {\n        if (startText.text.length !== 0) {\n          marks = marks.intersect(startText.marks);\n\n          if (marks.size === 0) {\n            return Set();\n          }\n        }\n\n        var _texts7 = this.texts({\n          path: startPath\n        });\n\n        var _texts8 = slicedToArray(_texts7, 1);\n\n        var _texts8$ = slicedToArray(_texts8[0], 2);\n\n        startText = _texts8$[0];\n        startPath = _texts8$[1];\n      }\n\n      return marks;\n    }\n    /**\n     * Get a list of the ancestors of a descendant.\n     *\n     * @param {List|String} path\n     * @return {List<Node>|Null}\n     */\n\n  }, {\n    key: 'getAncestors',\n    value: function getAncestors(path) {\n      var iterable = this.ancestors(path);\n      var array = Array.from(iterable, function (_ref6) {\n        var _ref7 = slicedToArray(_ref6, 1),\n            node = _ref7[0];\n\n        return node;\n      }).reverse();\n      var list = List(array);\n      return list;\n    }\n    /**\n     * Get the leaf block descendants of the node.\n     *\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getBlocks',\n    value: function getBlocks() {\n      var iterable = this.blocks({\n        onlyLeaves: true\n      });\n      var array = Array.from(iterable, function (_ref8) {\n        var _ref9 = slicedToArray(_ref8, 1),\n            node = _ref9[0];\n\n        return node;\n      });\n      var list = List(array);\n      return list;\n    }\n    /**\n     * Get all of the leaf blocks that match a `type`.\n     *\n     * @param {String} type\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getBlocksByType',\n    value: function getBlocksByType(type) {\n      var iterable = this.blocks({\n        onlyLeaves: true,\n        onlyTypes: [type]\n      });\n      var array = Array.from(iterable, function (_ref10) {\n        var _ref11 = slicedToArray(_ref10, 1),\n            node = _ref11[0];\n\n        return node;\n      });\n      var list = List(array);\n      return list;\n    }\n    /**\n     * Get a child node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getChild',\n    value: function getChild(path) {\n      path = this.resolvePath(path);\n\n      if (!path || path.size > 1) {\n        return null;\n      }\n\n      var child = this.nodes.get(path.first());\n      return child;\n    }\n    /**\n     * Get closest parent of node that matches a `predicate`.\n     *\n     * @param {List|String} path\n     * @param {Function} predicate\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getClosest',\n    value: function getClosest(path, predicate) {\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = this.ancestors(path)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var _ref12 = _step4.value;\n\n          var _ref13 = slicedToArray(_ref12, 2);\n\n          var n = _ref13[0];\n          var p = _ref13[1];\n\n          if (predicate(n, p)) {\n            return n;\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Get the closest block parent of a node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getClosestBlock',\n    value: function getClosestBlock(path) {\n      var closest = this.getClosest(path, function (n) {\n        return n.object === 'block';\n      });\n      return closest;\n    }\n    /**\n     * Get the closest inline parent of a node by `path`.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getClosestInline',\n    value: function getClosestInline(path) {\n      var closest = this.getClosest(path, function (n) {\n        return n.object === 'inline';\n      });\n      return closest;\n    }\n    /**\n     * Get the closest void parent of a node by `path`.\n     *\n     * @param {List|String} path\n     * @param {Editor} editor\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getClosestVoid',\n    value: function getClosestVoid(path, editor) {\n      invariant(!Value.isValue(editor), 'As of Slate 0.42.0, the `node.getClosestVoid` method takes an `editor` instead of a `value`.');\n      var closest = this.getClosest(path, function (n) {\n        return editor.isVoid(n);\n      });\n      return closest;\n    }\n    /**\n     * Get the common ancestor of nodes `a` and `b`.\n     *\n     * @param {List} a\n     * @param {List} b\n     * @return {Node}\n     */\n\n  }, {\n    key: 'getCommonAncestor',\n    value: function getCommonAncestor(a, b) {\n      a = this.resolvePath(a);\n      b = this.resolvePath(b);\n\n      if (!a || !b) {\n        return null;\n      }\n\n      var path = PathUtils.relate(a, b);\n      var node = this.getNode(path);\n      return node;\n    }\n    /**\n     * Get the decorations for the node from an `editor`.\n     *\n     * @param {Editor} editor\n     * @return {List}\n     */\n\n  }, {\n    key: 'getDecorations',\n    value: function getDecorations(editor) {\n      var decorations = editor.run('decorateNode', this);\n      decorations = Decoration.createList(decorations);\n      return decorations;\n    }\n    /**\n     * Get the depth of a descendant, with optional `startAt`.\n     *\n     * @param {List|String} path\n     * @param {Number} startAt\n     * @return {Number|Null}\n     */\n\n  }, {\n    key: 'getDepth',\n    value: function getDepth(path) {\n      var startAt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      path = this.resolvePath(path);\n\n      if (!path) {\n        return null;\n      }\n\n      var node = this.getNode(path);\n      var depth = node ? path.size - 1 + startAt : null;\n      return depth;\n    }\n    /**\n     * Get a descendant node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getDescendant',\n    value: function getDescendant(path) {\n      path = this.resolvePath(path);\n\n      if (!path || !path.size) {\n        return null;\n      }\n\n      var node = this;\n      path.forEach(function (index) {\n        node = node.getIn(['nodes', index]);\n        return !!node;\n      });\n      return node;\n    }\n    /**\n     * Get all of the descendant nodes in a `range`.\n     *\n     * @param {Range} range\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getDescendantsAtRange',\n    value: function getDescendantsAtRange(range) {\n      var iterable = this.descendants({\n        range: range\n      });\n      var array = Array.from(iterable, function (_ref14) {\n        var _ref15 = slicedToArray(_ref14, 1),\n            node = _ref15[0];\n\n        return node;\n      });\n      var list = List(array);\n      return list;\n    }\n    /**\n     * Get a fragment of the node at a `range`.\n     *\n     * @param {Range} range\n     * @return {Document}\n     */\n\n  }, {\n    key: 'getFragmentAtRange',\n    value: function getFragmentAtRange(range) {\n      range = this.resolveRange(range);\n\n      if (range.isUnset) {\n        return Document.create();\n      }\n\n      var _range3 = range,\n          start = _range3.start,\n          end = _range3.end;\n      var node = this;\n      var targetPath = end.path;\n      var targetPosition = end.offset;\n      var side = 'end';\n\n      while (targetPath.size) {\n        var index = targetPath.last();\n        node = node.splitNode(targetPath, targetPosition);\n        targetPosition = index + 1;\n        targetPath = PathUtils.lift(targetPath);\n\n        if (!targetPath.size && side === 'end') {\n          targetPath = start.path;\n          targetPosition = start.offset;\n          side = 'start';\n        }\n      }\n\n      var startIndex = start.path.first() + 1;\n      var endIndex = end.path.first() + 2;\n      var nodes = node.nodes.slice(startIndex, endIndex);\n      var fragment = Document.create({\n        nodes: nodes\n      });\n      return fragment;\n    }\n    /**\n     * Get the furthest ancestors of a node that matches a `predicate`.\n     *\n     * @param {Path} path\n     * @param {Function} predicate\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getFurthest',\n    value: function getFurthest(path) {\n      var predicate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;\n      var iterable = this.ancestors(path);\n      var results = Array.from(iterable).reverse();\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = results[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var _ref16 = _step5.value;\n\n          var _ref17 = slicedToArray(_ref16, 2);\n\n          var n = _ref17[0];\n          var p = _ref17[1];\n\n          if (predicate(n, p)) {\n            return n;\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Get the furthest block parent of a node.\n     *\n     * @param {Path} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getFurthestBlock',\n    value: function getFurthestBlock(path) {\n      var furthest = this.getFurthest(path, function (n) {\n        return n.object === 'block';\n      });\n      return furthest;\n    }\n    /**\n     * Get the furthest child ancestor of a node at `path`.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getFurthestChild',\n    value: function getFurthestChild(path) {\n      path = this.resolvePath(path);\n\n      if (!path || !path.size) {\n        return null;\n      }\n\n      var furthest = this.nodes.get(path.first());\n      return furthest;\n    }\n    /**\n     * Get the furthest inline parent of a node.\n     *\n     * @param {Path} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getFurthestInline',\n    value: function getFurthestInline(path) {\n      var furthest = this.getFurthest(path, function (n) {\n        return n.object === 'inline';\n      });\n      return furthest;\n    }\n    /**\n     * Get the closest inline nodes for each text node in the node.\n     *\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getInlines',\n    value: function getInlines() {\n      var iterable = this.inlines({\n        onlyLeaves: true\n      });\n      var array = Array.from(iterable, function (_ref18) {\n        var _ref19 = slicedToArray(_ref18, 1),\n            node = _ref19[0];\n\n        return node;\n      });\n      var list = List(array);\n      return list;\n    }\n    /**\n     * Get all of the leaf inline nodes that match a `type`.\n     *\n     * @param {String} type\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getInlinesByType',\n    value: function getInlinesByType(type) {\n      var iterable = this.inlines({\n        onlyLeaves: true,\n        onlyTypes: [type]\n      });\n      var array = Array.from(iterable, function (_ref20) {\n        var _ref21 = slicedToArray(_ref20, 1),\n            node = _ref21[0];\n\n        return node;\n      });\n      var list = List(array);\n      return list;\n    }\n    /**\n     * Get a set of marks that would occur on the next insert at a `point` in the\n     * node. This mimics expected rich text editing behaviors of mark contiuation.\n     *\n     * @param {Point} point\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'getInsertMarksAtPoint',\n    value: function getInsertMarksAtPoint(point) {\n      point = this.resolvePoint(point);\n      var _point = point,\n          path = _point.path,\n          offset = _point.offset;\n      var text = this.getDescendant(path); // PERF: we can exit early if the offset isn't at the start of the node.\n\n      if (offset !== 0) {\n        return text.marks;\n      }\n\n      var blockNode = void 0;\n      var blockPath = void 0;\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = this.ancestors(path)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var entry = _step6.value;\n\n          var _entry = slicedToArray(entry, 2),\n              n = _entry[0],\n              p = _entry[1];\n\n          if (n.object === 'block') {\n            blockNode = n;\n            blockPath = p;\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      var relativePath = PathUtils.drop(path, blockPath.size);\n\n      var _blockNode$texts = blockNode.texts({\n        path: relativePath,\n        direction: 'backward'\n      }),\n          _blockNode$texts2 = slicedToArray(_blockNode$texts, 1),\n          previous = _blockNode$texts2[0]; // If there's no previous text, we're at the start of the block, so use\n      // the current text nodes marks.\n\n\n      if (!previous) {\n        return text.marks;\n      } // Otherwise, continue with the previous text node's marks instead.\n\n\n      var _previous = slicedToArray(previous, 1),\n          previousText = _previous[0];\n\n      return previousText.marks;\n    }\n    /**\n     * Get a set of marks that would occur on the next insert at a `range`.\n     * This mimics expected rich text editing behaviors of mark contiuation.\n     *\n     * @param {Range} range\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'getInsertMarksAtRange',\n    value: function getInsertMarksAtRange(range) {\n      range = this.resolveRange(range);\n      var _range4 = range,\n          start = _range4.start;\n\n      if (range.isUnset) {\n        return Set();\n      }\n\n      if (range.isCollapsed) {\n        return this.getInsertMarksAtPoint(start);\n      }\n\n      var text = this.getDescendant(start.path);\n      return text.marks;\n    }\n    /**\n     * Get the bottom-most block descendants in a `range`.\n     *\n     * @param {Range} range\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getLeafBlocksAtRange',\n    value: function getLeafBlocksAtRange(range) {\n      var iterable = this.blocks({\n        range: range,\n        onlyLeaves: true\n      });\n      var array = Array.from(iterable, function (_ref22) {\n        var _ref23 = slicedToArray(_ref22, 1),\n            node = _ref23[0];\n\n        return node;\n      });\n      var list = List(array);\n      return list;\n    }\n    /**\n     * Get the bottom-most inline nodes for each text node in a `range`.\n     *\n     * @param {Range} range\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getLeafInlinesAtRange',\n    value: function getLeafInlinesAtRange(range) {\n      var iterable = this.inlines({\n        range: range,\n        onlyLeaves: true\n      });\n      var array = Array.from(iterable, function (_ref24) {\n        var _ref25 = slicedToArray(_ref24, 1),\n            node = _ref25[0];\n\n        return node;\n      });\n      var list = List(array);\n      return list;\n    }\n    /**\n     * Get an object mapping all the keys in the node to their paths.\n     *\n     * @return {Map}\n     */\n\n  }, {\n    key: 'getNodesToPathsMap',\n    value: function getNodesToPathsMap() {\n      var root = this;\n      var map = typeof window === 'undefined' ? new global$1.Map() : new window.Map();\n      map.set(root, PathUtils.create([]));\n      root.forEachDescendant(function (node, path) {\n        map.set(node, path);\n      });\n      return map;\n    }\n    /**\n     * Get all of the marks for all of the characters of every text node.\n     *\n     * @return {OrderedSet<Mark>}\n     */\n\n  }, {\n    key: 'getMarks',\n    value: function getMarks() {\n      var iterable = this.marks();\n      var array = Array.from(iterable, function (_ref26) {\n        var _ref27 = slicedToArray(_ref26, 1),\n            mark = _ref27[0];\n\n        return mark;\n      });\n      return OrderedSet(array);\n    }\n    /**\n     * Get a set of the marks in a `range`.\n     *\n     * @param {Range} range\n     * @return {OrderedSet<Mark>}\n     */\n\n  }, {\n    key: 'getMarksAtRange',\n    value: function getMarksAtRange(range) {\n      var iterable = this.marks({\n        range: range\n      });\n      var array = Array.from(iterable, function (_ref28) {\n        var _ref29 = slicedToArray(_ref28, 1),\n            mark = _ref29[0];\n\n        return mark;\n      });\n      return OrderedSet(array);\n    }\n    /**\n     * Get all of the marks that match a `type`.\n     *\n     * @param {String} type\n     * @return {OrderedSet<Mark>}\n     */\n\n  }, {\n    key: 'getMarksByType',\n    value: function getMarksByType(type) {\n      var iterable = this.marks({\n        onlyTypes: [type]\n      });\n      var array = Array.from(iterable, function (_ref30) {\n        var _ref31 = slicedToArray(_ref30, 1),\n            mark = _ref31[0];\n\n        return mark;\n      });\n      return OrderedSet(array);\n    }\n    /**\n     * Get the block node after a descendant text node by `path`.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNextBlock',\n    value: function getNextBlock(path) {\n      var _blocks = this.blocks({\n        path: path,\n        onlyLeaves: true\n      }),\n          _blocks2 = slicedToArray(_blocks, 1),\n          entry = _blocks2[0];\n\n      var block = entry ? entry[0] : null;\n      return block;\n    }\n    /**\n     * Get the next node in the tree, returning siblings or ancestor siblings.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNextNode',\n    value: function getNextNode(path) {\n      var iterable = this.createIterable({\n        path: path,\n        downward: false\n      });\n\n      var _iterable = slicedToArray(iterable, 1),\n          entry = _iterable[0];\n\n      var node = entry ? entry[0] : null;\n      return node;\n    }\n    /**\n     * Get the next sibling of a node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNextSibling',\n    value: function getNextSibling(path) {\n      var _siblings = this.siblings(path),\n          _siblings2 = slicedToArray(_siblings, 1),\n          entry = _siblings2[0];\n\n      var node = entry ? entry[0] : null;\n      return node;\n    }\n    /**\n     * Get the text node after a descendant text node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNextText',\n    value: function getNextText(path) {\n      var _texts9 = this.texts({\n        path: path\n      }),\n          _texts10 = slicedToArray(_texts9, 1),\n          entry = _texts10[0];\n\n      var node = entry ? entry[0] : null;\n      return node;\n    }\n    /**\n     * Get the offset for a descendant text node by `path` or `key`.\n     *\n     * @param {List|string} path\n     * @return {Number}\n     */\n\n  }, {\n    key: 'getOffset',\n    value: function getOffset(path) {\n      path = this.resolvePath(path);\n      this.assertDescendant(path); // Calculate the offset of the nodes before the highest child.\n\n      var index = path.first();\n      var offset = this.nodes.slice(0, index).reduce(function (memo, n) {\n        return memo + n.text.length;\n      }, 0); // Recurse if need be.\n\n      var ret = path.size === 1 ? offset : offset + this.nodes.get(index).getOffset(PathUtils.drop(path));\n      return ret;\n    }\n    /**\n     * Get the offset from a `range`.\n     *\n     * @param {Range} range\n     * @return {Number}\n     */\n\n  }, {\n    key: 'getOffsetAtRange',\n    value: function getOffsetAtRange(range) {\n      range = this.resolveRange(range);\n\n      if (range.isUnset) {\n        throw new Error('The range cannot be unset to calculcate its offset.');\n      }\n\n      if (range.isExpanded) {\n        throw new Error('The range must be collapsed to calculcate its offset.');\n      }\n\n      var _range5 = range,\n          start = _range5.start;\n      var offset = this.getOffset(start.path) + start.offset;\n      return offset;\n    }\n    /**\n     * Get the parent of a descendant node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getParent',\n    value: function getParent(path) {\n      path = this.resolvePath(path);\n      if (!path) return null;\n      if (!path.size) return null;\n      var parentPath = PathUtils.lift(path);\n      var parent = this.getNode(parentPath);\n      return parent;\n    }\n    /**\n     * Get the block node before a descendant text node by `path`.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getPreviousBlock',\n    value: function getPreviousBlock(path) {\n      var _blocks3 = this.blocks({\n        path: path,\n        onlyLeaves: true,\n        direction: 'backward'\n      }),\n          _blocks4 = slicedToArray(_blocks3, 1),\n          entry = _blocks4[0];\n\n      var block = entry ? entry[0] : null;\n      return block;\n    }\n    /**\n     * Get the previous node from a node in the tree.\n     *\n     * This will not only check for siblings but instead move up the tree\n     * returning the previous ancestor if no sibling is found.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getPreviousNode',\n    value: function getPreviousNode(path) {\n      var iterable = this.createIterable({\n        path: path,\n        downward: false,\n        direction: 'backward'\n      });\n\n      var _iterable2 = slicedToArray(iterable, 1),\n          entry = _iterable2[0];\n\n      var node = entry ? entry[0] : null;\n      return node;\n    }\n    /**\n     * Get the previous sibling of a node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getPreviousSibling',\n    value: function getPreviousSibling(path) {\n      var _siblings3 = this.siblings(path, {\n        direction: 'backward'\n      }),\n          _siblings4 = slicedToArray(_siblings3, 1),\n          entry = _siblings4[0];\n\n      var node = entry ? entry[0] : null;\n      return node;\n    }\n    /**\n     * Get the text node before a descendant text node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getPreviousText',\n    value: function getPreviousText(path) {\n      var _texts11 = this.texts({\n        path: path,\n        direction: 'backward'\n      }),\n          _texts12 = slicedToArray(_texts11, 1),\n          entry = _texts12[0];\n\n      var node = entry ? entry[0] : null;\n      return node;\n    }\n    /**\n     * Get only the root block nodes in a `range`.\n     *\n     * @param {Range} range\n     * @return {List}\n     */\n\n  }, {\n    key: 'getRootBlocksAtRange',\n    value: function getRootBlocksAtRange(range) {\n      var iterable = this.blocks({\n        range: range,\n        onlyRoots: true\n      });\n      var array = Array.from(iterable, function (_ref32) {\n        var _ref33 = slicedToArray(_ref32, 1),\n            node = _ref33[0];\n\n        return node;\n      });\n      var list = List(array);\n      return list;\n    }\n    /**\n     * Get only the root inline nodes in a `range`.\n     *\n     * @param {Range} range\n     * @return {List}\n     */\n\n  }, {\n    key: 'getRootInlinesAtRange',\n    value: function getRootInlinesAtRange(range) {\n      var iterable = this.inlines({\n        range: range,\n        onlyRoots: true\n      });\n      var array = Array.from(iterable, function (_ref34) {\n        var _ref35 = slicedToArray(_ref34, 1),\n            node = _ref35[0];\n\n        return node;\n      });\n      var list = List(array);\n      return list;\n    }\n    /**\n     * Get the descendent text node at an `offset`.\n     *\n     * @param {String} offset\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getTextAtOffset',\n    value: function getTextAtOffset(offset) {\n      // PERF: Add a few shortcuts for the obvious cases.\n      if (offset === 0) return this.getFirstText();\n      if (offset === this.text.length) return this.getLastText();\n      if (offset < 0 || offset > this.text.length) return null;\n      var length = 0;\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = this.texts()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var _ref36 = _step7.value;\n\n          var _ref37 = slicedToArray(_ref36, 1);\n\n          var node = _ref37[0];\n          length += node.text.length;\n\n          if (length > offset) {\n            return node;\n          }\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Get the direction of the node's text.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'getTextDirection',\n    value: function getTextDirection() {\n      var dir = getDirection(this.text);\n      return dir === 'neutral' ? null : dir;\n    }\n    /**\n     * Recursively get all of the child text nodes in order of appearance.\n     *\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getTexts',\n    value: function getTexts() {\n      var iterable = this.texts();\n      var array = Array.from(iterable, function (_ref38) {\n        var _ref39 = slicedToArray(_ref38, 1),\n            node = _ref39[0];\n\n        return node;\n      });\n      var list = List(array);\n      return list;\n    }\n    /**\n     * Get all of the text nodes in a `range` as a List.\n     *\n     * @param {Range} range\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getTextsAtRange',\n    value: function getTextsAtRange(range) {\n      var iterable = this.texts({\n        range: range\n      });\n      var array = Array.from(iterable, function (_ref40) {\n        var _ref41 = slicedToArray(_ref40, 1),\n            node = _ref41[0];\n\n        return node;\n      });\n      var list = List(array);\n      return list;\n    }\n    /**\n     * Check if the node has block children.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasBlockChildren',\n    value: function hasBlockChildren() {\n      return !!(this.nodes && this.nodes.find(function (n) {\n        return n.object === 'block';\n      }));\n    }\n    /**\n     * Check if a child node exists.\n     *\n     * @param {List|String} path\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasChild',\n    value: function hasChild(path) {\n      var child = this.getChild(path);\n      return !!child;\n    }\n    /**\n     * Check if a node has inline children.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasInlineChildren',\n    value: function hasInlineChildren() {\n      return !!(this.nodes && this.nodes.find(function (n) {\n        return n.object === 'inline' || n.object === 'text';\n      }));\n    }\n    /**\n     * Recursively check if a child node exists.\n     *\n     * @param {List|String} path\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasDescendant',\n    value: function hasDescendant(path) {\n      var descendant = this.getDescendant(path);\n      return !!descendant;\n    }\n    /**\n     * Check if a node has a void parent.\n     *\n     * @param {List|String} path\n     * @param {Editor} editor\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasVoidParent',\n    value: function hasVoidParent(path, editor) {\n      invariant(!Value.isValue(editor), 'As of Slate 0.42.0, the `node.hasVoidParent` method takes an `editor` instead of a `value`.');\n      var closest = this.getClosestVoid(path, editor);\n      return !!closest;\n    }\n    /**\n     * Create an iteratable for all of the inlines of a node with `options`.\n     *\n     * @param {Options}\n     * @return {Iterable}\n     */\n\n  }, {\n    key: 'inlines',\n    value: function inlines() {\n      var _this = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var onlyLeaves = options.onlyLeaves,\n          onlyRoots = options.onlyRoots,\n          onlyTypes = options.onlyTypes,\n          _match2 = options.match,\n          rest = objectWithoutProperties(options, ['onlyLeaves', 'onlyRoots', 'onlyTypes', 'match']);\n      var iterable = this.descendants(_extends({\n        includeBlocks: false,\n        includeTexts: false,\n        includeDocument: false\n      }, rest, {\n        match: function match(node, path) {\n          if (onlyTypes && !onlyTypes.includes(node.type)) {\n            return false;\n          } else if (onlyLeaves && !node.isLeafInline()) {\n            return false;\n          } else if (onlyRoots && _this.getParent(path).object !== 'block') {\n            return false;\n          } else if (_match2 && !_match2(node, path)) {\n            return false;\n          } else {\n            return true;\n          }\n        }\n      }));\n      return iterable;\n    }\n    /**\n     * Insert a `node`.\n     *\n     * @param {List|String} path\n     * @param {Node} node\n     * @return {Node}\n     */\n\n  }, {\n    key: 'insertNode',\n    value: function insertNode(path, node) {\n      path = this.resolvePath(path);\n      var index = path.last();\n      var parentPath = PathUtils.lift(path);\n      var parent = this.assertNode(parentPath);\n      var nodes = parent.nodes.splice(index, 0, node);\n      parent = parent.set('nodes', nodes);\n      var ret = this.replaceNode(parentPath, parent);\n      return ret;\n    }\n    /**\n     * Insert `text` at `offset` in node by `path`.\n     *\n     * @param {List|String} path\n     * @param {Number} offset\n     * @param {String} text\n     * @return {Node}\n     */\n\n  }, {\n    key: 'insertText',\n    value: function insertText(path, offset, text) {\n      path = this.resolvePath(path);\n      var node = this.assertDescendant(path);\n      node = node.insertText(offset, text);\n      var ret = this.replaceNode(path, node);\n      return ret;\n    }\n    /**\n     * Check whether the node is a leaf block.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isLeafBlock',\n    value: function isLeafBlock() {\n      if (this.object !== 'block') {\n        return false;\n      }\n\n      if (this.nodes.some(function (n) {\n        return n.object === 'block';\n      })) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Check whether the node is a leaf inline.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isLeafInline',\n    value: function isLeafInline() {\n      if (this.object !== 'inline') {\n        return false;\n      }\n\n      if (this.nodes.some(function (n) {\n        return n.object === 'inline';\n      })) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Check whether a descendant node is inside a `range` by `path`.\n     *\n     * @param {List|String} path\n     * @param {Range} range\n     * @return {Node}\n     */\n\n  }, {\n    key: 'isInRange',\n    value: function isInRange(path, range) {\n      path = this.resolvePath(path);\n      range = this.resolveRange(range);\n\n      if (range.isUnset) {\n        return false;\n      }\n\n      var toStart = PathUtils.compare(path, range.start.path);\n      var toEnd = PathUtils.compare(path, range.end.path);\n      var isInRange = toStart !== -1 && toEnd !== 1;\n      return isInRange;\n    }\n    /**\n     * Map all child nodes, updating them in their parents. This method is\n     * optimized to not return a new node if no changes are made.\n     *\n     * @param {Function} predicate\n     * @return {Node}\n     */\n\n  }, {\n    key: 'mapChildren',\n    value: function mapChildren() {\n      var _this2 = this;\n\n      var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;\n      var nodes = this.nodes;\n      nodes.forEach(function (node, i) {\n        var ret = predicate(node, i, _this2.nodes);\n        if (ret !== node) nodes = nodes.set(ret.key, ret);\n      });\n      var ret = this.set('nodes', nodes);\n      return ret;\n    }\n    /**\n     * Map all descendant nodes, updating them in their parents. This method is\n     * optimized to not return a new node if no changes are made.\n     *\n     * @param {Function} predicate\n     * @return {Node}\n     */\n\n  }, {\n    key: 'mapDescendants',\n    value: function mapDescendants() {\n      var _this3 = this;\n\n      var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;\n      var nodes = this.nodes;\n      nodes.forEach(function (node, index) {\n        var ret = node;\n        if (ret.object !== 'text') ret = ret.mapDescendants(predicate);\n        ret = predicate(ret, index, _this3.nodes);\n        if (ret === node) return;\n        nodes = nodes.set(index, ret);\n      });\n      var ret = this.set('nodes', nodes);\n      return ret;\n    }\n    /**\n     * Create an iteratable for all the marks in text nodes with `options`.\n     *\n     * @param {Options}\n     * @return {Iterable}\n     */\n\n  }, {\n    key: 'marks',\n    value: function marks() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _options$onlyTypes = options.onlyTypes,\n          onlyTypes = _options$onlyTypes === undefined ? null : _options$onlyTypes,\n          match = options.match,\n          rest = objectWithoutProperties(options, ['onlyTypes', 'match']);\n      var texts = this.texts(rest);\n      return defineProperty({}, Symbol.iterator, function () {\n        var iterator = texts[Symbol.iterator]();\n        var node = null;\n        var path = null;\n        var remaining = [];\n\n        var next = function next() {\n          if (remaining.length) {\n            var mark = remaining.shift();\n\n            if (onlyTypes && !onlyTypes.includes(mark.type)) {\n              return next();\n            } else if (match && !match(mark, node, path)) {\n              return next();\n            }\n\n            return {\n              value: [mark, node, path],\n              done: false\n            };\n          }\n\n          var _iterator$next = iterator.next(),\n              value = _iterator$next.value,\n              done = _iterator$next.done;\n\n          if (done) {\n            return {\n              done: true\n            };\n          }\n\n          var _value = slicedToArray(value, 2);\n\n          node = _value[0];\n          path = _value[1];\n          remaining = node.marks.toArray();\n          return next();\n        };\n\n        return {\n          next: next\n        };\n      });\n    }\n    /**\n     * Merge a node backwards its previous sibling.\n     *\n     * @param {List|Key} path\n     * @return {Node}\n     */\n\n  }, {\n    key: 'mergeNode',\n    value: function mergeNode(path) {\n      var b = this.assertNode(path);\n      path = this.resolvePath(path);\n\n      if (path.last() === 0) {\n        throw new Error('Unable to merge node because it has no previous sibling: ' + b);\n      }\n\n      var withPath = PathUtils.decrement(path);\n      var a = this.assertNode(withPath);\n\n      if (a.object !== b.object) {\n        throw new Error('Unable to merge two different kinds of nodes: ' + a + ' and ' + b);\n      }\n\n      var newNode = a.object === 'text' ? a.mergeText(b) : a.set('nodes', a.nodes.concat(b.nodes));\n      var ret = this;\n      ret = ret.removeNode(path);\n      ret = ret.removeNode(withPath);\n      ret = ret.insertNode(withPath, newNode);\n      return ret;\n    }\n    /**\n     * Move a node by `path` to `newPath`.\n     *\n     * A `newIndex` can be provided when move nodes by `key`, to account for not\n     * being able to have a key for a location in the tree that doesn't exist yet.\n     *\n     * @param {List|Key} path\n     * @param {List|Key} newPath\n     * @param {Number} newIndex\n     * @return {Node}\n     */\n\n  }, {\n    key: 'moveNode',\n    value: function moveNode(path, newPath) {\n      var newIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var node = this.assertNode(path);\n      path = this.resolvePath(path);\n      newPath = this.resolvePath(newPath, newIndex);\n      var newParentPath = PathUtils.lift(newPath);\n      this.assertNode(newParentPath); // TODO: this is a bit hacky, re-creating the operation that led to this method being called\n      // Alternative 1: pass the operation through from apply -> value.moveNode\n      // Alternative 2: add a third property to the operation called \"transformedNewPath\", pass that through\n\n      var op = Operation.create({\n        type: 'move_node',\n        path: path,\n        newPath: newPath\n      });\n      newPath = PathUtils.transform(path, op).first();\n      var ret = this;\n      ret = ret.removeNode(path);\n      ret = ret.insertNode(newPath, node);\n      return ret;\n    }\n    /**\n     * Remove `mark` from text at `path`.\n     *\n     * @param {List} path\n     * @param {Mark} mark\n     * @return {Node}\n     */\n\n  }, {\n    key: 'removeMark',\n    value: function removeMark(path, mark) {\n      path = this.resolvePath(path);\n      var node = this.assertDescendant(path);\n      node = node.removeMark(mark);\n      var ret = this.replaceNode(path, node);\n      return ret;\n    }\n    /**\n     * Remove a node.\n     *\n     * @param {List|String} path\n     * @return {Node}\n     */\n\n  }, {\n    key: 'removeNode',\n    value: function removeNode(path) {\n      this.assertDescendant(path);\n      path = this.resolvePath(path);\n      var deep = path.flatMap(function (x) {\n        return ['nodes', x];\n      });\n      var ret = this.deleteIn(deep);\n      return ret;\n    }\n    /**\n     * Remove `text` at `offset` in node.\n     *\n     * @param {List|Key} path\n     * @param {Number} offset\n     * @param {String} text\n     * @return {Node}\n     */\n\n  }, {\n    key: 'removeText',\n    value: function removeText(path, offset, text) {\n      var node = this.assertDescendant(path);\n      node = node.removeText(offset, text.length);\n      var ret = this.replaceNode(path, node);\n      return ret;\n    }\n    /**\n     * Replace a `node` in the tree.\n     *\n     * @param {List|Key} path\n     * @param {Node} node\n     * @return {Node}\n     */\n\n  }, {\n    key: 'replaceNode',\n    value: function replaceNode(path, node) {\n      path = this.resolvePath(path);\n\n      if (!path) {\n        throw new Error('Unable to replace a node because it could not be found in the first place: ' + path);\n      }\n\n      if (!path.size) return node;\n      this.assertNode(path);\n      var deep = path.flatMap(function (x) {\n        return ['nodes', x];\n      });\n      var ret = this.setIn(deep, node);\n      return ret;\n    }\n    /**\n     * Resolve a `annotation`, relative to the node, ensuring that the keys and\n     * offsets in the annotation exist and that they are synced with the paths.\n     *\n     * @param {Annotation|Object} annotation\n     * @return {Annotation}\n     */\n\n  }, {\n    key: 'resolveAnnotation',\n    value: function resolveAnnotation(annotation) {\n      annotation = Annotation.create(annotation);\n      annotation = annotation.normalize(this);\n      return annotation;\n    }\n    /**\n     * Resolve a `decoration`, relative to the node, ensuring that the keys and\n     * offsets in the decoration exist and that they are synced with the paths.\n     *\n     * @param {Decoration|Object} decoration\n     * @return {Decoration}\n     */\n\n  }, {\n    key: 'resolveDecoration',\n    value: function resolveDecoration(decoration) {\n      decoration = Decoration.create(decoration);\n      decoration = decoration.normalize(this);\n      return decoration;\n    }\n    /**\n     * Resolve a `point`, relative to the node, ensuring that the keys and\n     * offsets in the point exist and that they are synced with the paths.\n     *\n     * @param {Point|Object} point\n     * @return {Point}\n     */\n\n  }, {\n    key: 'resolvePoint',\n    value: function resolvePoint(point) {\n      point = Point.create(point);\n      point = point.normalize(this);\n      return point;\n    }\n    /**\n     * Resolve a `range`, relative to the node, ensuring that the keys and\n     * offsets in the range exist and that they are synced with the paths.\n     *\n     * @param {Range|Object} range\n     * @return {Range}\n     */\n\n  }, {\n    key: 'resolveRange',\n    value: function resolveRange(range) {\n      range = Range.create(range);\n      range = range.normalize(this);\n      return range;\n    }\n    /**\n     * Resolve a `selection`, relative to the node, ensuring that the keys and\n     * offsets in the selection exist and that they are synced with the paths.\n     *\n     * @param {Selection|Object} selection\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'resolveSelection',\n    value: function resolveSelection(selection) {\n      selection = Selection.create(selection);\n      selection = selection.normalize(this);\n      return selection;\n    }\n    /**\n     * Set `properties` on a node.\n     *\n     * @param {List|String} path\n     * @param {Object} properties\n     * @return {Node}\n     */\n\n  }, {\n    key: 'setNode',\n    value: function setNode(path, properties) {\n      var node = this.assertNode(path);\n      node = node.merge(properties);\n      var ret = this.replaceNode(path, node);\n      return ret;\n    }\n    /**\n     * Set `properties` on `mark` on text at `offset` and `length` in node.\n     *\n     * @param {List|String} path\n     * @param {Number} offset\n     * @param {Number} length\n     * @param {Mark} mark\n     * @param {Object} properties\n     * @return {Node}\n     */\n\n  }, {\n    key: 'setMark',\n    value: function setMark(path, properties, newProperties) {\n      path = this.resolvePath(path);\n      var node = this.assertDescendant(path);\n      node = node.setMark(properties, newProperties);\n      var ret = this.replaceNode(path, node);\n      return ret;\n    }\n    /**\n     * Create an iteratable for the siblings in the tree at `path`.\n     *\n     * @param {List|Array} path\n     * @return {Iterable}\n     */\n\n  }, {\n    key: 'siblings',\n    value: function siblings(path, options) {\n      var iterable = this.createIterable(_extends({\n        path: path,\n        upward: false,\n        downward: false\n      }, options));\n      return iterable;\n    }\n    /**\n     * Split a node by `path` at `position` with optional `properties` to apply\n     * to the newly split node.\n     *\n     * @param {List|String} path\n     * @param {Number} position\n     * @param {Object} properties\n     * @return {Node}\n     */\n\n  }, {\n    key: 'splitNode',\n    value: function splitNode(path, position, properties) {\n      var child = this.assertNode(path);\n      path = this.resolvePath(path);\n      var a = void 0;\n      var b = void 0;\n\n      if (child.object === 'text') {\n        var _child$splitText = child.splitText(position);\n\n        var _child$splitText2 = slicedToArray(_child$splitText, 2);\n\n        a = _child$splitText2[0];\n        b = _child$splitText2[1];\n      } else {\n        var befores = child.nodes.take(position);\n        var afters = child.nodes.skip(position);\n        a = child.set('nodes', befores);\n        b = child.set('nodes', afters).regenerateKey();\n      }\n\n      if (properties && child.object !== 'text') {\n        b = b.merge(properties);\n      }\n\n      var ret = this;\n      ret = ret.removeNode(path);\n      ret = ret.insertNode(path, b);\n      ret = ret.insertNode(path, a);\n      return ret;\n    }\n    /**\n     * Create an iteratable for all the text node descendants.\n     *\n     * @param {Object} options\n     * @return {Iterable}\n     */\n\n  }, {\n    key: 'texts',\n    value: function texts(options) {\n      var iterable = this.descendants(_extends({\n        includeBlocks: false,\n        includeInlines: false,\n        includeDocument: false\n      }, options));\n      return iterable;\n    }\n    /**\n     * Deprecated.\n     */\n\n  }, {\n    key: 'getBlocksAtRange',\n    value: function getBlocksAtRange(range) {\n      warning(false, 'As of slate@0.44 the `node.getBlocksAtRange` method has been renamed to `getLeafBlocksAtRange`.');\n      return this.getLeafBlocksAtRange(range);\n    }\n  }, {\n    key: 'getBlocksAtRangeAsArray',\n    value: function getBlocksAtRangeAsArray(range) {\n      warning(false, 'As of slate@0.44 the `node.getBlocksAtRangeAsArray` method has been renamed to `getLeafBlocksAtRangeAsArray`.');\n      return this.getLeafBlocksAtRangeAsArray(range);\n    }\n  }, {\n    key: 'getInlinesAtRange',\n    value: function getInlinesAtRange(range) {\n      warning(false, 'As of slate@0.44 the `node.getInlinesAtRange` method has been renamed to `getLeafInlinesAtRange`.');\n      return this.getLeafInlinesAtRange(range);\n    }\n  }, {\n    key: 'getInlinesAtRangeAsArray',\n    value: function getInlinesAtRangeAsArray(range) {\n      warning(false, 'As of slate@0.44 the `node.getInlinesAtRangeAsArray` method has been renamed to `getLeafInlinesAtRangeAsArray`.');\n      return this.getLeafInlinesAtRangeAsArray(range);\n    }\n  }, {\n    key: 'getNextTextAndPath',\n    value: function getNextTextAndPath(path) {\n      warning(false, 'As of slate@0.47, the `getNextTextAndPath` method has been renamed to `getNextTextEntry`.');\n      return this.getNextTextEntry(path);\n    }\n  }, {\n    key: 'getNextDeepMatchingNodeAndPath',\n    value: function getNextDeepMatchingNodeAndPath(path) {\n      var iterator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return true;\n      };\n      warning(false, 'As of slate@0.47, the `getNextDeepMatchingNodeAndPath` method is deprecated.');\n      var match = this.getNextMatchingNodeAndPath(path);\n      if (!match) return null;\n\n      var _match3 = slicedToArray(match, 2),\n          nextNode = _match3[0],\n          nextPath = _match3[1];\n\n      var childMatch = void 0;\n\n      var assign = function assign() {\n        childMatch = nextNode.object !== 'text' && nextNode.findFirstDescendantAndPath(iterator, nextPath);\n        return childMatch;\n      };\n\n      while (assign(childMatch)) {\n        var _childMatch = childMatch;\n\n        var _childMatch2 = slicedToArray(_childMatch, 2);\n\n        nextNode = _childMatch2[0];\n        nextPath = _childMatch2[1];\n      }\n\n      if (!nextNode) return null;\n      return iterator(nextNode) ? [nextNode, nextPath] : this.getNextDeepMatchingNodeAndPath(match[1], iterator);\n    }\n  }, {\n    key: 'getPreviousTextAndPath',\n    value: function getPreviousTextAndPath(path) {\n      warning(false, 'As of slate@0.47, the `getPreviousTextAndPath` method has been renamed to `getPreviousTextEntry`.');\n      return this.getPreviousTextEntry(path);\n    }\n  }, {\n    key: 'findFirstDescendantAndPath',\n    value: function findFirstDescendantAndPath(iterator, pathToThisNode) {\n      warning(false, 'As of slate@0.47, the `findFirstDescendantAndPath` method is deprecated.');\n      return this.findDescendantAndPath(iterator, pathToThisNode, false);\n    }\n  }, {\n    key: 'getPreviousMatchingNodeAndPath',\n    value: function getPreviousMatchingNodeAndPath(path) {\n      var iterator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return true;\n      };\n      warning(false, 'As of slate@0.47, the `getPreviousMatchingNodeAndPath` method is deprecated.');\n      if (!path) return null;\n\n      for (var i = path.size; i > 0; i--) {\n        var p = path.slice(0, i);\n        if (p.last() === 0) continue;\n        var previousPath = PathUtils.decrement(p);\n        var previousNode = this.getNode(previousPath);\n\n        while (previousNode && !iterator(previousNode)) {\n          previousPath = PathUtils.decrement(previousPath);\n          previousNode = this.getNode(previousPath);\n        }\n\n        if (previousNode) return [previousNode, previousPath];\n      }\n\n      return null;\n    }\n  }, {\n    key: 'getPreviousDeepMatchingNodeAndPath',\n    value: function getPreviousDeepMatchingNodeAndPath(path) {\n      var iterator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return true;\n      };\n      warning(false, 'As of slate@0.47, the `getPreviousDeepMatchingNodeAndPath` method is deprecated.');\n      var match = this.getPreviousMatchingNodeAndPath(path);\n      if (!match) return null;\n\n      var _match4 = slicedToArray(match, 2),\n          previousNode = _match4[0],\n          previousPath = _match4[1];\n\n      var childMatch = void 0;\n\n      var assign = function assign() {\n        childMatch = previousNode.object !== 'text' && previousNode.findLastDescendantAndPath(iterator, previousPath);\n        return childMatch;\n      };\n\n      while (assign(childMatch)) {\n        var _childMatch3 = childMatch;\n\n        var _childMatch4 = slicedToArray(_childMatch3, 2);\n\n        previousNode = _childMatch4[0];\n        previousPath = _childMatch4[1];\n      }\n\n      if (!previousNode) return null;\n      return iterator(previousNode) ? [previousNode, previousPath] : this.getPreviousDeepMatchingNodeAndPath(match[1], iterator);\n    }\n  }, {\n    key: 'findLastDescendantAndPath',\n    value: function findLastDescendantAndPath(iterator, pathToThisNode) {\n      warning(false, 'As of slate@0.47, the `findLastDescendantAndPath` method is deprecated.');\n      return this.findDescendantAndPath(iterator, pathToThisNode, true);\n    }\n  }, {\n    key: 'findDescendantAndPath',\n    value: function findDescendantAndPath(iterator) {\n      var pathToThisNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PathUtils.create([]);\n      var findLast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      warning(false, 'As of slate@0.47, the `findDescendantAndPath` method is deprecated.');\n      var found = void 0;\n      var foundPath = void 0;\n      this.forEachDescendantWithPath(function (node, path, nodes) {\n        if (iterator(node, path, nodes)) {\n          found = node;\n          foundPath = path;\n          return false;\n        }\n      }, pathToThisNode, findLast);\n      return found ? [found, foundPath] : null;\n    }\n  }, {\n    key: 'forEachDescendantWithPath',\n    value: function forEachDescendantWithPath(iterator) {\n      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PathUtils.create([]);\n      var findLast = arguments[2];\n      warning(false, 'As of slate@0.47, the `forEachDescendantWithPath` method is deprecated.');\n      var nodes = this.nodes;\n      var ret = void 0;\n      if (findLast) nodes = nodes.reverse();\n      nodes.forEach(function (child, i) {\n        var childPath = path.concat(i);\n\n        if (iterator(child, childPath, nodes) === false) {\n          ret = false;\n          return false;\n        }\n\n        if (child.object !== 'text') {\n          ret = child.forEachDescendantWithPath(iterator, childPath, findLast);\n          return ret;\n        }\n      });\n      return ret;\n    }\n  }, {\n    key: 'getNextMatchingNodeAndPath',\n    value: function getNextMatchingNodeAndPath(path) {\n      var iterator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return true;\n      };\n      warning(false, 'As of slate@0.47, the `getNextMatchingNodeAndPath` method is deprecated.');\n      if (!path) return null;\n\n      for (var i = path.size; i > 0; i--) {\n        var p = path.slice(0, i);\n        var nextPath = PathUtils.increment(p);\n        var nextNode = this.getNode(nextPath);\n\n        while (nextNode && !iterator(nextNode)) {\n          nextPath = PathUtils.increment(nextPath);\n          nextNode = this.getNode(nextPath);\n        }\n\n        if (nextNode) return [nextNode, nextPath];\n      }\n\n      return null;\n    }\n  }, {\n    key: 'getSelectionIndexes',\n    value: function getSelectionIndexes(range) {\n      var isSelected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      warning(false, 'As of slate@0.47, the `getSelectionIndexes` method is deprecated.');\n      var start = range.start,\n          end = range.end; // PERF: if we're not selected, we can exit early.\n\n      if (!isSelected) {\n        return null;\n      } // PERF: if we've been given an invalid selection we can exit early.\n\n\n      if (range.isUnset) {\n        return null;\n      } // PERF: if the start and end keys are the same, just check for the child\n      // that contains that single key.\n\n\n      if (start.path.equals(end.path)) {\n        var child = this.getFurthestAncestor(start.path);\n        var index = child ? this.nodes.indexOf(child) : null;\n        return {\n          start: index,\n          end: index + 1\n        };\n      } // Otherwise, check all of the children...\n\n\n      var startIndex = null;\n      var endIndex = null;\n      this.nodes.forEach(function (child, i) {\n        if (child.object === 'text') {\n          if (startIndex == null && child.key === start.key) startIndex = i;\n          if (endIndex == null && child.key === end.key) endIndex = i + 1;\n        } else {\n          if (startIndex == null && child.hasDescendant(start.key)) startIndex = i;\n          if (endIndex == null && child.hasDescendant(end.key)) endIndex = i + 1;\n        } // PERF: exit early if both start and end have been found.\n\n\n        return startIndex == null || endIndex == null;\n      });\n\n      if (isSelected && startIndex == null) {\n        startIndex = 0;\n      }\n\n      if (isSelected && endIndex == null) {\n        endIndex = this.nodes.size;\n      }\n\n      if (startIndex == null) {\n        return null;\n      }\n\n      return {\n        start: startIndex,\n        end: endIndex\n      };\n    }\n  }, {\n    key: 'getTextsBetweenPositionsAsArray',\n    value: function getTextsBetweenPositionsAsArray(startPath, endPath) {\n      warning(false, 'As of slate@0.47, the `getTextsBetweenPositionsAsArray` method is deprecated.');\n      startPath = this.resolvePath(startPath);\n      endPath = this.resolvePath(endPath);\n      return this.getTextsBetweenPathPositionsAsArray(startPath, endPath);\n    }\n  }, {\n    key: 'getOrderedMarksBetweenPositions',\n    value: function getOrderedMarksBetweenPositions(startPath, startOffset, endPath, endOffset) {\n      warning(false, 'As of slate@0.47, the `getOrderedMarksBetweenPositions` method is deprecated.');\n      startPath = this.resolvePath(startPath);\n      endPath = this.resolvePath(endPath);\n      var startText = this.getDescendant(startPath); // PERF: if the paths are equal, we can just use the start.\n\n      if (PathUtils.isEqual(startPath, endPath)) {\n        return startText.marks;\n      }\n\n      var texts = this.getTextsBetweenPathPositionsAsArray(startPath, endPath);\n      return OrderedSet().withMutations(function (result) {\n        texts.forEach(function (text) {\n          result.union(text.marks);\n        });\n      });\n    }\n  }, {\n    key: 'getTextsBetweenPathPositionsAsArray',\n    value: function getTextsBetweenPathPositionsAsArray(startPath, endPath) {\n      warning(false, 'As of slate@0.47, the `getTextsBetweenPathPositionsAsArray` method is deprecated.'); // PERF: the most common case is when the range is in a single text node,\n      // where we can avoid a lot of iterating of the tree.\n\n      if (startPath && endPath && PathUtils.isEqual(startPath, endPath)) {\n        return [this.getDescendant(startPath)];\n      } else if (!startPath && !endPath) {\n        return this.getTextsAsArray();\n      }\n\n      var startIndex = startPath ? startPath.get(0, 0) : 0;\n      var endIndex = endPath ? endPath.get(0, this.nodes.size - 1) : this.nodes.size - 1;\n      var array = [];\n      this.nodes.slice(startIndex, endIndex + 1).forEach(function (node, i) {\n        if (node.object === 'text') {\n          array.push(node);\n        } else {\n          // For the node at start and end of this list, we want to provide a start and end path\n          // For other nodes, we can just get all their text nodes, they are between the paths\n          var childStartPath = startPath && i === 0 ? PathUtils.drop(startPath) : null;\n          var childEndPath = endPath && i === endIndex - startIndex ? PathUtils.drop(endPath) : null;\n          array = array.concat(node.getTextsBetweenPathPositionsAsArray(childStartPath, childEndPath));\n        }\n      });\n      return array;\n    }\n  }, {\n    key: 'getFurthestAncestor',\n    value: function getFurthestAncestor(path) {\n      warning(false, 'As of slate@0.47, the `getFurthestAncestor` method has been renamed to `getFurthestChild`.');\n      return this.getFurthestChild(path);\n    }\n  }, {\n    key: 'getLeafBlocksAtRangeAsArray',\n    value: function getLeafBlocksAtRangeAsArray(range) {\n      warning(false, 'As of slate@0.47, the `getLeafBlocksAtRangeAsArray` method is deprecated.');\n      range = this.resolveRange(range);\n      if (range.isUnset) return [];\n      var _range6 = range,\n          start = _range6.start,\n          end = _range6.end;\n      return this.getLeafBlocksBetweenPathPositionsAsArray(start.path, end.path);\n    }\n  }, {\n    key: 'getLeafBlocksBetweenPathPositionsAsArray',\n    value: function getLeafBlocksBetweenPathPositionsAsArray(startPath, endPath) {\n      warning(false, 'As of slate@0.47, the `getLeafBlocksBetweenPathPositionsAsArray` method is deprecated.'); // PERF: the most common case is when the range is in a single block node,\n      // where we can avoid a lot of iterating of the tree.\n\n      if (startPath && endPath && PathUtils.isEqual(startPath, endPath)) {\n        return [this.getClosestBlock(startPath)];\n      } else if (!startPath && !endPath) {\n        return this.getBlocksAsArray();\n      }\n\n      var startIndex = startPath ? startPath.get(0, 0) : 0;\n      var endIndex = endPath ? endPath.get(0, this.nodes.size - 1) : this.nodes.size - 1;\n      var array = [];\n      this.nodes.slice(startIndex, endIndex + 1).forEach(function (node, i) {\n        if (node.object !== 'block') {\n          return;\n        } else if (node.isLeafBlock()) {\n          array.push(node);\n        } else {\n          var childStartPath = startPath && i === 0 ? PathUtils.drop(startPath) : null;\n          var childEndPath = endPath && i === endIndex - startIndex ? PathUtils.drop(endPath) : null;\n          array = array.concat(node.getLeafBlocksBetweenPathPositionsAsArray(childStartPath, childEndPath));\n        }\n      });\n      return array;\n    }\n  }, {\n    key: 'getBlocksAsArray',\n    value: function getBlocksAsArray() {\n      warning(false, 'As of slate@0.47, the `getBlocksAsArray` method is deprecated.');\n      var iterable = this.blocks({\n        onlyLeaves: true\n      });\n      var array = Array.from(iterable, function (_ref43) {\n        var _ref44 = slicedToArray(_ref43, 1),\n            node = _ref44[0];\n\n        return node;\n      });\n      return array;\n    }\n  }, {\n    key: 'getBlocksByTypeAsArray',\n    value: function getBlocksByTypeAsArray(type) {\n      warning(false, 'As of slate@0.47, the `getBlocksByTypeAsArray` method is deprecated.');\n      var iterable = this.blocks({\n        onlyLeaves: true,\n        onlyTypes: [type]\n      });\n      var array = Array.from(iterable, function (_ref45) {\n        var _ref46 = slicedToArray(_ref45, 1),\n            node = _ref46[0];\n\n        return node;\n      });\n      return array;\n    }\n  }, {\n    key: 'getFurthestOnlyChildAncestor',\n    value: function getFurthestOnlyChildAncestor(path) {\n      warning(false, 'As of slate@0.47, the `getFurthestOnlyChildAncestor` method is deprecated.');\n      var ancestors = this.getAncestors(path);\n      if (!ancestors) return null;\n      var furthest = ancestors.rest().reverse().takeUntil(function (p) {\n        return p.nodes.size > 1;\n      }).last();\n      return furthest || null;\n    }\n  }, {\n    key: 'getInlinesAsArray',\n    value: function getInlinesAsArray() {\n      warning(false, 'As of slate@0.47, the `getInlinesAsArray` method is deprecated.');\n      var array = Array.from(this.inlines({\n        onlyLeaves: true\n      }), function (_ref47) {\n        var _ref48 = slicedToArray(_ref47, 1),\n            node = _ref48[0];\n\n        return node;\n      });\n      return array;\n    }\n  }, {\n    key: 'getInlinesByTypeAsArray',\n    value: function getInlinesByTypeAsArray(type) {\n      warning(false, 'As of slate@0.47, the `getInlinesByTypeAsArray` method is deprecated.');\n      var array = Array.from(this.inlines({\n        onlyLeaves: true,\n        onlyTypes: [type]\n      }), function (_ref49) {\n        var _ref50 = slicedToArray(_ref49, 1),\n            node = _ref50[0];\n\n        return node;\n      });\n      return array;\n    }\n  }, {\n    key: 'getLeafInlinesAtRangeAsArray',\n    value: function getLeafInlinesAtRangeAsArray(range) {\n      var _this4 = this;\n\n      warning(false, 'As of slate@0.47, the `getLeafInlinesAtRangeAsArray` method is deprecated.');\n      range = this.resolveRange(range);\n      if (range.isUnset) return [];\n      var array = this.getTextsAtRangeAsArray(range).map(function (text) {\n        return _this4.getClosestInline(text.key);\n      }).filter(function (exists) {\n        return exists;\n      });\n      return array;\n    }\n  }, {\n    key: 'getOrderedMarks',\n    value: function getOrderedMarks() {\n      warning(false, 'As of slate@0.47, the `getOrderedMarks` method has been folded into `getMarks`, which will now return an ordered set.');\n      return this.getMarks();\n    }\n  }, {\n    key: 'getOrderedMarksAtRange',\n    value: function getOrderedMarksAtRange(range) {\n      warning(false, 'As of slate@0.47, the `getOrderedMarksAtRange` method has been folded into `getMarksAtRange`, which will now return an ordered set.');\n      return this.getMarksAtRange(range);\n    }\n  }, {\n    key: 'getOrderedMarksByType',\n    value: function getOrderedMarksByType(type) {\n      warning(false, 'As of slate@0.47, the `getOrderedMarksByType` method has been folded into `getMarksByType`, which will now return an ordered set.');\n      return this.getMarksByType(type);\n    }\n  }, {\n    key: 'getMarksByTypeAsArray',\n    value: function getMarksByTypeAsArray(type) {\n      warning(false, 'As of slate@0.47, the `getMarksByTypeAsArray` method is deprecated.');\n      var array = this.nodes.reduce(function (memo, node) {\n        return node.object === 'text' ? memo.concat(node.marks.filter(function (m) {\n          return m.type === type;\n        })) : memo.concat(node.getMarksByTypeAsArray(type));\n      }, []);\n      return array;\n    }\n  }, {\n    key: 'getMarksAsArray',\n    value: function getMarksAsArray() {\n      var _ref53;\n\n      warning(false, 'As of slate@0.47, the `getMarksAsArray` method is deprecated.');\n      var result = [];\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = this.texts()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var _ref51 = _step8.value;\n\n          var _ref52 = slicedToArray(_ref51, 1);\n\n          var node = _ref52[0];\n          result.push(node.marks.toArray());\n        } // PERF: use only one concat rather than multiple for speed.\n\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n\n      var array = (_ref53 = []).concat.apply(_ref53, result);\n\n      return array;\n    }\n  }, {\n    key: 'getRootInlinesAtRangeAsArray',\n    value: function getRootInlinesAtRangeAsArray(range) {\n      var _this5 = this;\n\n      warning(false, 'As of slate@0.47, the `getRootInlinesAtRangeAsArray` method is deprecated.');\n      range = this.resolveRange(range);\n      if (range.isUnset) return List();\n      var array = this.getTextsAtRangeAsArray(range).map(function (text) {\n        return _this5.getFurthestInline(text.key);\n      }).filter(function (exists) {\n        return exists;\n      });\n      return array;\n    }\n  }, {\n    key: 'getTextsAsArray',\n    value: function getTextsAsArray() {\n      warning(false, 'As of slate@0.47, the `getTextsAsArray` method is deprecated.');\n      var iterable = this.texts();\n      var array = Array.from(iterable, function (_ref54) {\n        var _ref55 = slicedToArray(_ref54, 1),\n            node = _ref55[0];\n\n        return node;\n      });\n      return array;\n    }\n  }, {\n    key: 'getTextsAtRangeAsArray',\n    value: function getTextsAtRangeAsArray(range) {\n      warning(false, 'As of slate@0.47, the `getTextsAtRangeAsArray` method is deprecated.');\n      var iterable = this.texts({\n        range: range\n      });\n      var array = Array.from(iterable, function (_ref56) {\n        var _ref57 = slicedToArray(_ref56, 1),\n            node = _ref57[0];\n\n        return node;\n      });\n      return array;\n    }\n  }, {\n    key: 'getMarksAtPosition',\n    value: function getMarksAtPosition(path, offset) {\n      warning(false, 'As of slate@0.47, the `getMarksAtPosition` method is deprecated.');\n      path = this.resolvePath(path);\n      var text = this.getDescendant(path);\n      var currentMarks = text.marks;\n\n      if (offset !== 0) {\n        return OrderedSet(currentMarks);\n      }\n\n      var closestBlock = this.getClosestBlock(path); // insert mark for empty block; the empty block are often created by split node or add marks in a range including empty blocks\n\n      if (closestBlock.text === '') {\n        return OrderedSet(currentMarks);\n      }\n\n      var _texts13 = this.texts({\n        path: path,\n        direction: 'backward'\n      }),\n          _texts14 = slicedToArray(_texts13, 1),\n          previous = _texts14[0];\n\n      if (!previous) {\n        return OrderedSet();\n      }\n\n      var _previous2 = slicedToArray(previous, 2),\n          previousText = _previous2[0],\n          previousPath = _previous2[1];\n\n      if (closestBlock.hasDescendant(previousPath)) {\n        return OrderedSet(previousText.marks);\n      }\n\n      return OrderedSet(currentMarks);\n    }\n  }, {\n    key: 'getNodesAtRange',\n    value: function getNodesAtRange(range) {\n      warning(false, 'As of slate@0.47, the `getNodesAtRange` method has been renamed to `getDescendantsAtRange`.');\n      var iterable = this.descendants({\n        range: range\n      });\n      var array = Array.from(iterable, function (_ref58) {\n        var _ref59 = slicedToArray(_ref58, 1),\n            node = _ref59[0];\n\n        return node;\n      });\n      var list = List(array);\n      return list;\n    }\n  }, {\n    key: 'isNodeInRange',\n    value: function isNodeInRange(path, range) {\n      warning(false, 'As of slate@0.47, the `isNodeInRange` method has been renamed to `isInRange`.');\n      return this.isInRange(path, range);\n    }\n  }, {\n    key: 'text',\n\n    /**\n     * Get the concatenated text of the node.\n     *\n     * @return {String}\n     */\n    get: function get$$1() {\n      return this.getText();\n    }\n  }]);\n  return ElementInterface;\n}();\n/**\n * Mix in assertion variants.\n */\n\n\nvar ASSERTS = ['Child', 'Depth', 'Descendant', 'Node', 'Parent', 'Path'];\n\nvar _loop$1 = function _loop(method) {\n  ElementInterface.prototype['assert' + method] = function (path) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var ret = this['get' + method].apply(this, [path].concat(args));\n\n    if (ret == null) {\n      throw new Error('`Node.assert' + method + '` could not find node with path or key: ' + path);\n    }\n\n    return ret;\n  };\n};\n\nvar _iteratorNormalCompletion9 = true;\nvar _didIteratorError9 = false;\nvar _iteratorError9 = undefined;\n\ntry {\n  for (var _iterator9 = ASSERTS[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n    var method$1 = _step9.value;\n\n    _loop$1(method$1);\n  }\n  /**\n   * Memoize read methods.\n   */\n\n} catch (err) {\n  _didIteratorError9 = true;\n  _iteratorError9 = err;\n} finally {\n  try {\n    if (!_iteratorNormalCompletion9 && _iterator9.return) {\n      _iterator9.return();\n    }\n  } finally {\n    if (_didIteratorError9) {\n      throw _iteratorError9;\n    }\n  }\n}\n\nmemoize(ElementInterface.prototype, ['getBlocksAsArray', 'getBlocksByTypeAsArray', 'getDecorations', 'getFragmentAtRange', 'getInlinesAsArray', 'getInlinesByTypeAsArray', 'getInsertMarksAtRange', 'getLeafBlocksAtRangeAsArray', 'getLeafBlocksAtRangeAsArray', 'getLeafInlinesAtRangeAsArray', 'getMarksAsArray', 'getMarksAtPosition', 'getMarksByTypeAsArray', 'getNextBlock', 'getNodesAtRange', 'getNodesToPathsMap', 'getOffset', 'getOffsetAtRange', 'getOrderedMarksBetweenPositions', 'getPreviousBlock', 'getRootBlocksAtRange', 'getRootInlinesAtRangeAsArray', 'getTextAtOffset', 'getTextDirection', 'getTextsAsArray', 'getTextsBetweenPathPositionsAsArray']);\n/**\n * Mix in the element interface.\n */\n\nmixin(ElementInterface, [Block, Document, Inline]);\n/**\n * The interface that `Decoration`, `Range` and `Selection` all implement, to make\n * working anchor and focus points easier.\n *\n * @type {Class}\n */\n\nvar RangeInterface = function () {\n  function RangeInterface() {\n    classCallCheck(this, RangeInterface);\n  }\n\n  createClass(RangeInterface, [{\n    key: 'flip',\n\n    /**\n     * Flip the range.\n     *\n     * @return {Range}\n     */\n    value: function flip() {\n      var range = this.setPoints([this.focus, this.anchor]);\n      return range;\n    }\n    /**\n     * Move the anchor and focus offsets forward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveForward',\n    value: function moveForward(n) {\n      return this.updatePoints(function (point) {\n        return point.moveForward(n);\n      });\n    }\n    /**\n     * Move the anchor and focus offsets backward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveBackward',\n    value: function moveBackward(n) {\n      return this.updatePoints(function (point) {\n        return point.moveBackward(n);\n      });\n    }\n    /**\n     * Move the anchor offset backward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveAnchorBackward',\n    value: function moveAnchorBackward(n) {\n      var range = this.setAnchor(this.anchor.moveBackward(n));\n      return range;\n    }\n    /**\n     * Move the anchor offset forward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveAnchorForward',\n    value: function moveAnchorForward(n) {\n      var range = this.setAnchor(this.anchor.moveForward(n));\n      return range;\n    }\n    /**\n     * Move the range's anchor point to a new `path` and `offset`.\n     *\n     * Optionally, the `path` can be a key string, or omitted entirely in which\n     * case it would be the offset number.\n     *\n     * @param {List|String} path\n     * @param {Number} offset\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveAnchorTo',\n    value: function moveAnchorTo(path, offset) {\n      var range = this.setAnchor(this.anchor.moveTo(path, offset));\n      return range;\n    }\n    /**\n     * Move the range's anchor point to the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveAnchorToStartOfNode',\n    value: function moveAnchorToStartOfNode(node) {\n      var range = this.setAnchor(this.anchor.moveToStartOfNode(node));\n      return range;\n    }\n    /**\n     * Move the range's anchor point to the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveAnchorToEndOfNode',\n    value: function moveAnchorToEndOfNode(node) {\n      var range = this.setAnchor(this.anchor.moveToEndOfNode(node));\n      return range;\n    }\n    /**\n     * Move the end offset backward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveEndBackward',\n    value: function moveEndBackward(n) {\n      var range = this.setEnd(this.end.moveBackward(n));\n      return range;\n    }\n    /**\n     * Move the end offset forward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveEndForward',\n    value: function moveEndForward(n) {\n      var range = this.setEnd(this.end.moveForward(n));\n      return range;\n    }\n    /**\n     * Move the range's end point to a new `path` and `offset`.\n     *\n     * Optionally, the `path` can be a key string, or omitted entirely in which\n     * case it would be the offset number.\n     *\n     * @param {List|String} path\n     * @param {Number} offset\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveEndTo',\n    value: function moveEndTo(path, offset) {\n      var range = this.setEnd(this.end.moveTo(path, offset));\n      return range;\n    }\n    /**\n     * Move the range's end point to the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveEndToStartOfNode',\n    value: function moveEndToStartOfNode(node) {\n      var range = this.setEnd(this.end.moveToStartOfNode(node));\n      return range;\n    }\n    /**\n     * Move the range's end point to the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveEndToEndOfNode',\n    value: function moveEndToEndOfNode(node) {\n      var range = this.setEnd(this.end.moveToEndOfNode(node));\n      return range;\n    }\n    /**\n     * Move the focus offset backward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveFocusBackward',\n    value: function moveFocusBackward(n) {\n      var range = this.setFocus(this.focus.moveBackward(n));\n      return range;\n    }\n    /**\n     * Move the focus offset forward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveFocusForward',\n    value: function moveFocusForward(n) {\n      var range = this.setFocus(this.focus.moveForward(n));\n      return range;\n    }\n    /**\n     * Move the range's focus point to a new `path` and `offset`.\n     *\n     * Optionally, the `path` can be a key string, or omitted entirely in which\n     * case it would be the offset number.\n     *\n     * @param {List|String} path\n     * @param {Number} offset\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveFocusTo',\n    value: function moveFocusTo(path, offset) {\n      var range = this.setFocus(this.focus.moveTo(path, offset));\n      return range;\n    }\n    /**\n     * Move the range's focus point to the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveFocusToStartOfNode',\n    value: function moveFocusToStartOfNode(node) {\n      var range = this.setFocus(this.focus.moveToStartOfNode(node));\n      return range;\n    }\n    /**\n     * Move the range's focus point to the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveFocusToEndOfNode',\n    value: function moveFocusToEndOfNode(node) {\n      var range = this.setFocus(this.focus.moveToEndOfNode(node));\n      return range;\n    }\n    /**\n     * Move the start offset backward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveStartBackward',\n    value: function moveStartBackward(n) {\n      var range = this.setStart(this.start.moveBackward(n));\n      return range;\n    }\n    /**\n     * Move the start offset forward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveStartForward',\n    value: function moveStartForward(n) {\n      var range = this.setStart(this.start.moveForward(n));\n      return range;\n    }\n    /**\n     * Move the range's start point to a new `path` and `offset`.\n     *\n     * Optionally, the `path` can be a key string, or omitted entirely in which\n     * case it would be the offset number.\n     *\n     * @param {List|String} path\n     * @param {Number} offset\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveStartTo',\n    value: function moveStartTo(path, offset) {\n      var range = this.setStart(this.start.moveTo(path, offset));\n      return range;\n    }\n    /**\n     * Move the range's start point to the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveStartToStartOfNode',\n    value: function moveStartToStartOfNode(node) {\n      var range = this.setStart(this.start.moveToStartOfNode(node));\n      return range;\n    }\n    /**\n     * Move the range's start point to the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveStartToEndOfNode',\n    value: function moveStartToEndOfNode(node) {\n      var range = this.setStart(this.start.moveToEndOfNode(node));\n      return range;\n    }\n    /**\n     * Move range's points to a new `path` and `offset`.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveTo',\n    value: function moveTo(path, offset) {\n      return this.updatePoints(function (point) {\n        return point.moveTo(path, offset);\n      });\n    }\n    /**\n     * Move the focus point to the anchor point.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveToAnchor',\n    value: function moveToAnchor() {\n      var range = this.setFocus(this.anchor);\n      return range;\n    }\n    /**\n     * Move the start point to the end point.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveToEnd',\n    value: function moveToEnd() {\n      var range = this.setStart(this.end);\n      return range;\n    }\n    /**\n     * Move the range's points to the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveToEndOfNode',\n    value: function moveToEndOfNode(node) {\n      return this.updatePoints(function (point) {\n        return point.moveToEndOfNode(node);\n      });\n    }\n    /**\n     * Move the anchor point to the focus point.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveToFocus',\n    value: function moveToFocus() {\n      var range = this.setAnchor(this.focus);\n      return range;\n    }\n    /**\n     * Move to the entire range of `start` and `end` nodes.\n     *\n     * @param {Node} start\n     * @param {Node} end (optional)\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveToRangeOfNode',\n    value: function moveToRangeOfNode(start) {\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : start;\n      var range = this.setPoints([this.anchor.moveToStartOfNode(start), this.focus.moveToEndOfNode(end)]);\n      return range;\n    }\n    /**\n     * Move the end point to the start point.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveToStart',\n    value: function moveToStart() {\n      var range = this.setEnd(this.start);\n      return range;\n    }\n    /**\n     * Move the range's points to the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveToStartOfNode',\n    value: function moveToStartOfNode(node) {\n      return this.updatePoints(function (point) {\n        return point.moveToStartOfNode(node);\n      });\n    }\n    /**\n     * Normalize the range, relative to a `node`, ensuring that the anchor\n     * and focus nodes of the range always refer to leaf text nodes.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'normalize',\n    value: function normalize(node) {\n      return this.updatePoints(function (point) {\n        return point.normalize(node);\n      });\n    }\n    /**\n     * Set the anchor point to a new `anchor`.\n     *\n     * @param {Point} anchor\n     * @return {Range}\n     */\n\n  }, {\n    key: 'setAnchor',\n    value: function setAnchor(anchor) {\n      var range = this.set('anchor', anchor);\n      return range;\n    }\n    /**\n     * Set the end point to a new `point`.\n     *\n     * @param {Point} point\n     * @return {Range}\n     */\n\n  }, {\n    key: 'setEnd',\n    value: function setEnd(point) {\n      var range = this.isBackward ? this.setAnchor(point) : this.setFocus(point);\n      return range;\n    }\n    /**\n     * Set the focus point to a new `focus`.\n     *\n     * @param {Point} focus\n     * @return {Range}\n     */\n\n  }, {\n    key: 'setFocus',\n    value: function setFocus(focus) {\n      var range = this.set('focus', focus);\n      return range;\n    }\n    /**\n     * Set the anchor and focus points to new `values`.\n     *\n     * @param {Array<Point>} values\n     * @return {Range}\n     */\n\n  }, {\n    key: 'setPoints',\n    value: function setPoints(values) {\n      var _values = slicedToArray(values, 2),\n          anchor = _values[0],\n          focus = _values[1];\n\n      var range = this.set('anchor', anchor).set('focus', focus);\n      return range;\n    }\n    /**\n     * Set the anchor and focus points with `updater` callback\n     *\n     * @param {Function} updater\n     * @return {Range}\n     */\n\n  }, {\n    key: 'updatePoints',\n    value: function updatePoints(updater) {\n      var anchor = this.anchor,\n          focus = this.focus;\n      anchor = updater(anchor);\n      focus = updater(focus);\n      return this.merge({\n        anchor: anchor,\n        focus: focus\n      });\n    }\n    /**\n     * Set the start point to a new `point`.\n     *\n     * @param {Point} point\n     * @return {Range}\n     */\n\n  }, {\n    key: 'setStart',\n    value: function setStart(point) {\n      var range = this.isBackward ? this.setFocus(point) : this.setAnchor(point);\n      return range;\n    }\n    /**\n     * Set new `properties` on the range.\n     *\n     * @param {Object|Range} properties\n     * @return {Range}\n     */\n\n  }, {\n    key: 'setProperties',\n    value: function setProperties(properties) {\n      properties = Range.createProperties(properties);\n      var _properties = properties,\n          anchor = _properties.anchor,\n          focus = _properties.focus,\n          props = objectWithoutProperties(_properties, ['anchor', 'focus']);\n\n      if (anchor) {\n        props.anchor = Point.create(anchor);\n      }\n\n      if (focus) {\n        props.focus = Point.create(focus);\n      }\n\n      var range = this.merge(props);\n      return range;\n    }\n    /**\n     * Return a JSON representation of the range.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var object = {\n        object: this.object,\n        anchor: this.anchor.toJSON(options),\n        focus: this.focus.toJSON(options)\n      };\n      return object;\n    }\n    /**\n     * Return a `Range` instance from any range-like instance.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'toRange',\n    value: function toRange() {\n      var properties = Range.createProperties(this);\n      var range = Range.create(properties);\n      return range;\n    }\n    /**\n     * Unset the range.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'unset',\n    value: function unset() {\n      var range = this.updatePoints(function (p) {\n        return p.unset();\n      });\n      return range;\n    }\n  }, {\n    key: 'isCollapsed',\n\n    /**\n     * Check whether the range is collapsed.\n     *\n     * @return {Boolean}\n     */\n    get: function get$$1() {\n      return this.anchor === this.focus || this.anchor.key === this.focus.key && this.anchor.offset === this.focus.offset;\n    }\n    /**\n     * Check whether the range is expanded.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isExpanded',\n    get: function get$$1() {\n      return !this.isCollapsed;\n    }\n    /**\n     * Check whether the range is backward.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isBackward',\n    get: function get$$1() {\n      var isUnset = this.isUnset,\n          anchor = this.anchor,\n          focus = this.focus;\n\n      if (isUnset) {\n        return null;\n      }\n\n      if (anchor.key === focus.key) {\n        return anchor.offset > focus.offset;\n      }\n\n      var isBackward = PathUtils.isBefore(focus.path, anchor.path);\n      return isBackward;\n    }\n    /**\n     * Check whether the range is forward.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isForward',\n    get: function get$$1() {\n      var isBackward = this.isBackward;\n      var isForward = isBackward == null ? null : !isBackward;\n      return isForward;\n    }\n    /**\n     * Check whether the range isn't set.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isUnset',\n    get: function get$$1() {\n      var anchor = this.anchor,\n          focus = this.focus;\n      var isUnset = anchor.isUnset || focus.isUnset;\n      return isUnset;\n    }\n    /**\n     * Check whether the range is set.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isSet',\n    get: function get$$1() {\n      return !this.isUnset;\n    }\n    /**\n     * Get the start point.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'start',\n    get: function get$$1() {\n      return this.isBackward ? this.focus : this.anchor;\n    }\n    /**\n     * Get the end point.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'end',\n    get: function get$$1() {\n      return this.isBackward ? this.anchor : this.focus;\n    }\n  }]);\n  return RangeInterface;\n}();\n/**\n * Mix in the range interface.\n *\n * @param {Record}\n */\n\n\nmixin(RangeInterface, [Annotation, Decoration, Range, Selection]);\nvar index = {\n  Annotation: Annotation,\n  Block: Block,\n  Change: Change,\n  Data: Data,\n  Decoration: Decoration,\n  Document: Document,\n  Editor: Editor,\n  Inline: Inline,\n  KeyUtils: KeyUtils,\n  Leaf: Leaf$1,\n  Mark: Mark,\n  Node: Node,\n  Operation: Operation,\n  PathUtils: PathUtils,\n  Point: Point,\n  Range: Range,\n  resetMemoization: resetMemoization,\n  Selection: Selection,\n  Text: Text,\n  TextUtils: TextUtils,\n  useMemoization: useMemoization,\n  Value: Value\n};\nexport default index;\nexport { Annotation, Block, Change, Data, Decoration, Document, Editor, Inline, KeyUtils, Leaf$1 as Leaf, Mark, Node, Operation, PathUtils, Point, Range, resetMemoization, Selection, Text, TextUtils, useMemoization, Value };","map":{"version":3,"sources":["../src/utils/key-utils.js","../src/utils/path-utils.js","../src/models/point.js","../src/models/data.js","../src/models/mark.js","../src/models/decoration.js","../src/models/selection.js","../src/utils/is-object.js","../src/models/range.js","../src/models/annotation.js","../src/models/document.js","../src/models/inline.js","../src/models/text.js","../src/models/node.js","../src/models/block.js","../src/models/value.js","../src/operations/apply.js","../src/operations/invert.js","../src/models/operation.js","../src/models/change.js","../src/plugins/commands.js","../src/utils/text-utils.js","../src/commands/at-range.js","../src/commands/by-path.js","../src/commands/on-history.js","../src/commands/on-selection.js","../src/commands/on-value.js","../src/plugins/queries.js","../src/utils/slate-error.js","../src/plugins/schema.js","../src/commands/with-intent.js","../src/plugins/core.js","../src/controllers/editor.js","../src/models/leaf.js","../src/utils/mixin.js","../src/interfaces/object.js","../src/interfaces/model.js","../src/utils/memoize.js","../src/interfaces/node.js","../../../node_modules/rollup-plugin-node-globals/src/global.js","../src/utils/identity.js","../src/interfaces/element.js","../src/interfaces/range.js","../src/index.js"],"names":["n","generate","key","resetGenerator","m","min","i","pv","path","tv","target","attrs","List","Array","size","ca","a","cb","b","index","increment","ancestors","value","newValue","newPath","p","t","crop","compare","pl","tl","isEqual","ancestor","relative","Math","array","av","bv","create","type","position","operation","pIndex","pEqual","pYounger","isYounger","pAbove","isAbove","decrement","np","paths","DEFAULTS","undefined","Point","Record","isPlainObject","PathUtils","object","offset","point","is","range","node","last","first","text","before","block","next","KeyUtils","options","Data","Map","fromJS","fromJSON","Mark","elements","Set","marks","props","data","mark","any","Decoration","Range","list","anchor","focus","JSON","decoration","properties","Selection","isFocused","selection","TYPES","isObject","Annotation","obj","annotation","Document","nodes","document","Node","Inline","inline","Leaf","Text","annotations","decorations","leaves","split","leaf","compile","formats","kind","format","start","end","o","length","middle","after","string","newProperties","newMark","one","two","other","Block","el","texts","Value","newDocument","withPath","max","newIndex","prev","iterator","sel","anns","debug","Debug","Operation","inversePath","inverseNewPath","inverse","op","OPERATION_ATTRIBUTES","ATTRIBUTES","v","apply","inverted","invert","json","Change","operations","change","commands","args","command","fn","SURROGATE_START","SURROGATE_END","SPACE","CHAMELEON","PUNCTUATION","code","remaining","getCharLength","rest","isWord","isSurrogate","char","charCode","modifier","isModifier","isBMPEmoji","forward","isVariationSelector","nextCharCode","chars","reverse","getCharOffset","started","l","getWordOffset","editor","Commands","startKey","startOffset","endKey","endOffset","isStartVoid","isEndVoid","startBlock","endBlock","isHanging","prevText","startVoid","nextText","endVoid","startText","endText","startLength","endLength","startChild","endChild","startParent","startParentIndex","endParentIndex","child","parent","afters","startChildIndex","endChildIndex","middles","befores","onlyChildAncestor","voidParent","prevBlock","prevVoid","traversed","TextUtils","nextBlock","nextVoid","wordOffset","deleteExpandedAtRange","startInline","insertionMode","getInsertionMode","atEnd","siblingText","splitRange","fragment","isAtStart","blocks","firstChild","lastChild","firstBlock","lastBlock","insertionNode","findInsertionNode","lonelyParent","lonelyChild","startIndex","excludingLonelyChild","nextChild","nextNodes","lastIndex","inlineChild","inlineIndex","deepestSingleBlock","result","ancestorTypesMatch","documentAncestors","fragmentAncestors","fragmentNode","matchingFragmentAncestor","depthDifference","fragIdx","docIdx","getAncestorBlocks","doc","fragmentStartBlock","isCollapsed","sets","inlines","height","h","Infinity","exists","wrappers","children","firstMatch","lastMatch","firstText","extra","firstblock","lastblock","siblings","p1","indexes","ind","inlineParent","endInline","endIndex","startInner","startInnerIndex","endInner","startInlines","endInlines","startNode","endNode","suffix","prefix","startRange","endRange","marksSet","marksToApply","marksToRemove","isAtomic","original","previous","newParentPath","state","pth","parentPath","prevProperties","pick","Object","lastPath","ancestorPath","parentIndex","grandPath","isFirst","isLast","updatedPath","childIndex","childPath","COMMANDS","method","textPath","save","merge","isValidOperation","undos","lastBatch","lastOperation","shouldMerge","batch","redos","newData","omit","charsOffset","snapshot","skip","Edge","edge","getNode","Side","side","getDirectionNode","pointForward","hasVoidParent","isInBlock","isPreviousInVoid","pointBackward","isNextInVoid","queries","query","ret","SlateError","Error","rules","schema","schemaRules","rule","testRules","r","error","validateNode","matches","failure","validateRules","every","Queries","isVoid","normalizeNode","match","valid","fail","validateObject","validateType","validateData","validateMarks","validateText","validateFirst","validateLast","validateNodes","def","defs","count","lastCount","err","validateParent","validatePrevious","validateNext","lastMin","nextDef","keys","newTexts","fragmentLength","depth","plugins","Editor","controller","construct","onChange","readOnly","core","CorePlugin","newDirtyPaths","getDirtyPaths","dirty","transformed","pathIndex","dirtyPaths","dirtyPath","has","table","middleware","fns","overrides","normalize","nextPath","previousPath","oldAncestors","newAncestors","iterations","found","registerPlugin","plugin","commandsPlugin","CommandsPlugin","queriesPlugin","QueriesPlugin","schemaPlugin","SchemaPlugin","invalid","firstLeaf","cache","left","right","newMarks","set","Class","Classes","name","desc","Interface","TYPE","camel","ObjectInterface","mixin","ModelInterface","ENABLED","LEAF","Symbol","STORE_KEY","UNDEFINED","NULL","UNSET","memoizeStore","property","noArgs","hasArgs","takesArguments","cachedValue","getIn","map","newChild","NodeInterface","descendant","nested","dict","memo","c","normalizer","memoize","ElementInterface","iterable","onlyLeaves","onlyRoots","onlyTypes","direction","downward","upward","includeBlocks","includeDocument","includeInlines","includeRoot","includeTarget","includeTargetAncestors","includeTexts","root","targetPath","targetRange","targetNode","NativeSet","global","window","visited","startPath","endPath","includedTarget","includedStart","includingStart","done","nextIndex","newNode","predicate","identity","startMarks","endMarks","closest","startAt","targetPosition","results","furthest","blockNode","blockPath","entry","relativePath","previousText","OrderedSet","dir","getDirection","toStart","toEnd","isInRange","deep","nextNode","childMatch","assign","pathToThisNode","previousNode","findLast","foundPath","isSelected","childStartPath","childEndPath","currentMarks","closestBlock","ASSERTS","RangeInterface","isUnset","isBackward","isForward","values","updater"],"mappings":"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","sourcesContent":["/**\n * An auto-incrementing index for generating keys.\n *\n * @type {Number}\n */\n\nlet n\n\n/**\n * The global key generating function.\n *\n * @type {Function}\n */\n\nlet generate\n\n/**\n * Create a key, using a provided key if available.\n *\n * @param {String|Void} key\n * @return {String}\n */\n\nfunction create(key) {\n  if (key == null) {\n    return generate()\n  }\n\n  if (typeof key === 'string') {\n    return key\n  }\n\n  throw new Error(`Keys must be strings, but you passed: ${key}`)\n}\n\n/**\n * Set a different unique ID generating `function`.\n *\n * @param {Function} func\n */\n\nfunction setGenerator(func) {\n  generate = func\n}\n\n/**\n * Reset the key generating function to its initial state.\n */\n\nfunction resetGenerator() {\n  n = 0\n  generate = () => `${n++}`\n}\n\n/**\n * Set the initial state.\n */\n\nresetGenerator()\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  create,\n  setGenerator,\n  resetGenerator,\n}\n","import { List } from 'immutable'\n\n/**\n * Compare paths `path` and `target` to see which is before or after.\n *\n * @param {List} path\n * @param {List} target\n * @return {Number|Null}\n */\n\nfunction compare(path, target) {\n  const m = min(path, target)\n\n  for (let i = 0; i < m; i++) {\n    const pv = path.get(i)\n    const tv = target.get(i)\n\n    // If the path's value is ever less than the target's, it's before.\n    if (pv < tv) return -1\n\n    // If the target's value is ever less than the path's, it's after.\n    if (pv > tv) return 1\n  }\n\n  // Paths should now be equal, otherwise something is wrong\n  return path.size === target.size ? 0 : null\n}\n\n/**\n * Create a path from `attrs`.\n *\n * @param {Array|List} attrs\n * @return {List}\n */\n\nfunction create(attrs) {\n  if (attrs == null) {\n    return null\n  }\n\n  if (List.isList(attrs)) {\n    return attrs\n  }\n\n  if (Array.isArray(attrs)) {\n    return List(attrs)\n  }\n\n  throw new Error(\n    `Paths can only be created from arrays or lists, but you passed: ${attrs}`\n  )\n}\n\n/**\n * Crop paths `a` and `b` to an equal size, defaulting to the shortest.\n *\n * @param {List} a\n * @param {List} b\n */\n\nfunction crop(a, b, size = min(a, b)) {\n  const ca = a.slice(0, size)\n  const cb = b.slice(0, size)\n  return [ca, cb]\n}\n\n/**\n * Decrement a `path` by `n` at `index`, defaulting to the last index.\n *\n * @param {List} path\n * @param {Number} n\n * @param {Number} index\n */\n\nfunction decrement(path, n = 1, index = path.size - 1) {\n  return increment(path, 0 - n, index)\n}\n\n/**\n * Get all ancestor paths of th given path.\n *\n * @param {List} path\n * @returns {List}\n */\n\nfunction getAncestors(path) {\n  const ancestors = List().withMutations(list => {\n    for (let i = 0; i < path.size; i++) {\n      list.push(path.slice(0, i))\n    }\n  })\n\n  return ancestors\n}\n\n/**\n * Increment a `path` by `n` at `index`, defaulting to the last index.\n *\n * @param {List} path\n * @param {Number} n\n * @param {Number} index\n */\n\nfunction increment(path, n = 1, index = path.size - 1) {\n  const value = path.get(index)\n  const newValue = value + n\n  const newPath = path.set(index, newValue)\n  return newPath\n}\n\n/**\n * Is a `path` above another `target` path?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isAbove(path, target) {\n  const [p, t] = crop(path, target)\n  return path.size < target.size && compare(p, t) === 0\n}\n\n/**\n * Is a `path` after another `target` path in a document?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isAfter(path, target) {\n  const [p, t] = crop(path, target)\n  return compare(p, t) === 1\n}\n\n/**\n * Is a `path` before another `target` path in a document?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isBefore(path, target) {\n  const [p, t] = crop(path, target)\n  return compare(p, t) === -1\n}\n\n/**\n * Is a `path` equal to another `target` path in a document?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isEqual(path, target) {\n  return path.equals(target)\n}\n\n/**\n * Is a `path` older than a `target` path? Meaning that it ends as an older\n * sibling of one of the indexes in the target.\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isOlder(path, target) {\n  const index = path.size - 1\n  const [p, t] = crop(path, target, index)\n  const pl = path.get(index)\n  const tl = target.get(index)\n  return isEqual(p, t) && pl > tl\n}\n\n/**\n * Is an `any` object a path?\n *\n * @param {Mixed} any\n * @return {Boolean}\n */\n\nfunction isPath(any) {\n  return (\n    (List.isList(any) || Array.isArray(any)) &&\n    any.every(n => typeof n === 'number')\n  )\n}\n\n/**\n * Is a `path` a sibling of a `target` path?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isSibling(path, target) {\n  if (path.size !== target.size) return false\n  const p = path.butLast()\n  const t = target.butLast()\n  return p.equals(t)\n}\n\n/**\n * Is a `path` younger than a `target` path? Meaning that it ends as a younger\n * sibling of one of the indexes in the target.\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isYounger(path, target) {\n  const index = path.size - 1\n  const [p, t] = crop(path, target, index)\n  const pl = path.get(index)\n  const tl = target.get(index)\n  return isEqual(p, t) && pl < tl\n}\n\n/**\n * Lift a `path` to refer to its `n`th ancestor.\n *\n * @param {List} path\n * @return {List}\n */\n\nfunction lift(path, n = 1) {\n  const ancestor = path.slice(0, -1 * n)\n  return ancestor\n}\n\n/**\n * Drop a `path`, returning a relative path from a depth of `n`.\n *\n * @param {List} path\n * @param {Number} n\n * @return {List}\n */\n\nfunction drop(path, n = 1) {\n  const relative = path.slice(n)\n  return relative\n}\n\n/**\n * Get the maximum length of paths `a` and `b`.\n *\n * @param {List} path\n * @param {List} path\n * @return {Number}\n */\n\nfunction max(a, b) {\n  const n = Math.max(a.size, b.size)\n  return n\n}\n\n/**\n * Get the minimum length of paths `a` and `b`.\n *\n * @param {List} path\n * @param {List} path\n * @return {Number}\n */\n\nfunction min(a, b) {\n  const n = Math.min(a.size, b.size)\n  return n\n}\n\n/**\n * Get the common ancestor path of path `a` and path `b`.\n *\n * @param {List} a\n * @param {List} b\n * @return {List}\n */\n\nfunction relate(a, b) {\n  const array = []\n\n  for (let i = 0; i < a.size && i < b.size; i++) {\n    const av = a.get(i)\n    const bv = b.get(i)\n\n    // If the values aren't equal, they've diverged and don't share an ancestor.\n    if (av !== bv) break\n\n    // Otherwise, the current value is still a common ancestor.\n    array.push(av)\n  }\n\n  const path = create(array)\n  return path\n}\n\n/**\n * Transform a `path` by an `operation`, adjusting it to stay current.\n *\n * @param {List} path\n * @param {Operation} operation\n * @return {List<List>}\n */\n\nfunction transform(path, operation) {\n  const { type, position, path: p } = operation\n\n  if (\n    type === 'add_mark' ||\n    type === 'insert_text' ||\n    type === 'remove_mark' ||\n    type === 'remove_text' ||\n    type === 'set_mark' ||\n    type === 'set_node' ||\n    type === 'set_selection' ||\n    type === 'set_value' ||\n    type === 'add_annotation' ||\n    type === 'remove_annotation' ||\n    type === 'set_annotation' ||\n    path.size === 0\n  ) {\n    return List([path])\n  }\n\n  const pIndex = p.size - 1\n  const pEqual = isEqual(p, path)\n  const pYounger = isYounger(p, path)\n  const pAbove = isAbove(p, path)\n\n  if (type === 'insert_node') {\n    if (pEqual || pYounger || pAbove) {\n      path = increment(path, 1, pIndex)\n    }\n  }\n\n  if (type === 'remove_node') {\n    if (pYounger) {\n      path = decrement(path, 1, pIndex)\n    } else if (pEqual || pAbove) {\n      path = []\n    }\n  }\n\n  if (type === 'merge_node') {\n    if (pEqual || pYounger) {\n      path = decrement(path, 1, pIndex)\n    } else if (pAbove) {\n      path = decrement(path, 1, pIndex)\n      path = increment(path, position, pIndex + 1)\n    }\n  }\n\n  if (type === 'split_node') {\n    if (pEqual) {\n      path = [path, increment(path)]\n    } else if (pYounger) {\n      path = increment(path, 1, pIndex)\n    } else if (pAbove) {\n      if (path.get(pIndex + 1) >= position) {\n        path = increment(path, 1, pIndex)\n        path = decrement(path, position, pIndex + 1)\n      }\n    }\n  }\n\n  if (type === 'move_node') {\n    const { newPath: np } = operation\n\n    if (isEqual(p, np)) {\n      return List([path])\n    }\n\n    if (pAbove || pEqual) {\n      // We are comparing something that was moved\n      // The new path is unaffected unless the old path was the left-sibling of an ancestor\n      if (isYounger(p, np) && p.size < np.size) {\n        path = decrement(np, 1, min(np, p) - 1).concat(path.slice(p.size))\n      } else {\n        path = np.concat(path.slice(p.size))\n      }\n    } else {\n      // This is equivalent logic to remove_node for path\n      if (pYounger) {\n        path = decrement(path, 1, pIndex)\n      }\n\n      // This is the equivalent logic to insert_node for newPath\n      if (isYounger(np, path) || isEqual(np, path) || isAbove(np, path)) {\n        path = increment(path, 1, np.size - 1)\n      }\n    }\n  }\n\n  const paths = Array.isArray(path) ? path : [path]\n  return List(paths)\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  compare,\n  create,\n  crop,\n  decrement,\n  getAncestors,\n  increment,\n  isAbove,\n  isAfter,\n  isBefore,\n  isEqual,\n  isOlder,\n  isPath,\n  isSibling,\n  isYounger,\n  lift,\n  drop,\n  max,\n  min,\n  relate,\n  transform,\n}\n","import isPlainObject from 'is-plain-object'\nimport warning from 'tiny-warning'\nimport { Record } from 'immutable'\n\nimport KeyUtils from '../utils/key-utils'\nimport PathUtils from '../utils/path-utils'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  key: undefined,\n  offset: undefined,\n  path: undefined,\n}\n\n/**\n * Point.\n *\n * @type {Point}\n */\n\nclass Point extends Record(DEFAULTS) {\n  /**\n   * Create a new `Point` with `attrs`.\n   *\n   * @param {Object|Point} attrs\n   * @return {Point}\n   */\n\n  static create(attrs = {}) {\n    if (Point.isPoint(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Point.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Point.create\\` only accepts objects or points, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable point properties from `attrs`.\n   *\n   * @param {Object|Point} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Point.isPoint(a)) {\n      return {\n        key: a.key,\n        offset: a.offset,\n        path: a.path,\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('key' in a) p.key = a.key\n      if ('offset' in a) p.offset = a.offset\n      if ('path' in a) p.path = PathUtils.create(a.path)\n\n      // If only a path is set, or only a key is set, ensure that the other is\n      // set to null so that it can be normalized back to the right value.\n      // Otherwise we won't realize that the path and key don't match anymore.\n      if ('path' in a && !('key' in a)) p.key = null\n      if ('key' in a && !('path' in a)) p.path = null\n\n      return p\n    }\n\n    throw new Error(\n      `\\`Point.createProperties\\` only accepts objects or points, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Point` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Point}\n   */\n\n  static fromJSON(object) {\n    const { key = null, offset = null, path = null } = object\n\n    const point = new Point({\n      key,\n      offset,\n      path: PathUtils.create(path),\n    })\n\n    return point\n  }\n\n  /**\n   * Check whether all properties of the point are set.\n   *\n   * @return {Boolean}\n   */\n\n  get isSet() {\n    return this.key != null && this.offset != null && this.path != null\n  }\n\n  /**\n   * Check whether any property of the point is not set.\n   *\n   * @return {Boolean}\n   */\n\n  get isUnset() {\n    return !this.isSet\n  }\n\n  /**\n   * Check whether the point is after another `point`.\n   *\n   * @return {Boolean}\n   */\n\n  isAfterPoint(point) {\n    if (this.isUnset) return false\n    const is =\n      (this.key === point.key && this.offset > point.offset) ||\n      PathUtils.compare(this.path, point.path) === 1\n    return is\n  }\n\n  /**\n   * Check whether the point is after a `range`.\n   *\n   * @return {Boolean}\n   */\n\n  isAfterRange(range) {\n    if (this.isUnset) return false\n    const is = this.isAfterPoint(range.end)\n    return is\n  }\n\n  /**\n   * Check whether the point is at the end of a `range`.\n   *\n   * @return {Boolean}\n   */\n\n  isAtEndOfRange(range) {\n    if (this.isUnset) return false\n    const is = this.equals(range.end)\n    return is\n  }\n\n  /**\n   * Check whether the point is at the start of a `range`.\n   *\n   * @return {Boolean}\n   */\n\n  isAtStartOfRange(range) {\n    if (this.isUnset) return false\n    const is = this.equals(range.start)\n    return is\n  }\n\n  /**\n   * Check whether the point is before another `point`.\n   *\n   * @return {Boolean}\n   */\n\n  isBeforePoint(point) {\n    if (this.isUnset) return false\n    const is =\n      (this.key === point.key && this.offset < point.offset) ||\n      PathUtils.compare(this.path, point.path) === -1\n    return is\n  }\n\n  /**\n   * Check whether the point is before a `range`.\n   *\n   * @return {Boolean}\n   */\n\n  isBeforeRange(range) {\n    if (this.isUnset) return false\n    const is = this.isBeforePoint(range.start)\n    return is\n  }\n\n  /**\n   * Check whether the point is inside a `range`.\n   *\n   * @return {Boolean}\n   */\n\n  isInRange(range) {\n    if (this.isUnset) return false\n    const is =\n      this.equals(range.start) ||\n      this.equals(range.end) ||\n      (this.isAfterPoint(range.start) && this.isBeforePoint(range.end))\n    return is\n  }\n\n  /**\n   * Check whether the point is at the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  isAtEndOfNode(node) {\n    if (this.isUnset) return false\n    const last = node.getLastText()\n    const is = this.key === last.key && this.offset === last.text.length\n    return is\n  }\n\n  /**\n   * Check whether the point is at the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  isAtStartOfNode(node) {\n    if (this.isUnset) return false\n\n    // PERF: Do a check for a `0` offset first since it's quickest.\n    if (this.offset !== 0) return false\n\n    const first = node.getFirstText()\n    const is = this.key === first.key\n    return is\n  }\n\n  /**\n   * Check whether the point is in a `node`.\n   *\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  isInNode(node) {\n    if (this.isUnset) return false\n    if (node.object === 'text' && node.key === this.key) return true\n    if (node.hasNode(this.key)) return true\n    return false\n  }\n\n  /**\n   * Move the point's offset backward `n` characters.\n   *\n   * @param {Number} n (optional)\n   * @return {Point}\n   */\n\n  moveBackward(n = 1) {\n    if (n === 0) return this\n    if (n < 0) return this.moveForward(-n)\n    const point = this.setOffset(this.offset - n)\n    return point\n  }\n\n  /**\n   * Move the point's offset forward `n` characters.\n   *\n   * @param {Number} n (optional)\n   * @return {Point}\n   */\n\n  moveForward(n = 1) {\n    if (n === 0) return this\n    if (n < 0) return this.moveBackward(-n)\n    const point = this.setOffset(this.offset + n)\n    return point\n  }\n\n  /**\n   * Move the point's anchor point to a new `path` and `offset`.\n   *\n   * Optionally, the `path` can be a key string, or omitted entirely in which\n   * case it would be the offset number.\n   *\n   * @param {List|String|Number} path\n   * @param {Number} offset\n   * @return {Point}\n   */\n\n  moveTo(path, offset = 0) {\n    let key = this.key\n\n    if (typeof path === 'number') {\n      offset = path\n      path = this.path\n    } else if (typeof path === 'string') {\n      key = path\n      path = key === this.key ? this.path : null\n    } else {\n      key = path.equals(this.path) ? this.key : null\n    }\n\n    const point = this.merge({ key, path, offset })\n    return point\n  }\n\n  /**\n   * Move the point's anchor point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Point}\n   */\n\n  moveToStartOfNode(node) {\n    const first = node.getFirstText()\n    const point = this.moveTo(first.key, 0)\n    return point\n  }\n\n  /**\n   * Move the point's anchor point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Point}\n   */\n\n  moveToEndOfNode(node) {\n    const last = node.getLastText()\n    const point = this.moveTo(last.key, last.text.length)\n    return point\n  }\n\n  /**\n   * Normalize the point relative to a `node`, ensuring that its key and path\n   * reference a text node, or that it gets unset.\n   *\n   * @param {Node} node\n   * @return {Point}\n   */\n\n  normalize(node) {\n    // If both the key and path are null, there's no reference to a node, so\n    // make sure it is entirely unset.\n    if (this.key == null && this.path == null) {\n      return this.setOffset(null)\n    }\n\n    const { key, offset, path } = this\n\n    // PERF: this function gets called a lot.\n    // to avoid creating the key -> path lookup table, we attempt to look up by path first.\n    let target = path && node.getNode(path)\n\n    if (!target) {\n      target = node.getNode(key)\n\n      if (target) {\n        // There is a misalignment of path and key\n        const point = this.merge({\n          path: node.getPath(key),\n        })\n\n        return point\n      }\n    }\n\n    if (!target) {\n      warning(false, \"A point's `path` or `key` invalid and was reset!\")\n\n      const text = node.getFirstText()\n      if (!text) return Point.create()\n\n      const point = this.merge({\n        key: text.key,\n        offset: 0,\n        path: node.getPath(text.key),\n      })\n\n      return point\n    }\n\n    if (target.object !== 'text') {\n      warning(false, 'A point should not reference a non-text node!')\n\n      const text = target.getTextAtOffset(offset)\n      const before = target.getOffset(text.key)\n      const point = this.merge({\n        offset: offset - before,\n        key: text.key,\n        path: node.getPath(text.key),\n      })\n\n      return point\n    }\n\n    if (target && path && key && key !== target.key) {\n      warning(false, \"A point's `key` did not match its `path`!\")\n\n      // TODO: if we look up by path above and it differs by key, do we want to reset it to looking up by key?\n    }\n\n    let point = this.merge({\n      key: target.key,\n      path: path == null ? node.getPath(target.key) : path,\n      offset: offset == null ? 0 : Math.min(offset, target.text.length),\n    })\n\n    // COMPAT: There is an ambiguity, since a point can exist at the end of a\n    // text node, or at the start of the following one. To eliminate it we\n    // enforce that if there is a following text node, we always move it there.\n    if (point.offset === target.text.length) {\n      const block = node.getClosestBlock(point.path)\n      // TODO: this next line is broken because `getNextText` takes a path\n      const next = block.getNextText()\n\n      if (next) {\n        point = point.merge({\n          key: next.key,\n          path: node.getPath(next.key),\n          offset: 0,\n        })\n      }\n    }\n\n    return point\n  }\n\n  /**\n   * Set the point's key to a new `key`.\n   *\n   * @param {String} key\n   * @return {Point}\n   */\n\n  setKey(key) {\n    if (key != null) {\n      key = KeyUtils.create(key)\n    }\n\n    const point = this.set('key', key)\n    return point\n  }\n\n  /**\n   * Set the point's offset to a new `offset`.\n   *\n   * @param {Number} offset\n   * @return {Point}\n   */\n\n  setOffset(offset) {\n    const point = this.set('offset', offset)\n    return point\n  }\n\n  /**\n   * Set the point's path to a new `path`.\n   *\n   * @param {List|Array} path\n   * @return {Point}\n   */\n\n  setPath(path) {\n    if (path != null) {\n      path = PathUtils.create(path)\n    }\n\n    const point = this.set('path', path)\n    return point\n  }\n\n  /**\n   * Return a JSON representation of the point.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      key: this.key,\n      offset: this.offset,\n      path: this.path && this.path.toArray(),\n    }\n\n    if (!options.preserveKeys) {\n      delete object.key\n    }\n\n    return object\n  }\n\n  /**\n   * Unset the point.\n   *\n   * @return {Point}\n   */\n\n  unset() {\n    return this.merge({\n      key: null,\n      offset: null,\n      path: null,\n    })\n  }\n}\n\n/**\n * Export.\n *\n * @type {Point}\n */\n\nexport default Point\n","import isPlainObject from 'is-plain-object'\nimport { Map } from 'immutable'\n\n/**\n * Data.\n *\n * This isn't an immutable record, it's just a thin wrapper around `Map` so that\n * we can allow for more convenient creation.\n *\n * @type {Object}\n */\n\nclass Data {\n  /**\n   * Create a new `Data` with `attrs`.\n   *\n   * @param {Object|Data|Map} attrs\n   * @return {Data} data\n   */\n\n  static create(attrs = {}) {\n    if (Map.isMap(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Data.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Data.create\\` only accepts objects or maps, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Data` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Data}\n   */\n\n  static fromJSON(object) {\n    return new Map(object)\n  }\n\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS = Data.fromJSON\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Data\n","import isPlainObject from 'is-plain-object'\nimport { Map, Record, Set } from 'immutable'\n\nimport Data from './data'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: undefined,\n  type: undefined,\n}\n\n/**\n * Mark.\n *\n * @type {Mark}\n */\n\nclass Mark extends Record(DEFAULTS) {\n  /**\n   * Create a new `Mark` with `attrs`.\n   *\n   * @param {Object|Mark} attrs\n   * @return {Mark}\n   */\n\n  static create(attrs = {}) {\n    if (Mark.isMark(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs === 'string') {\n      attrs = { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Mark.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Mark.create\\` only accepts objects, strings or marks, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a set of marks.\n   *\n   * @param {Array<Object|Mark>} elements\n   * @return {Set<Mark>}\n   */\n\n  static createSet(elements) {\n    if (Set.isSet(elements) || Array.isArray(elements)) {\n      const marks = new Set(elements.map(Mark.create))\n      return marks\n    }\n\n    if (elements == null) {\n      return Set()\n    }\n\n    throw new Error(\n      `\\`Mark.createSet\\` only accepts sets, arrays or null, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable mark properties from `attrs`.\n   *\n   * @param {Object|String|Mark} attrs\n   * @return {Object}\n   */\n\n  static createProperties(attrs = {}) {\n    if (Mark.isMark(attrs)) {\n      return {\n        data: attrs.data,\n        type: attrs.type,\n      }\n    }\n\n    if (typeof attrs === 'string') {\n      return { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      const props = {}\n      if ('type' in attrs) props.type = attrs.type\n      if ('data' in attrs) props.data = Data.create(attrs.data)\n      return props\n    }\n\n    throw new Error(\n      `\\`Mark.createProperties\\` only accepts objects, strings or marks, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Mark` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Mark}\n   */\n\n  static fromJSON(object) {\n    const { data = {}, type } = object\n\n    if (typeof type !== 'string') {\n      throw new Error('`Mark.fromJS` requires a `type` string.')\n    }\n\n    const mark = new Mark({\n      type,\n      data: new Map(data),\n    })\n\n    return mark\n  }\n\n  /**\n   * Check if `any` is a set of marks.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isMarkSet(any) {\n    return Set.isSet(any) && any.every(item => Mark.isMark(item))\n  }\n\n  /**\n   * Return a JSON representation of the mark.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      type: this.type,\n      data: this.data.toJSON(),\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Mark}\n */\n\nexport default Mark\n","import isPlainObject from 'is-plain-object'\nimport warning from 'tiny-warning'\nimport { List, Record } from 'immutable'\n\nimport Mark from './mark'\nimport Point from './point'\nimport Data from './data'\nimport Range from './range'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  type: undefined,\n  data: undefined,\n  anchor: undefined,\n  focus: undefined,\n}\n\n/**\n * Decoration.\n *\n * @type {Decoration}\n */\n\nclass Decoration extends Record(DEFAULTS) {\n  /**\n   * Create a new `Decoration` with `attrs`.\n   *\n   * @param {Object|Decoration} attrs\n   * @return {Decoration}\n   */\n\n  static create(attrs = {}) {\n    if (Decoration.isDecoration(attrs)) {\n      return attrs\n    }\n\n    if (Range.isRange(attrs)) {\n      return Decoration.fromJSON(Range.createProperties(attrs))\n    }\n\n    if (isPlainObject(attrs)) {\n      return Decoration.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Decoration.create\\` only accepts objects or decorations, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Ranges` from `elements`.\n   *\n   * @param {Array<Decoration|Object>|List<Decoration|Object>} elements\n   * @return {List<Decoration>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Decoration.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Decoration.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable decoration properties from `attrs`.\n   *\n   * @param {Object|String|Decoration} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Decoration.isDecoration(a)) {\n      return {\n        type: a.type,\n        data: a.data,\n        anchor: Point.createProperties(a.anchor),\n        focus: Point.createProperties(a.focus),\n        mark: Mark.create(a.mark),\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('type' in a) p.type = a.type\n      if ('data' in a) p.data = Data.create(a.data)\n      if ('anchor' in a) p.anchor = Point.create(a.anchor)\n      if ('focus' in a) p.focus = Point.create(a.focus)\n      return p\n    }\n\n    throw new Error(\n      `\\`Decoration.createProperties\\` only accepts objects or decorations, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Decoration` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Decoration}\n   */\n\n  static fromJSON(object) {\n    const { anchor, focus } = object\n    let { type, data } = object\n\n    if (object.mark && !type) {\n      warning(\n        false,\n        'As of slate@0.47 the `decoration.mark` property has been changed to `decoration.type` and `decoration.data` directly.'\n      )\n\n      type = object.mark.type\n      data = object.mark.data\n    }\n\n    if (!type) {\n      throw new Error(\n        `Decorations must be created with a \\`type\\`, but you passed: ${JSON.stringify(\n          object\n        )}`\n      )\n    }\n\n    const decoration = new Decoration({\n      type,\n      data: Data.create(data || {}),\n      anchor: Point.fromJSON(anchor || {}),\n      focus: Point.fromJSON(focus || {}),\n    })\n\n    return decoration\n  }\n\n  /**\n   * Set new `properties` on the decoration.\n   *\n   * @param {Object|Range|Selection} properties\n   * @return {Range}\n   */\n\n  setProperties(properties) {\n    properties = Decoration.createProperties(properties)\n    const decoration = this.merge(properties)\n    return decoration\n  }\n\n  /**\n   * Return a JSON representation of the decoration.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      type: this.type,\n      data: this.data.toJSON(),\n      anchor: this.anchor.toJSON(options),\n      focus: this.focus.toJSON(options),\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Decoration}\n */\n\nexport default Decoration\n","import isPlainObject from 'is-plain-object'\nimport { Record, Set } from 'immutable'\n\nimport Mark from './mark'\nimport Point from './point'\nimport Range from './range'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  anchor: undefined,\n  focus: undefined,\n  isFocused: undefined,\n  marks: undefined,\n}\n\n/**\n * Selection.\n *\n * @type {Selection}\n */\n\nclass Selection extends Record(DEFAULTS) {\n  /**\n   * Create a new `Selection` with `attrs`.\n   *\n   * @param {Object|Selection} attrs\n   * @return {Selection}\n   */\n\n  static create(attrs = {}) {\n    if (Selection.isSelection(attrs)) {\n      return attrs\n    }\n\n    if (Range.isRange(attrs)) {\n      return Selection.fromJSON(Range.createProperties(attrs))\n    }\n\n    if (isPlainObject(attrs)) {\n      return Selection.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Selection.create\\` only accepts objects, ranges or selections, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable selection properties from `attrs`.\n   *\n   * @param {Object|String|Selection} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Selection.isSelection(a)) {\n      return {\n        anchor: Point.createProperties(a.anchor),\n        focus: Point.createProperties(a.focus),\n        isFocused: a.isFocused,\n        marks: a.marks,\n      }\n    }\n\n    if (Range.isRange(a)) {\n      return {\n        anchor: Point.createProperties(a.anchor),\n        focus: Point.createProperties(a.focus),\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('anchor' in a) p.anchor = Point.create(a.anchor)\n      if ('focus' in a) p.focus = Point.create(a.focus)\n      if ('isFocused' in a) p.isFocused = a.isFocused\n      if ('marks' in a)\n        p.marks = a.marks == null ? null : Mark.createSet(a.marks)\n      return p\n    }\n\n    throw new Error(\n      `\\`Selection.createProperties\\` only accepts objects, ranges or selections, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Selection` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Selection}\n   */\n\n  static fromJSON(object) {\n    const { anchor, focus, isFocused = false, marks = null } = object\n    const selection = new Selection({\n      anchor: Point.fromJSON(anchor || {}),\n      focus: Point.fromJSON(focus || {}),\n      isFocused,\n      marks: marks == null ? null : new Set(marks.map(Mark.fromJSON)),\n    })\n\n    return selection\n  }\n\n  /**\n   * Check whether the selection is blurred.\n   *\n   * @return {Boolean}\n   */\n\n  get isBlurred() {\n    return !this.isFocused\n  }\n\n  /**\n   * Set the `isFocused` property to a new `value`.\n   *\n   * @param {Boolean} value\n   * @return {Selection}\n   */\n\n  setIsFocused(value) {\n    const selection = this.set('isFocused', value)\n    return selection\n  }\n\n  /**\n   * Set the `marks` property to a new set of `marks`.\n   *\n   * @param {Set} marks\n   * @return {Selection}\n   */\n\n  setMarks(marks) {\n    const selection = this.set('marks', marks)\n    return selection\n  }\n\n  /**\n   * Set new `properties` on the selection.\n   *\n   * @param {Object|Range|Selection} properties\n   * @return {Range}\n   */\n\n  setProperties(properties) {\n    properties = Selection.createProperties(properties)\n    const { anchor, focus, ...props } = properties\n\n    if (anchor) {\n      props.anchor = Point.create(anchor)\n    }\n\n    if (focus) {\n      props.focus = Point.create(focus)\n    }\n\n    const selection = this.merge(props)\n    return selection\n  }\n\n  /**\n   * Return a JSON representation of the selection.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      anchor: this.anchor.toJSON(options),\n      focus: this.focus.toJSON(options),\n      isFocused: this.isFocused,\n      marks:\n        this.marks == null ? null : this.marks.toArray().map(m => m.toJSON()),\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Selection}\n */\n\nexport default Selection\n","/**\n * Slate-specific object types.\n *\n * @type {Object}\n */\n\nexport const TYPES = {\n  annotation: '@@__SLATE_ANNOTATION__@@',\n  block: '@@__SLATE_BLOCK__@@',\n  change: '@@__SLATE_CHANGE__@@',\n  decoration: '@@__SLATE_DECORATION__@@',\n  document: '@@__SLATE_DOCUMENT__@@',\n  editor: '@@__SLATE_EDITOR__@@',\n  inline: '@@__SLATE_INLINE__@@',\n  leaf: '@@__SLATE_LEAF__@@',\n  mark: '@@__SLATE_MARK__@@',\n  operation: '@@__SLATE_OPERATION__@@',\n  point: '@@__SLATE_POINT__@@',\n  range: '@@__SLATE_RANGE__@@',\n  selection: '@@__SLATE_SELECTION__@@',\n  text: '@@__SLATE_TEXT__@@',\n  value: '@@__SLATE_VALUE__@@',\n}\n\n/**\n * Determine whether a `value` is of `type`.\n *\n * @param {string} type\n * @param {any} value\n * @return {boolean}\n */\n\nexport default function isObject(type, value) {\n  return !!(value && value[TYPES[type]])\n}\n","import isPlainObject from 'is-plain-object'\nimport { List, Record } from 'immutable'\n\nimport Decoration from './decoration'\nimport Point from './point'\nimport Selection from './selection'\nimport isObject from '../utils/is-object'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  anchor: undefined,\n  focus: undefined,\n}\n\n/**\n * Range.\n *\n * @type {Range}\n */\n\nclass Range extends Record(DEFAULTS) {\n  /**\n   * Create a new `Range` with `attrs`.\n   *\n   * @param {Object|Range} attrs\n   * @return {Range}\n   */\n\n  static create(attrs = {}) {\n    if (Range.isRange(attrs)) {\n      if (attrs.object === 'range') {\n        return attrs\n      } else {\n        return Range.fromJSON(Range.createProperties(attrs))\n      }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Range.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Range.create\\` only accepts objects or ranges, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Ranges` from `elements`.\n   *\n   * @param {Array<Range|Object>|List<Range|Object>} elements\n   * @return {List<Range>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Range.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Range.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable range properties from `attrs`.\n   *\n   * @param {Object|String|Range} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Range.isRange(a)) {\n      return {\n        anchor: Point.createProperties(a.anchor),\n        focus: Point.createProperties(a.focus),\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('anchor' in a) p.anchor = Point.create(a.anchor)\n      if ('focus' in a) p.focus = Point.create(a.focus)\n      return p\n    }\n\n    throw new Error(\n      `\\`Range.createProperties\\` only accepts objects, annotations, decorations, ranges or selections, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Range` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Range}\n   */\n\n  static fromJSON(object) {\n    const { anchor, focus } = object\n    const range = new Range({\n      anchor: Point.fromJSON(anchor || {}),\n      focus: Point.fromJSON(focus || {}),\n    })\n\n    return range\n  }\n\n  /**\n   * Check if a `value` is a `Range`, or is range-like.\n   *\n   * @param {Any} value\n   * @return {Boolean}\n   */\n\n  static isRange(value) {\n    return (\n      isObject('range', value) ||\n      Decoration.isDecoration(value) ||\n      Selection.isSelection(value)\n    )\n  }\n\n  /**\n   * Return a JSON representation of the range.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      anchor: this.anchor.toJSON(options),\n      focus: this.focus.toJSON(options),\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Range}\n */\n\nexport default Range\n","import isPlainObject from 'is-plain-object'\nimport { Map, Record } from 'immutable'\n\nimport Point from './point'\nimport Range from './range'\nimport Data from './data'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  key: undefined,\n  type: undefined,\n  data: undefined,\n  anchor: undefined,\n  focus: undefined,\n}\n\n/**\n * Annotation.\n *\n * @type {Annotation}\n */\n\nclass Annotation extends Record(DEFAULTS) {\n  /**\n   * Create a new `Annotation` with `attrs`.\n   *\n   * @param {Object|Annotation} attrs\n   * @return {Annotation}\n   */\n\n  static create(attrs = {}) {\n    if (Annotation.isAnnotation(attrs)) {\n      return attrs\n    }\n\n    if (Range.isRange(attrs)) {\n      return Annotation.fromJSON(Range.createProperties(attrs))\n    }\n\n    if (isPlainObject(attrs)) {\n      return Annotation.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Annotation.create\\` only accepts objects or annotations, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a map of annotations from `elements`.\n   *\n   * @param {Object<String,Annotation>|Map<String,Annotation>} elements\n   * @return {Map<String,Annotation>}\n   */\n\n  static createMap(elements = []) {\n    if (Map.isMap(elements)) {\n      return elements\n    }\n\n    if (isPlainObject(elements)) {\n      const obj = {}\n\n      for (const key in elements) {\n        const value = elements[key]\n        const annotation = Annotation.create(value)\n        obj[key] = annotation\n      }\n\n      return Map(obj)\n    }\n\n    throw new Error(\n      `\\`Annotation.createMap\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable annotation properties from `attrs`.\n   *\n   * @param {Object|String|Annotation} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Annotation.isAnnotation(a)) {\n      return {\n        key: a.key,\n        type: a.type,\n        data: a.data,\n        anchor: Point.createProperties(a.anchor),\n        focus: Point.createProperties(a.focus),\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('key' in a) p.key = a.key\n      if ('type' in a) p.type = a.type\n      if ('data' in a) p.data = Data.create(a.data)\n      if ('anchor' in a) p.anchor = Point.create(a.anchor)\n      if ('focus' in a) p.focus = Point.create(a.focus)\n      return p\n    }\n\n    throw new Error(\n      `\\`Annotation.createProperties\\` only accepts objects or annotations, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Annotation` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Annotation}\n   */\n\n  static fromJSON(object) {\n    const { key, type, data, anchor, focus } = object\n\n    if (!key) {\n      throw new Error(\n        `Annotations must be created with a \\`key\\`, but you passed: ${JSON.stringify(\n          object\n        )}`\n      )\n    }\n\n    if (!type) {\n      throw new Error(\n        `Annotations must be created with a \\`type\\`, but you passed: ${JSON.stringify(\n          object\n        )}`\n      )\n    }\n\n    const annotation = new Annotation({\n      key,\n      type,\n      data: Data.create(data || {}),\n      anchor: Point.fromJSON(anchor || {}),\n      focus: Point.fromJSON(focus || {}),\n    })\n\n    return annotation\n  }\n\n  /**\n   * Set new `properties` on the annotation.\n   *\n   * @param {Object|Range|Selection} properties\n   * @return {Range}\n   */\n\n  setProperties(properties) {\n    properties = Annotation.createProperties(properties)\n    const annotation = this.merge(properties)\n    return annotation\n  }\n\n  /**\n   * Return a JSON representation of the annotation.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      key: this.key,\n      type: this.type,\n      data: this.data.toJSON(),\n      anchor: this.anchor.toJSON(options),\n      focus: this.focus.toJSON(options),\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Annotation}\n */\n\nexport default Annotation\n","import isPlainObject from 'is-plain-object'\nimport { List, Map, Record } from 'immutable'\n\nimport KeyUtils from '../utils/key-utils'\nimport Node from './node'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: undefined,\n  key: undefined,\n  nodes: undefined,\n}\n\n/**\n * Document.\n *\n * @type {Document}\n */\n\nclass Document extends Record(DEFAULTS) {\n  /**\n   * Create a new `Document` with `attrs`.\n   *\n   * @param {Object|Array|List|Text} attrs\n   * @return {Document}\n   */\n\n  static create(attrs = {}) {\n    if (Document.isDocument(attrs)) {\n      return attrs\n    }\n\n    if (List.isList(attrs) || Array.isArray(attrs)) {\n      attrs = { nodes: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Document.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Document.create\\` only accepts objects, arrays, lists or documents, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Document` from a JSON `object`.\n   *\n   * @param {Object|Document} object\n   * @return {Document}\n   */\n\n  static fromJSON(object) {\n    if (Document.isDocument(object)) {\n      return object\n    }\n\n    const { data = {}, key = KeyUtils.create(), nodes = [] } = object\n\n    const document = new Document({\n      key,\n      data: new Map(data),\n      nodes: Node.createList(nodes),\n    })\n\n    return document\n  }\n\n  /**\n   * Return a JSON representation of the document.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      data: this.data.toJSON(),\n      nodes: this.nodes.toArray().map(n => n.toJSON(options)),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Document}\n */\n\nexport default Document\n","import isPlainObject from 'is-plain-object'\nimport { List, Map, Record } from 'immutable'\n\nimport KeyUtils from '../utils/key-utils'\nimport Node from './node'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: undefined,\n  key: undefined,\n  nodes: undefined,\n  type: undefined,\n}\n\n/**\n * Inline.\n *\n * @type {Inline}\n */\n\nclass Inline extends Record(DEFAULTS) {\n  /**\n   * Create a new `Inline` with `attrs`.\n   *\n   * @param {Object|String|Inline} attrs\n   * @return {Inline}\n   */\n\n  static create(attrs = {}) {\n    if (Inline.isInline(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs === 'string') {\n      attrs = { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Inline.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Inline.create\\` only accepts objects, strings or inlines, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Inlines` from an array.\n   *\n   * @param {Array<Inline|Object>|List<Inline|Object>} elements\n   * @return {List<Inline>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Inline.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Inline.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Inline` from a JSON `object`.\n   *\n   * @param {Object|Inline} object\n   * @return {Inline}\n   */\n\n  static fromJSON(object) {\n    if (Inline.isInline(object)) {\n      return object\n    }\n\n    const { data = {}, key = KeyUtils.create(), nodes = [], type } = object\n\n    if (typeof type !== 'string') {\n      throw new Error('`Inline.fromJS` requires a `type` string.')\n    }\n\n    const inline = new Inline({\n      key,\n      type,\n      data: new Map(data),\n      nodes: Node.createList(nodes),\n    })\n\n    return inline\n  }\n\n  /**\n   * Check if `any` is a list of inlines.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isInlineList(any) {\n    return List.isList(any) && any.every(item => Inline.isInline(item))\n  }\n\n  /**\n   * Return a JSON representation of the inline.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      type: this.type,\n      data: this.data.toJSON(),\n      nodes: this.nodes.toArray().map(n => n.toJSON(options)),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Inline}\n */\n\nexport default Inline\n","import isPlainObject from 'is-plain-object'\nimport invariant from 'tiny-invariant'\nimport { List, Record } from 'immutable'\n\nimport Mark from './mark'\nimport KeyUtils from '../utils/key-utils'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  key: undefined,\n  marks: undefined,\n  text: undefined,\n}\n\nconst Leaf = Record({\n  text: undefined,\n  marks: undefined,\n  annotations: undefined,\n  decorations: undefined,\n})\n\n/**\n * Text.\n *\n * @type {Text}\n */\n\nclass Text extends Record(DEFAULTS) {\n  /**\n   * Create a new `Text` with `attrs`.\n   *\n   * @param {Object|Array|List|String|Text} attrs\n   * @return {Text}\n   */\n\n  static create(attrs = '') {\n    if (Text.isText(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs === 'string') {\n      attrs = { text: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Text.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Text.create\\` only accepts objects, arrays, strings or texts, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Texts` from `elements`.\n   *\n   * @param {Array<Text|Object>|List<Text|Object>} elements\n   * @return {List<Text>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Text.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Text.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Text` from a JSON `object`.\n   *\n   * @param {Object|Text} object\n   * @return {Text}\n   */\n\n  static fromJSON(object) {\n    if (Text.isText(object)) {\n      return object\n    }\n\n    invariant(\n      object.leaves == null,\n      'As of slate@0.46, the `leaves` property of text nodes has been removed! Each individual leaf should be created as a text node instead.'\n    )\n\n    const { text = '', marks = [], key = KeyUtils.create() } = object\n    const node = new Text({\n      key,\n      text,\n      marks: Mark.createSet(marks),\n    })\n\n    return node\n  }\n\n  /**\n   * Check if `any` is a list of texts.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isTextList(any) {\n    return List.isList(any) && any.every(item => Text.isText(item))\n  }\n\n  /**\n   * Add a `mark`.\n   *\n   * @param {Mark} mark\n   * @return {Text}\n   */\n\n  addMark(mark) {\n    mark = Mark.create(mark)\n    const { marks } = this\n    const next = marks.add(mark)\n    const node = this.set('marks', next)\n    return node\n  }\n\n  /**\n   * Add a set of `marks`.\n   *\n   * @param {Set<Mark>} marks\n   * @return {Text}\n   */\n\n  addMarks(marks) {\n    marks = Mark.createSet(marks)\n    const node = this.set('marks', this.marks.union(marks))\n    return node\n  }\n\n  /**\n   * Get a list of uniquely-formatted leaves for the text node, given its\n   * existing marks, and its current `annotations` and `decorations`.\n   *\n   * @param {Map<String,Annotation>} annotations\n   * @param {List<Decoration>} decorations\n   * @return {List<Leaf>}\n   */\n\n  getLeaves(annotations, decorations) {\n    const { text, marks } = this\n    let leaves = [{ text, marks, annotations: [], decorations: [] }]\n\n    // Helper to split a leaf into two `at` an offset.\n    const split = (leaf, at) => {\n      return [\n        {\n          text: leaf.text.slice(0, at),\n          marks: leaf.marks,\n          annotations: [...leaf.annotations],\n          decorations: [...leaf.decorations],\n        },\n        {\n          text: leaf.text.slice(at),\n          marks: leaf.marks,\n          annotations: [...leaf.annotations],\n          decorations: [...leaf.decorations],\n        },\n      ]\n    }\n\n    // Helper to compile the leaves for a `kind` of format.\n    const compile = kind => {\n      const formats =\n        kind === 'annotations' ? annotations.values() : decorations\n\n      for (const format of formats) {\n        const { start, end } = format\n        const next = []\n        let o = 0\n\n        for (const leaf of leaves) {\n          const { length } = leaf.text\n          const offset = o\n          o += length\n\n          // If the range encompases the entire leaf, add the format.\n          if (start.offset <= offset && end.offset >= offset + length) {\n            leaf[kind].push(format)\n            next.push(leaf)\n            continue\n          }\n\n          // If the range starts after the leaf, or ends before it, continue.\n          if (\n            start.offset > offset + length ||\n            end.offset < offset ||\n            (end.offset === offset && offset !== 0)\n          ) {\n            next.push(leaf)\n            continue\n          }\n\n          // Otherwise we need to split the leaf, at the start, end, or both,\n          // and add the format to the middle intersecting section. Do the end\n          // split first since we don't need to update the offset that way.\n          let middle = leaf\n          let before\n          let after\n\n          if (end.offset < offset + length) {\n            ;[middle, after] = split(middle, end.offset - offset)\n          }\n\n          if (start.offset > offset) {\n            ;[before, middle] = split(middle, start.offset - offset)\n          }\n\n          middle[kind].push(format)\n\n          if (before) {\n            next.push(before)\n          }\n\n          next.push(middle)\n\n          if (after) {\n            next.push(after)\n          }\n        }\n\n        leaves = next\n      }\n    }\n\n    compile('annotations')\n    compile('decorations')\n\n    leaves = leaves.map(leaf => {\n      return new Leaf({\n        ...leaf,\n        annotations: List(leaf.annotations),\n        decorations: List(leaf.decorations),\n      })\n    })\n\n    const list = List(leaves)\n    return list\n  }\n\n  /**\n   * Insert `text` at `index`.\n   *\n   * @param {Number} index\n   * @param {String} string\n   * @return {Text}\n   */\n\n  insertText(index, string) {\n    const { text } = this\n    const next = text.slice(0, index) + string + text.slice(index)\n    const node = this.set('text', next)\n    return node\n  }\n\n  /**\n   * Remove a `mark`.\n   *\n   * @param {Mark} mark\n   * @return {Text}\n   */\n\n  removeMark(mark) {\n    mark = Mark.create(mark)\n    const { marks } = this\n    const next = marks.remove(mark)\n    const node = this.set('marks', next)\n    return node\n  }\n\n  /**\n   * Remove text from the text node at `index` for `length`.\n   *\n   * @param {Number} index\n   * @param {Number} length\n   * @return {Text}\n   */\n\n  removeText(index, length) {\n    const { text } = this\n    const next = text.slice(0, index) + text.slice(index + length)\n    const node = this.set('text', next)\n    return node\n  }\n\n  /**\n   * Return a JSON representation of the text.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      text: this.text,\n      marks: this.marks.toArray().map(m => m.toJSON()),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n\n  /**\n   * Set a `newProperties` on an existing `mark`.\n   *\n   * @param {Object} mark\n   * @param {Object} newProperties\n   * @return {Text}\n   */\n\n  setMark(properties, newProperties) {\n    const { marks } = this\n    const mark = Mark.create(properties)\n    const newMark = mark.merge(newProperties)\n    const next = marks.remove(mark).add(newMark)\n    const node = this.set('marks', next)\n    return node\n  }\n\n  /**\n   * Split the node into two at `index`.\n   *\n   * @param {Number} index\n   * @returns {Array<Text>}\n   */\n\n  splitText(index) {\n    const { text } = this\n    const one = this.set('text', text.slice(0, index))\n    const two = this.set('text', text.slice(index)).regenerateKey()\n    return [one, two]\n  }\n\n  /**\n   * Merge the node with an `other` text node.\n   *\n   * @param {Text} other\n   * @returns {Text}\n   */\n\n  mergeText(other) {\n    const next = this.text + other.text\n    const node = this.set('text', next)\n    return node\n  }\n}\n\n/**\n * Export.\n *\n * @type {Text}\n */\n\nexport default Text\n","import isPlainObject from 'is-plain-object'\nimport warning from 'tiny-warning'\nimport { List } from 'immutable'\n\nimport Block from './block'\nimport Data from './data'\nimport Document from './document'\nimport Inline from './inline'\nimport Text from './text'\n\n/**\n * A pseudo-model that is used for its static methods only.\n *\n * @type {Node}\n */\n\nclass Node {\n  /**\n   * Create a new `Node` with `attrs`.\n   *\n   * @param {Object|Node} attrs\n   * @return {Node}\n   */\n\n  static create(attrs = {}) {\n    if (Node.isNode(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      let { object } = attrs\n\n      if (!object && attrs.kind) {\n        warning(\n          false,\n          'As of slate@0.32.0, the `kind` property of Slate objects has been renamed to `object`.'\n        )\n\n        object = attrs.kind\n      }\n\n      switch (object) {\n        case 'block':\n          return Block.create(attrs)\n        case 'document':\n          return Document.create(attrs)\n        case 'inline':\n          return Inline.create(attrs)\n        case 'text':\n          return Text.create(attrs)\n\n        default: {\n          throw new Error('`Node.create` requires a `object` string.')\n        }\n      }\n    }\n\n    throw new Error(\n      `\\`Node.create\\` only accepts objects or nodes but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Nodes` from an array.\n   *\n   * @param {Array<Object|Node>} elements\n   * @return {List<Node>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      let array = []\n\n      elements.forEach(el => {\n        if (\n          el &&\n          el.object === 'text' &&\n          el.leaves &&\n          Array.isArray(el.leaves)\n        ) {\n          warning(\n            false,\n            'As of slate@0.46, the `leaves` property of Text nodes has been removed. Instead, each text node contains a string of text and a unique set of marks and leaves are unnecessary.'\n          )\n\n          const texts = Text.createList(el.leaves).toArray()\n          array = array.concat(texts)\n          return\n        }\n\n        const node = Node.create(el)\n        array.push(node)\n      })\n\n      const list = List(array)\n      return list\n    }\n\n    throw new Error(\n      `\\`Node.createList\\` only accepts lists or arrays, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable node properties from `attrs`.\n   *\n   * @param {Object|String|Node} attrs\n   * @return {Object}\n   */\n\n  static createProperties(attrs = {}) {\n    if (Block.isBlock(attrs) || Inline.isInline(attrs)) {\n      return {\n        data: attrs.data,\n        type: attrs.type,\n      }\n    }\n\n    if (typeof attrs === 'string') {\n      return { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      const props = {}\n      if ('type' in attrs) props.type = attrs.type\n      if ('data' in attrs) props.data = Data.create(attrs.data)\n      return props\n    }\n\n    throw new Error(\n      `\\`Node.createProperties\\` only accepts objects, strings, blocks or inlines, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Node` from a JSON `value`.\n   *\n   * @param {Object} value\n   * @return {Node}\n   */\n\n  static fromJSON(value) {\n    let { object } = value\n\n    if (!object && value.kind) {\n      warning(\n        false,\n        'As of slate@0.32.0, the `kind` property of Slate objects has been renamed to `object`.'\n      )\n\n      object = value.kind\n    }\n\n    switch (object) {\n      case 'block':\n        return Block.fromJSON(value)\n      case 'document':\n        return Document.fromJSON(value)\n      case 'inline':\n        return Inline.fromJSON(value)\n      case 'text':\n        return Text.fromJSON(value)\n\n      default: {\n        throw new Error(\n          `\\`Node.fromJSON\\` requires an \\`object\\` of either 'block', 'document', 'inline' or 'text', but you passed: ${value}`\n        )\n      }\n    }\n  }\n\n  /**\n   * Check if `any` is a `Node`.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isNode(any) {\n    return (\n      Block.isBlock(any) ||\n      Document.isDocument(any) ||\n      Inline.isInline(any) ||\n      Text.isText(any)\n    )\n  }\n\n  /**\n   * Check if `any` is a list of nodes.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isNodeList(any) {\n    return List.isList(any) && any.every(item => Node.isNode(item))\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Node\n","import isPlainObject from 'is-plain-object'\nimport { List, Map, Record } from 'immutable'\n\nimport KeyUtils from '../utils/key-utils'\nimport Node from './node'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  data: undefined,\n  key: undefined,\n  nodes: undefined,\n  type: undefined,\n}\n\n/**\n * Block.\n *\n * @type {Block}\n */\n\nclass Block extends Record(DEFAULTS) {\n  /**\n   * Create a new `Block` from `attrs`.\n   *\n   * @param {Object|String|Block} attrs\n   * @return {Block}\n   */\n\n  static create(attrs = {}) {\n    if (Block.isBlock(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs === 'string') {\n      attrs = { type: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Block.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Block.create\\` only accepts objects, strings or blocks, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Blocks` from `attrs`.\n   *\n   * @param {Array<Block|Object>|List<Block|Object>} attrs\n   * @return {List<Block>}\n   */\n\n  static createList(attrs = []) {\n    if (List.isList(attrs) || Array.isArray(attrs)) {\n      const list = new List(attrs.map(Block.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Block.createList\\` only accepts arrays or lists, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Block` from a JSON `object`.\n   *\n   * @param {Object|Block} object\n   * @return {Block}\n   */\n\n  static fromJSON(object) {\n    if (Block.isBlock(object)) {\n      return object\n    }\n\n    const { data = {}, key = KeyUtils.create(), nodes = [], type } = object\n\n    if (typeof type !== 'string') {\n      throw new Error('`Block.fromJSON` requires a `type` string.')\n    }\n\n    const block = new Block({\n      key,\n      type,\n      data: Map(data),\n      nodes: Node.createList(nodes),\n    })\n\n    return block\n  }\n\n  /**\n   * Check if `any` is a block list.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isBlockList(any) {\n    return List.isList(any) && any.every(item => Block.isBlock(item))\n  }\n\n  /**\n   * Return a JSON representation of the block.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      type: this.type,\n      data: this.data.toJSON(),\n      nodes: this.nodes.toArray().map(n => n.toJSON(options)),\n    }\n\n    if (options.preserveKeys) {\n      object.key = this.key\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Block}\n */\n\nexport default Block\n","import isPlainObject from 'is-plain-object'\nimport invariant from 'tiny-invariant'\nimport { Record, Set, List } from 'immutable'\n\nimport Annotation from './annotation'\nimport Data from './data'\nimport Document from './document'\nimport Mark from './mark'\nimport PathUtils from '../utils/path-utils'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  annotations: undefined,\n  data: undefined,\n  document: undefined,\n  selection: undefined,\n}\n\n/**\n * Value.\n *\n * @type {Value}\n */\n\nclass Value extends Record(DEFAULTS) {\n  /**\n   * Create a new `Value` with `attrs`.\n   *\n   * @param {Object|Value} attrs\n   * @param {Object} options\n   * @return {Value}\n   */\n\n  static create(attrs = {}, options = {}) {\n    if (Value.isValue(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Value.fromJSON(attrs, options)\n    }\n\n    throw new Error(\n      `\\`Value.create\\` only accepts objects or values, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a dictionary of settable value properties from `attrs`.\n   *\n   * @param {Object|Value} attrs\n   * @return {Object}\n   */\n\n  static createProperties(a = {}) {\n    if (Value.isValue(a)) {\n      return {\n        annotations: a.annotations,\n        data: a.data,\n      }\n    }\n\n    if (isPlainObject(a)) {\n      const p = {}\n      if ('annotations' in a)\n        p.annotations = Annotation.createMap(a.annotations)\n      if ('data' in a) p.data = Data.create(a.data)\n      return p\n    }\n\n    throw new Error(\n      `\\`Value.createProperties\\` only accepts objects or values, but you passed it: ${a}`\n    )\n  }\n\n  /**\n   * Create a `Value` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @param {Object} options\n   *   @property {Boolean} normalize\n   *   @property {Array} plugins\n   * @return {Value}\n   */\n\n  static fromJSON(object, options = {}) {\n    let { data = {}, annotations = {}, document = {}, selection = {} } = object\n    data = Data.fromJSON(data)\n    document = Document.fromJSON(document)\n    selection = document.createSelection(selection)\n    annotations = Annotation.createMap(annotations)\n\n    if (selection.isUnset) {\n      const text = document.getFirstText()\n      if (text) selection = selection.moveToStartOfNode(text)\n      selection = document.createSelection(selection)\n    }\n\n    const value = new Value({\n      annotations,\n      data,\n      document,\n      selection,\n    })\n\n    return value\n  }\n\n  /**\n   * Get the current start text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get startBlock() {\n    return (\n      this.selection.start.key &&\n      this.document.getClosestBlock(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the current end text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get endBlock() {\n    return (\n      this.selection.end.key &&\n      this.document.getClosestBlock(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the current anchor text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get anchorBlock() {\n    return (\n      this.selection.anchor.key &&\n      this.document.getClosestBlock(this.selection.anchor.key)\n    )\n  }\n\n  /**\n   * Get the current focus text node's closest block parent.\n   *\n   * @return {Block}\n   */\n\n  get focusBlock() {\n    return (\n      this.selection.focus.key &&\n      this.document.getClosestBlock(this.selection.focus.key)\n    )\n  }\n\n  /**\n   * Get the current start text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get startInline() {\n    return (\n      this.selection.start.key &&\n      this.document.getClosestInline(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the current end text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get endInline() {\n    return (\n      this.selection.end.key &&\n      this.document.getClosestInline(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the current anchor text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get anchorInline() {\n    return (\n      this.selection.anchor.key &&\n      this.document.getClosestInline(this.selection.anchor.key)\n    )\n  }\n\n  /**\n   * Get the current focus text node's closest inline parent.\n   *\n   * @return {Inline}\n   */\n\n  get focusInline() {\n    return (\n      this.selection.focus.key &&\n      this.document.getClosestInline(this.selection.focus.key)\n    )\n  }\n\n  /**\n   * Get the current start text node.\n   *\n   * @return {Text}\n   */\n\n  get startText() {\n    return (\n      this.selection.start.key &&\n      this.document.getDescendant(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the current end node.\n   *\n   * @return {Text}\n   */\n\n  get endText() {\n    return (\n      this.selection.end.key &&\n      this.document.getDescendant(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the current anchor node.\n   *\n   * @return {Text}\n   */\n\n  get anchorText() {\n    return (\n      this.selection.anchor.key &&\n      this.document.getDescendant(this.selection.anchor.key)\n    )\n  }\n\n  /**\n   * Get the current focus node.\n   *\n   * @return {Text}\n   */\n\n  get focusText() {\n    return (\n      this.selection.focus.key &&\n      this.document.getDescendant(this.selection.focus.key)\n    )\n  }\n\n  /**\n   * Get the next block node.\n   *\n   * @return {Block}\n   */\n\n  get nextBlock() {\n    return (\n      this.selection.end.key &&\n      this.document.getNextBlock(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the previous block node.\n   *\n   * @return {Block}\n   */\n\n  get previousBlock() {\n    return (\n      this.selection.start.key &&\n      this.document.getPreviousBlock(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the next inline node.\n   *\n   * @return {Inline}\n   */\n\n  get nextInline() {\n    return (\n      this.selection.end.key &&\n      this.document.getNextInline(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the previous inline node.\n   *\n   * @return {Inline}\n   */\n\n  get previousInline() {\n    return (\n      this.selection.start.key &&\n      this.document.getPreviousInline(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the next text node.\n   *\n   * @return {Text}\n   */\n\n  get nextText() {\n    return (\n      this.selection.end.key &&\n      this.document.getNextText(this.selection.end.key)\n    )\n  }\n\n  /**\n   * Get the previous text node.\n   *\n   * @return {Text}\n   */\n\n  get previousText() {\n    return (\n      this.selection.start.key &&\n      this.document.getPreviousText(this.selection.start.key)\n    )\n  }\n\n  /**\n   * Get the marks of the current selection.\n   *\n   * @return {Set<Mark>}\n   */\n\n  get marks() {\n    return this.selection.isUnset\n      ? new Set()\n      : this.selection.marks || this.document.getMarksAtRange(this.selection)\n  }\n\n  /**\n   * Get the active marks of the current selection.\n   *\n   * @return {Set<Mark>}\n   */\n\n  get activeMarks() {\n    return this.selection.isUnset\n      ? new Set()\n      : this.selection.marks ||\n          this.document.getActiveMarksAtRange(this.selection)\n  }\n\n  /**\n   * Get the block nodes in the current selection.\n   *\n   * @return {List<Block>}\n   */\n\n  get blocks() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getLeafBlocksAtRange(this.selection)\n  }\n\n  /**\n   * Get the fragment of the current selection.\n   *\n   * @return {Document}\n   */\n\n  get fragment() {\n    return this.selection.isUnset\n      ? Document.create()\n      : this.document.getFragmentAtRange(this.selection)\n  }\n\n  /**\n   * Get the bottom-most inline nodes in the current selection.\n   *\n   * @return {List<Inline>}\n   */\n\n  get inlines() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getLeafInlinesAtRange(this.selection)\n  }\n\n  /**\n   * Get the text nodes in the current selection.\n   *\n   * @return {List<Text>}\n   */\n\n  get texts() {\n    return this.selection.isUnset\n      ? new List()\n      : this.document.getTextsAtRange(this.selection)\n  }\n\n  /**\n   * Add an `annotation` to the value.\n   *\n   * @param {Annotation} annotation\n   * @param {Mark} mark\n   * @return {Value}\n   */\n\n  addAnnotation(annotation) {\n    annotation = Annotation.create(annotation)\n    let value = this\n    let { annotations, document } = value\n    const { key } = annotation\n    annotation = annotation.updatePoints(point => point.normalize(document))\n    annotations = annotations.set(key, annotation)\n    value = value.set('annotations', annotations)\n    return value\n  }\n\n  /**\n   * Add `mark` to text at `path`.\n   *\n   * @param {List|String} path\n   * @param {Mark} mark\n   * @return {Value}\n   */\n\n  addMark(path, mark) {\n    mark = Mark.create(mark)\n    let value = this\n    let { document } = value\n    document = document.addMark(path, mark)\n    value = value.set('document', document)\n    return value\n  }\n\n  /**\n   * Insert a `node`.\n   *\n   * @param {List|String} path\n   * @param {Node} node\n   * @return {Value}\n   */\n\n  insertNode(path, node) {\n    let value = this\n    let { document } = value\n    document = document.insertNode(path, node)\n    value = value.set('document', document)\n\n    value = value.mapRanges(range =>\n      range.updatePoints(point => point.setPath(null))\n    )\n\n    return value\n  }\n\n  /**\n   * Insert `text` at `offset` in node by `path`.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {String} text\n   * @return {Value}\n   */\n\n  insertText(path, offset, text) {\n    let value = this\n    let { document } = value\n    let node = document.assertNode(path)\n    document = document.insertText(path, offset, text)\n    node = document.assertNode(path)\n    value = value.set('document', document)\n\n    value = value.mapPoints(point => {\n      if (point.key === node.key && point.offset >= offset) {\n        return point.setOffset(point.offset + text.length)\n      } else {\n        return point\n      }\n    })\n\n    return value\n  }\n\n  /**\n   * Merge a node backwards its previous sibling.\n   *\n   * @param {List|Key} path\n   * @return {Value}\n   */\n\n  mergeNode(path) {\n    let value = this\n    const { document } = value\n    const newDocument = document.mergeNode(path)\n    path = document.resolvePath(path)\n    const withPath = PathUtils.decrement(path)\n    const one = document.getNode(withPath)\n    const two = document.getNode(path)\n    value = value.set('document', newDocument)\n\n    value = value.mapRanges(range => {\n      if (two.object === 'text') {\n        const max = one.text.length\n\n        if (range.anchor.key === two.key) {\n          range = range.moveAnchorTo(one.key, max + range.anchor.offset)\n        }\n\n        if (range.focus.key === two.key) {\n          range = range.moveFocusTo(one.key, max + range.focus.offset)\n        }\n      }\n\n      range = range.updatePoints(point => point.setPath(null))\n\n      return range\n    })\n\n    return value\n  }\n\n  /**\n   * Move a node by `path` to `newPath`.\n   *\n   * A `newIndex` can be provided when move nodes by `key`, to account for not\n   * being able to have a key for a location in the tree that doesn't exist yet.\n   *\n   * @param {List|Key} path\n   * @param {List|Key} newPath\n   * @param {Number} newIndex\n   * @return {Value}\n   */\n\n  moveNode(path, newPath, newIndex = 0) {\n    let value = this\n    let { document } = value\n\n    if (PathUtils.isEqual(path, newPath)) {\n      return value\n    }\n\n    document = document.moveNode(path, newPath, newIndex)\n    value = value.set('document', document)\n    value = value.mapPoints(point => point.setPath(null))\n    return value\n  }\n\n  /**\n   * Remove an `annotation` from the value.\n   *\n   * @param {Annotation} annotation\n   * @param {Mark} mark\n   * @return {Value}\n   */\n\n  removeAnnotation(annotation) {\n    annotation = Annotation.create(annotation)\n    let value = this\n    let { annotations } = value\n    const { key } = annotation\n    annotations = annotations.delete(key)\n    value = value.set('annotations', annotations)\n    return value\n  }\n\n  /**\n   * Remove `mark` at `path`.\n   *\n   * @param {List|String} path\n   * @param {Mark} mark\n   * @return {Value}\n   */\n\n  removeMark(path, mark) {\n    mark = Mark.create(mark)\n    let value = this\n    let { document } = value\n    document = document.removeMark(path, mark)\n    value = value.set('document', document)\n    return value\n  }\n\n  /**\n   * Remove a node by `path`.\n   *\n   * @param {List|String} path\n   * @return {Value}\n   */\n\n  removeNode(path) {\n    let value = this\n    let { document } = value\n    const node = document.assertNode(path)\n    const first = node.object === 'text' ? node : node.getFirstText() || node\n    const last = node.object === 'text' ? node : node.getLastText() || node\n    const prev = document.getPreviousText(first.key)\n    const next = document.getNextText(last.key)\n\n    document = document.removeNode(path)\n    value = value.set('document', document)\n\n    value = value.mapRanges(range => {\n      const { anchor, focus } = range\n\n      if (node.hasNode(anchor.key)) {\n        range = prev\n          ? range.moveAnchorTo(prev.key, prev.text.length)\n          : next ? range.moveAnchorTo(next.key, 0) : range.unset()\n      }\n\n      if (node.hasNode(focus.key)) {\n        range = prev\n          ? range.moveFocusTo(prev.key, prev.text.length)\n          : next ? range.moveFocusTo(next.key, 0) : range.unset()\n      }\n\n      range = range.updatePoints(point => point.setPath(null))\n\n      return range\n    })\n\n    return value\n  }\n\n  /**\n   * Remove `text` at `offset` in node by `path`.\n   *\n   * @param {List|Key} path\n   * @param {Number} offset\n   * @param {String} text\n   * @return {Value}\n   */\n\n  removeText(path, offset, text) {\n    let value = this\n    let { document } = value\n    const node = document.assertNode(path)\n    document = document.removeText(path, offset, text)\n    value = value.set('document', document)\n\n    const { length } = text\n    const start = offset\n    const end = offset + length\n\n    value = value.mapPoints(point => {\n      if (point.key !== node.key) {\n        return point\n      }\n\n      if (point.offset >= end) {\n        return point.setOffset(point.offset - length)\n      }\n\n      if (point.offset > start) {\n        return point.setOffset(start)\n      }\n\n      return point\n    })\n\n    return value\n  }\n\n  /**\n   * Add an `annotation` to the value.\n   *\n   * @param {Annotation} annotation\n   * @param {Mark} mark\n   * @return {Value}\n   */\n\n  setAnnotation(properties, newProperties) {\n    newProperties = Annotation.createProperties(newProperties)\n    const annotation = Annotation.create(properties)\n    const next = annotation.merge(newProperties)\n    let value = this\n    let { annotations } = value\n    const { key } = annotation\n    annotations = annotations.set(key, next)\n    value = value.set('annotations', annotations)\n    return value\n  }\n\n  /**\n   * Set `properties` on a node.\n   *\n   * @param {List|String} path\n   * @param {Object} properties\n   * @return {Value}\n   */\n\n  setNode(path, properties) {\n    let value = this\n    let { document } = value\n    document = document.setNode(path, properties)\n    value = value.set('document', document)\n    return value\n  }\n\n  /**\n   * Set `properties` on `mark` on text at `offset` and `length` in node.\n   *\n   * @param {List|String} path\n   * @param {Mark} mark\n   * @param {Object} properties\n   * @return {Value}\n   */\n\n  setMark(path, mark, properties) {\n    let value = this\n    let { document } = value\n    document = document.setMark(path, mark, properties)\n    value = value.set('document', document)\n    return value\n  }\n\n  /**\n   * Set `properties` on the value.\n   *\n   * @param {Object} properties\n   * @return {Value}\n   */\n\n  setProperties(properties) {\n    let value = this\n    const { document } = value\n    const { data, annotations } = properties\n    const props = {}\n\n    if (data) {\n      props.data = data\n    }\n\n    if (annotations) {\n      props.annotations = annotations.map(a => {\n        return a.isSet ? a : document.resolveAnnotation(a)\n      })\n    }\n\n    value = value.merge(props)\n    return value\n  }\n\n  /**\n   * Set `properties` on the selection.\n   *\n   * @param {Value} value\n   * @param {Operation} operation\n   * @return {Value}\n   */\n\n  setSelection(properties) {\n    let value = this\n    let { document, selection } = value\n    const next = selection.setProperties(properties)\n    selection = document.resolveSelection(next)\n    value = value.set('selection', selection)\n    return value\n  }\n\n  /**\n   * Split a node by `path` at `position` with optional `properties` to apply\n   * to the newly split node.\n   *\n   * @param {List|String} path\n   * @param {Number} position\n   * @param {Object} properties\n   * @return {Value}\n   */\n\n  splitNode(path, position, properties) {\n    let value = this\n    const { document } = value\n    const newDocument = document.splitNode(path, position, properties)\n    const node = document.assertNode(path)\n    value = value.set('document', newDocument)\n\n    value = value.mapRanges(range => {\n      const next = newDocument.getNextText(node.key)\n      const { anchor, focus } = range\n\n      // If the anchor was after the split, move it to the next node.\n      if (node.key === anchor.key && position <= anchor.offset) {\n        range = range.moveAnchorTo(next.key, anchor.offset - position)\n      }\n\n      // If the focus was after the split, move it to the next node.\n      if (node.key === focus.key && position <= focus.offset) {\n        range = range.moveFocusTo(next.key, focus.offset - position)\n      }\n\n      range = range.updatePoints(point => point.setPath(null))\n\n      return range\n    })\n\n    return value\n  }\n\n  /**\n   * Map all range objects to apply adjustments with an `iterator`.\n   *\n   * @param {Function} iterator\n   * @return {Value}\n   */\n\n  mapRanges(iterator) {\n    let value = this\n    const { document, selection, annotations } = value\n\n    let sel = selection.isSet ? iterator(selection) : selection\n    if (!sel) sel = selection.unset()\n    if (sel !== selection) sel = document.createSelection(sel)\n    value = value.set('selection', sel)\n\n    let anns = annotations.map(annotation => {\n      let n = annotation.isSet ? iterator(annotation) : annotation\n      if (n && n !== annotation) n = document.createAnnotation(n)\n      return n\n    })\n\n    anns = anns.filter(annotation => !!annotation)\n    value = value.set('annotations', anns)\n    return value\n  }\n\n  mapPoints(iterator) {\n    return this.mapRanges(range => range.updatePoints(iterator))\n  }\n\n  /**\n   * Return a JSON representation of the value.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      document: this.document.toJSON(options),\n    }\n\n    if (options.preserveData) {\n      object.data = this.data.toJSON(options)\n    }\n\n    if (options.preserveAnnotations) {\n      object.annotations = this.annotations\n        .map(a => a.toJSON(options))\n        .toObject()\n    }\n\n    if (options.preserveSelection) {\n      object.selection = this.selection.toJSON(options)\n    }\n\n    return object\n  }\n\n  /**\n   * Deprecated.\n   */\n\n  get history() {\n    invariant(\n      false,\n      'As of Slate 0.42.0, the `value.history` model no longer exists, and the history is stored in `value.data` instead using plugins.'\n    )\n  }\n\n  change() {\n    invariant(\n      false,\n      'As of Slate 0.42.0, value object are no longer schema-aware, and the `value.change()` method is no longer available. Use the `editor.change()` method on the new `Editor` controller instead.'\n    )\n  }\n}\n\n/**\n * Export.\n */\n\nexport default Value\n","import Debug from 'debug'\n\nimport Operation from '../models/operation'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:operation:apply')\n\n/**\n * Apply an `op` to a `value`.\n *\n * @param {Value} value\n * @param {Object|Operation} op\n * @return {Value} value\n */\n\nfunction applyOperation(value, op) {\n  op = Operation.create(op)\n  const { type } = op\n  debug(type, op)\n\n  switch (type) {\n    case 'add_annotation': {\n      const { annotation } = op\n      const next = value.addAnnotation(annotation)\n      return next\n    }\n\n    case 'add_mark': {\n      const { path, mark } = op\n      const next = value.addMark(path, mark)\n      return next\n    }\n\n    case 'insert_node': {\n      const { path, node } = op\n      const next = value.insertNode(path, node)\n      return next\n    }\n\n    case 'insert_text': {\n      const { path, offset, text, marks } = op\n      const next = value.insertText(path, offset, text, marks)\n      return next\n    }\n\n    case 'merge_node': {\n      const { path } = op\n      const next = value.mergeNode(path)\n      return next\n    }\n\n    case 'move_node': {\n      const { path, newPath } = op\n      const next = value.moveNode(path, newPath)\n      return next\n    }\n\n    case 'remove_annotation': {\n      const { annotation } = op\n      const next = value.removeAnnotation(annotation)\n      return next\n    }\n\n    case 'remove_mark': {\n      const { path, mark } = op\n      const next = value.removeMark(path, mark)\n      return next\n    }\n\n    case 'remove_node': {\n      const { path } = op\n      const next = value.removeNode(path)\n      return next\n    }\n\n    case 'remove_text': {\n      const { path, offset, text } = op\n      const next = value.removeText(path, offset, text)\n      return next\n    }\n\n    case 'set_annotation': {\n      const { properties, newProperties } = op\n      const next = value.setAnnotation(properties, newProperties)\n      return next\n    }\n\n    case 'set_mark': {\n      const { path, properties, newProperties } = op\n      const next = value.setMark(path, properties, newProperties)\n      return next\n    }\n\n    case 'set_node': {\n      const { path, newProperties } = op\n      const next = value.setNode(path, newProperties)\n      return next\n    }\n\n    case 'set_selection': {\n      const { newProperties } = op\n      const next = value.setSelection(newProperties)\n      return next\n    }\n\n    case 'set_value': {\n      const { newProperties } = op\n      const next = value.setProperties(newProperties)\n      return next\n    }\n\n    case 'split_node': {\n      const { path, position, properties } = op\n      const next = value.splitNode(path, position, properties)\n      return next\n    }\n\n    default: {\n      throw new Error(`Unknown operation type: \"${type}\".`)\n    }\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default applyOperation\n","import Debug from 'debug'\n\nimport Operation from '../models/operation'\nimport PathUtils from '../utils/path-utils'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:operation:invert')\n\n/**\n * Invert an `op`.\n *\n * @param {Object} op\n * @return {Object}\n */\n\nfunction invertOperation(op) {\n  op = Operation.create(op)\n  const { type } = op\n  debug(type, op)\n\n  switch (type) {\n    case 'move_node': {\n      const { newPath, path } = op\n\n      // PERF: this case can exit early.\n      if (PathUtils.isEqual(newPath, path)) {\n        return op\n      }\n\n      const inversePath = PathUtils.transform(path, op).first()\n\n      // Get the true path we are trying to move back to\n      // We transform the right-sibling of the path\n      // This will end up at the operation.path most of the time\n      // But if the newPath is a left-sibling or left-ancestor-sibling, this will account for it\n      const inverseNewPath = PathUtils.transform(\n        PathUtils.increment(path),\n        op\n      ).first()\n\n      const inverse = op.set('path', inversePath).set('newPath', inverseNewPath)\n      return inverse\n    }\n\n    case 'merge_node': {\n      const { path } = op\n      const inversePath = PathUtils.decrement(path)\n      const inverse = op.set('type', 'split_node').set('path', inversePath)\n      return inverse\n    }\n\n    case 'split_node': {\n      const { path } = op\n      const inversePath = PathUtils.increment(path)\n      const inverse = op.set('type', 'merge_node').set('path', inversePath)\n      return inverse\n    }\n\n    case 'set_annotation':\n    case 'set_node':\n    case 'set_value':\n    case 'set_selection':\n    case 'set_mark': {\n      const { properties, newProperties } = op\n      const inverse = op\n        .set('properties', newProperties)\n        .set('newProperties', properties)\n      return inverse\n    }\n\n    case 'insert_node':\n    case 'insert_text': {\n      const inverse = op.set('type', type.replace('insert_', 'remove_'))\n      return inverse\n    }\n\n    case 'remove_node':\n    case 'remove_text': {\n      const inverse = op.set('type', type.replace('remove_', 'insert_'))\n      return inverse\n    }\n\n    case 'add_annotation':\n    case 'add_mark': {\n      const inverse = op.set('type', type.replace('add_', 'remove_'))\n      return inverse\n    }\n\n    case 'remove_annotation':\n    case 'remove_mark': {\n      const inverse = op.set('type', type.replace('remove_', 'add_'))\n      return inverse\n    }\n\n    default: {\n      throw new Error(`Unknown operation type: \"${type}\".`)\n    }\n  }\n}\n\n/**\n * Export.\n *\n * @type {Function}\n */\n\nexport default invertOperation\n","import isPlainObject from 'is-plain-object'\nimport { List, Record, Map } from 'immutable'\n\nimport Annotation from './annotation'\nimport Mark from './mark'\nimport Node from './node'\nimport PathUtils from '../utils/path-utils'\nimport Selection from './selection'\nimport Value from './value'\nimport apply from '../operations/apply'\nimport invert from '../operations/invert'\n\n/**\n * Operation attributes.\n *\n * @type {Array}\n */\n\nconst OPERATION_ATTRIBUTES = {\n  add_mark: ['path', 'mark', 'data'],\n  add_annotation: ['annotation', 'data'],\n  insert_node: ['path', 'node', 'data'],\n  insert_text: ['path', 'offset', 'text', 'data'],\n  merge_node: ['path', 'position', 'properties', 'target', 'data'],\n  move_node: ['path', 'newPath', 'data'],\n  remove_annotation: ['annotation', 'data'],\n  remove_mark: ['path', 'mark', 'data'],\n  remove_node: ['path', 'node', 'data'],\n  remove_text: ['path', 'offset', 'text', 'data'],\n  set_annotation: ['properties', 'newProperties', 'data'],\n  set_mark: ['path', 'properties', 'newProperties', 'data'],\n  set_node: ['path', 'properties', 'newProperties', 'data'],\n  set_selection: ['properties', 'newProperties', 'data'],\n  set_value: ['properties', 'newProperties', 'data'],\n  split_node: ['path', 'position', 'properties', 'target', 'data'],\n}\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  annotation: undefined,\n  data: undefined,\n  length: undefined,\n  mark: undefined,\n  marks: undefined,\n  newPath: undefined,\n  newProperties: undefined,\n  node: undefined,\n  offset: undefined,\n  path: undefined,\n  position: undefined,\n  properties: undefined,\n  target: undefined,\n  text: undefined,\n  type: undefined,\n}\n\n/**\n * Operation.\n *\n * @type {Operation}\n */\n\nclass Operation extends Record(DEFAULTS) {\n  /**\n   * Create a new `Operation` with `attrs`.\n   *\n   * @param {Object|Array|List|String|Operation} attrs\n   * @return {Operation}\n   */\n\n  static create(attrs = {}) {\n    if (Operation.isOperation(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Operation.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Operation.create\\` only accepts objects or operations, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a list of `Operations` from `elements`.\n   *\n   * @param {Array<Operation|Object>|List<Operation|Object>} elements\n   * @return {List<Operation>}\n   */\n\n  static createList(elements = []) {\n    if (List.isList(elements) || Array.isArray(elements)) {\n      const list = new List(elements.map(Operation.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Operation.createList\\` only accepts arrays or lists, but you passed it: ${elements}`\n    )\n  }\n\n  /**\n   * Create a `Operation` from a JSON `object`.\n   *\n   * @param {Object|Operation} object\n   * @return {Operation}\n   */\n\n  static fromJSON(object) {\n    if (Operation.isOperation(object)) {\n      return object\n    }\n\n    const { type } = object\n    const ATTRIBUTES = OPERATION_ATTRIBUTES[type]\n    const attrs = { type }\n\n    if (!ATTRIBUTES) {\n      throw new Error(\n        `\\`Operation.fromJSON\\` was passed an unrecognized operation type: \"${type}\"`\n      )\n    }\n\n    for (const key of ATTRIBUTES) {\n      let v = object[key]\n\n      // Default `data` to an empty object.\n      if (key === 'data' && v === undefined) {\n        v = {}\n      }\n\n      if (v === undefined) {\n        throw new Error(\n          `\\`Operation.fromJSON\\` was passed a \"${type}\" operation without the required \"${key}\" attribute.`\n        )\n      }\n\n      if (key === 'annotation') {\n        v = Annotation.create(v)\n      }\n\n      if (key === 'path' || key === 'newPath') {\n        v = PathUtils.create(v)\n      }\n\n      if (key === 'mark') {\n        v = Mark.create(v)\n      }\n\n      if (key === 'node') {\n        v = Node.create(v)\n      }\n\n      if (\n        (key === 'properties' || key === 'newProperties') &&\n        type === 'set_annotation'\n      ) {\n        v = Annotation.createProperties(v)\n      }\n\n      if (\n        (key === 'properties' || key === 'newProperties') &&\n        type === 'set_mark'\n      ) {\n        v = Mark.createProperties(v)\n      }\n\n      if (\n        (key === 'properties' || key === 'newProperties') &&\n        (type === 'set_node' || type === 'merge_node' || type === 'split_node')\n      ) {\n        v = Node.createProperties(v)\n      }\n\n      if (\n        (key === 'properties' || key === 'newProperties') &&\n        type === 'set_selection'\n      ) {\n        v = Selection.createProperties(v)\n      }\n\n      if (\n        (key === 'properties' || key === 'newProperties') &&\n        type === 'set_value'\n      ) {\n        v = Value.createProperties(v)\n      }\n\n      if (key === 'data') {\n        v = Map(v)\n      }\n\n      attrs[key] = v\n    }\n\n    const op = new Operation(attrs)\n    return op\n  }\n\n  /**\n   * Check if `any` is a list of operations.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isOperationList(any) {\n    return List.isList(any) && any.every(item => Operation.isOperation(item))\n  }\n\n  /**\n   * Apply the operation to a `value`.\n   *\n   * @param {Value} value\n   * @return {Value}\n   */\n\n  apply(value) {\n    const next = apply(value, this)\n    return next\n  }\n\n  /**\n   * Invert the operation.\n   *\n   * @return {Operation}\n   */\n\n  invert() {\n    const inverted = invert(this)\n    return inverted\n  }\n\n  /**\n   * Return a JSON representation of the operation.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const { object, type } = this\n    const json = { object, type }\n    const ATTRIBUTES = OPERATION_ATTRIBUTES[type]\n\n    for (const key of ATTRIBUTES) {\n      let value = this[key]\n\n      if (\n        key === 'annotation' ||\n        key === 'mark' ||\n        key === 'marks' ||\n        key === 'node' ||\n        key === 'path' ||\n        key === 'newPath'\n      ) {\n        value = value.toJSON()\n      }\n\n      if (key === 'properties' && type === 'merge_node') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (\n        (key === 'properties' || key === 'newProperties') &&\n        type === 'set_annotation'\n      ) {\n        const v = {}\n        if ('anchor' in value) v.anchor = value.anchor.toJS()\n        if ('focus' in value) v.focus = value.focus.toJS()\n        if ('key' in value) v.key = value.key\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (\n        (key === 'properties' || key === 'newProperties') &&\n        type === 'set_mark'\n      ) {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (\n        (key === 'properties' || key === 'newProperties') &&\n        type === 'set_node'\n      ) {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (\n        (key === 'properties' || key === 'newProperties') &&\n        type === 'set_selection'\n      ) {\n        const v = {}\n        if ('anchor' in value) v.anchor = value.anchor.toJSON()\n        if ('focus' in value) v.focus = value.focus.toJSON()\n        if ('isFocused' in value) v.isFocused = value.isFocused\n        if ('marks' in value) v.marks = value.marks && value.marks.toJSON()\n        value = v\n      }\n\n      if (\n        (key === 'properties' || key === 'newProperties') &&\n        type === 'set_value'\n      ) {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        value = v\n      }\n\n      if (key === 'properties' && type === 'split_node') {\n        const v = {}\n        if ('data' in value) v.data = value.data.toJS()\n        if ('type' in value) v.type = value.type\n        value = v\n      }\n\n      if (key === 'data') {\n        value = value.toJSON()\n      }\n\n      json[key] = value\n    }\n\n    return json\n  }\n}\n\n/**\n * Export.\n *\n * @type {Operation}\n */\n\nexport default Operation\n","import isPlainObject from 'is-plain-object'\nimport { Record } from 'immutable'\n\nimport Operation from './operation'\nimport Value from './value'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  operations: undefined,\n  value: undefined,\n}\n\n/**\n * Change.\n *\n * @type {Change}\n */\n\nclass Change extends Record(DEFAULTS) {\n  /**\n   * Create a new `Change` with `attrs`.\n   *\n   * @param {Object|Change} attrs\n   * @return {Change}\n   */\n\n  static create(attrs = {}) {\n    if (Change.isChange(attrs)) {\n      return attrs\n    }\n\n    if (isPlainObject(attrs)) {\n      return Change.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Change.create\\` only accepts objects or changes, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Change` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Change}\n   */\n\n  static fromJSON(object) {\n    const { value, operations = [] } = object\n\n    const change = new Change({\n      value: Value.create(value),\n      operations: Operation.createList(operations),\n    })\n\n    return change\n  }\n\n  /**\n   * Return a JSON representation of the change.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      value: this.value.toJSON(options),\n      operations: this.operations.toArray().map(o => o.toJSON(options)),\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Change}\n */\n\nexport default Change\n","/**\n * A plugin that adds a set of commands to the editor.\n *\n * @param {Object} commands\n * @return {Object}\n */\n\nfunction CommandsPlugin(commands = {}) {\n  /**\n   * On command, if it exists in our list of commands, call it.\n   *\n   * @param {Object} command\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCommand(command, editor, next) {\n    const { type, args } = command\n    const fn = commands[type]\n    if (!fn) return next()\n    editor.command(fn, ...args)\n  }\n\n  /**\n   * On construct, register all the commands.\n   *\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onConstruct(editor, next) {\n    for (const command in commands) {\n      editor.registerCommand(command)\n    }\n\n    return next()\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onCommand,\n    onConstruct,\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default CommandsPlugin\n","import { reverse } from 'esrever'\n\n/**\n * Surrogate pair start and end points.\n *\n * @type {Number}\n */\n\nconst SURROGATE_START = 0xd800\nconst SURROGATE_END = 0xdfff\n\n/**\n * A regex to match space characters.\n *\n * @type {RegExp}\n */\n\nconst SPACE = /\\s/\n\n/**\n * A regex to match chameleon characters, that count as word characters as long\n * as they are inside of a word.\n *\n * @type {RegExp}\n */\n\nconst CHAMELEON = /['\\u2018\\u2019]/\n\n/**\n * A regex that matches punctuation.\n *\n * @type {RegExp}\n */\n\nconst PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/\n\n/**\n * Is a character `code` in a surrogate character.\n *\n * @param {Number} code\n * @return {Boolean}\n */\n\nfunction isSurrogate(code) {\n  return SURROGATE_START <= code && code <= SURROGATE_END\n}\n\n/**\n * Does `code` form Modifier with next one.\n *\n * https://emojipedia.org/modifiers/\n *\n * @param {Number} code\n * @param {String} text\n * @param {Number} offset\n * @return {Boolean}\n */\n\nfunction isModifier(code, text, offset) {\n  if (code === 0xd83c) {\n    const next = text.charCodeAt(offset + 1)\n    return next <= 0xdfff && next >= 0xdffb\n  }\n  return false\n}\n\n/**\n * Is `code` a Variation Selector.\n *\n * https://codepoints.net/variation_selectors\n *\n * @param {Number} code\n * @return {Boolean}\n */\n\nfunction isVariationSelector(code) {\n  return code <= 0xfe0f && code >= 0xfe00\n}\n\n/**\n * Is `code` one of the BMP codes used in emoji sequences.\n *\n * https://emojipedia.org/emoji-zwj-sequences/\n *\n * @param {Number} code\n * @return {Boolean}\n */\n\nfunction isBMPEmoji(code) {\n  // This requires tiny bit of maintanance, better ideas?\n  // Fortunately it only happens if new Unicode Standard\n  // is released. Fails gracefully if upkeep lags behind,\n  // same way Slate previously behaved with all emojis.\n  return (\n    code === 0x2764 || // heart (❤)\n    code === 0x2642 || // male (♂)\n    code === 0x2640 || // female (♀)\n    code === 0x2620 || // scull (☠)\n    code === 0x2695 || // medical (⚕)\n    code === 0x2708 || // plane (✈️)\n    code === 0x25ef // large circle (◯)\n  )\n}\n\n/**\n * Is a character a word character? Needs the `remaining` characters too.\n *\n * @param {String} char\n * @param {String|Void} remaining\n * @return {Boolean}\n */\n\nfunction isWord(char, remaining) {\n  if (SPACE.test(char)) return false\n\n  // If it's a chameleon character, recurse to see if the next one is or not.\n  if (CHAMELEON.test(char)) {\n    let next = remaining.charAt(0)\n    const length = getCharLength(next)\n    next = remaining.slice(0, length)\n    const rest = remaining.slice(length)\n    if (isWord(next, rest)) return true\n  }\n\n  if (PUNCTUATION.test(char)) return false\n  return true\n}\n\n/**\n * Get the length of a `character`.\n *\n * @param {String} char\n * @return {Number}\n */\n\nfunction getCharLength(char) {\n  return isSurrogate(char.charCodeAt(0)) ? 2 : 1\n}\n\n/**\n * Get the offset to the end of the character(s) in `text`.\n * This function is emoji aware and handles them correctly.\n *\n * @param {String} text\n * @param {Number} chars\n * @param {Boolean} forward\n * @return {Number}\n */\n\nfunction getCharOffset(text, chars, forward) {\n  let offset = 0\n\n  // Handle end/beginning of node: we have to return 1 in order not to\n  // break cursor's jumping to next/previous node. We need to return early\n  // because otherwise, ''.charCodeAt(0) returned NaN and, the default\n  // handling 'latin characters' at the end of the while loop would\n  // would never be reached an we returned '0' as offset.\n  if (text === '') return 1\n\n  // Calculate offset sum of each character\n  for (let i = 0; i < chars; i++) {\n    // `prev` types (better ideas?):\n    // - SURR: surrogate pair\n    // - MOD: modifier (technically also surrogate pair)\n    // - ZWJ: zero width joiner\n    // - VAR: variation selector\n    // - BMP: sequenceable character from Basic Multilingual Plane\n    let prev = null\n    let charCode = text.charCodeAt(offset)\n\n    while (charCode) {\n      if (isSurrogate(charCode)) {\n        const modifier = isModifier(charCode, text, offset)\n\n        // Early returns are the heart of this loop where\n        // we decide if previous and current codepoints\n        // should form a single character (in other words:\n        // how many of them should selection jump over).\n        if (forward) {\n          if (\n            (!modifier && prev && prev !== 'ZWJ') ||\n            (modifier && prev && prev !== 'SURR')\n          ) {\n            break\n          }\n        } else if (prev === 'SURR' || prev === 'BMP') {\n          break\n        }\n\n        offset += 2\n        prev = modifier ? 'MOD' : 'SURR'\n        charCode = text.charCodeAt(offset)\n        // It's okay to `continue` without checking\n        // because if `charCode` is NaN (which is\n        // the case when out of `text` range), next\n        // `while` loop won't execute and we're done.\n        continue\n      }\n\n      // If zero width joiner\n      if (charCode === 0x200d) {\n        offset += 1\n        prev = 'ZWJ'\n        charCode = text.charCodeAt(offset)\n        continue\n      }\n\n      if (isBMPEmoji(charCode)) {\n        if (\n          (forward && prev === 'VAR') ||\n          (prev && prev !== 'ZWJ' && prev !== 'VAR')\n        ) {\n          break\n        }\n\n        offset += 1\n        prev = 'BMP'\n        charCode = text.charCodeAt(offset)\n        continue\n      }\n\n      if (isVariationSelector(charCode)) {\n        if (!forward && prev && prev !== 'ZWJ') {\n          break\n        }\n\n        offset += 1\n        prev = 'VAR'\n        charCode = text.charCodeAt(offset)\n        continue\n      }\n\n      // Modifier \"fuses\" with what ever character is before that\n      // (even whitespace), need to look ahead if loop gets here.\n      if (forward) {\n        const nextCharCode = text.charCodeAt(offset + 1)\n\n        if (isModifier(nextCharCode, text, offset + 1)) {\n          offset += 3\n          prev = 'MOD'\n          charCode = text.charCodeAt(offset)\n          continue\n        }\n      } else if (prev === 'MOD') {\n        offset += 1\n        break\n      }\n\n      // If while loop ever gets here, we're\n      // done (e.g Latin characters, length 1).\n      if (prev === null) offset += 1\n      break\n    }\n  }\n\n  return offset\n}\n\n/**\n * Get the offset to the end of character(s) before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @param {Number} chars\n * @return {Number}\n */\n\nfunction getCharOffsetBackward(text, offset, chars = 1) {\n  text = text.slice(0, offset)\n  text = reverse(text)\n  return getCharOffset(text, chars)\n}\n\n/**\n * Get the offset to the end of character(s) after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @param {Number} chars\n * @return {Number}\n */\n\nfunction getCharOffsetForward(text, offset, chars = 1) {\n  text = text.slice(offset)\n  return getCharOffset(text, chars, true)\n}\n\n/**\n * Get the offset to the end of the first word in `text`.\n *\n * @param {String} text\n * @return {Number}\n */\n\nfunction getWordOffset(text) {\n  let length = 0\n  let i = 0\n  let started = false\n  let char\n\n  while ((char = text.charAt(i))) {\n    const l = getCharLength(char)\n    char = text.slice(i, i + l)\n    const rest = text.slice(i + l)\n\n    if (isWord(char, rest)) {\n      started = true\n      length += l\n    } else if (!started) {\n      length += l\n    } else {\n      break\n    }\n\n    i += l\n  }\n\n  return length\n}\n\n/**\n * Get the offset to the end of the word before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getWordOffsetBackward(text, offset) {\n  text = text.slice(0, offset)\n  text = reverse(text)\n  const o = getWordOffset(text)\n  return o\n}\n\n/**\n * Get the offset to the end of the word after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getWordOffsetForward(text, offset) {\n  text = text.slice(offset)\n  const o = getWordOffset(text)\n  return o\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default {\n  getCharLength,\n  getCharOffset,\n  getCharOffsetBackward,\n  getCharOffsetForward,\n  getWordOffset,\n  getWordOffsetBackward,\n  getWordOffsetForward,\n  isSurrogate,\n  isWord,\n}\n","import { List } from 'immutable'\nimport Block from '../models/block'\nimport Inline from '../models/inline'\nimport Mark from '../models/mark'\nimport Node from '../models/node'\nimport TextUtils from '../utils/text-utils'\n\n/**\n * Ensure that an expanded selection is deleted first, and return the updated\n * range to account for the deleted part.\n *\n * @param {Editor}\n */\n\nfunction deleteExpandedAtRange(editor, range) {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range)\n  }\n\n  const { value } = editor\n  const { document } = value\n  const { start, end } = range\n\n  if (document.hasDescendant(start.path)) {\n    range = range.moveToStart()\n  } else {\n    range = range.moveTo(end.path, 0).normalize(document)\n  }\n\n  return range\n}\n\n/**\n * Commands.\n *\n * @type {Object}\n */\n\nconst Commands = {}\n\n/**\n * Add a new `mark` to the characters at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Mixed} mark\n */\n\nCommands.addMarkAtRange = (editor, range, mark) => {\n  if (range.isCollapsed) return\n\n  const { value } = editor\n  const { document } = value\n  const { start, end } = range\n  const texts = document.getTextsAtRange(range)\n\n  editor.withoutNormalizing(() => {\n    texts.forEach(node => {\n      const { key } = node\n      let index = 0\n      let length = node.text.length\n\n      if (key === start.key) index = start.offset\n      if (key === end.key) length = end.offset\n      if (key === start.key && key === end.key)\n        length = end.offset - start.offset\n\n      editor.addMarkByKey(key, index, length, mark)\n    })\n  })\n}\n\n/**\n * Add a list of `marks` to the characters at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Array<Mixed>} mark\n */\n\nCommands.addMarksAtRange = (editor, range, marks) => {\n  marks.forEach(mark => editor.addMarkAtRange(range, mark))\n}\n\n/**\n * Delete everything in a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nCommands.deleteAtRange = (editor, range) => {\n  // Snapshot the selection, which creates an extra undo save point, so that\n  // when you undo a delete, the expanded selection will be retained.\n  editor.snapshotSelection()\n\n  const { value } = editor\n  const { start, end } = range\n  let startKey = start.key\n  let startOffset = start.offset\n  let endKey = end.key\n  let endOffset = end.offset\n  let { document } = value\n  let isStartVoid = document.hasVoidParent(startKey, editor)\n  let isEndVoid = document.hasVoidParent(endKey, editor)\n  let startBlock = document.getClosestBlock(startKey)\n  let endBlock = document.getClosestBlock(endKey)\n\n  // Check if we have a \"hanging\" selection case where the even though the\n  // selection extends into the start of the end node, we actually want to\n  // ignore that for UX reasons.\n  const isHanging =\n    startOffset === 0 &&\n    endOffset === 0 &&\n    isStartVoid === false &&\n    startKey === startBlock.getFirstText().key &&\n    endKey === endBlock.getFirstText().key &&\n    startKey !== endKey\n\n  // If it's a hanging selection, nudge it back to end in the previous text.\n  if (isHanging && isEndVoid) {\n    const prevText = document.getPreviousText(endKey)\n    endKey = prevText.key\n    endOffset = prevText.text.length\n    isEndVoid = document.hasVoidParent(endKey, editor)\n  }\n\n  editor.withoutNormalizing(() => {\n    // If the start node is inside a void node, remove the void node and update\n    // the starting point to be right after it, continuously until the start point\n    // is not a void, or until the entire range is handled.\n    while (isStartVoid) {\n      const startVoid = document.getClosestVoid(startKey, editor)\n      const nextText = document.getNextText(startKey)\n      editor.removeNodeByKey(startVoid.key)\n\n      // If the start and end keys are the same, we're done.\n      if (startKey === endKey) return\n\n      // If there is no next text node, we're done.\n      if (!nextText) return\n\n      // Continue...\n      document = editor.value.document\n      startKey = nextText.key\n      startOffset = 0\n      isStartVoid = document.hasVoidParent(startKey, editor)\n    }\n\n    // If the end node is inside a void node, do the same thing but backwards. But\n    // we don't need any aborting checks because if we've gotten this far there\n    // must be a non-void node that will exit the loop.\n    while (isEndVoid) {\n      const endVoid = document.getClosestVoid(endKey, editor)\n      const prevText = document.getPreviousText(endKey)\n      editor.removeNodeByKey(endVoid.key)\n\n      // Continue...\n      document = editor.value.document\n      endKey = prevText.key\n      endOffset = prevText.text.length\n      isEndVoid = document.hasVoidParent(endKey, editor)\n    }\n\n    // If the start and end key are the same, and it was a hanging selection, we\n    // can just remove the entire block.\n    if (startKey === endKey && isHanging) {\n      editor.removeNodeByKey(startBlock.key)\n      return\n    } else if (startKey === endKey) {\n      // Otherwise, if it wasn't hanging, we're inside a single text node, so we can\n      // simply remove the text in the range.\n      const index = startOffset\n      const length = endOffset - startOffset\n      editor.removeTextByKey(startKey, index, length)\n      return\n    } else {\n      // Otherwise, we need to recursively remove text and nodes inside the start\n      // block after the start offset and inside the end block before the end\n      // offset. Then remove any blocks that are in between the start and end\n      // blocks. Then finally merge the start and end nodes.\n      startBlock = document.getClosestBlock(startKey)\n      endBlock = document.getClosestBlock(endKey)\n      const startText = document.getNode(startKey)\n      const endText = document.getNode(endKey)\n      const startLength = startText.text.length - startOffset\n      const endLength = endOffset\n\n      const ancestor = document.getCommonAncestor(startKey, endKey)\n      const startChild = ancestor.getFurthestChild(startKey)\n      const endChild = ancestor.getFurthestChild(endKey)\n\n      const startParent = document.getParent(startBlock.key)\n      const startParentIndex = startParent.nodes.indexOf(startBlock)\n      const endParentIndex = startParent.nodes.indexOf(endBlock)\n\n      let child\n\n      // Iterate through all of the nodes in the tree after the start text node\n      // but inside the end child, and remove them.\n      child = startText\n\n      while (child.key !== startChild.key) {\n        const parent = document.getParent(child.key)\n        const index = parent.nodes.indexOf(child)\n        const afters = parent.nodes.slice(index + 1)\n\n        afters.reverse().forEach(node => {\n          editor.removeNodeByKey(node.key)\n        })\n\n        child = parent\n      }\n\n      // Remove all of the middle children.\n      const startChildIndex = ancestor.nodes.indexOf(startChild)\n      const endChildIndex = ancestor.nodes.indexOf(endChild)\n      const middles = ancestor.nodes.slice(startChildIndex + 1, endChildIndex)\n\n      middles.reverse().forEach(node => {\n        editor.removeNodeByKey(node.key)\n      })\n\n      // Remove the nodes before the end text node in the tree.\n      child = endText\n\n      while (child.key !== endChild.key) {\n        const parent = document.getParent(child.key)\n        const index = parent.nodes.indexOf(child)\n        const befores = parent.nodes.slice(0, index)\n\n        befores.reverse().forEach(node => {\n          editor.removeNodeByKey(node.key)\n        })\n\n        child = parent\n      }\n\n      // Remove any overlapping text content from the leaf text nodes.\n      if (startLength !== 0) {\n        editor.removeTextByKey(startKey, startOffset, startLength)\n      }\n\n      if (endLength !== 0) {\n        editor.removeTextByKey(endKey, 0, endOffset)\n      }\n\n      // If the start and end blocks aren't the same, move and merge the end block\n      // into the start block.\n      if (startBlock.key !== endBlock.key) {\n        document = editor.value.document\n        let onlyChildAncestor\n\n        for (const [node] of document.ancestors(endBlock.key)) {\n          if (node.nodes.size > 1) {\n            break\n          } else {\n            onlyChildAncestor = node\n          }\n        }\n\n        // Move the end block to be right after the start block.\n        if (endParentIndex !== startParentIndex + 1) {\n          editor.moveNodeByKey(\n            endBlock.key,\n            startParent.key,\n            startParentIndex + 1\n          )\n        }\n\n        // If the selection is hanging, just remove the start block, otherwise\n        // merge the end block into it.\n        if (isHanging) {\n          editor.removeNodeByKey(startBlock.key)\n        } else {\n          editor.mergeNodeByKey(endBlock.key)\n        }\n\n        // If nested empty blocks are left over above the end block, remove them.\n        if (onlyChildAncestor) {\n          editor.removeNodeByKey(onlyChildAncestor.key)\n        }\n      }\n    }\n  })\n}\n\n/**\n * Delete backward `n` characters at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Number} n (optional)\n */\n\nCommands.deleteBackwardAtRange = (editor, range, n = 1) => {\n  if (n === 0) return\n  const { value } = editor\n  const { document } = value\n  const { start, focus } = range\n\n  // If the range is expanded, perform a regular delete instead.\n  if (range.isExpanded) {\n    editor.deleteAtRange(range)\n    return\n  }\n\n  const voidParent = document.getClosestVoid(start.path, editor)\n\n  // If there is a void parent, delete it.\n  if (voidParent) {\n    editor.removeNodeByKey(voidParent.key)\n    return\n  }\n\n  // If the range is at the start of the document, abort.\n  if (start.isAtStartOfNode(document)) {\n    return\n  }\n\n  const block = document.getClosestBlock(start.path)\n\n  // PERF: If the closest block is empty, remove it. This is just a shortcut,\n  // since merging it would result in the same outcome.\n  if (\n    document.nodes.size !== 1 &&\n    block &&\n    block.text === '' &&\n    block.nodes.size === 1\n  ) {\n    editor.removeNodeByKey(block.key)\n    return\n  }\n\n  // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n  const text = document.getDescendant(start.path)\n\n  if (start.isAtStartOfNode(text)) {\n    let prev = document.getPreviousText(text.key)\n    const inline = document.getClosestInline(text.key)\n\n    // If the range is at the start of the inline node, and previous text node\n    // is empty, take the text node before that, or \"prevBlock\" would be the\n    // same node as \"block\"\n    if (inline && prev.text === '') {\n      prev = document.getPreviousText(prev.key)\n    }\n\n    const prevBlock = document.getClosestBlock(prev.key)\n    const prevVoid = document.getClosestVoid(prev.key, editor)\n\n    // If the previous text node has a void parent, remove it.\n    if (prevVoid) {\n      editor.removeNodeByKey(prevVoid.key)\n      return\n    }\n\n    // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to merge the two blocks together.\n    if (n === 1 && prevBlock !== block) {\n      range = range.moveAnchorTo(prev.key, prev.text.length)\n      editor.deleteAtRange(range)\n      return\n    }\n  }\n\n  // If the focus offset is farther than the number of characters to delete,\n  // just remove the characters backwards inside the current node.\n  if (n <= focus.offset) {\n    range = range.moveFocusBackward(n)\n    editor.deleteAtRange(range)\n    return\n  }\n\n  // Otherwise, we need to see how many nodes backwards to go.\n  let node = text\n  let offset = 0\n  let traversed = focus.offset\n\n  while (n > traversed) {\n    node = document.getPreviousText(node.key)\n    const next = traversed + node.text.length\n\n    if (n <= next) {\n      offset = next - n\n      break\n    } else {\n      traversed = next\n    }\n  }\n\n  range = range.moveAnchorTo(node.key, offset)\n  editor.deleteAtRange(range)\n}\n\n/**\n * Delete backward until the character boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nCommands.deleteCharBackwardAtRange = (editor, range) => {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range)\n    return\n  }\n\n  const { value } = editor\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.path)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  const { text } = startBlock\n  const n = TextUtils.getCharOffsetBackward(text, o)\n  editor.deleteBackwardAtRange(range, n)\n}\n\n/**\n * Delete forward until the character boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nCommands.deleteCharForwardAtRange = (editor, range) => {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range)\n    return\n  }\n\n  const { value } = editor\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.path)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  const { text } = startBlock\n  const n = TextUtils.getCharOffsetForward(text, o)\n  editor.deleteForwardAtRange(range, n)\n}\n\n/**\n * Delete forward `n` characters at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Number} n (optional)\n */\n\nCommands.deleteForwardAtRange = (editor, range, n = 1) => {\n  if (n === 0) return\n  const { value } = editor\n  const { document } = value\n  const { start, focus } = range\n\n  // If the range is expanded, perform a regular delete instead.\n  if (range.isExpanded) {\n    editor.deleteAtRange(range)\n    return\n  }\n\n  const voidParent = document.getClosestVoid(start.path, editor)\n\n  // If the node has a void parent, delete it.\n  if (voidParent) {\n    editor.removeNodeByKey(voidParent.key)\n    return\n  }\n\n  const block = document.getClosestBlock(start.path)\n\n  // If the closest is not void, but empty, remove it\n  if (\n    block &&\n    !editor.isVoid(block) &&\n    block.text === '' &&\n    document.nodes.size !== 1\n  ) {\n    const nextBlock = document.getNextBlock(block.key)\n    editor.removeNodeByKey(block.key)\n\n    if (nextBlock && nextBlock.key) {\n      editor.moveToStartOfNode(nextBlock)\n    }\n\n    return\n  }\n\n  // If the range is at the start of the document, abort.\n  if (start.isAtEndOfNode(document)) {\n    return\n  }\n\n  // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n  const text = document.getDescendant(start.path)\n\n  if (start.isAtEndOfNode(text)) {\n    const next = document.getNextText(text.key)\n    const nextBlock = document.getClosestBlock(next.key)\n    const nextVoid = document.getClosestVoid(next.key, editor)\n\n    // If the next text node has a void parent, remove it.\n    if (nextVoid) {\n      editor.removeNodeByKey(nextVoid.key)\n      return\n    }\n\n    // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to merge the two blocks together.\n    if (n === 1 && nextBlock !== block) {\n      range = range.moveFocusTo(next.key, 0)\n      editor.deleteAtRange(range)\n      return\n    }\n  }\n\n  // If the remaining characters to the end of the node is greater than or equal\n  // to the number of characters to delete, just remove the characters forwards\n  // inside the current node.\n  if (n <= text.text.length - focus.offset) {\n    range = range.moveFocusForward(n)\n    editor.deleteAtRange(range)\n    return\n  }\n\n  // Otherwise, we need to see how many nodes forwards to go.\n  let node = text\n  let offset = focus.offset\n  let traversed = text.text.length - focus.offset\n\n  while (n > traversed) {\n    node = document.getNextText(node.key)\n    const next = traversed + node.text.length\n\n    if (n <= next) {\n      offset = n - traversed\n      break\n    } else {\n      traversed = next\n    }\n  }\n\n  range = range.moveFocusTo(node.key, offset)\n  editor.deleteAtRange(range)\n}\n\n/**\n * Delete backward until the line boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nCommands.deleteLineBackwardAtRange = (editor, range) => {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range)\n    return\n  }\n\n  const { value } = editor\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.path)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  editor.deleteBackwardAtRange(range, o)\n}\n\n/**\n * Delete forward until the line boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nCommands.deleteLineForwardAtRange = (editor, range) => {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range)\n    return\n  }\n\n  const { value } = editor\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.path)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  editor.deleteForwardAtRange(range, startBlock.text.length - o)\n}\n\n/**\n * Delete backward until the word boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nCommands.deleteWordBackwardAtRange = (editor, range) => {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range)\n    return\n  }\n\n  const { value } = editor\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.path)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  const { text } = startBlock\n  const n = o === 0 ? 1 : TextUtils.getWordOffsetBackward(text, o)\n  editor.deleteBackwardAtRange(range, n)\n}\n\n/**\n * Delete forward until the word boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nCommands.deleteWordForwardAtRange = (editor, range) => {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range)\n    return\n  }\n\n  const { value } = editor\n  const { document } = value\n  const { start } = range\n  const startBlock = document.getClosestBlock(start.path)\n  const offset = startBlock.getOffset(start.key)\n  const o = offset + start.offset\n  const { text } = startBlock\n  const wordOffset = TextUtils.getWordOffsetForward(text, o)\n  const n = wordOffset === 0 ? 1 : wordOffset\n  editor.deleteForwardAtRange(range, n)\n}\n\n/**\n * Insert a `block` node at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Block|String|Object} block\n */\n\nCommands.insertBlockAtRange = (editor, range, block) => {\n  range = deleteExpandedAtRange(editor, range)\n  block = Block.create(block)\n\n  const { value } = editor\n  const { document } = value\n  const { start } = range\n  let startKey = start.key\n  let startOffset = start.offset\n  const startBlock = document.getClosestBlock(startKey)\n  const startInline = document.getClosestInline(startKey)\n  const parent = document.getParent(startBlock.key)\n  const index = parent.nodes.indexOf(startBlock)\n  const insertionMode = getInsertionMode(editor, range)\n\n  if (insertionMode === 'before') {\n    editor.insertNodeByKey(parent.key, index, block)\n  } else if (insertionMode === 'behind') {\n    editor.insertNodeByKey(parent.key, index + 1, block)\n  } else {\n    if (startInline && editor.isVoid(startInline)) {\n      const atEnd = start.isAtEndOfNode(startInline)\n      const siblingText = atEnd\n        ? document.getNextText(startKey)\n        : document.getPreviousText(startKey)\n\n      const splitRange = atEnd\n        ? range.moveToStartOfNode(siblingText)\n        : range.moveToEndOfNode(siblingText)\n\n      startKey = splitRange.start.key\n      startOffset = splitRange.start.offset\n    }\n\n    editor.withoutNormalizing(() => {\n      editor.splitDescendantsByKey(startBlock.key, startKey, startOffset)\n      editor.insertNodeByKey(parent.key, index + 1, block)\n    })\n  }\n}\n\n/**\n * Check if current block should be split or new block should be added before or behind it.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nconst getInsertionMode = (editor, range) => {\n  const { value } = editor\n  const { document } = value\n  const { start } = range\n  const startKey = start.key\n  const startBlock = document.getClosestBlock(startKey)\n  const startInline = document.getClosestInline(startKey)\n\n  if (editor.isVoid(startBlock)) {\n    if (start.isAtEndOfNode(startBlock)) return 'behind'\n    else return 'before'\n  } else if (!startInline && startBlock.text === '') {\n    return 'behind'\n  } else if (start.isAtStartOfNode(startBlock)) {\n    return 'before'\n  } else if (start.isAtEndOfNode(startBlock)) {\n    return 'behind'\n  }\n  return 'split'\n}\n\n/**\n * Insert a `fragment` at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Document} fragment\n */\n\nCommands.insertFragmentAtRange = (editor, range, fragment) => {\n  editor.withoutNormalizing(() => {\n    range = deleteExpandedAtRange(editor, range)\n\n    // If the fragment is empty, there's nothing to do after deleting.\n    if (!fragment.nodes.size) return\n\n    // Regenerate the keys for all of the fragments nodes, so that they're\n    // guaranteed not to collide with the existing keys in the document. Otherwise\n    // they will be regenerated automatically and we won't have an easy way to\n    // reference them.\n    fragment = fragment.mapDescendants(child => child.regenerateKey())\n\n    // Calculate a few things...\n    const { start } = range\n    const { value } = editor\n    let { document } = value\n    let startText = document.getDescendant(start.path)\n    let startBlock = document.getClosestBlock(startText.key)\n    let startChild = startBlock.getFurthestChild(startText.key)\n    const isAtStart = start.isAtStartOfNode(startBlock)\n    const parent = document.getParent(startBlock.key)\n    const index = parent.nodes.indexOf(startBlock)\n    const blocks = fragment.getBlocks()\n    const firstChild = fragment.nodes.first()\n    const lastChild = fragment.nodes.last()\n    const firstBlock = blocks.first()\n    const lastBlock = blocks.last()\n    const insertionNode = findInsertionNode(fragment, document, startBlock.key)\n\n    // If the fragment only contains a void block, use `insertBlock` instead.\n    if (firstBlock === lastBlock && editor.isVoid(firstBlock)) {\n      editor.insertBlockAtRange(range, firstBlock)\n      return\n    }\n\n    // If inserting the entire fragment and it starts or ends with a single\n    // nested block, e.g. a table, we do not merge it with existing blocks.\n    if (\n      insertionNode === fragment &&\n      (firstChild.hasBlockChildren() || lastChild.hasBlockChildren())\n    ) {\n      // check if reversal is necessary or not\n      const insertionMode = getInsertionMode(editor, range)\n      const nodes =\n        insertionMode === 'before' ? fragment.nodes : fragment.nodes.reverse()\n\n      nodes.forEach(node => {\n        editor.insertBlockAtRange(range, node)\n      })\n      return\n    }\n\n    // If the first and last block aren't the same, we need to insert all of the\n    // nodes after the insertion node's first block at the index.\n    if (firstBlock !== lastBlock) {\n      const lonelyParent = insertionNode.getFurthest(\n        firstBlock.key,\n        p => p.nodes.size === 1\n      )\n      const lonelyChild = lonelyParent || firstBlock\n\n      const startIndex = parent.nodes.indexOf(startBlock)\n      const excludingLonelyChild = insertionNode.removeNode(lonelyChild.key)\n\n      excludingLonelyChild.nodes.forEach((node, i) => {\n        const newIndex = startIndex + i + 1\n        editor.insertNodeByKey(parent.key, newIndex, node)\n      })\n    }\n\n    // Check if we need to split the node.\n    if (start.offset !== 0) {\n      editor.splitDescendantsByKey(startChild.key, start.key, start.offset)\n    }\n\n    // Update our variables with the new value.\n    document = editor.value.document\n    startText = document.getDescendant(start.key)\n    startBlock = document.getClosestBlock(start.key)\n    startChild = startBlock.getFurthestChild(startText.key)\n\n    // If the first and last block aren't the same, we need to move any of the\n    // starting block's children after the split into the last block of the\n    // fragment, which has already been inserted.\n    if (firstBlock !== lastBlock) {\n      const nextChild = isAtStart\n        ? startChild\n        : startBlock.getNextSibling(startChild.key)\n      const nextNodes = nextChild\n        ? startBlock.nodes.skipUntil(n => n.key === nextChild.key)\n        : List()\n      const lastIndex = lastBlock.nodes.size\n\n      nextNodes.forEach((node, i) => {\n        const newIndex = lastIndex + i\n        editor.moveNodeByKey(node.key, lastBlock.key, newIndex)\n      })\n    }\n\n    // If the starting block is empty, we replace it entirely with the first block\n    // of the fragment, since this leads to a more expected behavior for the user.\n    if (\n      !editor.isVoid(startBlock) &&\n      startBlock.text === '' &&\n      !startBlock.findDescendant(n => editor.isVoid(n))\n    ) {\n      editor.removeNodeByKey(startBlock.key)\n      editor.insertNodeByKey(parent.key, index, firstBlock)\n    } else {\n      // Otherwise, we maintain the starting block, and insert all of the first\n      // block's inline nodes into it at the split point.\n      const inlineChild = startBlock.getFurthestChild(startText.key)\n      const inlineIndex = startBlock.nodes.indexOf(inlineChild)\n\n      firstBlock.nodes.forEach((inline, i) => {\n        const o = start.offset === 0 ? 0 : 1\n        const newIndex = inlineIndex + i + o\n        editor.insertNodeByKey(startBlock.key, newIndex, inline)\n      })\n    }\n  })\n}\n\n/**\n * Get the deepest single child block inside `fragment` whose reversed block\n * ancestors match the reversed block ancestors of the `document` starting at\n * the `documentKey`.\n *\n * @param {Document} document\n * @param {string} documentKey\n * @param {Document} fragment\n * @return {Node}\n */\n\nconst findInsertionNode = (fragment, document, documentKey) => {\n  // Find the deepest block in a doc with no siblings.\n  const deepestSingleBlock = doc => {\n    let result = doc\n\n    while (result.nodes.size === 1 && result.nodes.first().object === 'block') {\n      result = result.nodes.first()\n    }\n\n    return result === doc ? null : result\n  }\n\n  // Return whether every block in the `fragmentAncestors` list has the\n  // same type as the block in `documentAncestors` with the same index.\n  const ancestorTypesMatch = (fragmentAncestors, documentAncestors) => {\n    return (\n      documentAncestors.size >= fragmentAncestors.size &&\n      fragmentAncestors.every((fragmentNode, i) => {\n        return documentAncestors.get(i).type === fragmentNode.type\n      })\n    )\n  }\n\n  // Given two reverse lists of ancestors, check if all fragment ancestor types\n  // match the doc ancestors at some position.\n  const matchingFragmentAncestor = (documentAncestors, fragmentAncestors) => {\n    const depthDifference = documentAncestors.size - fragmentAncestors.size\n\n    // There is nothing to align if the fragment is deeper than the document.\n    if (depthDifference < 0) {\n      return fragment\n    }\n\n    for (let fragIdx = 0; fragIdx < fragmentAncestors.size; fragIdx++) {\n      // The docIdx loop relaxes our check in that we can still match if there\n      // are node type differences leaf-side.\n      // This is important for example if our fragment inserts multiple siblings\n      // or inserts another type while the tree structure remains the same.\n      for (let docIdx = 0; docIdx <= depthDifference; docIdx++) {\n        if (\n          ancestorTypesMatch(\n            fragmentAncestors.slice(fragIdx),\n            documentAncestors.slice(docIdx)\n          )\n        ) {\n          return fragmentAncestors.get(fragIdx)\n        }\n      }\n    }\n    return fragment\n  }\n\n  // Get the type definitions for all ancestors up from node with key `key`,\n  // except the document object.\n  const getAncestorBlocks = (doc, key) => {\n    return doc\n      .getAncestors(key)\n      .slice(1)\n      .push(doc.getNode(key))\n      .reverse()\n  }\n\n  const fragmentStartBlock = deepestSingleBlock(fragment)\n\n  if (!fragmentStartBlock) {\n    return fragment\n  }\n\n  const documentAncestors = getAncestorBlocks(document, documentKey)\n  const fragmentAncestors = getAncestorBlocks(fragment, fragmentStartBlock.key)\n\n  return matchingFragmentAncestor(documentAncestors, fragmentAncestors)\n}\n\n/**\n * Insert an `inline` node at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Inline|String|Object} inline\n */\n\nCommands.insertInlineAtRange = (editor, range, inline) => {\n  inline = Inline.create(inline)\n\n  editor.withoutNormalizing(() => {\n    range = deleteExpandedAtRange(editor, range)\n\n    const { value } = editor\n    const { document } = value\n    const { start } = range\n    const parent = document.getParent(start.path)\n    const startText = document.assertDescendant(start.path)\n    const index = parent.nodes.indexOf(startText)\n\n    if (editor.isVoid(parent)) {\n      return\n    }\n\n    editor.splitNodeByPath(start.path, start.offset)\n    editor.insertNodeByKey(parent.key, index + 1, inline)\n  })\n}\n\n/**\n * Insert `text` at a `range`, with optional `marks`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nCommands.insertTextAtRange = (editor, range, text, marks) => {\n  editor.withoutNormalizing(() => {\n    range = deleteExpandedAtRange(editor, range)\n\n    const { value } = editor\n    const { document } = value\n    const { start } = range\n    const offset = start.offset\n    const parent = document.getParent(start.path)\n\n    if (editor.isVoid(parent)) {\n      return\n    }\n\n    editor.insertTextByPath(start.path, offset, text, marks)\n  })\n}\n\n/**\n * Remove an existing `mark` to the characters at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Mark|String} mark (optional)\n */\n\nCommands.removeMarkAtRange = (editor, range, mark) => {\n  if (range.isCollapsed) return\n\n  const { value } = editor\n  const { document } = value\n  const texts = document.getTextsAtRange(range)\n  const { start, end } = range\n\n  editor.withoutNormalizing(() => {\n    texts.forEach(node => {\n      const { key } = node\n      let index = 0\n      let length = node.text.length\n\n      if (key === start.key) index = start.offset\n      if (key === end.key) length = end.offset\n      if (key === start.key && key === end.key)\n        length = end.offset - start.offset\n\n      editor.removeMarkByKey(key, index, length, mark)\n    })\n  })\n}\n\n/**\n * Set the `properties` of block nodes in a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Object|String} properties\n */\n\nCommands.setBlocksAtRange = (editor, range, properties) => {\n  const { value } = editor\n  const { document } = value\n  const blocks = document.getLeafBlocksAtRange(range)\n\n  const { start, end, isCollapsed } = range\n  const isStartVoid = document.hasVoidParent(start.path, editor)\n  const startBlock = document.getClosestBlock(start.path)\n  const endBlock = document.getClosestBlock(end.key)\n\n  // Check if we have a \"hanging\" selection case where the even though the\n  // selection extends into the start of the end node, we actually want to\n  // ignore that for UX reasons.\n  const isHanging =\n    isCollapsed === false &&\n    start.offset === 0 &&\n    end.offset === 0 &&\n    isStartVoid === false &&\n    start.key === startBlock.getFirstText().key &&\n    end.key === endBlock.getFirstText().key\n\n  // If it's a hanging selection, ignore the last block.\n  const sets = isHanging ? blocks.slice(0, -1) : blocks\n\n  editor.withoutNormalizing(() => {\n    sets.forEach(block => {\n      editor.setNodeByKey(block.key, properties)\n    })\n  })\n}\n\n/**\n * Set the `properties` of inline nodes in a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Object|String} properties\n */\n\nCommands.setInlinesAtRange = (editor, range, properties) => {\n  const { value } = editor\n  const { document } = value\n  const inlines = document.getLeafInlinesAtRange(range)\n\n  editor.withoutNormalizing(() => {\n    inlines.forEach(inline => {\n      editor.setNodeByKey(inline.key, properties)\n    })\n  })\n}\n\n/**\n * Split the block nodes at a `range`, to optional `height`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Number} height (optional)\n */\n\nCommands.splitBlockAtRange = (editor, range, height = 1) => {\n  range = deleteExpandedAtRange(editor, range)\n\n  const { start, end } = range\n  let { value } = editor\n  let { document } = value\n  let node = document.assertDescendant(start.path)\n  let parent = document.getClosestBlock(node.key)\n  let h = 0\n\n  while (parent && parent.object === 'block' && h < height) {\n    node = parent\n    parent = document.getClosestBlock(parent.key)\n    h++\n  }\n\n  editor.withoutNormalizing(() => {\n    editor.splitDescendantsByKey(node.key, start.path, start.offset)\n\n    value = editor.value\n    document = value.document\n\n    if (range.isExpanded) {\n      if (range.isBackward) range = range.flip()\n      const nextBlock = document.getNextBlock(node.key)\n      range = range.moveAnchorToStartOfNode(nextBlock)\n      range = range.setFocus(range.focus.setPath(null))\n\n      if (start.path.equals(end.path)) {\n        range = range.moveFocusTo(range.anchor.key, end.offset - start.offset)\n      }\n\n      range = document.resolveRange(range)\n      editor.deleteAtRange(range)\n    }\n  })\n}\n\n/**\n * Split the inline nodes at a `range`, to optional `height`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Number} height (optional)\n */\n\nCommands.splitInlineAtRange = (editor, range, height = Infinity) => {\n  range = deleteExpandedAtRange(editor, range)\n\n  const { start } = range\n  const { value } = editor\n  const { document } = value\n  let node = document.assertDescendant(start.path)\n  let parent = document.getClosestInline(node.key)\n  let h = 0\n\n  while (parent && parent.object === 'inline' && h < height) {\n    node = parent\n    parent = document.getClosestInline(parent.key)\n    h++\n  }\n\n  editor.splitDescendantsByKey(node.key, start.path, start.offset)\n}\n\n/**\n * Add or remove a `mark` from the characters at `range`, depending on whether\n * it's already there.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Mixed} mark\n */\n\nCommands.toggleMarkAtRange = (editor, range, mark) => {\n  if (range.isCollapsed) return\n\n  mark = Mark.create(mark)\n\n  const { value } = editor\n  const { document } = value\n  const marks = document.getActiveMarksAtRange(range)\n  const exists = marks.some(m => m.equals(mark))\n\n  if (exists) {\n    editor.removeMarkAtRange(range, mark)\n  } else {\n    editor.addMarkAtRange(range, mark)\n  }\n}\n\n/**\n * Unwrap all of the block nodes in a `range` from a block with `properties`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {String|Object} properties\n */\n\nCommands.unwrapBlockAtRange = (editor, range, properties) => {\n  properties = Node.createProperties(properties)\n\n  const { value } = editor\n  let { document } = value\n  const blocks = document.getLeafBlocksAtRange(range)\n  const wrappers = blocks\n    .map(block => {\n      return document.getClosest(block.key, parent => {\n        if (parent.object !== 'block') return false\n        if (properties.type != null && parent.type !== properties.type)\n          return false\n        if (properties.data != null && !parent.data.isSuperset(properties.data))\n          return false\n        return true\n      })\n    })\n    .filter(exists => exists)\n    .toOrderedSet()\n    .toList()\n\n  editor.withoutNormalizing(() => {\n    wrappers.forEach(block => {\n      const first = block.nodes.first()\n      const last = block.nodes.last()\n      const parent = editor.value.document.getParent(block.key)\n      const index = parent.nodes.indexOf(block)\n\n      const children = block.nodes.filter(child => {\n        return blocks.some(b => child === b || child.hasDescendant(b.key))\n      })\n\n      const firstMatch = children.first()\n      const lastMatch = children.last()\n\n      if (first === firstMatch && last === lastMatch) {\n        block.nodes.forEach((child, i) => {\n          editor.moveNodeByKey(child.key, parent.key, index + i)\n        })\n\n        editor.removeNodeByKey(block.key)\n      } else if (last === lastMatch) {\n        block.nodes.skipUntil(n => n === firstMatch).forEach((child, i) => {\n          editor.moveNodeByKey(child.key, parent.key, index + 1 + i)\n        })\n      } else if (first === firstMatch) {\n        block.nodes\n          .takeUntil(n => n === lastMatch)\n          .push(lastMatch)\n          .forEach((child, i) => {\n            editor.moveNodeByKey(child.key, parent.key, index + i)\n          })\n      } else {\n        const firstText = firstMatch.getFirstText()\n\n        editor.splitDescendantsByKey(block.key, firstText.key, 0)\n\n        document = editor.value.document\n\n        children.forEach((child, i) => {\n          if (i === 0) {\n            const extra = child\n            child = document.getNextBlock(child.key)\n            editor.removeNodeByKey(extra.key)\n          }\n\n          editor.moveNodeByKey(child.key, parent.key, index + 1 + i)\n        })\n      }\n    })\n  })\n}\n\n/**\n * Unwrap the inline nodes in a `range` from an inline with `properties`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {String|Object} properties\n */\n\nCommands.unwrapInlineAtRange = (editor, range, properties) => {\n  properties = Node.createProperties(properties)\n\n  const { value } = editor\n  const { document } = value\n  const texts = document.getTextsAtRange(range)\n  const inlines = texts\n    .map(text => {\n      return document.getClosest(text.key, parent => {\n        if (parent.object !== 'inline') return false\n        if (properties.type != null && parent.type !== properties.type)\n          return false\n        if (properties.data != null && !parent.data.isSuperset(properties.data))\n          return false\n        return true\n      })\n    })\n    .filter(exists => exists)\n    .toOrderedSet()\n    .toList()\n\n  editor.withoutNormalizing(() => {\n    inlines.forEach(inline => {\n      const parent = editor.value.document.getParent(inline.key)\n      const index = parent.nodes.indexOf(inline)\n\n      inline.nodes.forEach((child, i) => {\n        editor.moveNodeByKey(child.key, parent.key, index + i)\n      })\n\n      editor.removeNodeByKey(inline.key)\n    })\n  })\n}\n\n/**\n * Wrap all of the blocks in a `range` in a new `block`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Block|Object|String} block\n */\n\nCommands.wrapBlockAtRange = (editor, range, block) => {\n  block = Block.create(block)\n  block = block.set('nodes', block.nodes.clear())\n\n  const { value } = editor\n  const { document } = value\n\n  const blocks = document.getLeafBlocksAtRange(range)\n  const firstblock = blocks.first()\n  const lastblock = blocks.last()\n  let parent, siblings, index\n\n  // If there is only one block in the selection then we know the parent and\n  // siblings.\n  if (blocks.length === 1) {\n    parent = document.getParent(firstblock.key)\n    siblings = blocks\n  } else {\n    // Determine closest shared parent to all blocks in selection.\n    parent = document.getClosest(firstblock.key, p1 => {\n      return !!document.getClosest(lastblock.key, p2 => p1 === p2)\n    })\n  }\n\n  // If no shared parent could be found then the parent is the document.\n  if (parent == null) parent = document\n\n  // Create a list of direct children siblings of parent that fall in the\n  // selection.\n  if (siblings == null) {\n    const indexes = parent.nodes.reduce((ind, node, i) => {\n      if (node === firstblock || node.hasDescendant(firstblock.key)) ind[0] = i\n      if (node === lastblock || node.hasDescendant(lastblock.key)) ind[1] = i\n      return ind\n    }, [])\n\n    index = indexes[0]\n    siblings = parent.nodes.slice(indexes[0], indexes[1] + 1)\n  }\n\n  // Get the index to place the new wrapped node at.\n  if (index == null) {\n    index = parent.nodes.indexOf(siblings.first())\n  }\n\n  editor.withoutNormalizing(() => {\n    // Inject the new block node into the parent.\n    editor.insertNodeByKey(parent.key, index, block)\n\n    // Move the sibling nodes into the new block node.\n    siblings.forEach((node, i) => {\n      editor.moveNodeByKey(node.key, block.key, i)\n    })\n  })\n}\n\n/**\n * Wrap the text and inlines in a `range` in a new `inline`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Inline|Object|String} inline\n */\n\nCommands.wrapInlineAtRange = (editor, range, inline) => {\n  const { value } = editor\n  let { document } = value\n  const { start, end } = range\n\n  if (range.isCollapsed) {\n    // Wrapping an inline void\n    const inlineParent = document.getClosestInline(start.path)\n\n    if (!inlineParent) {\n      return\n    }\n\n    if (!editor.isVoid(inlineParent)) {\n      return\n    }\n\n    return editor.wrapInlineByKey(inlineParent.key, inline)\n  }\n\n  inline = Inline.create(inline)\n  inline = inline.set('nodes', inline.nodes.clear())\n\n  const blocks = document.getLeafBlocksAtRange(range)\n  let startBlock = document.getClosestBlock(start.path)\n  let endBlock = document.getClosestBlock(end.path)\n  const startInline = document.getClosestInline(start.path)\n  const endInline = document.getClosestInline(end.path)\n  let startChild = startBlock.getFurthestChild(start.key)\n  let endChild = endBlock.getFurthestChild(end.key)\n\n  editor.withoutNormalizing(() => {\n    if (!startInline || startInline !== endInline) {\n      editor.splitDescendantsByKey(endChild.key, end.key, end.offset)\n      editor.splitDescendantsByKey(startChild.key, start.key, start.offset)\n    }\n\n    document = editor.value.document\n    startBlock = document.getDescendant(startBlock.key)\n    endBlock = document.getDescendant(endBlock.key)\n    startChild = startBlock.getFurthestChild(start.key)\n    endChild = endBlock.getFurthestChild(end.key)\n    const startIndex = startBlock.nodes.indexOf(startChild)\n    const endIndex = endBlock.nodes.indexOf(endChild)\n\n    if (startInline && startInline === endInline) {\n      const texts = startBlock.getTextsAtRange(range).map(text => {\n        if (start.key === text.key && end.key === text.key) {\n          return text\n            .splitText(start.offset)[1]\n            .splitText(end.offset - start.offset)[0]\n            .regenerateKey()\n        } else if (start.key === text.key) {\n          return text.splitText(start.offset)[1].regenerateKey()\n        } else if (end.key === text.key) {\n          return text.splitText(end.offset)[0].regenerateKey()\n        } else {\n          return text.regenerateKey()\n        }\n      })\n\n      inline = inline.set('nodes', texts)\n      editor.insertInlineAtRange(range, inline)\n    } else if (startBlock === endBlock) {\n      document = editor.value.document\n      startBlock = document.getClosestBlock(start.key)\n      startChild = startBlock.getFurthestChild(start.key)\n\n      const startInner = document.getNextSibling(startChild.key)\n      const startInnerIndex = startBlock.nodes.indexOf(startInner)\n      const endInner =\n        start.key === end.key\n          ? startInner\n          : startBlock.getFurthestChild(end.key)\n      const inlines = startBlock.nodes\n        .skipUntil(n => n === startInner)\n        .takeUntil(n => n === endInner)\n        .push(endInner)\n\n      const node = inline.regenerateKey()\n\n      editor.insertNodeByKey(startBlock.key, startInnerIndex, node)\n\n      inlines.forEach((child, i) => {\n        editor.moveNodeByKey(child.key, node.key, i)\n      })\n    } else {\n      const startInlines = startBlock.nodes.slice(startIndex + 1)\n      const endInlines = endBlock.nodes.slice(0, endIndex + 1)\n      const startNode = inline.regenerateKey()\n      const endNode = inline.regenerateKey()\n\n      editor.insertNodeByKey(startBlock.key, startIndex + 1, startNode)\n      editor.insertNodeByKey(endBlock.key, endIndex, endNode)\n\n      startInlines.forEach((child, i) => {\n        editor.moveNodeByKey(child.key, startNode.key, i)\n      })\n\n      endInlines.forEach((child, i) => {\n        editor.moveNodeByKey(child.key, endNode.key, i)\n      })\n\n      blocks.slice(1, -1).forEach(block => {\n        const node = inline.regenerateKey()\n        editor.insertNodeByKey(block.key, 0, node)\n\n        block.nodes.forEach((child, i) => {\n          editor.moveNodeByKey(child.key, node.key, i)\n        })\n      })\n    }\n  })\n}\n\n/**\n * Wrap the text in a `range` in a prefix/suffix.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {String} prefix\n * @param {String} suffix (optional)\n */\n\nCommands.wrapTextAtRange = (editor, range, prefix, suffix = prefix) => {\n  const { start, end } = range\n  const startRange = range.moveToStart()\n  let endRange = range.moveToEnd()\n\n  if (start.path.equals(end.path)) {\n    endRange = endRange.moveForward(prefix.length)\n  }\n\n  editor.withoutNormalizing(() => {\n    editor.insertTextAtRange(startRange, prefix)\n    editor.insertTextAtRange(endRange, suffix)\n  })\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Commands\n","import pick from 'lodash/pick'\nimport Block from '../models/block'\nimport Inline from '../models/inline'\nimport Mark from '../models/mark'\nimport Node from '../models/node'\nimport PathUtils from '../utils/path-utils'\n\n/**\n * Commands.\n *\n * @type {Object}\n */\n\nconst Commands = {}\n\n/**\n * Add mark to text at `offset` and `length` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mixed} mark\n */\n\nCommands.addMarkByPath = (editor, path, offset, length, mark) => {\n  mark = Mark.create(mark)\n  editor.addMarksByPath(path, offset, length, [mark])\n}\n\nCommands.addMarksByPath = (editor, path, offset, length, marks) => {\n  marks = Mark.createSet(marks)\n\n  if (!marks.size) {\n    return\n  }\n\n  const { value } = editor\n  const { document } = value\n  const node = document.assertNode(path)\n\n  editor.withoutNormalizing(() => {\n    // If it ends before the end of the node, we'll need to split to create a new\n    // text with different marks.\n    if (offset + length < node.text.length) {\n      editor.splitNodeByPath(path, offset + length)\n    }\n\n    // Same thing if it starts after the start. But in that case, we need to\n    // update our path and offset to point to the new start.\n    if (offset > 0) {\n      editor.splitNodeByPath(path, offset)\n      path = PathUtils.increment(path)\n      offset = 0\n    }\n\n    marks.forEach(mark => {\n      editor.applyOperation({\n        type: 'add_mark',\n        path,\n        mark: Mark.create(mark),\n      })\n    })\n  })\n}\n\n/**\n * Sets specific set of marks on the path\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Array<Object|Mark>} marks\n */\n\nCommands.replaceMarksByPath = (editor, path, offset, length, marks) => {\n  const marksSet = Mark.createSet(marks)\n\n  const { value } = editor\n  const { document } = value\n  const node = document.assertNode(path)\n\n  if (node.marks.equals(marksSet)) {\n    return\n  }\n\n  editor.withoutNormalizing(() => {\n    // If it ends before the end of the node, we'll need to split to create a new\n    // text with different marks.\n    if (offset + length < node.text.length) {\n      editor.splitNodeByPath(path, offset + length)\n    }\n\n    // Same thing if it starts after the start. But in that case, we need to\n    // update our path and offset to point to the new start.\n    if (offset > 0) {\n      editor.splitNodeByPath(path, offset)\n      path = PathUtils.increment(path)\n      offset = 0\n    }\n\n    const marksToApply = marksSet.subtract(node.marks)\n    const marksToRemove = node.marks.subtract(marksSet)\n\n    marksToRemove.forEach(mark => {\n      editor.applyOperation({\n        type: 'remove_mark',\n        path,\n        mark: Mark.create(mark),\n      })\n    })\n\n    marksToApply.forEach(mark => {\n      editor.applyOperation({\n        type: 'add_mark',\n        path,\n        mark: Mark.create(mark),\n      })\n    })\n  })\n}\n\n/**\n * Insert a `fragment` at `index` in a node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} index\n * @param {Fragment} fragment\n */\n\nCommands.insertFragmentByPath = (editor, path, index, fragment) => {\n  fragment.nodes.forEach((node, i) => {\n    editor.insertNodeByPath(path, index + i, node)\n  })\n}\n\n/**\n * Insert a `node` at `index` in a node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} index\n * @param {Node} node\n */\n\nCommands.insertNodeByPath = (editor, path, index, node) => {\n  editor.applyOperation({\n    type: 'insert_node',\n    path: path.concat(index),\n    node,\n  })\n}\n\n/**\n * Insert `text` at `offset` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nCommands.insertTextByPath = (editor, path, offset, text, marks) => {\n  const { value } = editor\n  const { annotations, document } = value\n  document.assertNode(path)\n\n  editor.withoutNormalizing(() => {\n    for (const annotation of annotations.values()) {\n      const { start, end } = annotation\n      const isAtomic = editor.isAtomic(annotation)\n\n      if (!isAtomic) {\n        continue\n      }\n\n      if (!start.path.equals(path)) {\n        continue\n      }\n\n      if (\n        start.offset < offset &&\n        (!end.path.equals(path) || end.offset > offset)\n      ) {\n        editor.removeAnnotation(annotation)\n      }\n    }\n\n    editor.applyOperation({\n      type: 'insert_text',\n      path,\n      offset,\n      text,\n    })\n\n    if (marks) {\n      editor.replaceMarksByPath(path, offset, text.length, marks)\n    }\n  })\n}\n\n/**\n * Merge a node by `path` with the previous node.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\nCommands.mergeNodeByPath = (editor, path) => {\n  const { value } = editor\n  const { document } = value\n  const original = document.getDescendant(path)\n  const previous = document.getPreviousSibling(path)\n\n  if (!previous) {\n    throw new Error(\n      `Unable to merge node with path \"${path}\", because it has no previous sibling.`\n    )\n  }\n\n  const position =\n    previous.object === 'text' ? previous.text.length : previous.nodes.size\n\n  editor.applyOperation({\n    type: 'merge_node',\n    path,\n    position,\n    // for undos to succeed we only need the type and data because\n    // these are the only properties that get changed in the merge operation\n    properties: {\n      type: original.type,\n      data: original.data,\n    },\n    target: null,\n  })\n}\n\n/**\n * Move a node by `path` to a new parent by `newParentPath` and `newIndex`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {String} newParentPath\n * @param {Number} newIndex\n */\n\nCommands.moveNodeByPath = (editor, path, newParentPath, newIndex) => {\n  // If the operation path and newParentPath are the same,\n  // this should be considered a NOOP\n  if (PathUtils.isEqual(path, newParentPath)) {\n    return editor\n  }\n\n  const newPath = newParentPath.concat(newIndex)\n\n  if (PathUtils.isEqual(path, newPath)) {\n    return editor\n  }\n\n  editor.applyOperation({\n    type: 'move_node',\n    path,\n    newPath,\n  })\n}\n\n/**\n * Remove mark from text at `offset` and `length` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n */\n\nCommands.removeMarkByPath = (editor, path, offset, length, mark) => {\n  mark = Mark.create(mark)\n  editor.removeMarksByPath(path, offset, length, [mark])\n}\n\nCommands.removeMarksByPath = (editor, path, offset, length, marks) => {\n  marks = Mark.createSet(marks)\n\n  if (!marks.size) {\n    return\n  }\n\n  const { value } = editor\n  const { document } = value\n  const node = document.assertNode(path)\n\n  if (marks.intersect(node.marks).isEmpty()) {\n    return\n  }\n\n  editor.withoutNormalizing(() => {\n    // If it ends before the end of the node, we'll need to split to create a new\n    // text with different marks.\n    if (offset + length < node.text.length) {\n      editor.splitNodeByPath(path, offset + length)\n    }\n\n    // Same thing if it starts after the start. But in that case, we need to\n    // update our path and offset to point to the new start.\n    if (offset > 0) {\n      editor.splitNodeByPath(path, offset)\n      path = PathUtils.increment(path)\n      offset = 0\n    }\n\n    marks.forEach(mark => {\n      editor.applyOperation({\n        type: 'remove_mark',\n        path,\n        offset,\n        length,\n        mark,\n      })\n    })\n  })\n}\n\n/**\n * Remove all `marks` from node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\nCommands.removeAllMarksByPath = (editor, path) => {\n  const { state } = editor\n  const { document } = state\n  const node = document.assertNode(path)\n\n  editor.withoutNormalizing(() => {\n    if (node.object === 'text') {\n      editor.removeMarksByPath(path, 0, node.text.length, node.marks)\n      return\n    }\n\n    for (const [n, p] of node.texts()) {\n      const pth = path.concat(p)\n      editor.removeMarksByPath(pth, 0, n.text.length, n.marks)\n    }\n  })\n}\n\n/**\n * Remove a node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\nCommands.removeNodeByPath = (editor, path) => {\n  const { value } = editor\n  const { document } = value\n  const node = document.assertNode(path)\n\n  editor.applyOperation({\n    type: 'remove_node',\n    path,\n    node,\n  })\n}\n\n/**\n * Remove text at `offset` and `length` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n */\n\nCommands.removeTextByPath = (editor, path, offset, length) => {\n  const { value } = editor\n  const { document, annotations } = value\n  const node = document.assertNode(path)\n  const text = node.text.slice(offset, offset + length)\n\n  editor.withoutNormalizing(() => {\n    for (const annotation of annotations.values()) {\n      const { start, end } = annotation\n      const isAtomic = editor.isAtomic(annotation)\n\n      if (!isAtomic) {\n        continue\n      }\n\n      if (!start.path.equals(path)) {\n        continue\n      }\n\n      if (\n        start.offset < offset &&\n        (!end.path.equals(path) || end.offset > offset)\n      ) {\n        editor.removeAnnotation(annotation)\n      }\n    }\n\n    editor.applyOperation({\n      type: 'remove_text',\n      path,\n      offset,\n      text,\n    })\n  })\n}\n\n/**\n`* Replace a `node` with another `node`\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Object|Node} node\n */\n\nCommands.replaceNodeByPath = (editor, path, newNode) => {\n  newNode = Node.create(newNode)\n  const index = path.last()\n  const parentPath = PathUtils.lift(path)\n\n  editor.withoutNormalizing(() => {\n    editor.removeNodeByPath(path)\n    editor.insertNodeByPath(parentPath, index, newNode)\n  })\n}\n\n/**\n * Replace a `length` of text at `offset` with new `text` and optional `marks`.\n *\n * @param {Editor} editor\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {string} text\n * @param {Set<Mark>} marks (optional)\n */\n\nCommands.replaceTextByPath = (editor, path, offset, length, text, marks) => {\n  editor.withoutNormalizing(() => {\n    editor.removeTextByPath(path, offset, length)\n    editor.insertTextByPath(path, offset, text, marks)\n  })\n}\n\n/**\n * Set `newProperties` on mark on text at `offset` and `length` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Object|Mark} properties\n * @param {Object} newProperties\n */\n\nCommands.setMarkByPath = (\n  editor,\n  path,\n  offset,\n  length,\n  properties,\n  newProperties\n) => {\n  properties = Mark.create(properties)\n  newProperties = Mark.createProperties(newProperties)\n\n  const { value } = editor\n  const { document } = value\n  const node = document.assertNode(path)\n\n  editor.withoutNormalizing(() => {\n    // If it ends before the end of the node, we'll need to split to create a new\n    // text with different marks.\n    if (offset + length < node.text.length) {\n      editor.splitNodeByPath(path, offset + length)\n    }\n\n    // Same thing if it starts after the start. But in that case, we need to\n    // update our path and offset to point to the new start.\n    if (offset > 0) {\n      editor.splitNodeByPath(path, offset)\n      path = PathUtils.increment(path)\n      offset = 0\n    }\n\n    editor.applyOperation({\n      type: 'set_mark',\n      path,\n      properties,\n      newProperties,\n    })\n  })\n}\n\n/**\n * Set `properties` on a node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Object|String} newProperties\n */\n\nCommands.setNodeByPath = (editor, path, newProperties) => {\n  const { value } = editor\n  const { document } = value\n  const node = document.assertNode(path)\n  newProperties = Node.createProperties(newProperties)\n  const prevProperties = pick(node, Object.keys(newProperties))\n\n  editor.applyOperation({\n    type: 'set_node',\n    path,\n    properties: prevProperties,\n    newProperties,\n  })\n}\n\n/**\n * Insert `text` at `offset` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nCommands.setTextByPath = (editor, path, text, marks) => {\n  const { value } = editor\n  const { document } = value\n  const node = document.assertNode(path)\n  const end = node.text.length\n  editor.replaceTextByPath(path, 0, end, text, marks)\n}\n\n/**\n * Split a node by `path` at `position`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} position\n * @param {Object} options\n */\n\nCommands.splitNodeByPath = (editor, path, position, options = {}) => {\n  const { target = null } = options\n  const { value } = editor\n  const { document } = value\n  const node = document.getDescendant(path)\n\n  editor.applyOperation({\n    type: 'split_node',\n    path,\n    position,\n    target,\n    properties: {\n      type: node.type,\n      data: node.data,\n    },\n  })\n}\n\n/**\n * Split a node deeply down the tree by `path`, `textPath` and `textOffset`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Array} textPath\n * @param {Number} textOffset\n */\n\nCommands.splitDescendantsByPath = (editor, path, textPath, textOffset) => {\n  if (path.equals(textPath)) {\n    editor.splitNodeByPath(textPath, textOffset)\n    return\n  }\n\n  const { value } = editor\n  const { document } = value\n  let index = textOffset\n  let lastPath = textPath\n\n  editor.withoutNormalizing(() => {\n    editor.splitNodeByKey(textPath, textOffset)\n\n    for (const [, ancestorPath] of document.ancestors(textPath)) {\n      const target = index\n      index = lastPath.last() + 1\n      lastPath = ancestorPath\n      editor.splitNodeByPath(ancestorPath, index, { target })\n\n      if (ancestorPath.equals(path)) {\n        break\n      }\n    }\n  })\n}\n\n/**\n * Unwrap content from an inline parent with `properties`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Object|String} properties\n */\n\nCommands.unwrapInlineByPath = (editor, path, properties) => {\n  const { value } = editor\n  const { document, selection } = value\n  const node = document.assertNode(path)\n  const first = node.getFirstText()\n  const last = node.getLastText()\n  const range = selection.moveToRangeOfNode(first, last)\n  editor.unwrapInlineAtRange(range, properties)\n}\n\n/**\n * Unwrap content from a block parent with `properties`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Object|String} properties\n */\n\nCommands.unwrapBlockByPath = (editor, path, properties) => {\n  const { value } = editor\n  const { document, selection } = value\n  const node = document.assertNode(path)\n  const first = node.getFirstText()\n  const last = node.getLastText()\n  const range = selection.moveToRangeOfNode(first, last)\n  editor.unwrapBlockAtRange(range, properties)\n}\n\n/**\n * Unwrap a single node from its parent.\n *\n * If the node is surrounded with siblings, its parent will be\n * split. If the node is the only child, the parent is removed, and\n * simply replaced by the node itself.  Cannot unwrap a root node.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\nCommands.unwrapNodeByPath = (editor, path) => {\n  const { value } = editor\n  const { document } = value\n  document.assertNode(path)\n\n  const parentPath = PathUtils.lift(path)\n  const parent = document.assertNode(parentPath)\n  const index = path.last()\n  const parentIndex = parentPath.last()\n  const grandPath = PathUtils.lift(parentPath)\n  const isFirst = index === 0\n  const isLast = index === parent.nodes.size - 1\n\n  editor.withoutNormalizing(() => {\n    if (parent.nodes.size === 1) {\n      editor.moveNodeByPath(path, grandPath, parentIndex + 1)\n      editor.removeNodeByPath(parentPath)\n    } else if (isFirst) {\n      editor.moveNodeByPath(path, grandPath, parentIndex)\n    } else if (isLast) {\n      editor.moveNodeByPath(path, grandPath, parentIndex + 1)\n    } else {\n      let updatedPath = PathUtils.increment(path, 1, parentPath.size - 1)\n      updatedPath = updatedPath.set(updatedPath.size - 1, 0)\n      editor.splitNodeByPath(parentPath, index)\n      editor.moveNodeByPath(updatedPath, grandPath, parentIndex + 1)\n    }\n  })\n}\n\n/**\n * Unwrap all of the children of a node, by removing the node and replacing it\n * with the children in the tree.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\nCommands.unwrapChildrenByPath = (editor, path) => {\n  path = PathUtils.create(path)\n  const { value } = editor\n  const { document } = value\n  const node = document.assertNode(path)\n  const parentPath = PathUtils.lift(path)\n  const index = path.last()\n  const { nodes } = node\n\n  editor.withoutNormalizing(() => {\n    nodes.reverse().forEach((child, i) => {\n      const childIndex = nodes.size - i - 1\n      const childPath = path.push(childIndex)\n      editor.moveNodeByPath(childPath, parentPath, index + 1)\n    })\n\n    editor.removeNodeByPath(path)\n  })\n}\n\n/**\n * Wrap a node in a block with `properties`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Block|Object|String} block\n */\n\nCommands.wrapBlockByPath = (editor, path, block) => {\n  block = Block.create(block)\n  block = block.set('nodes', block.nodes.clear())\n  const parentPath = PathUtils.lift(path)\n  const index = path.last()\n  const newPath = PathUtils.increment(path)\n\n  editor.withoutNormalizing(() => {\n    editor.insertNodeByPath(parentPath, index, block)\n    editor.moveNodeByPath(newPath, path, 0)\n  })\n}\n\n/**\n * Wrap a node in an inline with `properties`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Block|Object|String} inline\n */\n\nCommands.wrapInlineByPath = (editor, path, inline) => {\n  inline = Inline.create(inline)\n  inline = inline.set('nodes', inline.nodes.clear())\n  const parentPath = PathUtils.lift(path)\n  const index = path.last()\n  const newPath = PathUtils.increment(path)\n\n  editor.withoutNormalizing(() => {\n    editor.insertNodeByPath(parentPath, index, inline)\n    editor.moveNodeByPath(newPath, path, 0)\n  })\n}\n\n/**\n * Wrap a node by `path` with `node`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Node|Object} node\n */\n\nCommands.wrapNodeByPath = (editor, path, node) => {\n  node = Node.create(node)\n\n  if (node.object === 'block') {\n    editor.wrapBlockByPath(path, node)\n  } else if (node.object === 'inline') {\n    editor.wrapInlineByPath(path, node)\n  }\n}\n\n/**\n * Mix in `*ByKey` variants.\n */\n\nconst COMMANDS = [\n  'addMark',\n  'insertFragment',\n  'insertNode',\n  'insertText',\n  'mergeNode',\n  'removeAllMarks',\n  'removeMark',\n  'removeNode',\n  'removeText',\n  'replaceMarks',\n  'replaceNode',\n  'replaceText',\n  'setMark',\n  'setNode',\n  'setText',\n  'splitNode',\n  'unwrapBlock',\n  'unwrapChildren',\n  'unwrapInline',\n  'unwrapNode',\n  'wrapBlock',\n  'wrapInline',\n  'wrapNode',\n]\n\nfor (const method of COMMANDS) {\n  Commands[`${method}ByKey`] = (editor, key, ...args) => {\n    const { value } = editor\n    const { document } = value\n    const path = document.assertPath(key)\n    editor[`${method}ByPath`](path, ...args)\n  }\n}\n\n// Moving nodes takes two keys, so it's slightly different.\nCommands.moveNodeByKey = (editor, key, newKey, ...args) => {\n  const { value } = editor\n  const { document } = value\n  const path = document.assertPath(key)\n  const newPath = document.assertPath(newKey)\n  editor.moveNodeByPath(path, newPath, ...args)\n}\n\n// Splitting descendants takes two keys, so it's slightly different.\nCommands.splitDescendantsByKey = (editor, key, textKey, ...args) => {\n  const { value } = editor\n  const { document } = value\n  const path = document.assertPath(key)\n  const textPath = document.assertPath(textKey)\n  editor.splitDescendantsByPath(path, textPath, ...args)\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Commands\n","import omit from 'lodash/omit'\nimport { List } from 'immutable'\n\n/**\n * Commands.\n *\n * @type {Object}\n */\n\nconst Commands = {}\n\n/**\n * Save an `operation` into the history.\n *\n * @param {Editor} editor\n * @param {Object} operation\n */\n\nCommands.save = (editor, operation) => {\n  const { operations, value } = editor\n  const { data } = value\n  let { save, merge } = editor.tmp\n  if (save === false || !isValidOperation(operation)) return\n\n  let undos = data.get('undos') || List()\n  const lastBatch = undos.last()\n  const lastOperation = lastBatch && lastBatch.last()\n\n  // If `merge` is non-commital, and this is not the first operation in a new\n  // editor, then merge, otherwise merge based on the last operation.\n  if (merge == null) {\n    if (operations.size !== 0) {\n      merge = true\n    } else {\n      merge = shouldMerge(operation, lastOperation)\n    }\n  }\n\n  // If the `merge` flag is true, add the operation to the last batch.\n  if (merge && lastBatch) {\n    const batch = lastBatch.push(operation)\n    undos = undos.pop()\n    undos = undos.push(batch)\n  } else {\n    // Otherwise, create a new batch with the operation.\n    const batch = List([operation])\n    undos = undos.push(batch)\n  }\n\n  // Constrain the history to 100 entries for memory's sake.\n  if (undos.size > 100) {\n    undos = undos.takeLast(100)\n  }\n\n  // Clear the redos and update the history.\n  editor.withoutSaving(() => {\n    const redos = List()\n    const newData = data.set('undos', undos).set('redos', redos)\n    editor.setData(newData)\n  })\n}\n\n/**\n * Redo to the next value in the history.\n *\n * @param {Editor} editor\n */\n\nCommands.redo = editor => {\n  const { value } = editor\n  const { data } = value\n  let redos = data.get('redos') || List()\n  let undos = data.get('undos') || List()\n  const batch = redos.last()\n  if (!batch) return\n\n  editor.withoutSaving(() => {\n    editor.withoutNormalizing(() => {\n      // Replay the batch of operations.\n      batch.forEach(op => {\n        const { type, newProperties } = op\n\n        // When the operation mutates the selection, omit its `isFocused` value to\n        // prevent the editor focus from changing during redoing.\n        if (type === 'set_selection') {\n          op = op.set('newProperties', omit(newProperties, 'isFocused'))\n        }\n\n        editor.applyOperation(op)\n      })\n\n      // Shift the next value into the undo stack.\n      redos = redos.pop()\n      undos = undos.push(batch)\n      const newData = data.set('undos', undos).set('redos', redos)\n      editor.setData(newData)\n    })\n  })\n}\n\n/**\n * Undo the previous operations in the history.\n *\n * @param {Editor} editor\n */\n\nCommands.undo = editor => {\n  const { value } = editor\n  const { data } = value\n  let redos = data.get('redos') || List()\n  let undos = data.get('undos') || List()\n  const batch = undos.last()\n  if (!batch) return\n\n  editor.withoutSaving(() => {\n    editor.withoutNormalizing(() => {\n      // Replay the inverse of the previous operations.\n      batch\n        .slice()\n        .reverse()\n        .map(op => op.invert())\n        .forEach(inverse => {\n          const { type, newProperties } = inverse\n\n          // When the operation mutates the selection, omit its `isFocused` value to\n          // prevent the editor focus from changing during undoing.\n          if (type === 'set_selection') {\n            inverse = inverse.set(\n              'newProperties',\n              omit(newProperties, 'isFocused')\n            )\n          }\n\n          editor.applyOperation(inverse)\n        })\n\n      // Shift the previous operations into the redo stack.\n      redos = redos.push(batch)\n      undos = undos.pop()\n      const newData = data.set('undos', undos).set('redos', redos)\n      editor.setData(newData)\n    })\n  })\n}\n\n/**\n * Apply a series of changes inside a synchronous `fn`, without merging any of\n * the new operations into previous save point in the history.\n *\n * @param {Editor} editor\n * @param {Function} fn\n */\n\nCommands.withoutMerging = (editor, fn) => {\n  const value = editor.tmp.merge\n  editor.tmp.merge = false\n  fn(editor)\n  editor.tmp.merge = value\n}\n\n/**\n * Apply a series of changes inside a synchronous `fn`, without saving any of\n * their operations into the history.\n *\n * @param {Editor} editor\n * @param {Function} fn\n */\n\nCommands.withoutSaving = (editor, fn) => {\n  const value = editor.tmp.save\n  editor.tmp.save = false\n  fn(editor)\n  editor.tmp.save = value\n}\n\n/**\n * Check whether to merge a new operation `o` into the previous operation `p`.\n *\n * @param {Object} o\n * @param {Object} p\n * @return {Boolean}\n */\n\nfunction shouldMerge(o, p) {\n  if (!p) return false\n\n  const merge =\n    (o.type === 'set_selection' && p.type === 'set_selection') ||\n    (o.type === 'insert_text' &&\n      p.type === 'insert_text' &&\n      o.offset === p.offset + p.text.length &&\n      o.path.equals(p.path)) ||\n    (o.type === 'remove_text' &&\n      p.type === 'remove_text' &&\n      o.offset + o.text.length === p.offset &&\n      o.path.equals(p.path))\n\n  return merge\n}\n\n/**\n * Check weather an operation needs to be saved to the history\n * @param {Object} o - operation\n * @returns {Boolean}\n */\n\nfunction isValidOperation(o) {\n  if (o.type === 'set_selection') {\n    const { isFocused, anchor, focus } = o.newProperties\n\n    // this is blur/focus operation, dont need to store it into the history\n    if (isFocused !== undefined && !anchor && !focus) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Commands\n","import { is } from 'immutable'\nimport pick from 'lodash/pick'\n\nimport Selection from '../models/selection'\nimport TextUtils from '../utils/text-utils'\n\nconst Commands = {}\n\nCommands.blur = editor => {\n  editor.select({ isFocused: false })\n}\n\nCommands.deselect = editor => {\n  const range = Selection.create()\n  editor.select(range)\n}\n\nCommands.focus = editor => {\n  editor.select({ isFocused: true })\n}\n\nCommands.flip = editor => {\n  editor.command(proxy, 'flip')\n}\n\nCommands.moveAnchorBackward = (editor, ...args) => {\n  editor.command(pointBackward, 'anchor', ...args)\n}\n\nCommands.moveAnchorWordBackward = (editor, ...args) => {\n  editor.command(pointWordBackward, 'anchor', ...args)\n}\n\nCommands.moveAnchorForward = (editor, ...args) => {\n  editor.command(pointForward, 'anchor', ...args)\n}\n\nCommands.moveAnchorWordForward = (editor, ...args) => {\n  editor.command(pointWordForward, 'anchor', ...args)\n}\n\nCommands.moveAnchorTo = (editor, ...args) => {\n  editor.command(proxy, 'moveAnchorTo', ...args)\n}\n\nCommands.moveAnchorToEndOfBlock = editor => {\n  editor.command(pointEdgeObject, 'anchor', 'end', 'block')\n}\n\nCommands.moveAnchorToEndOfInline = editor => {\n  editor.command(pointEdgeObject, 'anchor', 'end', 'inline')\n}\n\nCommands.moveAnchorToEndOfDocument = editor => {\n  editor.moveAnchorToEndOfNode(editor.value.document).moveToAnchor()\n}\n\nCommands.moveAnchorToEndOfNextBlock = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'next', 'block')\n}\n\nCommands.moveAnchorToEndOfNextInline = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'next', 'inline')\n}\n\nCommands.moveAnchorToEndOfNextText = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'next', 'text')\n}\n\nCommands.moveAnchorToEndOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveAnchorToEndOfNode', ...args)\n}\n\nCommands.moveAnchorToEndOfPreviousBlock = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'previous', 'block')\n}\n\nCommands.moveAnchorToEndOfPreviousInline = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'previous', 'inline')\n}\n\nCommands.moveAnchorToEndOfPreviousText = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'previous', 'text')\n}\n\nCommands.moveAnchorToEndOfText = editor => {\n  editor.command(pointEdgeObject, 'anchor', 'end', 'text')\n}\n\nCommands.moveAnchorToStartOfBlock = editor => {\n  editor.command(pointEdgeObject, 'anchor', 'start', 'block')\n}\n\nCommands.moveAnchorToStartOfDocument = editor => {\n  editor.moveAnchorToStartOfNode(editor.value.document).moveToAnchor()\n}\n\nCommands.moveAnchorToStartOfInline = editor => {\n  editor.command(pointEdgeObject, 'anchor', 'start', 'inline')\n}\n\nCommands.moveAnchorToStartOfNextBlock = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'next', 'block')\n}\n\nCommands.moveAnchorToStartOfNextInline = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'next', 'inline')\n}\n\nCommands.moveAnchorToStartOfNextText = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'next', 'text')\n}\n\nCommands.moveAnchorToStartOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveAnchorToStartOfNode', ...args)\n}\n\nCommands.moveAnchorToStartOfPreviousBlock = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'previous', 'block')\n}\n\nCommands.moveAnchorToStartOfPreviousInline = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'previous', 'inline')\n}\n\nCommands.moveAnchorToStartOfPreviousText = editor => {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'previous', 'text')\n}\n\nCommands.moveAnchorToStartOfText = editor => {\n  editor.command(pointEdgeObject, 'anchor', 'start', 'text')\n}\n\nCommands.moveBackward = (editor, chars = 1) => {\n  if (chars === 0) return\n\n  const { value } = editor\n  const { document, selection } = value\n  const { start } = selection\n  const startBlock = document.getClosestBlock(start.key)\n  const o = startBlock.getOffset(start.key)\n  const offset = o + start.offset\n  const { text } = startBlock\n  const charsOffset = TextUtils.getCharOffsetBackward(text, offset, chars)\n  editor.moveAnchorBackward(charsOffset).moveFocusBackward(charsOffset)\n}\n\nCommands.moveWordBackward = (editor, ...args) => {\n  editor.moveFocusWordBackward(...args).moveToFocus()\n}\n\nCommands.moveEndBackward = (editor, ...args) => {\n  editor.command(pointBackward, 'end', ...args)\n}\n\nCommands.moveEndWordBackward = (editor, ...args) => {\n  editor.command(pointWordBackward, 'end', ...args)\n}\n\nCommands.moveEndForward = (editor, ...args) => {\n  editor.command(pointForward, 'end', ...args)\n}\n\nCommands.moveEndWordForward = (editor, ...args) => {\n  editor.command(pointWordForward, 'end', ...args)\n}\n\nCommands.moveEndTo = (editor, ...args) => {\n  editor.command(proxy, 'moveEndTo', ...args)\n}\n\nCommands.moveEndToEndOfBlock = editor => {\n  editor.command(pointEdgeObject, 'end', 'end', 'block')\n}\n\nCommands.moveEndToEndOfDocument = editor => {\n  editor.moveEndToEndOfNode(editor.value.document).moveToEnd()\n}\n\nCommands.moveEndToEndOfInline = editor => {\n  editor.command(pointEdgeObject, 'end', 'end', 'inline')\n}\n\nCommands.moveEndToEndOfNextBlock = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'next', 'block')\n}\n\nCommands.moveEndToEndOfNextInline = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'next', 'inline')\n}\n\nCommands.moveEndToEndOfNextText = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'next', 'text')\n}\n\nCommands.moveEndToEndOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveEndToEndOfNode', ...args)\n}\n\nCommands.moveEndToEndOfPreviousBlock = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'previous', 'block')\n}\n\nCommands.moveEndToEndOfPreviousInline = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'previous', 'inline')\n}\n\nCommands.moveEndToEndOfPreviousText = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'previous', 'text')\n}\n\nCommands.moveEndToEndOfText = editor => {\n  editor.command(pointEdgeObject, 'end', 'end', 'text')\n}\n\nCommands.moveEndToStartOfBlock = editor => {\n  editor.command(pointEdgeObject, 'end', 'start', 'block')\n}\n\nCommands.moveEndToStartOfDocument = editor => {\n  editor.moveEndToStartOfNode(editor.value.document).moveToEnd()\n}\n\nCommands.moveEndToStartOfInline = editor => {\n  editor.command(pointEdgeObject, 'end', 'start', 'inline')\n}\n\nCommands.moveEndToStartOfNextBlock = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'next', 'block')\n}\n\nCommands.moveEndToStartOfNextInline = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'next', 'inline')\n}\n\nCommands.moveEndToStartOfNextText = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'next', 'text')\n}\n\nCommands.moveEndToStartOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveEndToStartOfNode', ...args)\n}\n\nCommands.moveEndToStartOfPreviousBlock = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'previous', 'block')\n}\n\nCommands.moveEndToStartOfPreviousInline = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'previous', 'inline')\n}\n\nCommands.moveEndToStartOfPreviousText = editor => {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'previous', 'text')\n}\n\nCommands.moveEndToStartOfText = editor => {\n  editor.command(pointEdgeObject, 'end', 'start', 'text')\n}\n\nCommands.moveFocusBackward = (editor, ...args) => {\n  editor.command(pointBackward, 'focus', ...args)\n}\n\nCommands.moveFocusWordBackward = (editor, ...args) => {\n  editor.command(pointWordBackward, 'focus', ...args)\n}\n\nCommands.moveFocusForward = (editor, ...args) => {\n  editor.command(pointForward, 'focus', ...args)\n}\n\nCommands.moveFocusWordForward = (editor, ...args) => {\n  editor.command(pointWordForward, 'focus', ...args)\n}\n\nCommands.moveFocusTo = (editor, ...args) => {\n  editor.command(proxy, 'moveFocusTo', ...args)\n}\n\nCommands.moveFocusToEndOfBlock = editor => {\n  editor.command(pointEdgeObject, 'focus', 'end', 'block')\n}\n\nCommands.moveFocusToEndOfDocument = editor => {\n  editor.moveFocusToEndOfNode(editor.value.document).moveToFocus()\n}\n\nCommands.moveFocusToEndOfInline = editor => {\n  editor.command(pointEdgeObject, 'focus', 'end', 'inline')\n}\n\nCommands.moveFocusToEndOfNextBlock = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'next', 'block')\n}\n\nCommands.moveFocusToEndOfNextInline = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'next', 'inline')\n}\n\nCommands.moveFocusToEndOfNextText = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'next', 'text')\n}\n\nCommands.moveFocusToEndOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveFocusToEndOfNode', ...args)\n}\n\nCommands.moveFocusToEndOfPreviousBlock = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'previous', 'block')\n}\n\nCommands.moveFocusToEndOfPreviousInline = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'previous', 'inline')\n}\n\nCommands.moveFocusToEndOfPreviousText = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'previous', 'text')\n}\n\nCommands.moveFocusToEndOfText = editor => {\n  editor.command(pointEdgeObject, 'focus', 'end', 'text')\n}\n\nCommands.moveFocusToStartOfBlock = editor => {\n  editor.command(pointEdgeObject, 'focus', 'start', 'block')\n}\n\nCommands.moveFocusToStartOfDocument = editor => {\n  editor.moveFocusToStartOfNode(editor.value.document).moveToFocus()\n}\n\nCommands.moveFocusToStartOfInline = editor => {\n  editor.command(pointEdgeObject, 'focus', 'start', 'inline')\n}\n\nCommands.moveFocusToStartOfNextBlock = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'next', 'block')\n}\n\nCommands.moveFocusToStartOfNextInline = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'next', 'inline')\n}\n\nCommands.moveFocusToStartOfNextText = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'next', 'text')\n}\n\nCommands.moveFocusToStartOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveFocusToStartOfNode', ...args)\n}\n\nCommands.moveFocusToStartOfPreviousBlock = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'previous', 'block')\n}\n\nCommands.moveFocusToStartOfPreviousInline = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'previous', 'inline')\n}\n\nCommands.moveFocusToStartOfPreviousText = editor => {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'previous', 'text')\n}\n\nCommands.moveFocusToStartOfText = editor => {\n  editor.command(pointEdgeObject, 'focus', 'start', 'text')\n}\n\nCommands.moveForward = (editor, chars = 1) => {\n  if (chars === 0) return\n\n  const { value } = editor\n  const { document, selection } = value\n  const { start } = selection\n  const startBlock = document.getClosestBlock(start.path)\n  const o = startBlock.getOffset(start.key)\n  const offset = o + start.offset\n  const { text } = startBlock\n  const charsOffset = TextUtils.getCharOffsetForward(text, offset, chars)\n  editor.moveAnchorForward(charsOffset).moveFocusForward(charsOffset)\n}\n\nCommands.moveWordForward = (editor, ...args) => {\n  editor.moveFocusWordForward(...args).moveToFocus(...args)\n}\n\nCommands.moveStartBackward = (editor, ...args) => {\n  editor.command(pointBackward, 'start', ...args)\n}\n\nCommands.moveStartWordBackward = (editor, ...args) => {\n  editor.command(pointWordBackward, 'start', ...args)\n}\n\nCommands.moveStartForward = (editor, ...args) => {\n  editor.command(pointForward, 'start', ...args)\n}\n\nCommands.moveStartWordForward = (editor, ...args) => {\n  editor.command(pointWordForward, 'start', ...args)\n}\n\nCommands.moveStartTo = (editor, ...args) => {\n  editor.command(proxy, 'moveStartTo', ...args)\n}\n\nCommands.moveStartToEndOfBlock = editor => {\n  editor.command(pointEdgeObject, 'start', 'end', 'block')\n}\n\nCommands.moveStartToEndOfDocument = editor => {\n  editor.moveStartToEndOfNode(editor.value.document).moveToStart()\n}\n\nCommands.moveStartToEndOfInline = editor => {\n  editor.command(pointEdgeObject, 'start', 'end', 'inline')\n}\n\nCommands.moveStartToEndOfNextBlock = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'next', 'block')\n}\n\nCommands.moveStartToEndOfNextInline = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'next', 'inline')\n}\n\nCommands.moveStartToEndOfNextText = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'next', 'text')\n}\n\nCommands.moveStartToEndOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveStartToEndOfNode', ...args)\n}\n\nCommands.moveStartToEndOfPreviousBlock = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'previous', 'block')\n}\n\nCommands.moveStartToEndOfPreviousInline = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'previous', 'inline')\n}\n\nCommands.moveStartToEndOfPreviousText = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'previous', 'text')\n}\n\nCommands.moveStartToEndOfText = editor => {\n  editor.command(pointEdgeObject, 'start', 'end', 'text')\n}\n\nCommands.moveStartToStartOfBlock = editor => {\n  editor.command(pointEdgeObject, 'start', 'start', 'block')\n}\n\nCommands.moveStartToStartOfDocument = editor => {\n  editor.moveStartToStartOfNode(editor.value.document).moveToStart()\n}\n\nCommands.moveStartToStartOfInline = editor => {\n  editor.command(pointEdgeObject, 'start', 'start', 'inline')\n}\n\nCommands.moveStartToStartOfNextBlock = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'next', 'block')\n}\n\nCommands.moveStartToStartOfNextInline = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'next', 'inline')\n}\n\nCommands.moveStartToStartOfNextText = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'next', 'text')\n}\n\nCommands.moveStartToStartOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveStartToStartOfNode', ...args)\n}\n\nCommands.moveStartToStartOfPreviousBlock = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'previous', 'block')\n}\n\nCommands.moveStartToStartOfPreviousInline = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'previous', 'inline')\n}\n\nCommands.moveStartToStartOfPreviousText = editor => {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'previous', 'text')\n}\n\nCommands.moveStartToStartOfText = editor => {\n  editor.command(pointEdgeObject, 'start', 'start', 'text')\n}\n\nCommands.moveTo = (editor, ...args) => {\n  editor.command(proxy, 'moveTo', ...args)\n}\n\nCommands.moveToAnchor = editor => {\n  editor.command(proxy, 'moveToAnchor')\n}\n\nCommands.moveToEnd = editor => {\n  editor.command(proxy, 'moveToEnd')\n}\n\nCommands.moveToEndOfBlock = editor => {\n  editor.moveEndToEndOfBlock().moveToEnd()\n}\n\nCommands.moveToEndOfDocument = editor => {\n  editor.moveEndToEndOfNode(editor.value.document).moveToEnd()\n}\n\nCommands.moveToEndOfInline = editor => {\n  editor.moveEndToEndOfInline().moveToEnd()\n}\n\nCommands.moveToEndOfNextBlock = editor => {\n  editor.moveEndToEndOfNextBlock().moveToEnd()\n}\n\nCommands.moveToEndOfNextInline = editor => {\n  editor.moveEndToEndOfNextInline().moveToEnd()\n}\n\nCommands.moveToEndOfNextText = editor => {\n  editor.moveEndToEndOfNextText().moveToEnd()\n}\n\nCommands.moveToEndOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveToEndOfNode', ...args)\n}\n\nCommands.moveToEndOfPreviousBlock = editor => {\n  editor.moveStartToEndOfPreviousBlock().moveToStart()\n}\n\nCommands.moveToEndOfPreviousInline = editor => {\n  editor.moveStartToEndOfPreviousInline().moveToStart()\n}\n\nCommands.moveToEndOfPreviousText = editor => {\n  editor.moveStartToEndOfPreviousText().moveToStart()\n}\n\nCommands.moveToEndOfText = editor => {\n  editor.moveEndToEndOfText().moveToEnd()\n}\n\nCommands.moveToFocus = editor => {\n  editor.command(proxy, 'moveToFocus')\n}\n\nCommands.moveToRangeOfDocument = editor => {\n  editor.moveToRangeOfNode(editor.value.document)\n}\n\nCommands.moveToRangeOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveToRangeOfNode', ...args)\n}\n\nCommands.moveToStart = editor => {\n  editor.command(proxy, 'moveToStart')\n}\n\nCommands.moveToStartOfBlock = editor => {\n  editor.moveStartToStartOfBlock().moveToStart()\n}\n\nCommands.moveToStartOfDocument = editor => {\n  editor.moveStartToStartOfNode(editor.value.document).moveToStart()\n}\n\nCommands.moveToStartOfInline = editor => {\n  editor.moveStartToStartOfInline().moveToStart()\n}\n\nCommands.moveToStartOfNextBlock = editor => {\n  editor.moveEndToStartOfNextBlock().moveToEnd()\n}\n\nCommands.moveToStartOfNextInline = editor => {\n  editor.moveEndToStartOfNextInline().moveToEnd()\n}\n\nCommands.moveToStartOfNextText = editor => {\n  editor.moveEndToStartOfNextText().moveToEnd()\n}\n\nCommands.moveToStartOfNode = (editor, ...args) => {\n  editor.command(proxy, 'moveToStartOfNode', ...args)\n}\n\nCommands.moveToStartOfPreviousBlock = editor => {\n  editor.moveStartToStartOfPreviousBlock().moveToStart()\n}\n\nCommands.moveToStartOfPreviousInline = editor => {\n  editor.moveStartToStartOfPreviousInline().moveToStart()\n}\n\nCommands.moveToStartOfPreviousText = editor => {\n  editor.moveStartToStartOfPreviousText().moveToStart()\n}\n\nCommands.moveToStartOfText = editor => {\n  editor.moveStartToStartOfText().moveToStart()\n}\n\nCommands.select = (editor, properties, options = {}) => {\n  properties = Selection.createProperties(properties)\n  const { snapshot = false } = options\n  const { value } = editor\n  const { document, selection } = value\n  const newProperties = {}\n  let next = selection.setProperties(properties)\n  next = document.resolveSelection(next)\n\n  // Re-compute the properties, to ensure that we get their normalized values.\n  properties = pick(next, Object.keys(properties))\n\n  // Remove any properties that are already equal to the current selection. And\n  // create a dictionary of the previous values for all of the properties that\n  // are being changed, for the inverse operation.\n  for (const k in properties) {\n    if (snapshot === true || !is(properties[k], selection[k])) {\n      newProperties[k] = properties[k]\n    }\n  }\n\n  // If the selection moves, clear any marks, unless the new selection\n  // properties change the marks in some way.\n  if (\n    selection.marks &&\n    !newProperties.marks &&\n    (newProperties.anchor || newProperties.focus)\n  ) {\n    newProperties.marks = null\n  }\n\n  // If there are no new properties to set, abort to avoid extra operations.\n  if (Object.keys(newProperties).length === 0) {\n    return\n  }\n\n  // TODO: for some reason toJSON() is required here (it breaks selections between blocks)? - 2018-10-10\n  const prevProperties = pick(selection.toJSON(), Object.keys(newProperties))\n\n  editor.applyOperation(\n    {\n      type: 'set_selection',\n      value,\n      properties: prevProperties,\n      newProperties,\n    },\n    snapshot ? { skip: false, merge: false } : {}\n  )\n}\n\nCommands.setAnchor = (editor, ...args) => {\n  editor.command(proxy, 'setAnchor', ...args)\n}\n\nCommands.setEnd = (editor, ...args) => {\n  editor.command(proxy, 'setEnd', ...args)\n}\n\nCommands.setFocus = (editor, ...args) => {\n  editor.command(proxy, 'setFocus', ...args)\n}\n\nCommands.setStart = (editor, ...args) => {\n  editor.command(proxy, 'setStart', ...args)\n}\n\nCommands.snapshotSelection = editor => {\n  editor.withoutMerging(() => {\n    editor.select(editor.value.selection, { snapshot: true })\n  })\n}\n\n/**\n * Helpers.\n */\n\nfunction proxy(editor, method, ...args) {\n  const range = editor.value.selection[method](...args)\n  editor.select(range)\n}\n\nfunction pointEdgeObject(editor, point, edge, object) {\n  const Point = point.slice(0, 1).toUpperCase() + point.slice(1)\n  const Edge = edge.slice(0, 1).toUpperCase() + edge.slice(1)\n  const Object = object.slice(0, 1).toUpperCase() + object.slice(1)\n  const method = `move${Point}To${Edge}OfNode`\n  const getNode = object === 'text' ? 'getNode' : `getClosest${Object}`\n  const { value } = editor\n  const { document, selection } = value\n  const p = selection[point]\n  const node = document[getNode](p.key)\n  if (!node) return\n  editor[method](node)\n}\n\nfunction pointEdgeSideObject(editor, point, edge, side, object) {\n  const Point = point.slice(0, 1).toUpperCase() + point.slice(1)\n  const Edge = edge.slice(0, 1).toUpperCase() + edge.slice(1)\n  const Side = side.slice(0, 1).toUpperCase() + side.slice(1)\n  const Object = object.slice(0, 1).toUpperCase() + object.slice(1)\n  const method = `move${Point}To${Edge}OfNode`\n  const getNode = object === 'text' ? 'getNode' : `getClosest${Object}`\n  const getDirectionNode = `get${Side}${Object}`\n  const { value } = editor\n  const { document, selection } = value\n  const p = selection[point]\n  const node = document[getNode](p.key)\n  if (!node) return\n  const target = document[getDirectionNode](node.key)\n  if (!target) return\n  editor[method](target)\n}\n\nfunction pointBackward(editor, point, n = 1) {\n  if (n === 0) return\n  if (n < 0) return pointForward(editor, point, -n)\n\n  const Point = point.slice(0, 1).toUpperCase() + point.slice(1)\n  const { value } = editor\n  const { document, selection } = value\n  const p = selection[point]\n  const hasVoidParent = document.hasVoidParent(p.path, editor)\n\n  // what is this?\n  if (!hasVoidParent && p.offset - n >= 0) {\n    const range = selection[`move${Point}Backward`](n)\n    editor.select(range)\n    return\n  }\n\n  const previous = document.getPreviousText(p.path)\n  if (!previous) return\n\n  const block = document.getClosestBlock(p.path)\n  const isInBlock = block.hasNode(previous.key)\n  const isPreviousInVoid =\n    previous && document.hasVoidParent(previous.key, editor)\n  editor[`move${Point}ToEndOfNode`](previous)\n\n  // when is this called?\n  if (!hasVoidParent && !isPreviousInVoid && isInBlock) {\n    const range = editor.value.selection[`move${Point}Backward`](n)\n    editor.select(range)\n  }\n}\n\nfunction pointForward(editor, point, n = 1) {\n  if (n === 0) return\n  if (n < 0) return pointBackward(editor, point, -n)\n\n  const Point = point.slice(0, 1).toUpperCase() + point.slice(1)\n  const { value } = editor\n  const { document, selection } = value\n  const p = selection[point]\n  const text = document.getNode(p.path)\n  const hasVoidParent = document.hasVoidParent(p.path, editor)\n\n  // what is this?\n  if (!hasVoidParent && p.offset + n <= text.text.length) {\n    const range = selection[`move${Point}Forward`](n)\n    editor.select(range)\n    return\n  }\n\n  const next = document.getNextText(p.path)\n  if (!next) return\n\n  const block = document.getClosestBlock(p.path)\n  const isInBlock = block.hasNode(next.key)\n  const isNextInVoid = document.hasVoidParent(next.key, editor)\n  editor[`move${Point}ToStartOfNode`](next)\n\n  // when is this called?\n  if (!hasVoidParent && !isNextInVoid && isInBlock) {\n    const range = editor.value.selection[`move${Point}Forward`](n)\n    editor.select(range)\n  }\n}\n\nfunction pointWordBackward(editor, pointName) {\n  const { value } = editor\n  const { document, selection } = value\n  const point = selection[pointName]\n  const block = document.getClosestBlock(point.key)\n  const offset = block.getOffset(point.key)\n  const o = offset + point.offset\n  const { text } = block\n  const n = TextUtils.getWordOffsetBackward(text, o)\n  editor.command(pointBackward, pointName, n > 0 ? n : 1)\n}\n\nfunction pointWordForward(editor, pointName) {\n  const { value } = editor\n  const { document, selection } = value\n  const point = selection[pointName]\n  const block = document.getClosestBlock(point.key)\n  const offset = block.getOffset(point.key)\n  const o = offset + point.offset\n  const { text } = block\n  const n = TextUtils.getWordOffsetForward(text, o)\n  editor.command(pointForward, pointName, n > 0 ? n : 1)\n}\n\nexport default Commands\n","import pick from 'lodash/pick'\nimport Annotation from '../models/annotation'\nimport Value from '../models/value'\n\n/**\n * Commands.\n *\n * @type {Object}\n */\n\nconst Commands = {}\n\n/**\n * Set `properties` on the value.\n *\n * @param {Editor} editor\n * @param {Object|Value} properties\n */\n\nCommands.setData = (editor, data = {}) => {\n  const { value } = editor\n  const newProperties = Value.createProperties({ data })\n  const prevProperties = pick(value, Object.keys(newProperties))\n\n  editor.applyOperation({\n    type: 'set_value',\n    properties: prevProperties,\n    newProperties,\n  })\n}\n\nCommands.addAnnotation = (editor, annotation) => {\n  annotation = Annotation.create(annotation)\n\n  editor.applyOperation({\n    type: 'add_annotation',\n    annotation,\n  })\n}\n\nCommands.removeAnnotation = (editor, annotation) => {\n  annotation = Annotation.create(annotation)\n\n  editor.applyOperation({\n    type: 'remove_annotation',\n    annotation,\n  })\n}\n\nCommands.setAnnotation = (editor, annotation, newProperties) => {\n  annotation = Annotation.create(annotation)\n  newProperties = Annotation.createProperties(newProperties)\n\n  editor.applyOperation({\n    type: 'set_annotation',\n    properties: annotation,\n    newProperties,\n  })\n}\n\nCommands.setAnnotations = (editor, annotations = []) => {\n  const { value } = editor\n  const newProperties = Value.createProperties({ annotations })\n  const prevProperties = pick(value, Object.keys(newProperties))\n\n  editor.applyOperation({\n    type: 'set_value',\n    properties: prevProperties,\n    newProperties,\n  })\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Commands\n","/**\n * A plugin that adds a set of queries to the editor.\n *\n * @param {Object} queries\n * @return {Object}\n */\n\nfunction QueriesPlugin(queries = {}) {\n  /**\n   * On construct, register all the queries.\n   *\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onConstruct(editor, next) {\n    for (const query in queries) {\n      editor.registerQuery(query)\n    }\n\n    return next()\n  }\n\n  /**\n   * On query, if it exists in our list of queries, call it.\n   *\n   * @param {Object} query\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onQuery(query, editor, next) {\n    const { type, args } = query\n    const fn = queries[type]\n    if (!fn) return next()\n    const ret = fn(editor, ...args)\n    return ret === undefined ? next() : ret\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onConstruct,\n    onQuery,\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default QueriesPlugin\n","/**\n * Define a Slate error.\n *\n * @type {SlateError}\n */\n\nclass SlateError extends Error {\n  constructor(code, attrs = {}) {\n    super(code)\n    this.code = code\n\n    for (const key in attrs) {\n      this[key] = attrs[key]\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor)\n    } else {\n      this.stack = new Error().stack\n    }\n  }\n}\n\n/**\n * Export.\n *\n * @type {SlateError}\n */\n\nexport default SlateError\n","import SlateError from '../utils/slate-error'\nimport Queries from './queries'\n\n/**\n * Create a plugin from a `schema` definition.\n *\n * @param {Object} schema\n * @return {Object}\n */\n\nfunction SchemaPlugin(schema) {\n  const {\n    rules,\n    document,\n    blocks,\n    inlines,\n    marks,\n    annotations,\n    decorations,\n  } = schema\n  let schemaRules = []\n\n  if (rules) {\n    schemaRules = schemaRules.concat(rules)\n  }\n\n  if (document) {\n    schemaRules.push({\n      match: [{ object: 'document' }],\n      ...document,\n    })\n  }\n\n  if (blocks) {\n    for (const key in blocks) {\n      schemaRules.push({\n        match: [{ object: 'block', type: key }],\n        ...blocks[key],\n      })\n    }\n  }\n\n  if (inlines) {\n    for (const key in inlines) {\n      schemaRules.push({\n        match: [{ object: 'inline', type: key }],\n        ...inlines[key],\n      })\n    }\n  }\n\n  if (marks) {\n    for (const key in marks) {\n      schemaRules.push({\n        match: [{ object: 'mark', type: key }],\n        ...marks[key],\n      })\n    }\n  }\n\n  if (annotations) {\n    for (const key in annotations) {\n      schemaRules.push({\n        match: [{ object: 'annotation', type: key }],\n        ...annotations[key],\n      })\n    }\n  }\n\n  if (decorations) {\n    for (const key in decorations) {\n      schemaRules.push({\n        match: [{ object: 'decoration', type: key }],\n        ...decorations[key],\n      })\n    }\n  }\n\n  /**\n   * Check if a `format` is atomic based on the schema rules.\n   *\n   * @param {Editor} editor\n   * @param {Format} format\n   * @return {Boolean}\n   */\n\n  function isAtomic(editor, format) {\n    const rule = schemaRules.find(\n      r => 'isAtomic' in r && testRules(format, r.match)\n    )\n\n    return rule && rule.isAtomic\n  }\n\n  /**\n   * Check if a `node` is void based on the schema rules.\n   *\n   * @param {Editor} editor\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  function isVoid(editor, node) {\n    const rule = schemaRules.find(\n      r => 'isVoid' in r && testRules(node, r.match)\n    )\n\n    return rule && rule.isVoid\n  }\n\n  /**\n   * Normalize a `node` with the schema rules, returning a function that will\n   * fix the invalid node, or void if the node is valid.\n   *\n   * @param {Node} node\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Function|Void}\n   */\n\n  function normalizeNode(node, editor, next) {\n    const error = validateNode(node, editor, () => {})\n    if (!error) return next()\n\n    return () => {\n      const { rule } = error\n      const { size } = editor.operations\n\n      // First run the user-provided `normalize` function if one exists...\n      if (rule.normalize) {\n        rule.normalize(editor, error)\n      }\n\n      // If the `normalize` function did not add any operations to the editor\n      // object, it can't have normalized, so run the default one.\n      if (editor.operations.size === size) {\n        defaultNormalize(editor, error)\n      }\n    }\n  }\n\n  /**\n   * Validate a `node` with the schema rules, returning a `SlateError` if it's\n   * invalid.\n   *\n   * @param {Node} node\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Error|Void}\n   */\n\n  function validateNode(node, editor, next) {\n    const matches = schemaRules.filter(r => testRules(node, r.match))\n    const failure = validateRules(node, matches, schemaRules, { every: true })\n    if (!failure) return next()\n    const error = new SlateError(failure.code, failure)\n    return error\n  }\n\n  /**\n   * On schema-related queries, respond if we can.\n   *\n   * @param {Object} query\n   * @param {Function} next\n   */\n\n  const queries = Queries({ isAtomic, isVoid })\n\n  /**\n   * Return the plugins.\n   *\n   * @type {Object}\n   */\n\n  return [{ normalizeNode, validateNode }, queries]\n}\n\n/**\n * Normalize an invalid value with `error` with default remedies.\n *\n * @param {Editor} editor\n * @param {SlateError} error\n */\n\nfunction defaultNormalize(editor, error) {\n  const { code, node, child, next, previous, key, mark } = error\n\n  switch (code) {\n    case 'child_max_invalid':\n    case 'child_object_invalid':\n    case 'child_type_invalid':\n    case 'child_unknown':\n    case 'first_child_object_invalid':\n    case 'first_child_type_invalid':\n    case 'last_child_object_invalid':\n    case 'last_child_type_invalid': {\n      return child.object === 'text' &&\n        node.object === 'block' &&\n        node.nodes.size === 1\n        ? editor.removeNodeByKey(node.key)\n        : editor.removeNodeByKey(child.key)\n    }\n\n    case 'previous_sibling_object_invalid':\n    case 'previous_sibling_type_invalid': {\n      return previous.object === 'text' &&\n        node.object === 'block' &&\n        node.nodes.size === 1\n        ? editor.removeNodeByKey(node.key)\n        : editor.removeNodeByKey(previous.key)\n    }\n\n    case 'next_sibling_object_invalid':\n    case 'next_sibling_type_invalid': {\n      return next.object === 'text' &&\n        node.object === 'block' &&\n        node.nodes.size === 1\n        ? editor.removeNodeByKey(node.key)\n        : editor.removeNodeByKey(next.key)\n    }\n\n    case 'child_min_invalid':\n    case 'node_text_invalid':\n    case 'parent_object_invalid':\n    case 'parent_type_invalid': {\n      return node.object === 'document'\n        ? node.nodes.forEach(n => editor.removeNodeByKey(n.key))\n        : editor.removeNodeByKey(node.key)\n    }\n\n    case 'node_data_invalid': {\n      return node.data.get(key) === undefined && node.object !== 'document'\n        ? editor.removeNodeByKey(node.key)\n        : editor.setNodeByKey(node.key, { data: node.data.delete(key) })\n    }\n\n    case 'node_mark_invalid': {\n      return node\n        .getTexts()\n        .forEach(t => editor.removeMarkByKey(t.key, 0, t.text.length, mark))\n    }\n\n    default: {\n      return editor.removeNodeByKey(node.key)\n    }\n  }\n}\n\n/**\n * Check that an `object` matches one of a set of `rules`.\n *\n * @param {Mixed} object\n * @param {Object|Array} rules\n * @return {Boolean}\n */\n\nfunction testRules(object, rules) {\n  const error = validateRules(object, rules)\n  return !error\n}\n\n/**\n * Validate that a `object` matches a `rule` object or array.\n *\n * @param {Mixed} object\n * @param {Object|Array} rule\n * @param {Array|Void} rules\n * @return {Error|Void}\n */\n\nfunction validateRules(object, rule, rules, options = {}) {\n  const { every = false, match = null } = options\n\n  if (typeof rule === 'function') {\n    const valid = rule(object, match)\n    return valid ? null : fail('node_invalid', { rule, node: object })\n  }\n\n  if (Array.isArray(rule)) {\n    const array = rule.length ? rule : [{}]\n    let first\n\n    for (const r of array) {\n      const error = validateRules(object, r, rules)\n      first = first || error\n      if (every && error) return error\n      if (!every && !error) return\n    }\n\n    return first\n  }\n\n  const error =\n    validateObject(object, rule) ||\n    validateType(object, rule) ||\n    validateData(object, rule) ||\n    validateMarks(object, rule) ||\n    validateText(object, rule) ||\n    validateFirst(object, rule) ||\n    validateLast(object, rule) ||\n    validateNodes(object, rule, rules)\n\n  return error\n}\n\nfunction validateObject(node, rule) {\n  if (rule.object == null) return\n  if (rule.object === node.object) return\n  if (typeof rule.object === 'function' && rule.object(node.object)) return\n  return fail('node_object_invalid', { rule, node })\n}\n\nfunction validateType(node, rule) {\n  if (rule.type == null) return\n  if (rule.type === node.type) return\n  if (typeof rule.type === 'function' && rule.type(node.type)) return\n  return fail('node_type_invalid', { rule, node })\n}\n\nfunction validateData(node, rule) {\n  if (rule.data == null) return\n  if (node.data == null) return\n\n  if (typeof rule.data === 'function') {\n    if (rule.data(node.data)) return\n    return fail('node_data_invalid', { rule, node })\n  }\n\n  for (const key in rule.data) {\n    const fn = rule.data[key]\n    const value = node.data && node.data.get(key)\n    const valid = typeof fn === 'function' ? fn(value) : fn === value\n    if (valid) continue\n    return fail('node_data_invalid', { rule, node, key, value })\n  }\n}\n\nfunction validateMarks(node, rule) {\n  if (rule.marks == null) return\n\n  const marks =\n    node.object === 'text' ? node.marks.toArray() : node.getMarks().toArray()\n\n  for (const mark of marks) {\n    const valid = rule.marks.some(\n      def =>\n        typeof def.type === 'function'\n          ? def.type(mark.type)\n          : def.type === mark.type\n    )\n    if (valid) continue\n    return fail('node_mark_invalid', { rule, node, mark })\n  }\n}\n\nfunction validateText(node, rule) {\n  if (rule.text == null) return\n  const { text } = node\n  const valid =\n    typeof rule.text === 'function' ? rule.text(text) : rule.text.test(text)\n  if (valid) return\n  return fail('node_text_invalid', { rule, node, text })\n}\n\nfunction validateFirst(node, rule) {\n  if (rule.first == null) return\n  const first = node.nodes.first()\n  if (!first) return\n  const error = validateRules(first, rule.first)\n  if (!error) return\n  error.rule = rule\n  error.node = node\n  error.child = first\n  error.code = error.code.replace('node_', 'first_child_')\n  return error\n}\n\nfunction validateLast(node, rule) {\n  if (rule.last == null) return\n  const last = node.nodes.last()\n  if (!last) return\n  const error = validateRules(last, rule.last)\n  if (!error) return\n  error.rule = rule\n  error.node = node\n  error.child = last\n  error.code = error.code.replace('node_', 'last_child_')\n  return error\n}\n\nfunction validateNodes(node, rule, rules = []) {\n  if (node.nodes == null) return\n\n  const children = node.nodes\n  const defs = rule.nodes != null ? rule.nodes.slice() : []\n  let count = 0\n  let lastCount = 0\n  let min = null\n  let index = -1\n  let def = null\n  let max = null\n  let child = null\n  let previous = null\n  let next = null\n\n  function nextDef() {\n    if (defs.length === 0) return false\n    def = defs.shift()\n    lastCount = count\n    count = 0\n    min = def.min || null\n    max = def.max || null\n    return true\n  }\n\n  function nextChild() {\n    index += 1\n    previous = index ? children.get(index - 1) : null\n    child = children.get(index)\n    next = children.get(index + 1)\n    if (!child) return false\n    lastCount = count\n    count += 1\n    return true\n  }\n\n  function rewind() {\n    if (index > 0) {\n      index -= 1\n      count = lastCount\n    }\n  }\n\n  if (rule.nodes != null) {\n    nextDef()\n  }\n\n  while (nextChild()) {\n    const err =\n      validateParent(node, child, rules) ||\n      validatePrevious(node, child, previous, index, rules) ||\n      validateNext(node, child, next, index, rules)\n\n    if (err) return err\n\n    if (rule.nodes != null) {\n      if (!def) {\n        return fail('child_unknown', { rule, node, child, index })\n      }\n\n      if (def.match) {\n        const error = validateRules(child, def.match)\n\n        if (error) {\n          // Since we want to report overflow on last matching child we don't\n          // immediately check for count > max, but instead do so once we find\n          // a child that doesn't match.\n          if (max != null && count - 1 > max) {\n            rewind()\n            return fail('child_max_invalid', {\n              rule,\n              node,\n              index,\n              child: children.get(index),\n              count,\n              limit: max,\n            })\n          }\n\n          const lastMin = min\n\n          // If there are more groups after this one then child might actually\n          // be valid.\n          if (nextDef()) {\n            // If we've already satisfied the minimum for the current group,\n            // then we can rewind and proceed to the next group.\n            if (lastCount - 1 >= lastMin) {\n              index -= 1\n              continue\n            }\n\n            // Otherwise we know that current value is underflowing. There are\n            // three possible causes for this...\n\n            // 1. There might just not be enough elements for current group, and\n            // current child is in fact the first of the next group. If so, the\n            // next def will not report errors, in which case we can rewind and\n            // report an minimum error.\n            if (validateRules(child, def.match) == null) {\n              rewind()\n              return fail('child_min_invalid', {\n                rule,\n                node,\n                index,\n                count: lastCount - 1,\n                limit: lastMin,\n              })\n            }\n\n            // 2. The current group is underflowing, but there is also an\n            // invalid child before the next group.\n            // 3. Or the current group is not underflowing but it appears so\n            // because there's an invalid child between its members.\n            // It's either the second or third case. If it's the second then\n            // we could report an underflow, but presence of an invalid child\n            // is arguably more important, so we report it first. It also lets\n            // us avoid checking for which case exactly is it.\n            error.rule = rule\n            error.node = node\n            error.child = child\n            error.index = index\n            error.code = error.code.replace('node_', 'child_')\n            return error\n          }\n\n          // Otherwise either we exhausted the last group, in which case it's\n          // an unknown child, ...\n          if (max != null && count > max) {\n            return fail('child_unknown', { rule, node, child, index })\n          }\n\n          // ... or it's an invalid child for the last group.\n          error.rule = rule\n          error.node = node\n          error.child = child\n          error.index = index\n          error.code = error.code.replace('node_', 'child_')\n          return error\n        }\n      }\n    }\n  }\n\n  // Since we want to report overflow on last matching child we don't\n  // immediately check for count > max, but do so after processing all nodes.\n  if (max != null && count > max) {\n    return fail('child_max_invalid', {\n      rule,\n      node,\n      index: index - 1,\n      count,\n      child: children.get(index - 1),\n      limit: max,\n    })\n  }\n\n  if (rule.nodes != null) {\n    do {\n      if (count < min) {\n        return fail('child_min_invalid', {\n          rule,\n          node,\n          index,\n          count,\n          limit: min,\n        })\n      }\n    } while (nextDef())\n  }\n}\n\nfunction validateParent(node, child, rules) {\n  for (const rule of rules) {\n    if (rule.parent == null) continue\n    if (!testRules(child, rule.match)) continue\n\n    const error = validateRules(node, rule.parent)\n    if (!error) continue\n\n    error.rule = rule\n    error.parent = node\n    error.node = child\n    error.code = error.code.replace('node_', 'parent_')\n    return error\n  }\n}\n\nfunction validatePrevious(node, child, previous, index, rules) {\n  if (!previous) return\n\n  for (const rule of rules) {\n    if (rule.previous == null) continue\n    if (!testRules(child, rule.match)) continue\n\n    const error = validateRules(previous, rule.previous)\n    if (!error) continue\n\n    error.rule = rule\n    error.node = node\n    error.child = child\n    error.index = index\n    error.previous = previous\n    error.code = error.code.replace('node_', 'previous_sibling_')\n    return error\n  }\n}\n\nfunction validateNext(node, child, next, index, rules) {\n  if (!next) return\n\n  for (const rule of rules) {\n    if (rule.next == null) continue\n    if (!testRules(child, rule.match)) continue\n\n    const error = validateRules(next, rule.next, [], { match: child })\n    if (!error) continue\n\n    error.rule = rule\n    error.node = node\n    error.child = child\n    error.index = index\n    error.next = next\n    error.code = error.code.replace('node_', 'next_sibling_')\n    return error\n  }\n}\n\n/**\n * Create an interim failure object with `code` and `attrs`.\n *\n * @param {String} code\n * @param {Object} attrs\n * @return {Object}\n */\n\nfunction fail(code, attrs) {\n  return { code, ...attrs }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default SchemaPlugin\n","import Block from '../models/block'\nimport Inline from '../models/inline'\nimport Mark from '../models/mark'\n\n/**\n * Ensure that an expanded selection is deleted first using the `editor.delete`\n * command. This guarantees that it uses the proper semantic \"intent\" instead of\n * using `deleteAtRange` under the covers and skipping `delete`.\n *\n * @param {Editor}\n */\n\nfunction deleteExpanded(editor) {\n  const { value } = editor\n  const { selection } = value\n\n  if (selection.isExpanded) {\n    editor.delete()\n  }\n}\n\n/**\n * Commands.\n *\n * @type {Object}\n */\n\nconst Commands = {}\n\n/**\n * Add a `mark` to the characters in the current selection.\n *\n * @param {Editor} editor\n * @param {Mark} mark\n */\n\nCommands.addMark = (editor, mark) => {\n  mark = Mark.create(mark)\n  const { value } = editor\n  const { document, selection } = value\n\n  if (selection.isExpanded) {\n    editor.addMarkAtRange(selection, mark)\n  } else if (selection.marks) {\n    const marks = selection.marks.add(mark)\n    const sel = selection.set('marks', marks)\n    editor.select(sel)\n  } else {\n    const marks = document.getActiveMarksAtRange(selection).add(mark)\n    const sel = selection.set('marks', marks)\n    editor.select(sel)\n  }\n}\n\n/**\n * Add a list of `marks` to the characters in the current selection.\n *\n * @param {Editor} editor\n * @param {Set<Mark>|Array<Object>} marks\n */\n\nCommands.addMarks = (editor, marks) => {\n  marks.forEach(mark => editor.addMark(mark))\n}\n\n/**\n * Delete at the current selection.\n *\n * @param {Editor} editor\n */\n\nCommands.delete = editor => {\n  const { value } = editor\n  const { selection } = value\n  editor.deleteAtRange(selection)\n\n  // COMPAT: Ensure that the selection is collapsed, because in certain cases\n  // when deleting across inline nodes, when splitting the inline node the end\n  // point of the selection will end up after the split point.\n  editor.moveToFocus()\n}\n\n/**\n * Delete backward `n` characters.\n *\n * @param {Editor} editor\n * @param {Number} n (optional)\n */\n\nCommands.deleteBackward = (editor, n = 1) => {\n  const { value } = editor\n  const { selection } = value\n\n  if (selection.isExpanded) {\n    editor.delete()\n  } else {\n    editor.deleteBackwardAtRange(selection, n)\n  }\n}\n\n/**\n * Delete backward one character.\n *\n * @param {Editor} editor\n */\n\nCommands.deleteCharBackward = editor => {\n  const { value } = editor\n  const { selection } = value\n\n  if (selection.isExpanded) {\n    editor.delete()\n  } else {\n    editor.deleteCharBackwardAtRange(selection)\n  }\n}\n\n/**\n * Delete backward one line.\n *\n * @param {Editor} editor\n */\n\nCommands.deleteLineBackward = editor => {\n  const { value } = editor\n  const { selection } = value\n\n  if (selection.isExpanded) {\n    editor.delete()\n  } else {\n    editor.deleteLineBackwardAtRange(selection)\n  }\n}\n\n/**\n * Delete backward one word.\n *\n * @param {Editor} editor\n */\n\nCommands.deleteWordBackward = editor => {\n  const { value } = editor\n  const { selection } = value\n\n  if (selection.isExpanded) {\n    editor.delete()\n  } else {\n    editor.deleteWordBackwardAtRange(selection)\n  }\n}\n\n/**\n * Delete backward `n` characters.\n *\n * @param {Editor} editor\n * @param {Number} n (optional)\n */\n\nCommands.deleteForward = (editor, n = 1) => {\n  const { value } = editor\n  const { selection } = value\n\n  if (selection.isExpanded) {\n    editor.delete()\n  } else {\n    editor.deleteForwardAtRange(selection, n)\n  }\n}\n\n/**\n * Delete backward one character.\n *\n * @param {Editor} editor\n */\n\nCommands.deleteCharForward = editor => {\n  const { value } = editor\n  const { selection } = value\n\n  if (selection.isExpanded) {\n    editor.delete()\n  } else {\n    editor.deleteCharForwardAtRange(selection)\n  }\n}\n\n/**\n * Delete backward one line.\n *\n * @param {Editor} editor\n */\n\nCommands.deleteLineForward = editor => {\n  const { value } = editor\n  const { selection } = value\n\n  if (selection.isExpanded) {\n    editor.delete()\n  } else {\n    editor.deleteLineForwardAtRange(selection)\n  }\n}\n\n/**\n * Delete backward one word.\n *\n * @param {Editor} editor\n */\n\nCommands.deleteWordForward = editor => {\n  const { value } = editor\n  const { selection } = value\n\n  if (selection.isExpanded) {\n    editor.delete()\n  } else {\n    editor.deleteWordForwardAtRange(selection)\n  }\n}\n\n/**\n * Insert a `block` at the current selection.\n *\n * @param {Editor} editor\n * @param {String|Object|Block} block\n */\n\nCommands.insertBlock = (editor, block) => {\n  deleteExpanded(editor)\n\n  block = Block.create(block)\n  const { value } = editor\n  const { selection } = value\n  editor.insertBlockAtRange(selection, block)\n\n  // If the node was successfully inserted, update the selection.\n  const node = editor.value.document.getNode(block.key)\n  if (node) editor.moveToEndOfNode(node)\n}\n\n/**\n * Insert a `fragment` at the current selection.\n *\n * @param {Editor} editor\n * @param {Document} fragment\n */\n\nCommands.insertFragment = (editor, fragment) => {\n  if (!fragment.nodes.size) return\n\n  deleteExpanded(editor)\n\n  let { value } = editor\n  let { document, selection } = value\n  const { start } = selection\n  const keys = Array.from(document.texts(), ([text]) => text.key)\n\n  editor.insertFragmentAtRange(selection, fragment)\n  value = editor.value\n  document = value.document\n\n  const newTexts = document.getTexts().filter(n => !keys.includes(n.key))\n  if (newTexts.size === 0) return\n  const fragmentLength = fragment.text.length\n\n  // Either startText is still here, or we want the first un-previously known text\n  const startText = document.getNode(start.key) || newTexts.first()\n  // We want the last un-previously known text\n  let endText = newTexts.last() || startText\n\n  if (startText === endText) {\n    editor.moveTo(endText.key, fragmentLength)\n    return\n  }\n\n  // Everything will be calculated relative to the first common ancestor to optimize speed\n  const parent = document.getCommonAncestor(startText.key, endText.key)\n\n  const startOffset =\n    parent.getOffset(startText.key) +\n    (start.key === startText.key ? start.offset : 0)\n\n  // endText might not be the last un-previously known text node, so we precisely pick it by offset\n  endText = parent.getTextAtOffset(startOffset + fragmentLength - 1) || endText\n\n  editor.moveTo(\n    endText.key,\n    startOffset + fragmentLength - parent.getOffset(endText.key)\n  )\n}\n\n/**\n * Insert an `inline` at the current selection.\n *\n * @param {Editor} editor\n * @param {String|Object|Inline} inline\n */\n\nCommands.insertInline = (editor, inline) => {\n  deleteExpanded(editor)\n\n  inline = Inline.create(inline)\n  const { value } = editor\n  const { selection } = value\n  editor.insertInlineAtRange(selection, inline)\n\n  // If the node was successfully inserted, update the selection.\n  const node = editor.value.document.getNode(inline.key)\n  if (node) editor.moveToEndOfNode(node)\n}\n\n/**\n * Insert a string of `text` with optional `marks` at the current selection.\n *\n * @param {Editor} editor\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nCommands.insertText = (editor, text, marks) => {\n  deleteExpanded(editor)\n\n  const { value } = editor\n  const { document, selection } = value\n  marks = marks || selection.marks || document.getInsertMarksAtRange(selection)\n\n  editor.withoutNormalizing(() => {\n    editor.insertTextAtRange(selection, text, marks)\n\n    // If the text was successfully inserted, and the selection had marks on it,\n    // unset the selection's marks.\n    if (selection.marks && document !== editor.value.document) {\n      editor.select({ marks: null })\n    }\n  })\n}\n\n/**\n * Remove a `mark` from the characters in the current selection.\n *\n * @param {Editor} editor\n * @param {Mark} mark\n */\n\nCommands.removeMark = (editor, mark) => {\n  mark = Mark.create(mark)\n  const { value } = editor\n  const { document, selection } = value\n\n  if (selection.isExpanded) {\n    editor.removeMarkAtRange(selection, mark)\n  } else if (selection.marks) {\n    const marks = selection.marks.remove(mark)\n    const sel = selection.set('marks', marks)\n    editor.select(sel)\n  } else {\n    const marks = document.getActiveMarksAtRange(selection).remove(mark)\n    const sel = selection.set('marks', marks)\n    editor.select(sel)\n  }\n}\n\n/**\n * Replace an `oldMark` with a `newMark` in the characters in the current selection.\n *\n * @param {Editor} editor\n * @param {Mark} oldMark\n * @param {Mark} newMark\n */\n\nCommands.replaceMark = (editor, oldMark, newMark) => {\n  editor.removeMark(oldMark)\n  editor.addMark(newMark)\n}\n\n/**\n * Set the `properties` of block nodes.\n *\n * @param {Editor} editor\n * @param {Object|String} properties\n */\n\nCommands.setBlocks = (editor, properties) => {\n  const { value } = editor\n  const { selection } = value\n  editor.setBlocksAtRange(selection, properties)\n}\n\n/**\n * Set the `properties` of inline nodes.\n *\n * @param {Editor} editor\n * @param {Object|String} properties\n */\n\nCommands.setInlines = (editor, properties) => {\n  const { value } = editor\n  const { selection } = value\n  editor.setInlinesAtRange(selection, properties)\n}\n\n/**\n * Split the block node at the current selection, to optional `depth`.\n *\n * @param {Editor} editor\n * @param {Number} depth (optional)\n */\n\nCommands.splitBlock = (editor, depth = 1) => {\n  deleteExpanded(editor)\n\n  const { value } = editor\n  const { selection, document } = value\n  const marks = selection.marks || document.getInsertMarksAtRange(selection)\n  editor.splitBlockAtRange(selection, depth).moveToEnd()\n\n  if (marks && marks.size !== 0) {\n    editor.select({ marks })\n  }\n}\n\n/**\n * Split the inline nodes to optional `height`.\n *\n * @param {Editor} editor\n * @param {Number} height (optional)\n */\n\nCommands.splitInline = (editor, height) => {\n  deleteExpanded(editor)\n  const { value } = editor\n  const { selection } = value\n  editor.splitInlineAtRange(selection, height)\n}\n\n/**\n * Add or remove a `mark` from the characters in the current selection,\n * depending on whether it's already there.\n *\n * @param {Editor} editor\n * @param {Mark} mark\n */\n\nCommands.toggleMark = (editor, mark) => {\n  mark = Mark.create(mark)\n  const { value } = editor\n  const exists = value.activeMarks.has(mark)\n\n  if (exists) {\n    editor.removeMark(mark)\n  } else {\n    editor.addMark(mark)\n  }\n}\n\n/**\n * Unwrap nodes from a block with `properties`.\n *\n * @param {Editor} editor\n * @param {String|Object} properties\n */\n\nCommands.unwrapBlock = (editor, properties) => {\n  const { value } = editor\n  const { selection } = value\n  editor.unwrapBlockAtRange(selection, properties)\n}\n\n/**\n * Unwrap nodes from an inline with `properties`.\n *\n * @param {Editor} editor\n * @param {String|Object} properties\n */\n\nCommands.unwrapInline = (editor, properties) => {\n  const { value } = editor\n  const { selection } = value\n  editor.unwrapInlineAtRange(selection, properties)\n}\n\n/**\n * Wrap nodes in a new `block`.\n *\n * @param {Editor} editor\n * @param {Block|Object|String} block\n */\n\nCommands.wrapBlock = (editor, block) => {\n  const { value } = editor\n  const { selection } = value\n  editor.wrapBlockAtRange(selection, block)\n}\n\n/**\n * Wrap nodes in a new `inline`.\n *\n * @param {Editor} editor\n * @param {Inline|Object|String} inline\n */\n\nCommands.wrapInline = (editor, inline) => {\n  const { value } = editor\n  const { selection } = value\n  editor.wrapInlineAtRange(selection, inline)\n}\n\n/**\n * Wrap the current selection with prefix/suffix.\n *\n * @param {Editor} editor\n * @param {String} prefix\n * @param {String} suffix\n */\n\nCommands.wrapText = (editor, prefix, suffix = prefix) => {\n  const { value } = editor\n  const { selection } = value\n  editor.wrapTextAtRange(selection, prefix, suffix)\n\n  // If the selection was collapsed, it will have moved the start offset too.\n  if (selection.isCollapsed) {\n    editor.moveStartBackward(prefix.length)\n  }\n\n  // Adding the suffix will have pushed the end of the selection further on, so\n  // we need to move it back to account for this.\n  editor.moveEndBackward(suffix.length)\n\n  // There's a chance that the selection points moved \"through\" each other,\n  // resulting in a now-incorrect selection direction.\n  if (selection.isForward !== editor.value.selection.isForward) {\n    editor.flip()\n  }\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default Commands\n","import AtRange from '../commands/at-range'\nimport ByPath from '../commands/by-path'\nimport Commands from './commands'\nimport OnHistory from '../commands/on-history'\nimport OnSelection from '../commands/on-selection'\nimport OnValue from '../commands/on-value'\nimport Queries from './queries'\nimport Schema from './schema'\nimport Text from '../models/text'\nimport WithIntent from '../commands/with-intent'\n\n/**\n * A plugin that defines the core Slate logic.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction CorePlugin(options = {}) {\n  const { plugins = [] } = options\n\n  /**\n   * The core Slate commands.\n   *\n   * @type {Object}\n   */\n\n  const commands = Commands({\n    ...AtRange,\n    ...ByPath,\n    ...OnHistory,\n    ...OnSelection,\n    ...OnValue,\n    ...WithIntent,\n  })\n\n  /**\n   * The core Slate queries.\n   *\n   * @type {Object}\n   */\n\n  const queries = Queries({\n    isAtomic: () => false,\n    isVoid: () => false,\n  })\n\n  /**\n   * The core Slate schema.\n   *\n   * @type {Object}\n   */\n\n  const schema = Schema({\n    rules: [\n      // Only allow block nodes in documents.\n      {\n        match: { object: 'document' },\n        nodes: [\n          {\n            match: { object: 'block' },\n          },\n        ],\n      },\n\n      // Only allow block nodes or inline and text nodes in blocks.\n      {\n        match: {\n          object: 'block',\n          first: { object: 'block' },\n        },\n        nodes: [\n          {\n            match: { object: 'block' },\n          },\n        ],\n      },\n      {\n        match: {\n          object: 'block',\n          first: [{ object: 'inline' }, { object: 'text' }],\n        },\n        nodes: [\n          {\n            match: [{ object: 'inline' }, { object: 'text' }],\n          },\n        ],\n      },\n\n      // Only allow inline and text nodes in inlines.\n      {\n        match: { object: 'inline' },\n        nodes: [{ match: [{ object: 'inline' }, { object: 'text' }] }],\n      },\n\n      // Ensure that block and inline nodes have at least one text child.\n      {\n        match: [{ object: 'block' }, { object: 'inline' }],\n        nodes: [{ min: 1 }],\n        normalize: (editor, error) => {\n          const { code, node } = error\n\n          if (code === 'child_min_invalid' && node.nodes.isEmpty()) {\n            editor.insertNodeByKey(node.key, 0, Text.create())\n          }\n        },\n      },\n\n      // Ensure that inline nodes are surrounded by text nodes.\n      {\n        match: { object: 'block' },\n        first: [{ object: 'block' }, { object: 'text' }],\n        last: [{ object: 'block' }, { object: 'text' }],\n        normalize: (editor, error) => {\n          const { code, node } = error\n          const text = Text.create()\n          let i\n\n          if (code === 'first_child_object_invalid') {\n            i = 0\n          } else if (code === 'last_child_object_invalid') {\n            i = node.nodes.size\n          } else {\n            return\n          }\n\n          editor.insertNodeByKey(node.key, i, text)\n        },\n      },\n      {\n        match: { object: 'inline' },\n        first: [{ object: 'block' }, { object: 'text' }],\n        last: [{ object: 'block' }, { object: 'text' }],\n        previous: [{ object: 'block' }, { object: 'text' }],\n        next: [{ object: 'block' }, { object: 'text' }],\n        normalize: (editor, error) => {\n          const { code, node, index } = error\n          const text = Text.create()\n          let i\n\n          if (code === 'first_child_object_invalid') {\n            i = 0\n          } else if (code === 'last_child_object_invalid') {\n            i = node.nodes.size\n          } else if (code === 'previous_sibling_object_invalid') {\n            i = index\n          } else if (code === 'next_sibling_object_invalid') {\n            i = index + 1\n          } else {\n            return\n          }\n\n          editor.insertNodeByKey(node.key, i, text)\n        },\n      },\n\n      // Merge adjacent text nodes with the same marks.\n      {\n        match: { object: 'text' },\n        next: (next, match) => {\n          return next.object !== 'text' || !match.marks.equals(next.marks)\n        },\n        normalize: (editor, error) => {\n          const { code, next } = error\n\n          if (code === 'next_sibling_invalid') {\n            editor.mergeNodeByKey(next.key)\n          }\n        },\n      },\n\n      // Remove extra adjacent empty text nodes.\n      {\n        match: { object: 'text' },\n        previous: prev => {\n          return prev.object !== 'text' || prev.text !== ''\n        },\n        next: next => {\n          return next.object !== 'text' || next.text !== ''\n        },\n        normalize: (editor, error) => {\n          const { code, next, previous } = error\n\n          if (code === 'next_sibling_invalid') {\n            editor.removeNodeByKey(next.key)\n          } else if (code === 'previous_sibling_invalid') {\n            editor.removeNodeByKey(previous.key)\n          }\n        },\n      },\n    ],\n  })\n\n  /**\n   * Return the plugins.\n   *\n   * @type {Array}\n   */\n\n  return [schema, ...plugins, commands, queries]\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default CorePlugin\n","import Debug from 'debug'\nimport invariant from 'tiny-invariant'\nimport isPlainObject from 'is-plain-object'\nimport warning from 'tiny-warning'\nimport { List } from 'immutable'\n\nimport CommandsPlugin from '../plugins/commands'\nimport CorePlugin from '../plugins/core'\nimport Operation from '../models/operation'\nimport PathUtils from '../utils/path-utils'\nimport QueriesPlugin from '../plugins/queries'\nimport SchemaPlugin from '../plugins/schema'\nimport Value from '../models/value'\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nconst debug = Debug('slate:editor')\n\n/**\n * Editor.\n *\n * @type {Editor}\n */\n\nclass Editor {\n  /**\n   * Create a new `Editor` with `attrs`.\n   *\n   * @param {Object} attrs\n   * @param {Object} options\n   */\n\n  constructor(attrs = {}, options = {}) {\n    const { controller = this, construct = true } = options\n    const {\n      onChange = () => {},\n      plugins = [],\n      readOnly = false,\n      value = Value.create(),\n    } = attrs\n\n    this.controller = controller\n    this.middleware = {}\n    this.onChange = onChange\n    this.operations = List()\n    this.readOnly = null\n    this.value = null\n\n    this.tmp = {\n      dirty: [],\n      flushing: false,\n      merge: null,\n      normalize: true,\n      save: true,\n    }\n\n    const core = CorePlugin({ plugins })\n    registerPlugin(this, core)\n\n    if (construct) {\n      this.run('onConstruct')\n      this.setReadOnly(readOnly)\n      this.setValue(value, options)\n    }\n  }\n\n  /**\n   * Apply an `operation` to the editor, updating its value.\n   *\n   * @param {Operation|Object} operation\n   * @return {Editor}\n   */\n\n  applyOperation(operation) {\n    const { operations, controller } = this\n    let value = this.value\n\n    // Add in the current `value` in case the operation was serialized.\n    if (isPlainObject(operation)) {\n      operation = { ...operation, value }\n    }\n\n    operation = Operation.create(operation)\n\n    // Save the operation into the history. Since `save` is a command, we need\n    // to do it without normalizing, since it would have side effects.\n    this.withoutNormalizing(() => {\n      controller.save(operation)\n      value = this.value\n    })\n\n    // Apply the operation to the value.\n    debug('apply', { operation })\n    this.value = operation.apply(value)\n    this.operations = operations.push(operation)\n\n    // Get the paths of the affected nodes, and mark them as dirty.\n    const newDirtyPaths = getDirtyPaths(operation)\n\n    const dirty = this.tmp.dirty.map(path => {\n      path = PathUtils.create(path)\n      const transformed = PathUtils.transform(path, operation)\n      return transformed.toArray()\n    })\n\n    const pathIndex = {}\n    const dirtyPaths = Array.prototype.concat.apply(newDirtyPaths, dirty)\n    this.tmp.dirty = []\n\n    // PERF: De-dupe the paths so we don't do extra normalization.\n    dirtyPaths.forEach(dirtyPath => {\n      const key = dirtyPath.join(',')\n\n      if (!pathIndex[key]) {\n        this.tmp.dirty.push(dirtyPath)\n      }\n\n      pathIndex[key] = true\n    })\n\n    // If we're not already, queue the flushing process on the next tick.\n    if (!this.tmp.flushing) {\n      this.tmp.flushing = true\n      Promise.resolve().then(() => this.flush())\n    }\n\n    return controller\n  }\n\n  /**\n   * Flush the editor's current change.\n   *\n   * @return {Editor}\n   */\n\n  flush() {\n    this.run('onChange')\n    const { value, operations, controller } = this\n    const change = { value, operations }\n    this.operations = List()\n    this.tmp.flushing = false\n    this.onChange(change)\n    return controller\n  }\n\n  /**\n   * Trigger a command by `type` with `...args`.\n   *\n   * @param {String|Function} type\n   * @param {Any} ...args\n   * @return {Editor}\n   */\n\n  command(type, ...args) {\n    const { controller } = this\n\n    if (typeof type === 'function') {\n      type(controller, ...args)\n      normalizeDirtyPaths(this)\n      return controller\n    }\n\n    debug('command', { type, args })\n    const obj = { type, args }\n    this.run('onCommand', obj)\n    normalizeDirtyPaths(this)\n    return controller\n  }\n\n  /**\n   * Checks if a command by `type` has been registered.\n   *\n   * @param {String} type\n   * @return {Boolean}\n   */\n\n  hasCommand(type) {\n    const { controller } = this\n    const has = type in controller && controller[type].__command\n\n    return has\n  }\n\n  /**\n   * Checks if a query by `type` has been registered.\n   *\n   * @param {String} type\n   * @return {Boolean}\n   */\n\n  hasQuery(type) {\n    const { controller } = this\n    const has = type in controller && controller[type].__query\n\n    return has\n  }\n\n  /**\n   * Normalize all of the nodes in the document from scratch.\n   *\n   * @return {Editor}\n   */\n\n  normalize() {\n    const { value, controller } = this\n    let { document } = value\n    const table = document.getKeysToPathsTable()\n    const paths = Object.values(table).map(PathUtils.create)\n    this.tmp.dirty = this.tmp.dirty.concat(paths)\n    normalizeDirtyPaths(this)\n\n    const { selection } = value\n    document = value.document\n\n    if (selection.isUnset && document.nodes.size) {\n      controller.moveToStartOfDocument()\n    }\n\n    return controller\n  }\n\n  /**\n   * Ask a query by `type` with `...args`.\n   *\n   * @param {String|Function} type\n   * @param {Any} ...args\n   * @return {Any}\n   */\n\n  query(type, ...args) {\n    const { controller } = this\n\n    if (typeof type === 'function') {\n      return type(controller, ...args)\n    }\n\n    debug('query', { type, args })\n    const obj = { type, args }\n    return this.run('onQuery', obj)\n  }\n\n  /**\n   * Register a command `type` with the editor.\n   *\n   * @param {String} type\n   * @return {Editor}\n   */\n\n  registerCommand(type) {\n    const { controller } = this\n\n    if (type in controller && controller[type].__command) {\n      return controller\n    }\n\n    invariant(\n      !(type in controller),\n      `You cannot register a \\`${type}\\` command because it would overwrite an existing property of the \\`Editor\\`.`\n    )\n\n    const method = (...args) => this.command(type, ...args)\n    controller[type] = method\n    method.__command = true\n    return controller\n  }\n\n  /**\n   * Register a query `type` with the editor.\n   *\n   * @param {String} type\n   * @return {Editor}\n   */\n\n  registerQuery(type) {\n    const { controller } = this\n\n    if (type in controller && controller[type].__query) {\n      return controller\n    }\n\n    invariant(\n      !(type in controller),\n      `You cannot register a \\`${type}\\` query because it would overwrite an existing property of the \\`Editor\\`.`\n    )\n\n    const method = (...args) => this.query(type, ...args)\n    controller[type] = method\n    method.__query = true\n    return controller\n  }\n\n  /**\n   * Run through the middleware stack by `key` with `args`.\n   *\n   * @param {String} key\n   * @param {Any} ...args\n   * @return {Any}\n   */\n\n  run(key, ...args) {\n    const { controller, middleware } = this\n    const fns = middleware[key] || []\n    let i = 0\n\n    function next(...overrides) {\n      const fn = fns[i++]\n      if (!fn) return\n\n      if (overrides.length) {\n        args = overrides\n      }\n\n      const ret = fn(...args, controller, next)\n      return ret\n    }\n\n    Object.defineProperty(next, 'change', {\n      get() {\n        invariant(\n          false,\n          'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.'\n        )\n      },\n    })\n\n    Object.defineProperty(next, 'onChange', {\n      get() {\n        invariant(\n          false,\n          'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.'\n        )\n      },\n    })\n\n    Object.defineProperty(next, 'props', {\n      get() {\n        invariant(\n          false,\n          'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.'\n        )\n      },\n    })\n\n    Object.defineProperty(next, 'schema', {\n      get() {\n        invariant(\n          false,\n          'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.'\n        )\n      },\n    })\n\n    Object.defineProperty(next, 'stack', {\n      get() {\n        invariant(\n          false,\n          'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.'\n        )\n      },\n    })\n\n    return next()\n  }\n\n  /**\n   * Set the `readOnly` flag.\n   *\n   * @param {Boolean} readOnly\n   * @return {Editor}\n   */\n\n  setReadOnly(readOnly) {\n    this.readOnly = readOnly\n    return this\n  }\n\n  /**\n   * Set the editor's `value`.\n   *\n   * @param {Value} value\n   * @param {Options} options\n   * @return {Editor}\n   */\n\n  setValue(value, options = {}) {\n    const { normalize = value !== this.value } = options\n    this.value = value\n\n    if (normalize) {\n      this.normalize()\n    }\n\n    return this\n  }\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, deferring\n   * normalization until after the function has finished executing.\n   *\n   * @param {Function} fn\n   * @return {Editor}\n   */\n\n  withoutNormalizing(fn) {\n    const { controller } = this\n    const value = this.tmp.normalize\n    this.tmp.normalize = false\n    fn(controller)\n    this.tmp.normalize = value\n    normalizeDirtyPaths(this)\n    return controller\n  }\n\n  /**\n   * Deprecated.\n   */\n\n  get editor() {\n    warning(\n      false,\n      \"As of Slate 0.43 the `change` object has been replaced with `editor`, so you don't need to access `change.editor`.\"\n    )\n\n    return this.controller\n  }\n\n  change(fn, ...args) {\n    warning(\n      false,\n      'As of Slate 0.43 the `change` object has been replaced with `editor`, so the `editor.change()` method is deprecated.`'\n    )\n\n    fn(this.controller, ...args)\n  }\n\n  call(fn, ...args) {\n    warning(\n      false,\n      'As of Slate 0.43 the `editor.call(fn)` method has been deprecated, please use `editor.command(fn)` instead.'\n    )\n\n    fn(this.controller, ...args)\n    return this.controller\n  }\n\n  applyOperations(operations) {\n    warning(\n      false,\n      'As of Slate 0.43 the `applyOperations` method is deprecated, please apply each operation in a loop instead.'\n    )\n\n    operations.forEach(op => this.applyOperation(op))\n    return this.controller\n  }\n\n  setOperationFlag(key, value) {\n    warning(\n      false,\n      'As of slate@0.41 the `change.setOperationFlag` method has been deprecated.'\n    )\n\n    this.tmp[key] = value\n    return this\n  }\n\n  getFlag(key, options = {}) {\n    warning(\n      false,\n      'As of slate@0.41 the `change.getFlag` method has been deprecated.'\n    )\n\n    return options[key] !== undefined ? options[key] : this.tmp[key]\n  }\n\n  unsetOperationFlag(key) {\n    warning(\n      false,\n      'As of slate@0.41 the `change.unsetOperationFlag` method has been deprecated.'\n    )\n\n    delete this.tmp[key]\n    return this\n  }\n\n  withoutNormalization(fn) {\n    warning(\n      false,\n      'As of slate@0.41 the `change.withoutNormalization` helper has been renamed to `change.withoutNormalizing`.'\n    )\n\n    return this.withoutNormalizing(fn)\n  }\n}\n\n/**\n * Get the \"dirty\" paths for a given `operation`.\n *\n * @param {Operation} operation\n * @return {Array}\n */\n\nfunction getDirtyPaths(operation) {\n  const { type, node, path, newPath } = operation\n\n  switch (type) {\n    case 'add_mark':\n    case 'insert_text':\n    case 'remove_mark':\n    case 'remove_text':\n    case 'set_mark':\n    case 'set_node': {\n      const ancestors = PathUtils.getAncestors(path).toArray()\n      return [...ancestors, path]\n    }\n\n    case 'insert_node': {\n      const table = node.getKeysToPathsTable()\n      const paths = Object.values(table).map(p => path.concat(p))\n      const ancestors = PathUtils.getAncestors(path).toArray()\n      return [...ancestors, path, ...paths]\n    }\n\n    case 'split_node': {\n      const ancestors = PathUtils.getAncestors(path).toArray()\n      const nextPath = PathUtils.increment(path)\n      return [...ancestors, path, nextPath]\n    }\n\n    case 'merge_node': {\n      const ancestors = PathUtils.getAncestors(path).toArray()\n      const previousPath = PathUtils.decrement(path)\n      return [...ancestors, previousPath]\n    }\n\n    case 'move_node': {\n      if (PathUtils.isEqual(path, newPath)) {\n        return []\n      }\n\n      const oldAncestors = PathUtils.getAncestors(path).reduce((arr, p) => {\n        arr.push(...PathUtils.transform(p, operation).toArray())\n        return arr\n      }, [])\n\n      const newAncestors = PathUtils.getAncestors(newPath).reduce((arr, p) => {\n        arr.push(...PathUtils.transform(p, operation).toArray())\n        return arr\n      }, [])\n\n      return [...oldAncestors, ...newAncestors]\n    }\n\n    case 'remove_node': {\n      const ancestors = PathUtils.getAncestors(path).toArray()\n      return [...ancestors]\n    }\n\n    default: {\n      return []\n    }\n  }\n}\n\n/**\n * Normalize any new \"dirty\" paths that have been added to the change.\n *\n * @param {Editor}\n */\n\nfunction normalizeDirtyPaths(editor) {\n  if (!editor.tmp.normalize) {\n    return\n  }\n\n  if (!editor.tmp.dirty.length) {\n    return\n  }\n\n  editor.withoutNormalizing(() => {\n    while (editor.tmp.dirty.length) {\n      const path = editor.tmp.dirty.pop()\n      normalizeNodeByPath(editor, path)\n    }\n  })\n}\n\n/**\n * Normalize the node at a specific `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\nfunction normalizeNodeByPath(editor, path) {\n  const { controller } = editor\n  let { value } = editor\n  let { document } = value\n  let node = document.assertNode(path)\n  let iterations = 0\n  const max = 100 + (node.object === 'text' ? 1 : node.nodes.size)\n\n  while (node) {\n    const fn = node.normalize(controller)\n\n    if (!fn) {\n      break\n    }\n\n    // Run the normalize `fn` to fix the node.\n    fn(controller)\n\n    // Attempt to re-find the node by path, or by key if it has changed\n    // locations in the tree continue iterating.\n    value = editor.value\n    document = value.document\n    const { key } = node\n    let found = document.getDescendant(path)\n\n    if (found && found.key === key) {\n      node = found\n    } else {\n      found = document.getDescendant(key)\n\n      if (found) {\n        node = found\n        path = document.getPath(key)\n      } else {\n        // If it no longer exists by key, it was removed, so we're done.\n        break\n      }\n    }\n\n    // Increment the iterations counter, and check to make sure that we haven't\n    // exceeded the max. Without this check, it's easy for the `normalize`\n    // function of a schema rule to be written incorrectly and for an infinite\n    // invalid loop to occur.\n    iterations++\n\n    if (iterations > max) {\n      throw new Error(\n        'A schema rule could not be normalized after sufficient iterations. This is usually due to a `rule.normalize` or `plugin.normalizeNode` function of a schema being incorrectly written, causing an infinite loop.'\n      )\n    }\n  }\n}\n\n/**\n * Register a `plugin` with the editor.\n *\n * @param {Editor} editor\n * @param {Object|Array|Null} plugin\n */\n\nfunction registerPlugin(editor, plugin) {\n  if (Array.isArray(plugin)) {\n    plugin.forEach(p => registerPlugin(editor, p))\n    return\n  }\n\n  if (plugin == null) {\n    return\n  }\n\n  const { commands, queries, schema, ...rest } = plugin\n\n  if (commands) {\n    const commandsPlugin = CommandsPlugin(commands)\n    registerPlugin(editor, commandsPlugin)\n  }\n\n  if (queries) {\n    const queriesPlugin = QueriesPlugin(queries)\n    registerPlugin(editor, queriesPlugin)\n  }\n\n  if (schema) {\n    const schemaPlugin = SchemaPlugin(schema)\n    registerPlugin(editor, schemaPlugin)\n  }\n\n  for (const key in rest) {\n    const fn = rest[key]\n    const middleware = (editor.middleware[key] = editor.middleware[key] || [])\n    middleware.push(fn)\n  }\n}\n\n/**\n * Export.\n *\n * @type {Editor}\n */\n\nexport default Editor\n","import isPlainObject from 'is-plain-object'\nimport warning from 'tiny-warning'\nimport { List, Record, Set } from 'immutable'\n\nimport Mark from './mark'\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nconst DEFAULTS = {\n  marks: undefined,\n  text: undefined,\n}\n\n/**\n * Leaf.\n *\n * @type {Leaf}\n */\n\nclass Leaf extends Record(DEFAULTS) {\n  /**\n   * Create a new `Leaf` with `attrs`.\n   *\n   * @param {Object|Leaf} attrs\n   * @return {Leaf}\n   */\n\n  static create(attrs = {}) {\n    warning(false, 'As of slate@0.47 the `Leaf` model is deprecated.')\n\n    if (Leaf.isLeaf(attrs)) {\n      return attrs\n    }\n\n    if (typeof attrs === 'string') {\n      attrs = { text: attrs }\n    }\n\n    if (isPlainObject(attrs)) {\n      return Leaf.fromJSON(attrs)\n    }\n\n    throw new Error(\n      `\\`Leaf.create\\` only accepts objects, strings or leaves, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a valid List of `Leaf` from `leaves`\n   *\n   * @param {List<Leaf>} leaves\n   * @return {List<Leaf>}\n   */\n\n  static createLeaves(leaves) {\n    if (leaves.size <= 1) return leaves\n\n    let invalid = false\n\n    // TODO: we can make this faster with [List] and then flatten\n    const result = List().withMutations(cache => {\n      // Search from the leaves left end to find invalid node;\n      leaves.findLast((leaf, index) => {\n        const firstLeaf = cache.first()\n\n        // If the first leaf of cache exist, check whether the first leaf is connectable with the current leaf\n        if (firstLeaf) {\n          // If marks equals, then the two leaves can be connected\n          if (firstLeaf.marks.equals(leaf.marks)) {\n            invalid = true\n            cache.set(0, firstLeaf.set('text', `${leaf.text}${firstLeaf.text}`))\n            return\n          }\n\n          // If the cached leaf is empty, drop the empty leaf with the upcoming leaf\n          if (firstLeaf.text === '') {\n            invalid = true\n            cache.set(0, leaf)\n            return\n          }\n\n          // If the current leaf is empty, drop the leaf\n          if (leaf.text === '') {\n            invalid = true\n            return\n          }\n        }\n\n        cache.unshift(leaf)\n      })\n    })\n\n    if (!invalid) return leaves\n    return result\n  }\n\n  /**\n   * Split a list of leaves to two lists; if the leaves are valid leaves, the returned leaves are also valid\n   * Corner Cases:\n   *   1. if offset is smaller than 0, then return [List(), leaves]\n   *   2. if offset is bigger than the text length, then return [leaves, List()]\n   *\n   * @param {List<Leaf> leaves\n   * @return {Array<List<Leaf>>}\n   */\n\n  static splitLeaves(leaves, offset) {\n    if (offset < 0) return [List(), leaves]\n\n    if (leaves.size === 0) {\n      return [List(), List()]\n    }\n\n    let endOffset = 0\n    let index = -1\n    let left, right\n\n    leaves.find(leaf => {\n      index++\n      const startOffset = endOffset\n      const { text } = leaf\n      endOffset += text.length\n\n      if (endOffset < offset) return false\n      if (startOffset > offset) return false\n\n      const length = offset - startOffset\n      left = leaf.set('text', text.slice(0, length))\n      right = leaf.set('text', text.slice(length))\n      return true\n    })\n\n    if (!left) return [leaves, List()]\n\n    if (left.text === '') {\n      if (index === 0) {\n        return [List.of(left), leaves]\n      }\n\n      return [leaves.take(index), leaves.skip(index)]\n    }\n\n    if (right.text === '') {\n      if (index === leaves.size - 1) {\n        return [leaves, List.of(right)]\n      }\n\n      return [leaves.take(index + 1), leaves.skip(index + 1)]\n    }\n\n    return [\n      leaves.take(index).push(left),\n      leaves.skip(index + 1).unshift(right),\n    ]\n  }\n\n  /**\n   * Create a `Leaf` list from `attrs`.\n   *\n   * @param {Array<Leaf|Object>|List<Leaf|Object>} attrs\n   * @return {List<Leaf>}\n   */\n\n  static createList(attrs = []) {\n    if (List.isList(attrs) || Array.isArray(attrs)) {\n      const list = new List(attrs.map(Leaf.create))\n      return list\n    }\n\n    throw new Error(\n      `\\`Leaf.createList\\` only accepts arrays or lists, but you passed it: ${attrs}`\n    )\n  }\n\n  /**\n   * Create a `Leaf` from a JSON `object`.\n   *\n   * @param {Object} object\n   * @return {Leaf}\n   */\n\n  static fromJSON(object) {\n    const { text = '', marks = [] } = object\n\n    const leaf = new Leaf({\n      text,\n      marks: Set(marks.map(Mark.fromJSON)),\n    })\n\n    return leaf\n  }\n\n  /**\n   * Check if `any` is a list of leaves.\n   *\n   * @param {Any} any\n   * @return {Boolean}\n   */\n\n  static isLeafList(any) {\n    return List.isList(any) && any.every(item => Leaf.isLeaf(item))\n  }\n\n  /**\n   * Update a `mark` at leaf, replace with newMark\n   *\n   * @param {Mark} mark\n   * @param {Mark} newMark\n   * @returns {Leaf}\n   */\n\n  updateMark(mark, newMark) {\n    const { marks } = this\n    if (newMark.equals(mark)) return this\n    if (!marks.has(mark)) return this\n    const newMarks = marks.withMutations(collection => {\n      collection.remove(mark).add(newMark)\n    })\n    return this.set('marks', newMarks)\n  }\n\n  /**\n   * Add a `mark` to the leaf.\n   *\n   * @param {Mark} mark\n   * @returns {Text}\n   */\n\n  addMark(mark) {\n    const { marks } = this\n    return this.set('marks', marks.add(mark))\n  }\n\n  /**\n   * Add a `set` of marks to the leaf.\n   *\n   * @param {Set<Mark>} set\n   * @returns {Text}\n   */\n\n  addMarks(set) {\n    const { marks } = this\n    return this.set('marks', marks.union(set))\n  }\n\n  /**\n   * Insert a text `string` into the leaf at `offset`.\n   *\n   * @param {Number} offset\n   * @param {String} string\n   * @return {Leaf}\n   */\n\n  insertText(offset, string) {\n    const { text } = this\n    const next = text.slice(0, offset) + string + text.slice(offset)\n    return this.set('text', next)\n  }\n\n  /**\n   * Remove a `mark` from the leaf.\n   *\n   * @param {Mark} mark\n   * @returns {Text}\n   */\n\n  removeMark(mark) {\n    const { marks } = this\n    return this.set('marks', marks.remove(mark))\n  }\n\n  /**\n   * Return a JSON representation of the leaf.\n   *\n   * @return {Object}\n   */\n\n  toJSON() {\n    const object = {\n      object: this.object,\n      text: this.text,\n      marks: this.marks.toArray().map(m => m.toJSON()),\n    }\n\n    return object\n  }\n}\n\n/**\n * Export.\n *\n * @type {Leaf}\n */\n\nexport default Leaf\n","/**\n * Mix in an `Interface` to a `Class`.\n *\n * @param {Class} Interface\n * @param {Class} Class\n */\n\nexport default function mixin(Interface, Classes) {\n  for (const Class of Classes) {\n    // Copy static properties from the interface.\n    for (const name of Object.getOwnPropertyNames(Interface)) {\n      if (Class.hasOwnProperty(name)) continue\n      const desc = Object.getOwnPropertyDescriptor(Interface, name)\n      Object.defineProperty(Class, name, desc)\n    }\n\n    // Copy instance properties from the interface.\n    for (const name of Object.getOwnPropertyNames(Interface.prototype)) {\n      if (Class.prototype.hasOwnProperty(name)) continue\n      const desc = Object.getOwnPropertyDescriptor(Interface.prototype, name)\n      Object.defineProperty(Class.prototype, name, desc)\n    }\n  }\n}\n","import Annotation from '../models/annotation'\nimport Block from '../models/block'\nimport Change from '../models/change'\nimport Decoration from '../models/decoration'\nimport Document from '../models/document'\nimport Editor from '../controllers/editor'\nimport Inline from '../models/inline'\nimport Leaf from '../models/leaf'\nimport Mark from '../models/mark'\nimport Node from '../models/node'\nimport Operation from '../models/operation'\nimport Point from '../models/point'\nimport Range from '../models/range'\nimport Selection from '../models/selection'\nimport Text from '../models/text'\nimport Value from '../models/value'\nimport isObject, { TYPES } from '../utils/is-object'\nimport mixin from '../utils/mixin'\n\n/**\n * A factory for the interface that all Slate objects implement.\n *\n * @type {Function}\n */\n\nfunction create(type) {\n  const TYPE = TYPES[type]\n  const camel = `${type.charAt(0).toUpperCase()}${type.slice(1)}`\n  const is = `is${camel}`\n\n  class ObjectInterface {\n    /**\n     * Return the type of the object.\n     *\n     * @return {String}\n     */\n\n    get object() {\n      return type\n    }\n  }\n\n  ObjectInterface[is] = isObject.bind(null, type)\n  ObjectInterface.prototype[TYPE] = true\n  return ObjectInterface\n}\n\n/**\n * Mix in the object interfaces.\n */\n\nObject.entries({\n  Annotation,\n  Block,\n  Change,\n  Decoration,\n  Document,\n  Editor,\n  Inline,\n  Leaf,\n  Mark,\n  Node,\n  Operation,\n  Point,\n  Range,\n  Selection,\n  Text,\n  Value,\n}).forEach(([camel, obj]) => mixin(create(camel.toLowerCase()), [obj]))\n","import mixin from '../utils/mixin'\nimport Annotation from '../models/annotation'\nimport Block from '../models/block'\nimport Decoration from '../models/decoration'\nimport Document from '../models/document'\nimport Inline from '../models/inline'\nimport Leaf from '../models/leaf'\nimport Mark from '../models/mark'\nimport Node from '../models/node'\nimport Operation from '../models/operation'\nimport Point from '../models/point'\nimport Range from '../models/range'\nimport Selection from '../models/selection'\nimport Text from '../models/text'\nimport Value from '../models/value'\n\n/**\n * The interface that all Slate models implement.\n *\n * @type {Class}\n */\n\nclass ModelInterface {\n  /**\n   * Alias `fromJS`.\n   */\n\n  static fromJS(...args) {\n    return this.fromJSON(...args)\n  }\n\n  /**\n   * Alias `toJS`.\n   */\n\n  toJS(...args) {\n    return this.toJSON(...args)\n  }\n}\n\n/**\n * Mix in the common interface.\n *\n * @param {Record}\n */\n\nmixin(ModelInterface, [\n  Annotation,\n  Block,\n  Decoration,\n  Document,\n  Inline,\n  Leaf,\n  Mark,\n  Node,\n  Operation,\n  Point,\n  Range,\n  Selection,\n  Text,\n  Value,\n])\n","/* global WeakMap, Map, Symbol */\n\n/**\n * GLOBAL: True if memoization should is enabled.\n *\n * @type {Boolean}\n */\n\nlet ENABLED = true\n\n/**\n * The leaf node of a cache tree. Used to support variable argument length. A\n * unique object, so that native Maps will key it by reference.\n *\n * @type {Symbol}\n */\n\nconst LEAF = Symbol('LEAF')\n\n/**\n * The node of a cache tree for a WeakMap to store cache visited by objects\n *\n * @type {Symbol}\n */\n\nconst STORE_KEY = Symbol('STORE_KEY')\n\n/**\n * Values to represent a memoized undefined and null value. Allows efficient value\n * retrieval using Map.get only.\n *\n * @type {Symbol}\n */\n\nconst UNDEFINED = Symbol('undefined')\nconst NULL = Symbol('null')\n\n/**\n * Default value for unset keys in native Maps\n *\n * @type {Undefined}\n */\n\nconst UNSET = undefined\n\n/**\n * Global Store for all cached values\n *\n * @type {WeakMap}\n */\n\nlet memoizeStore = new WeakMap()\n\n/**\n * Memoize all of the `properties` on a `object`.\n *\n * @param {Object} object\n * @param {Array} properties\n * @return {Record}\n */\n\nfunction memoize(object, properties) {\n  for (const property of properties) {\n    const original = object[property]\n\n    if (!original) {\n      throw new Error(`Object does not have a property named \"${property}\".`)\n    }\n\n    object[property] = function(...args) {\n      // If memoization is disabled, call into the original method.\n      if (!ENABLED) return original.apply(this, args)\n\n      if (!memoizeStore.has(this)) {\n        memoizeStore.set(this, {\n          noArgs: {},\n          hasArgs: {},\n        })\n      }\n\n      const { noArgs, hasArgs } = memoizeStore.get(this)\n\n      const takesArguments = args.length !== 0\n\n      let cachedValue\n      let keys\n\n      if (takesArguments) {\n        keys = [property, ...args]\n        cachedValue = getIn(hasArgs, keys)\n      } else {\n        cachedValue = noArgs[property]\n      }\n\n      // If we've got a result already, return it.\n      if (cachedValue !== UNSET) {\n        return cachedValue === UNDEFINED ? undefined : cachedValue\n      }\n\n      // Otherwise calculate what it should be once and cache it.\n      const value = original.apply(this, args)\n      const v = value === undefined ? UNDEFINED : value\n\n      if (takesArguments) {\n        setIn(hasArgs, keys, v)\n      } else {\n        noArgs[property] = v\n      }\n\n      return value\n    }\n  }\n}\n\n/**\n * Get a value at a key path in a tree of Map.\n *\n * If not set, returns UNSET.\n * If the set value is undefined, returns UNDEFINED.\n *\n * @param {Map} map\n * @param {Array} keys\n * @return {Any|UNSET|UNDEFINED}\n */\n\nfunction getIn(map, keys) {\n  for (let key of keys) {\n    if (key === undefined) {\n      key = UNDEFINED\n    } else if (key == null) {\n      key = NULL\n    }\n\n    if (typeof key === 'object') {\n      map = map[STORE_KEY] && map[STORE_KEY].get(key)\n    } else {\n      map = map[key]\n    }\n\n    if (map === UNSET) return UNSET\n  }\n\n  return map[LEAF]\n}\n\n/**\n * Set a value at a key path in a tree of Map, creating Maps on the go.\n *\n * @param {Map} map\n * @param {Array} keys\n * @param {Any} value\n * @return {Map}\n */\n\nfunction setIn(map, keys, value) {\n  let child = map\n\n  for (let key of keys) {\n    if (key === undefined) {\n      key = UNDEFINED\n    } else if (key == null) {\n      key = NULL\n    }\n\n    if (typeof key !== 'object') {\n      if (!child[key]) {\n        child[key] = {}\n      }\n\n      child = child[key]\n      continue\n    }\n\n    if (!child[STORE_KEY]) {\n      child[STORE_KEY] = new WeakMap()\n    }\n\n    if (!child[STORE_KEY].has(key)) {\n      const newChild = {}\n      child[STORE_KEY].set(key, newChild)\n      child = newChild\n      continue\n    }\n\n    child = child[STORE_KEY].get(key)\n  }\n\n  // The whole path has been created, so set the value to the bottom most map.\n  child[LEAF] = value\n  return map\n}\n\n/**\n * In DEV mode, clears the previously memoized values, globally.\n *\n * @return {Void}\n */\n\nfunction resetMemoization() {\n  memoizeStore = new WeakMap()\n}\n\n/**\n * In DEV mode, enable or disable the use of memoize values, globally.\n *\n * @param {Boolean} enabled\n * @return {Void}\n */\n\nfunction useMemoization(enabled) {\n  ENABLED = enabled\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport default memoize\nexport { resetMemoization, useMemoization }\n","import warning from 'tiny-warning'\nimport { List } from 'immutable'\n\nimport mixin from '../utils/mixin'\nimport Block from '../models/block'\nimport Document from '../models/document'\nimport Inline from '../models/inline'\nimport Node from '../models/node'\nimport KeyUtils from '../utils/key-utils'\nimport memoize from '../utils/memoize'\nimport PathUtils from '../utils/path-utils'\nimport Text from '../models/text'\n\n/**\n * The interface that `Document`, `Block` and `Inline` all implement, to make\n * working with the recursive node tree easier.\n *\n * @type {Class}\n */\n\nclass NodeInterface {\n  /**\n   * Get the first text node of a node, or the node itself.\n   *\n   * @return {Node|Null}\n   */\n\n  getFirstText() {\n    if (this.object === 'text') {\n      return this\n    }\n\n    let descendant = null\n\n    const found = this.nodes.find(node => {\n      if (node.object === 'text') return true\n      descendant = node.getFirstText()\n      return !!descendant\n    })\n\n    return descendant || found\n  }\n\n  /**\n   * Get an object mapping all the keys in the node to their paths.\n   *\n   * @return {Object}\n   */\n\n  getKeysToPathsTable() {\n    const ret = {\n      [this.key]: [],\n    }\n\n    if (this.nodes) {\n      this.nodes.forEach((node, i) => {\n        const nested = node.getKeysToPathsTable()\n\n        for (const key in nested) {\n          const path = nested[key]\n\n          warning(\n            !(key in ret),\n            `A node with a duplicate key of \"${key}\" was found! Duplicate keys are not allowed, you should use \\`node.regenerateKey\\` before inserting if you are reusing an existing node.`\n          )\n\n          ret[key] = [i, ...path]\n        }\n      })\n    }\n\n    return ret\n  }\n\n  /**\n   * Get the last text node of a node, or the node itself.\n   *\n   * @return {Node|Null}\n   */\n\n  getLastText() {\n    if (this.object === 'text') {\n      return this\n    }\n\n    let descendant = null\n\n    const found = this.nodes.findLast(node => {\n      if (node.object === 'text') return true\n      descendant = node.getLastText()\n      return descendant\n    })\n\n    return descendant || found\n  }\n\n  /**\n   * Get a node in the tree, or the node itself.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getNode(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (this.object === 'text' && path.size) return null\n    const node = path.size ? this.getDescendant(path) : this\n    return node\n  }\n\n  /**\n   * Find the path to a node.\n   *\n   * @param {String|List} key\n   * @return {List}\n   */\n\n  getPath(key) {\n    // COMPAT: Handle passing in a path, to match other methods.\n    if (List.isList(key)) {\n      return key\n    }\n\n    // COMPAT: Handle a node object by iterating the descendants tree, so that\n    // we avoid using keys for the future.\n    if (Node.isNode(key) && this.descendants) {\n      for (const [node, path] of this.descendants()) {\n        if (key === node) return path\n      }\n    }\n\n    const dict = this.getKeysToPathsTable()\n    const path = dict[key]\n    return path ? List(path) : null\n  }\n\n  /**\n   * Get the concatenated text string of a node.\n   *\n   * @return {String}\n   */\n\n  getText() {\n    if (this.object === 'text') {\n      return this.text\n    }\n\n    const text = this.nodes.reduce((memo, c) => memo + c.text, '')\n    return text\n  }\n\n  /**\n   * Check if a node exists.\n   *\n   * @param {List|String} path\n   * @return {Boolean}\n   */\n\n  hasNode(path) {\n    const node = this.getNode(path)\n    return !!node\n  }\n\n  /**\n   * Normalize the text node with an `editor`.\n   *\n   * @param {Editor} editor\n   * @return {Function|Void}\n   */\n\n  normalize(editor) {\n    const normalizer = editor.run('normalizeNode', this)\n    return normalizer\n  }\n\n  /**\n   * Regenerate the node's key.\n   *\n   * @return {Node}\n   */\n\n  regenerateKey() {\n    const key = KeyUtils.create()\n    const node = this.set('key', key)\n    return node\n  }\n\n  /**\n   * Resolve a path from a path list or key string.\n   *\n   * An `index` can be provided, in which case paths created from a key string\n   * will have the index pushed onto them. This is helpful in cases where you\n   * want to accept either a `path` or a `key, index` combination for targeting\n   * a location in the tree that doesn't exist yet, like when inserting.\n   *\n   * @param {List|String} value\n   * @param {Number} index\n   * @return {List}\n   */\n\n  resolvePath(path, index) {\n    if (typeof path === 'string') {\n      path = this.getPath(path)\n\n      if (index != null) {\n        path = path.concat(index)\n      }\n    } else {\n      path = PathUtils.create(path)\n    }\n\n    return path\n  }\n\n  /**\n   * Validate the node with an `editor`.\n   *\n   * @param {Editor} editor\n   * @return {Error|Void}\n   */\n\n  validate(editor) {\n    const error = editor.run('validateNode', this)\n    return error\n  }\n}\n\n/**\n * Memoize read methods.\n */\n\nmemoize(NodeInterface.prototype, [\n  'getFirstText',\n  'getKeysToPathsTable',\n  'getLastText',\n  'getText',\n  'normalize',\n  'validate',\n])\n\n/**\n * Mix in the node interface.\n */\n\nmixin(NodeInterface, [Block, Document, Inline, Text])\n","export default typeof global !== \"undefined\" ? global :\n            typeof self !== \"undefined\" ? self :\n            typeof window !== \"undefined\" ? window : {}\n","export default function identity() {\n  return true\n}\n","import getDirection from 'direction'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport { List, OrderedSet, Set } from 'immutable'\n\nimport Annotation from '../models/annotation'\nimport Block from '../models/block'\nimport Decoration from '../models/decoration'\nimport Document from '../models/document'\nimport Inline from '../models/inline'\nimport Operation from '../models/operation'\nimport PathUtils from '../utils/path-utils'\nimport Point from '../models/point'\nimport Range from '../models/range'\nimport Selection from '../models/selection'\nimport Value from '../models/value'\nimport identity from '../utils/identity'\nimport memoize from '../utils/memoize'\nimport mixin from '../utils/mixin'\n\n/**\n * The interface that `Document`, `Block` and `Inline` all implement, to make\n * working with the recursive node tree easier.\n *\n * @type {Class}\n */\n\nclass ElementInterface {\n  /**\n   * Get the concatenated text of the node.\n   *\n   * @return {String}\n   */\n\n  get text() {\n    return this.getText()\n  }\n\n  /**\n   * Add `mark` to text at `path`.\n   *\n   * @param {List|String} path\n   * @param {Mark} mark\n   * @return {Node}\n   */\n\n  addMark(path, mark) {\n    path = this.resolvePath(path)\n    let node = this.assertDescendant(path)\n    node = node.addMark(mark)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Create an iteratable for all of the ancestors of the node.\n   *\n   * @return {Iterable}\n   */\n\n  ancestors(path) {\n    const iterable = this.createIterable({\n      path,\n      direction: null,\n      downward: false,\n      includeTargetAncestors: true,\n      includeRoot: true,\n    })\n\n    return iterable\n  }\n\n  /**\n   * Create an iteratable for all of the blocks of a node with `options`.\n   *\n   * @param {Options}\n   * @return {Iterable}\n   */\n\n  blocks(options = {}) {\n    const { onlyLeaves, onlyRoots, onlyTypes, match, ...rest } = options\n    const iterable = this.descendants({\n      includeDocument: false,\n      includeInlines: false,\n      includeTexts: false,\n      ...rest,\n      match: (node, path) => {\n        if (onlyTypes && !onlyTypes.includes(node.type)) {\n          return false\n        } else if (onlyRoots && path.size !== 1) {\n          return false\n        } else if (onlyLeaves && !node.isLeafBlock()) {\n          return false\n        } else if (match && !match(node, path)) {\n          return false\n        } else {\n          return true\n        }\n      },\n    })\n\n    return iterable\n  }\n\n  /**\n   * Create an annotation with `properties` relative to the node.\n   *\n   * @param {Object|Annotation} properties\n   * @return {Annotation}\n   */\n\n  createAnnotation(properties) {\n    properties = Annotation.createProperties(properties)\n    const annotation = this.resolveAnnotation(properties)\n    return annotation\n  }\n\n  /**\n   * Create a decoration with `properties` relative to the node.\n   *\n   * @param {Object|Decoration} properties\n   * @return {Decoration}\n   */\n\n  createDecoration(properties) {\n    properties = Decoration.createProperties(properties)\n    const decoration = this.resolveDecoration(properties)\n    return decoration\n  }\n\n  /**\n   * Create an iteratable function starting at `target` path with `options`.\n   *\n   * @param {Object} options (optional)\n   * @return {Function}\n   */\n\n  createIterable(options = {}) {\n    const {\n      direction = 'forward',\n      downward = true,\n      upward = true,\n      includeBlocks = true,\n      includeDocument = true,\n      includeInlines = true,\n      includeRoot = false,\n      includeTarget = !!options.range,\n      includeTargetAncestors = false,\n      includeTexts = true,\n      match = null,\n    } = options\n\n    const root = this\n    let targetPath = null\n    let targetRange = null\n\n    // You can iterate over either a range or a path, but not both.\n    if (options.range) {\n      targetRange = root.resolveRange(options.range)\n      targetPath = root.resolvePath(targetRange.start.path)\n    } else if (options.path) {\n      targetPath = root.resolvePath(options.path)\n    }\n\n    const targetNode = targetPath && root.assertNode(targetPath)\n    const NativeSet = typeof window === 'undefined' ? global.Set : window.Set\n\n    // Return an object that implements the iterable interface.\n    return {\n      [Symbol.iterator]() {\n        const visited = new NativeSet()\n        const startPath = targetRange && targetRange.start.path\n        const endPath = targetRange && targetRange.end.path\n        let path = targetPath\n        let node = targetNode\n        let includedTarget = false\n        let includedStart = false\n        let includingStart = false\n\n        const result = () => {\n          // When these are nulled out we've finished iterating.\n          if (!path || !node) {\n            return { done: true }\n          }\n\n          // We often don't want to include the root node itself.\n          if (!includeRoot && node === root) {\n            return next()\n          }\n\n          if (!includeBlocks && node.object === 'block') {\n            return next()\n          }\n\n          if (!includeDocument && node.object === 'document') {\n            return next()\n          }\n\n          if (!includeInlines && node.object === 'inline') {\n            return next()\n          }\n\n          if (!includeTexts && node.object === 'text') {\n            return next()\n          }\n\n          if (match && !match(node, path)) {\n            return next()\n          }\n\n          return { value: [node, path], done: false }\n        }\n\n        const next = () => {\n          if (!path || !node) {\n            return result()\n          }\n\n          // When iterating over a range, we need to include the specific\n          // ancestors in the start path of the range manually.\n          if (startPath && !includedStart) {\n            if (!includingStart) {\n              includingStart = true\n              path = PathUtils.create([])\n              node = root\n              return result()\n            }\n\n            if (path.size === startPath.size - 1) {\n              includedStart = true\n              path = targetPath\n              node = targetNode\n              return next()\n            }\n\n            path = startPath.slice(0, path.size + 1)\n            node = root.assertNode(path)\n            return result()\n          }\n\n          // Sometimes we want to include the target itself.\n          if (includeTarget && !includedTarget) {\n            includedTarget = true\n            return result()\n          }\n\n          // When iterating over a range, if we get to the end path then exit.\n          if (endPath && path.equals(endPath)) {\n            node = null\n            path = null\n            return next()\n          }\n\n          // If we're allowed to go downward, and we haven't decsended yet, do so.\n          if (downward && node.nodes && node.nodes.size && !visited.has(node)) {\n            visited.add(node)\n            const nextIndex = direction === 'forward' ? 0 : node.nodes.size - 1\n            path = path.push(nextIndex)\n            node = root.assertNode(path)\n            return result()\n          }\n\n          // If we're going forward...\n          if (direction === 'forward') {\n            const newPath = PathUtils.increment(path)\n            const newNode = root.getNode(newPath)\n\n            if (newNode) {\n              path = newPath\n              node = newNode\n              return result()\n            }\n          }\n\n          // If we're going backward...\n          if (direction === 'backward' && path.last() !== 0) {\n            const newPath = PathUtils.decrement(path)\n            const newNode = root.getNode(newPath)\n\n            if (newNode) {\n              path = newPath\n              node = newNode\n              return result()\n            }\n          }\n\n          // If we're going upward...\n          if (upward && path.size) {\n            path = PathUtils.lift(path)\n            node = root.assertNode(path)\n\n            // Sometimes we'll have already visited the node on the way down\n            // so we don't want to double count it.\n            if (visited.has(node)) {\n              return next()\n            }\n\n            visited.add(node)\n\n            // If ancestors of the target node shouldn't be included, skip them.\n            if (!includeTargetAncestors) {\n              return next()\n            } else {\n              return result()\n            }\n          }\n\n          path = null\n          node = null\n          return next()\n        }\n\n        return { next }\n      },\n    }\n  }\n\n  /**\n   * Create a point with `properties` relative to the node.\n   *\n   * @param {Object|Point} properties\n   * @return {Range}\n   */\n\n  createPoint(properties) {\n    properties = Point.createProperties(properties)\n    const point = this.resolvePoint(properties)\n    return point\n  }\n\n  /**\n   * Create a range with `properties` relative to the node.\n   *\n   * @param {Object|Range} properties\n   * @return {Range}\n   */\n\n  createRange(properties) {\n    properties = Range.createProperties(properties)\n    const range = this.resolveRange(properties)\n    return range\n  }\n\n  /**\n   * Create a selection with `properties` relative to the node.\n   *\n   * @param {Object|Selection} properties\n   * @return {Selection}\n   */\n\n  createSelection(properties) {\n    properties = Selection.createProperties(properties)\n    const selection = this.resolveSelection(properties)\n    return selection\n  }\n\n  /**\n   * Create an iteratable for all of the descendants of the node.\n   *\n   * @param {Object} options\n   * @return {Iterable}\n   */\n\n  descendants(options) {\n    const iterable = this.createIterable({ path: [], ...options })\n    return iterable\n  }\n\n  /**\n   * Find all of the descendants that match a `predicate`.\n   *\n   * @param {Function} predicate\n   * @return {List<Node>}\n   */\n\n  filterDescendants(predicate = identity) {\n    const matches = []\n\n    for (const [node, path] of this.descendants()) {\n      if (predicate(node, path)) {\n        matches.push(node)\n      }\n    }\n\n    return List(matches)\n  }\n\n  /**\n   * Find the first descendant that matches a `predicate`.\n   *\n   * @param {Function} predicate\n   * @return {Node|Null}\n   */\n\n  findDescendant(predicate = identity) {\n    for (const [node, path] of this.descendants()) {\n      if (predicate(node, path)) {\n        return node\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Iterate over all descendants, breaking if `predicate` returns false.\n   *\n   * @param {Function} predicate\n   */\n\n  forEachDescendant(predicate = identity) {\n    for (const next of this.descendants()) {\n      const ret = predicate(...next)\n\n      if (ret === false) {\n        return\n      }\n    }\n  }\n\n  /**\n   * Get a set of the active marks in a `range`. Active marks are marks that are\n   * on every text node in a given range. This is a common distinction for\n   * highlighting toolbar buttons for example.\n   *\n   * TODO: this method needs to be cleaned up, it's very hard to follow and\n   * probably doing unnecessary work.\n   *\n   * @param {Range} range\n   * @return {Set<Mark>}\n   */\n\n  getActiveMarksAtRange(range) {\n    range = this.resolveRange(range)\n\n    if (range.isUnset) {\n      return Set()\n    }\n\n    if (range.isCollapsed) {\n      const { start } = range\n      return this.getInsertMarksAtPoint(start)\n    }\n\n    const { start, end } = range\n    let startPath = start.path\n    let startOffset = start.offset\n    let endPath = end.path\n    let endOffset = end.offset\n    let startText = this.getDescendant(startPath)\n    let endText = this.getDescendant(endPath)\n\n    if (!startPath.equals(endPath)) {\n      while (!startPath.equals(endPath) && endOffset === 0) {\n        ;[[endText, endPath]] = this.texts({\n          path: endPath,\n          direction: 'backward',\n        })\n\n        endOffset = endText.text.length\n      }\n\n      while (\n        !startPath.equals(endPath) &&\n        startOffset === startText.text.length\n      ) {\n        ;[[startText, startPath]] = this.texts({ path: startPath })\n        startOffset = 0\n      }\n    }\n\n    if (startPath.equals(endPath)) {\n      return startText.marks\n    }\n\n    const startMarks = startText.marks\n\n    // PERF: if start marks is empty we can return early.\n    if (startMarks.size === 0) {\n      return Set()\n    }\n\n    const endMarks = endText.marks\n    let marks = startMarks.intersect(endMarks)\n\n    // If marks is already empty, the active marks is empty\n    if (marks.size === 0) {\n      return marks\n    }\n\n    ;[[startText, startPath]] = this.texts({ path: startPath })\n\n    while (!startPath.equals(endPath)) {\n      if (startText.text.length !== 0) {\n        marks = marks.intersect(startText.marks)\n\n        if (marks.size === 0) {\n          return Set()\n        }\n      }\n\n      ;[[startText, startPath]] = this.texts({ path: startPath })\n    }\n\n    return marks\n  }\n\n  /**\n   * Get a list of the ancestors of a descendant.\n   *\n   * @param {List|String} path\n   * @return {List<Node>|Null}\n   */\n\n  getAncestors(path) {\n    const iterable = this.ancestors(path)\n    const array = Array.from(iterable, ([node]) => node).reverse()\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Get the leaf block descendants of the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getBlocks() {\n    const iterable = this.blocks({ onlyLeaves: true })\n    const array = Array.from(iterable, ([node]) => node)\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Get all of the leaf blocks that match a `type`.\n   *\n   * @param {String} type\n   * @return {List<Node>}\n   */\n\n  getBlocksByType(type) {\n    const iterable = this.blocks({ onlyLeaves: true, onlyTypes: [type] })\n    const array = Array.from(iterable, ([node]) => node)\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Get a child node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getChild(path) {\n    path = this.resolvePath(path)\n\n    if (!path || path.size > 1) {\n      return null\n    }\n\n    const child = this.nodes.get(path.first())\n    return child\n  }\n\n  /**\n   * Get closest parent of node that matches a `predicate`.\n   *\n   * @param {List|String} path\n   * @param {Function} predicate\n   * @return {Node|Null}\n   */\n\n  getClosest(path, predicate) {\n    for (const [n, p] of this.ancestors(path)) {\n      if (predicate(n, p)) {\n        return n\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Get the closest block parent of a node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getClosestBlock(path) {\n    const closest = this.getClosest(path, n => n.object === 'block')\n    return closest\n  }\n\n  /**\n   * Get the closest inline parent of a node by `path`.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getClosestInline(path) {\n    const closest = this.getClosest(path, n => n.object === 'inline')\n    return closest\n  }\n\n  /**\n   * Get the closest void parent of a node by `path`.\n   *\n   * @param {List|String} path\n   * @param {Editor} editor\n   * @return {Node|Null}\n   */\n\n  getClosestVoid(path, editor) {\n    invariant(\n      !Value.isValue(editor),\n      'As of Slate 0.42.0, the `node.getClosestVoid` method takes an `editor` instead of a `value`.'\n    )\n\n    const closest = this.getClosest(path, n => editor.isVoid(n))\n    return closest\n  }\n\n  /**\n   * Get the common ancestor of nodes `a` and `b`.\n   *\n   * @param {List} a\n   * @param {List} b\n   * @return {Node}\n   */\n\n  getCommonAncestor(a, b) {\n    a = this.resolvePath(a)\n    b = this.resolvePath(b)\n\n    if (!a || !b) {\n      return null\n    }\n\n    const path = PathUtils.relate(a, b)\n    const node = this.getNode(path)\n    return node\n  }\n\n  /**\n   * Get the decorations for the node from an `editor`.\n   *\n   * @param {Editor} editor\n   * @return {List}\n   */\n\n  getDecorations(editor) {\n    let decorations = editor.run('decorateNode', this)\n    decorations = Decoration.createList(decorations)\n    return decorations\n  }\n\n  /**\n   * Get the depth of a descendant, with optional `startAt`.\n   *\n   * @param {List|String} path\n   * @param {Number} startAt\n   * @return {Number|Null}\n   */\n\n  getDepth(path, startAt = 1) {\n    path = this.resolvePath(path)\n\n    if (!path) {\n      return null\n    }\n\n    const node = this.getNode(path)\n    const depth = node ? path.size - 1 + startAt : null\n    return depth\n  }\n\n  /**\n   * Get a descendant node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getDescendant(path) {\n    path = this.resolvePath(path)\n\n    if (!path || !path.size) {\n      return null\n    }\n\n    let node = this\n\n    path.forEach(index => {\n      node = node.getIn(['nodes', index])\n      return !!node\n    })\n\n    return node\n  }\n\n  /**\n   * Get all of the descendant nodes in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getDescendantsAtRange(range) {\n    const iterable = this.descendants({ range })\n    const array = Array.from(iterable, ([node]) => node)\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Get a fragment of the node at a `range`.\n   *\n   * @param {Range} range\n   * @return {Document}\n   */\n\n  getFragmentAtRange(range) {\n    range = this.resolveRange(range)\n\n    if (range.isUnset) {\n      return Document.create()\n    }\n\n    const { start, end } = range\n    let node = this\n    let targetPath = end.path\n    let targetPosition = end.offset\n    let side = 'end'\n\n    while (targetPath.size) {\n      const index = targetPath.last()\n      node = node.splitNode(targetPath, targetPosition)\n      targetPosition = index + 1\n      targetPath = PathUtils.lift(targetPath)\n\n      if (!targetPath.size && side === 'end') {\n        targetPath = start.path\n        targetPosition = start.offset\n        side = 'start'\n      }\n    }\n\n    const startIndex = start.path.first() + 1\n    const endIndex = end.path.first() + 2\n    const nodes = node.nodes.slice(startIndex, endIndex)\n    const fragment = Document.create({ nodes })\n    return fragment\n  }\n\n  /**\n   * Get the furthest ancestors of a node that matches a `predicate`.\n   *\n   * @param {Path} path\n   * @param {Function} predicate\n   * @return {Node|Null}\n   */\n\n  getFurthest(path, predicate = identity) {\n    const iterable = this.ancestors(path)\n    const results = Array.from(iterable).reverse()\n\n    for (const [n, p] of results) {\n      if (predicate(n, p)) {\n        return n\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Get the furthest block parent of a node.\n   *\n   * @param {Path} path\n   * @return {Node|Null}\n   */\n\n  getFurthestBlock(path) {\n    const furthest = this.getFurthest(path, n => n.object === 'block')\n    return furthest\n  }\n\n  /**\n   * Get the furthest child ancestor of a node at `path`.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getFurthestChild(path) {\n    path = this.resolvePath(path)\n\n    if (!path || !path.size) {\n      return null\n    }\n\n    const furthest = this.nodes.get(path.first())\n    return furthest\n  }\n\n  /**\n   * Get the furthest inline parent of a node.\n   *\n   * @param {Path} path\n   * @return {Node|Null}\n   */\n\n  getFurthestInline(path) {\n    const furthest = this.getFurthest(path, n => n.object === 'inline')\n    return furthest\n  }\n\n  /**\n   * Get the closest inline nodes for each text node in the node.\n   *\n   * @return {List<Node>}\n   */\n\n  getInlines() {\n    const iterable = this.inlines({ onlyLeaves: true })\n    const array = Array.from(iterable, ([node]) => node)\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Get all of the leaf inline nodes that match a `type`.\n   *\n   * @param {String} type\n   * @return {List<Node>}\n   */\n\n  getInlinesByType(type) {\n    const iterable = this.inlines({ onlyLeaves: true, onlyTypes: [type] })\n    const array = Array.from(iterable, ([node]) => node)\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Get a set of marks that would occur on the next insert at a `point` in the\n   * node. This mimics expected rich text editing behaviors of mark contiuation.\n   *\n   * @param {Point} point\n   * @return {Set<Mark>}\n   */\n\n  getInsertMarksAtPoint(point) {\n    point = this.resolvePoint(point)\n    const { path, offset } = point\n    const text = this.getDescendant(path)\n\n    // PERF: we can exit early if the offset isn't at the start of the node.\n    if (offset !== 0) {\n      return text.marks\n    }\n\n    let blockNode\n    let blockPath\n\n    for (const entry of this.ancestors(path)) {\n      const [n, p] = entry\n\n      if (n.object === 'block') {\n        blockNode = n\n        blockPath = p\n      }\n    }\n\n    const relativePath = PathUtils.drop(path, blockPath.size)\n    const [previous] = blockNode.texts({\n      path: relativePath,\n      direction: 'backward',\n    })\n\n    // If there's no previous text, we're at the start of the block, so use\n    // the current text nodes marks.\n    if (!previous) {\n      return text.marks\n    }\n\n    // Otherwise, continue with the previous text node's marks instead.\n    const [previousText] = previous\n    return previousText.marks\n  }\n\n  /**\n   * Get a set of marks that would occur on the next insert at a `range`.\n   * This mimics expected rich text editing behaviors of mark contiuation.\n   *\n   * @param {Range} range\n   * @return {Set<Mark>}\n   */\n\n  getInsertMarksAtRange(range) {\n    range = this.resolveRange(range)\n    const { start } = range\n\n    if (range.isUnset) {\n      return Set()\n    }\n\n    if (range.isCollapsed) {\n      return this.getInsertMarksAtPoint(start)\n    }\n\n    const text = this.getDescendant(start.path)\n    return text.marks\n  }\n\n  /**\n   * Get the bottom-most block descendants in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getLeafBlocksAtRange(range) {\n    const iterable = this.blocks({ range, onlyLeaves: true })\n    const array = Array.from(iterable, ([node]) => node)\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Get the bottom-most inline nodes for each text node in a `range`.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getLeafInlinesAtRange(range) {\n    const iterable = this.inlines({ range, onlyLeaves: true })\n    const array = Array.from(iterable, ([node]) => node)\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Get an object mapping all the keys in the node to their paths.\n   *\n   * @return {Map}\n   */\n\n  getNodesToPathsMap() {\n    const root = this\n    const map =\n      typeof window === 'undefined' ? new global.Map() : new window.Map()\n\n    map.set(root, PathUtils.create([]))\n\n    root.forEachDescendant((node, path) => {\n      map.set(node, path)\n    })\n\n    return map\n  }\n\n  /**\n   * Get all of the marks for all of the characters of every text node.\n   *\n   * @return {OrderedSet<Mark>}\n   */\n\n  getMarks() {\n    const iterable = this.marks()\n    const array = Array.from(iterable, ([mark]) => mark)\n    return OrderedSet(array)\n  }\n\n  /**\n   * Get a set of the marks in a `range`.\n   *\n   * @param {Range} range\n   * @return {OrderedSet<Mark>}\n   */\n\n  getMarksAtRange(range) {\n    const iterable = this.marks({ range })\n    const array = Array.from(iterable, ([mark]) => mark)\n    return OrderedSet(array)\n  }\n\n  /**\n   * Get all of the marks that match a `type`.\n   *\n   * @param {String} type\n   * @return {OrderedSet<Mark>}\n   */\n\n  getMarksByType(type) {\n    const iterable = this.marks({ onlyTypes: [type] })\n    const array = Array.from(iterable, ([mark]) => mark)\n    return OrderedSet(array)\n  }\n\n  /**\n   * Get the block node after a descendant text node by `path`.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getNextBlock(path) {\n    const [entry] = this.blocks({ path, onlyLeaves: true })\n    const block = entry ? entry[0] : null\n    return block\n  }\n\n  /**\n   * Get the next node in the tree, returning siblings or ancestor siblings.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getNextNode(path) {\n    const iterable = this.createIterable({ path, downward: false })\n    const [entry] = iterable\n    const node = entry ? entry[0] : null\n    return node\n  }\n\n  /**\n   * Get the next sibling of a node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getNextSibling(path) {\n    const [entry] = this.siblings(path)\n    const node = entry ? entry[0] : null\n    return node\n  }\n\n  /**\n   * Get the text node after a descendant text node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getNextText(path) {\n    const [entry] = this.texts({ path })\n    const node = entry ? entry[0] : null\n    return node\n  }\n\n  /**\n   * Get the offset for a descendant text node by `path` or `key`.\n   *\n   * @param {List|string} path\n   * @return {Number}\n   */\n\n  getOffset(path) {\n    path = this.resolvePath(path)\n    this.assertDescendant(path)\n\n    // Calculate the offset of the nodes before the highest child.\n    const index = path.first()\n\n    const offset = this.nodes\n      .slice(0, index)\n      .reduce((memo, n) => memo + n.text.length, 0)\n\n    // Recurse if need be.\n    const ret =\n      path.size === 1\n        ? offset\n        : offset + this.nodes.get(index).getOffset(PathUtils.drop(path))\n\n    return ret\n  }\n\n  /**\n   * Get the offset from a `range`.\n   *\n   * @param {Range} range\n   * @return {Number}\n   */\n\n  getOffsetAtRange(range) {\n    range = this.resolveRange(range)\n\n    if (range.isUnset) {\n      throw new Error('The range cannot be unset to calculcate its offset.')\n    }\n\n    if (range.isExpanded) {\n      throw new Error('The range must be collapsed to calculcate its offset.')\n    }\n\n    const { start } = range\n    const offset = this.getOffset(start.path) + start.offset\n    return offset\n  }\n\n  /**\n   * Get the parent of a descendant node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getParent(path) {\n    path = this.resolvePath(path)\n    if (!path) return null\n    if (!path.size) return null\n    const parentPath = PathUtils.lift(path)\n    const parent = this.getNode(parentPath)\n    return parent\n  }\n\n  /**\n   * Get the block node before a descendant text node by `path`.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getPreviousBlock(path) {\n    const [entry] = this.blocks({\n      path,\n      onlyLeaves: true,\n      direction: 'backward',\n    })\n    const block = entry ? entry[0] : null\n    return block\n  }\n\n  /**\n   * Get the previous node from a node in the tree.\n   *\n   * This will not only check for siblings but instead move up the tree\n   * returning the previous ancestor if no sibling is found.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getPreviousNode(path) {\n    const iterable = this.createIterable({\n      path,\n      downward: false,\n      direction: 'backward',\n    })\n\n    const [entry] = iterable\n    const node = entry ? entry[0] : null\n    return node\n  }\n\n  /**\n   * Get the previous sibling of a node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getPreviousSibling(path) {\n    const [entry] = this.siblings(path, { direction: 'backward' })\n    const node = entry ? entry[0] : null\n    return node\n  }\n\n  /**\n   * Get the text node before a descendant text node.\n   *\n   * @param {List|String} path\n   * @return {Node|Null}\n   */\n\n  getPreviousText(path) {\n    const [entry] = this.texts({ path, direction: 'backward' })\n    const node = entry ? entry[0] : null\n    return node\n  }\n\n  /**\n   * Get only the root block nodes in a `range`.\n   *\n   * @param {Range} range\n   * @return {List}\n   */\n\n  getRootBlocksAtRange(range) {\n    const iterable = this.blocks({ range, onlyRoots: true })\n    const array = Array.from(iterable, ([node]) => node)\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Get only the root inline nodes in a `range`.\n   *\n   * @param {Range} range\n   * @return {List}\n   */\n\n  getRootInlinesAtRange(range) {\n    const iterable = this.inlines({ range, onlyRoots: true })\n    const array = Array.from(iterable, ([node]) => node)\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Get the descendent text node at an `offset`.\n   *\n   * @param {String} offset\n   * @return {Node|Null}\n   */\n\n  getTextAtOffset(offset) {\n    // PERF: Add a few shortcuts for the obvious cases.\n    if (offset === 0) return this.getFirstText()\n    if (offset === this.text.length) return this.getLastText()\n    if (offset < 0 || offset > this.text.length) return null\n\n    let length = 0\n\n    for (const [node] of this.texts()) {\n      length += node.text.length\n\n      if (length > offset) {\n        return node\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Get the direction of the node's text.\n   *\n   * @return {String}\n   */\n\n  getTextDirection() {\n    const dir = getDirection(this.text)\n    return dir === 'neutral' ? null : dir\n  }\n\n  /**\n   * Recursively get all of the child text nodes in order of appearance.\n   *\n   * @return {List<Node>}\n   */\n\n  getTexts() {\n    const iterable = this.texts()\n    const array = Array.from(iterable, ([node]) => node)\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Get all of the text nodes in a `range` as a List.\n   *\n   * @param {Range} range\n   * @return {List<Node>}\n   */\n\n  getTextsAtRange(range) {\n    const iterable = this.texts({ range })\n    const array = Array.from(iterable, ([node]) => node)\n    const list = List(array)\n    return list\n  }\n\n  /**\n   * Check if the node has block children.\n   *\n   * @return {Boolean}\n   */\n\n  hasBlockChildren() {\n    return !!(this.nodes && this.nodes.find(n => n.object === 'block'))\n  }\n\n  /**\n   * Check if a child node exists.\n   *\n   * @param {List|String} path\n   * @return {Boolean}\n   */\n\n  hasChild(path) {\n    const child = this.getChild(path)\n    return !!child\n  }\n\n  /**\n   * Check if a node has inline children.\n   *\n   * @return {Boolean}\n   */\n\n  hasInlineChildren() {\n    return !!(\n      this.nodes &&\n      this.nodes.find(n => n.object === 'inline' || n.object === 'text')\n    )\n  }\n\n  /**\n   * Recursively check if a child node exists.\n   *\n   * @param {List|String} path\n   * @return {Boolean}\n   */\n\n  hasDescendant(path) {\n    const descendant = this.getDescendant(path)\n    return !!descendant\n  }\n\n  /**\n   * Check if a node has a void parent.\n   *\n   * @param {List|String} path\n   * @param {Editor} editor\n   * @return {Boolean}\n   */\n\n  hasVoidParent(path, editor) {\n    invariant(\n      !Value.isValue(editor),\n      'As of Slate 0.42.0, the `node.hasVoidParent` method takes an `editor` instead of a `value`.'\n    )\n\n    const closest = this.getClosestVoid(path, editor)\n    return !!closest\n  }\n\n  /**\n   * Create an iteratable for all of the inlines of a node with `options`.\n   *\n   * @param {Options}\n   * @return {Iterable}\n   */\n\n  inlines(options = {}) {\n    const { onlyLeaves, onlyRoots, onlyTypes, match, ...rest } = options\n    const iterable = this.descendants({\n      includeBlocks: false,\n      includeTexts: false,\n      includeDocument: false,\n      ...rest,\n      match: (node, path) => {\n        if (onlyTypes && !onlyTypes.includes(node.type)) {\n          return false\n        } else if (onlyLeaves && !node.isLeafInline()) {\n          return false\n        } else if (onlyRoots && this.getParent(path).object !== 'block') {\n          return false\n        } else if (match && !match(node, path)) {\n          return false\n        } else {\n          return true\n        }\n      },\n    })\n\n    return iterable\n  }\n\n  /**\n   * Insert a `node`.\n   *\n   * @param {List|String} path\n   * @param {Node} node\n   * @return {Node}\n   */\n\n  insertNode(path, node) {\n    path = this.resolvePath(path)\n    const index = path.last()\n    const parentPath = PathUtils.lift(path)\n    let parent = this.assertNode(parentPath)\n    const nodes = parent.nodes.splice(index, 0, node)\n    parent = parent.set('nodes', nodes)\n    const ret = this.replaceNode(parentPath, parent)\n    return ret\n  }\n\n  /**\n   * Insert `text` at `offset` in node by `path`.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {String} text\n   * @return {Node}\n   */\n\n  insertText(path, offset, text) {\n    path = this.resolvePath(path)\n    let node = this.assertDescendant(path)\n    node = node.insertText(offset, text)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Check whether the node is a leaf block.\n   *\n   * @return {Boolean}\n   */\n\n  isLeafBlock() {\n    if (this.object !== 'block') {\n      return false\n    }\n\n    if (this.nodes.some(n => n.object === 'block')) {\n      return false\n    }\n\n    return true\n  }\n\n  /**\n   * Check whether the node is a leaf inline.\n   *\n   * @return {Boolean}\n   */\n\n  isLeafInline() {\n    if (this.object !== 'inline') {\n      return false\n    }\n\n    if (this.nodes.some(n => n.object === 'inline')) {\n      return false\n    }\n\n    return true\n  }\n\n  /**\n   * Check whether a descendant node is inside a `range` by `path`.\n   *\n   * @param {List|String} path\n   * @param {Range} range\n   * @return {Node}\n   */\n\n  isInRange(path, range) {\n    path = this.resolvePath(path)\n    range = this.resolveRange(range)\n\n    if (range.isUnset) {\n      return false\n    }\n\n    const toStart = PathUtils.compare(path, range.start.path)\n    const toEnd = PathUtils.compare(path, range.end.path)\n    const isInRange = toStart !== -1 && toEnd !== 1\n    return isInRange\n  }\n\n  /**\n   * Map all child nodes, updating them in their parents. This method is\n   * optimized to not return a new node if no changes are made.\n   *\n   * @param {Function} predicate\n   * @return {Node}\n   */\n\n  mapChildren(predicate = identity) {\n    let { nodes } = this\n\n    nodes.forEach((node, i) => {\n      const ret = predicate(node, i, this.nodes)\n      if (ret !== node) nodes = nodes.set(ret.key, ret)\n    })\n\n    const ret = this.set('nodes', nodes)\n    return ret\n  }\n\n  /**\n   * Map all descendant nodes, updating them in their parents. This method is\n   * optimized to not return a new node if no changes are made.\n   *\n   * @param {Function} predicate\n   * @return {Node}\n   */\n\n  mapDescendants(predicate = identity) {\n    let { nodes } = this\n\n    nodes.forEach((node, index) => {\n      let ret = node\n      if (ret.object !== 'text') ret = ret.mapDescendants(predicate)\n      ret = predicate(ret, index, this.nodes)\n      if (ret === node) return\n\n      nodes = nodes.set(index, ret)\n    })\n\n    const ret = this.set('nodes', nodes)\n    return ret\n  }\n\n  /**\n   * Create an iteratable for all the marks in text nodes with `options`.\n   *\n   * @param {Options}\n   * @return {Iterable}\n   */\n\n  marks(options = {}) {\n    const { onlyTypes = null, match, ...rest } = options\n    const texts = this.texts(rest)\n\n    return {\n      [Symbol.iterator]() {\n        const iterator = texts[Symbol.iterator]()\n        let node = null\n        let path = null\n        let remaining = []\n\n        const next = () => {\n          if (remaining.length) {\n            const mark = remaining.shift()\n\n            if (onlyTypes && !onlyTypes.includes(mark.type)) {\n              return next()\n            } else if (match && !match(mark, node, path)) {\n              return next()\n            }\n\n            return { value: [mark, node, path], done: false }\n          }\n\n          const { value, done } = iterator.next()\n\n          if (done) {\n            return { done: true }\n          }\n\n          ;[node, path] = value\n          remaining = node.marks.toArray()\n          return next()\n        }\n\n        return { next }\n      },\n    }\n  }\n\n  /**\n   * Merge a node backwards its previous sibling.\n   *\n   * @param {List|Key} path\n   * @return {Node}\n   */\n\n  mergeNode(path) {\n    const b = this.assertNode(path)\n    path = this.resolvePath(path)\n\n    if (path.last() === 0) {\n      throw new Error(\n        `Unable to merge node because it has no previous sibling: ${b}`\n      )\n    }\n\n    const withPath = PathUtils.decrement(path)\n    const a = this.assertNode(withPath)\n\n    if (a.object !== b.object) {\n      throw new Error(\n        `Unable to merge two different kinds of nodes: ${a} and ${b}`\n      )\n    }\n\n    const newNode =\n      a.object === 'text'\n        ? a.mergeText(b)\n        : a.set('nodes', a.nodes.concat(b.nodes))\n\n    let ret = this\n    ret = ret.removeNode(path)\n    ret = ret.removeNode(withPath)\n    ret = ret.insertNode(withPath, newNode)\n    return ret\n  }\n\n  /**\n   * Move a node by `path` to `newPath`.\n   *\n   * A `newIndex` can be provided when move nodes by `key`, to account for not\n   * being able to have a key for a location in the tree that doesn't exist yet.\n   *\n   * @param {List|Key} path\n   * @param {List|Key} newPath\n   * @param {Number} newIndex\n   * @return {Node}\n   */\n\n  moveNode(path, newPath, newIndex = 0) {\n    const node = this.assertNode(path)\n    path = this.resolvePath(path)\n    newPath = this.resolvePath(newPath, newIndex)\n\n    const newParentPath = PathUtils.lift(newPath)\n    this.assertNode(newParentPath)\n\n    // TODO: this is a bit hacky, re-creating the operation that led to this method being called\n    // Alternative 1: pass the operation through from apply -> value.moveNode\n    // Alternative 2: add a third property to the operation called \"transformedNewPath\", pass that through\n    const op = Operation.create({\n      type: 'move_node',\n      path,\n      newPath,\n    })\n    newPath = PathUtils.transform(path, op).first()\n\n    let ret = this\n    ret = ret.removeNode(path)\n    ret = ret.insertNode(newPath, node)\n    return ret\n  }\n\n  /**\n   * Remove `mark` from text at `path`.\n   *\n   * @param {List} path\n   * @param {Mark} mark\n   * @return {Node}\n   */\n\n  removeMark(path, mark) {\n    path = this.resolvePath(path)\n    let node = this.assertDescendant(path)\n    node = node.removeMark(mark)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Remove a node.\n   *\n   * @param {List|String} path\n   * @return {Node}\n   */\n\n  removeNode(path) {\n    this.assertDescendant(path)\n    path = this.resolvePath(path)\n    const deep = path.flatMap(x => ['nodes', x])\n    const ret = this.deleteIn(deep)\n    return ret\n  }\n\n  /**\n   * Remove `text` at `offset` in node.\n   *\n   * @param {List|Key} path\n   * @param {Number} offset\n   * @param {String} text\n   * @return {Node}\n   */\n\n  removeText(path, offset, text) {\n    let node = this.assertDescendant(path)\n    node = node.removeText(offset, text.length)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Replace a `node` in the tree.\n   *\n   * @param {List|Key} path\n   * @param {Node} node\n   * @return {Node}\n   */\n\n  replaceNode(path, node) {\n    path = this.resolvePath(path)\n\n    if (!path) {\n      throw new Error(\n        `Unable to replace a node because it could not be found in the first place: ${path}`\n      )\n    }\n\n    if (!path.size) return node\n    this.assertNode(path)\n    const deep = path.flatMap(x => ['nodes', x])\n    const ret = this.setIn(deep, node)\n    return ret\n  }\n\n  /**\n   * Resolve a `annotation`, relative to the node, ensuring that the keys and\n   * offsets in the annotation exist and that they are synced with the paths.\n   *\n   * @param {Annotation|Object} annotation\n   * @return {Annotation}\n   */\n\n  resolveAnnotation(annotation) {\n    annotation = Annotation.create(annotation)\n    annotation = annotation.normalize(this)\n    return annotation\n  }\n\n  /**\n   * Resolve a `decoration`, relative to the node, ensuring that the keys and\n   * offsets in the decoration exist and that they are synced with the paths.\n   *\n   * @param {Decoration|Object} decoration\n   * @return {Decoration}\n   */\n\n  resolveDecoration(decoration) {\n    decoration = Decoration.create(decoration)\n    decoration = decoration.normalize(this)\n    return decoration\n  }\n\n  /**\n   * Resolve a `point`, relative to the node, ensuring that the keys and\n   * offsets in the point exist and that they are synced with the paths.\n   *\n   * @param {Point|Object} point\n   * @return {Point}\n   */\n\n  resolvePoint(point) {\n    point = Point.create(point)\n    point = point.normalize(this)\n    return point\n  }\n\n  /**\n   * Resolve a `range`, relative to the node, ensuring that the keys and\n   * offsets in the range exist and that they are synced with the paths.\n   *\n   * @param {Range|Object} range\n   * @return {Range}\n   */\n\n  resolveRange(range) {\n    range = Range.create(range)\n    range = range.normalize(this)\n    return range\n  }\n\n  /**\n   * Resolve a `selection`, relative to the node, ensuring that the keys and\n   * offsets in the selection exist and that they are synced with the paths.\n   *\n   * @param {Selection|Object} selection\n   * @return {Selection}\n   */\n\n  resolveSelection(selection) {\n    selection = Selection.create(selection)\n    selection = selection.normalize(this)\n    return selection\n  }\n\n  /**\n   * Set `properties` on a node.\n   *\n   * @param {List|String} path\n   * @param {Object} properties\n   * @return {Node}\n   */\n\n  setNode(path, properties) {\n    let node = this.assertNode(path)\n    node = node.merge(properties)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Set `properties` on `mark` on text at `offset` and `length` in node.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @param {Number} length\n   * @param {Mark} mark\n   * @param {Object} properties\n   * @return {Node}\n   */\n\n  setMark(path, properties, newProperties) {\n    path = this.resolvePath(path)\n    let node = this.assertDescendant(path)\n    node = node.setMark(properties, newProperties)\n    const ret = this.replaceNode(path, node)\n    return ret\n  }\n\n  /**\n   * Create an iteratable for the siblings in the tree at `path`.\n   *\n   * @param {List|Array} path\n   * @return {Iterable}\n   */\n\n  siblings(path, options) {\n    const iterable = this.createIterable({\n      path,\n      upward: false,\n      downward: false,\n      ...options,\n    })\n\n    return iterable\n  }\n\n  /**\n   * Split a node by `path` at `position` with optional `properties` to apply\n   * to the newly split node.\n   *\n   * @param {List|String} path\n   * @param {Number} position\n   * @param {Object} properties\n   * @return {Node}\n   */\n\n  splitNode(path, position, properties) {\n    const child = this.assertNode(path)\n    path = this.resolvePath(path)\n    let a\n    let b\n\n    if (child.object === 'text') {\n      ;[a, b] = child.splitText(position)\n    } else {\n      const befores = child.nodes.take(position)\n      const afters = child.nodes.skip(position)\n      a = child.set('nodes', befores)\n      b = child.set('nodes', afters).regenerateKey()\n    }\n\n    if (properties && child.object !== 'text') {\n      b = b.merge(properties)\n    }\n\n    let ret = this\n    ret = ret.removeNode(path)\n    ret = ret.insertNode(path, b)\n    ret = ret.insertNode(path, a)\n    return ret\n  }\n\n  /**\n   * Create an iteratable for all the text node descendants.\n   *\n   * @param {Object} options\n   * @return {Iterable}\n   */\n\n  texts(options) {\n    const iterable = this.descendants({\n      includeBlocks: false,\n      includeInlines: false,\n      includeDocument: false,\n      ...options,\n    })\n\n    return iterable\n  }\n\n  /**\n   * Deprecated.\n   */\n\n  getBlocksAtRange(range) {\n    warning(\n      false,\n      'As of slate@0.44 the `node.getBlocksAtRange` method has been renamed to `getLeafBlocksAtRange`.'\n    )\n\n    return this.getLeafBlocksAtRange(range)\n  }\n\n  getBlocksAtRangeAsArray(range) {\n    warning(\n      false,\n      'As of slate@0.44 the `node.getBlocksAtRangeAsArray` method has been renamed to `getLeafBlocksAtRangeAsArray`.'\n    )\n\n    return this.getLeafBlocksAtRangeAsArray(range)\n  }\n\n  getInlinesAtRange(range) {\n    warning(\n      false,\n      'As of slate@0.44 the `node.getInlinesAtRange` method has been renamed to `getLeafInlinesAtRange`.'\n    )\n\n    return this.getLeafInlinesAtRange(range)\n  }\n\n  getInlinesAtRangeAsArray(range) {\n    warning(\n      false,\n      'As of slate@0.44 the `node.getInlinesAtRangeAsArray` method has been renamed to `getLeafInlinesAtRangeAsArray`.'\n    )\n\n    return this.getLeafInlinesAtRangeAsArray(range)\n  }\n\n  getNextTextAndPath(path) {\n    warning(\n      false,\n      'As of slate@0.47, the `getNextTextAndPath` method has been renamed to `getNextTextEntry`.'\n    )\n\n    return this.getNextTextEntry(path)\n  }\n\n  getNextDeepMatchingNodeAndPath(path, iterator = () => true) {\n    warning(\n      false,\n      'As of slate@0.47, the `getNextDeepMatchingNodeAndPath` method is deprecated.'\n    )\n\n    const match = this.getNextMatchingNodeAndPath(path)\n\n    if (!match) return null\n\n    let [nextNode, nextPath] = match\n\n    let childMatch\n\n    const assign = () => {\n      childMatch =\n        nextNode.object !== 'text' &&\n        nextNode.findFirstDescendantAndPath(iterator, nextPath)\n      return childMatch\n    }\n\n    while (assign(childMatch)) {\n      ;[nextNode, nextPath] = childMatch\n    }\n\n    if (!nextNode) return null\n\n    return iterator(nextNode)\n      ? [nextNode, nextPath]\n      : this.getNextDeepMatchingNodeAndPath(match[1], iterator)\n  }\n\n  getPreviousTextAndPath(path) {\n    warning(\n      false,\n      'As of slate@0.47, the `getPreviousTextAndPath` method has been renamed to `getPreviousTextEntry`.'\n    )\n\n    return this.getPreviousTextEntry(path)\n  }\n\n  findFirstDescendantAndPath(iterator, pathToThisNode) {\n    warning(\n      false,\n      'As of slate@0.47, the `findFirstDescendantAndPath` method is deprecated.'\n    )\n\n    return this.findDescendantAndPath(iterator, pathToThisNode, false)\n  }\n\n  getPreviousMatchingNodeAndPath(path, iterator = () => true) {\n    warning(\n      false,\n      'As of slate@0.47, the `getPreviousMatchingNodeAndPath` method is deprecated.'\n    )\n\n    if (!path) return null\n\n    for (let i = path.size; i > 0; i--) {\n      const p = path.slice(0, i)\n      if (p.last() === 0) continue\n\n      let previousPath = PathUtils.decrement(p)\n      let previousNode = this.getNode(previousPath)\n\n      while (previousNode && !iterator(previousNode)) {\n        previousPath = PathUtils.decrement(previousPath)\n        previousNode = this.getNode(previousPath)\n      }\n\n      if (previousNode) return [previousNode, previousPath]\n    }\n\n    return null\n  }\n\n  getPreviousDeepMatchingNodeAndPath(path, iterator = () => true) {\n    warning(\n      false,\n      'As of slate@0.47, the `getPreviousDeepMatchingNodeAndPath` method is deprecated.'\n    )\n\n    const match = this.getPreviousMatchingNodeAndPath(path)\n\n    if (!match) return null\n\n    let [previousNode, previousPath] = match\n\n    let childMatch\n\n    const assign = () => {\n      childMatch =\n        previousNode.object !== 'text' &&\n        previousNode.findLastDescendantAndPath(iterator, previousPath)\n      return childMatch\n    }\n\n    while (assign(childMatch)) {\n      ;[previousNode, previousPath] = childMatch\n    }\n\n    if (!previousNode) return null\n\n    return iterator(previousNode)\n      ? [previousNode, previousPath]\n      : this.getPreviousDeepMatchingNodeAndPath(match[1], iterator)\n  }\n\n  findLastDescendantAndPath(iterator, pathToThisNode) {\n    warning(\n      false,\n      'As of slate@0.47, the `findLastDescendantAndPath` method is deprecated.'\n    )\n\n    return this.findDescendantAndPath(iterator, pathToThisNode, true)\n  }\n\n  findDescendantAndPath(\n    iterator,\n    pathToThisNode = PathUtils.create([]),\n    findLast = false\n  ) {\n    warning(\n      false,\n      'As of slate@0.47, the `findDescendantAndPath` method is deprecated.'\n    )\n\n    let found\n    let foundPath\n\n    this.forEachDescendantWithPath(\n      (node, path, nodes) => {\n        if (iterator(node, path, nodes)) {\n          found = node\n          foundPath = path\n          return false\n        }\n      },\n      pathToThisNode,\n      findLast\n    )\n\n    return found ? [found, foundPath] : null\n  }\n\n  forEachDescendantWithPath(iterator, path = PathUtils.create([]), findLast) {\n    warning(\n      false,\n      'As of slate@0.47, the `forEachDescendantWithPath` method is deprecated.'\n    )\n\n    let nodes = this.nodes\n    let ret\n\n    if (findLast) nodes = nodes.reverse()\n\n    nodes.forEach((child, i) => {\n      const childPath = path.concat(i)\n\n      if (iterator(child, childPath, nodes) === false) {\n        ret = false\n        return false\n      }\n\n      if (child.object !== 'text') {\n        ret = child.forEachDescendantWithPath(iterator, childPath, findLast)\n        return ret\n      }\n    })\n\n    return ret\n  }\n\n  getNextMatchingNodeAndPath(path, iterator = () => true) {\n    warning(\n      false,\n      'As of slate@0.47, the `getNextMatchingNodeAndPath` method is deprecated.'\n    )\n\n    if (!path) return null\n\n    for (let i = path.size; i > 0; i--) {\n      const p = path.slice(0, i)\n\n      let nextPath = PathUtils.increment(p)\n      let nextNode = this.getNode(nextPath)\n\n      while (nextNode && !iterator(nextNode)) {\n        nextPath = PathUtils.increment(nextPath)\n        nextNode = this.getNode(nextPath)\n      }\n\n      if (nextNode) return [nextNode, nextPath]\n    }\n\n    return null\n  }\n\n  getSelectionIndexes(range, isSelected = true) {\n    warning(\n      false,\n      'As of slate@0.47, the `getSelectionIndexes` method is deprecated.'\n    )\n\n    const { start, end } = range\n\n    // PERF: if we're not selected, we can exit early.\n    if (!isSelected) {\n      return null\n    }\n\n    // PERF: if we've been given an invalid selection we can exit early.\n    if (range.isUnset) {\n      return null\n    }\n\n    // PERF: if the start and end keys are the same, just check for the child\n    // that contains that single key.\n    if (start.path.equals(end.path)) {\n      const child = this.getFurthestAncestor(start.path)\n      const index = child ? this.nodes.indexOf(child) : null\n      return { start: index, end: index + 1 }\n    }\n\n    // Otherwise, check all of the children...\n    let startIndex = null\n    let endIndex = null\n\n    this.nodes.forEach((child, i) => {\n      if (child.object === 'text') {\n        if (startIndex == null && child.key === start.key) startIndex = i\n        if (endIndex == null && child.key === end.key) endIndex = i + 1\n      } else {\n        if (startIndex == null && child.hasDescendant(start.key)) startIndex = i\n        if (endIndex == null && child.hasDescendant(end.key)) endIndex = i + 1\n      }\n\n      // PERF: exit early if both start and end have been found.\n      return startIndex == null || endIndex == null\n    })\n\n    if (isSelected && startIndex == null) {\n      startIndex = 0\n    }\n\n    if (isSelected && endIndex == null) {\n      endIndex = this.nodes.size\n    }\n\n    if (startIndex == null) {\n      return null\n    }\n\n    return { start: startIndex, end: endIndex }\n  }\n\n  getTextsBetweenPositionsAsArray(startPath, endPath) {\n    warning(\n      false,\n      'As of slate@0.47, the `getTextsBetweenPositionsAsArray` method is deprecated.'\n    )\n\n    startPath = this.resolvePath(startPath)\n    endPath = this.resolvePath(endPath)\n\n    return this.getTextsBetweenPathPositionsAsArray(startPath, endPath)\n  }\n\n  getOrderedMarksBetweenPositions(startPath, startOffset, endPath, endOffset) {\n    warning(\n      false,\n      'As of slate@0.47, the `getOrderedMarksBetweenPositions` method is deprecated.'\n    )\n\n    startPath = this.resolvePath(startPath)\n    endPath = this.resolvePath(endPath)\n    const startText = this.getDescendant(startPath)\n\n    // PERF: if the paths are equal, we can just use the start.\n    if (PathUtils.isEqual(startPath, endPath)) {\n      return startText.marks\n    }\n\n    const texts = this.getTextsBetweenPathPositionsAsArray(startPath, endPath)\n\n    return OrderedSet().withMutations(result => {\n      texts.forEach(text => {\n        result.union(text.marks)\n      })\n    })\n  }\n\n  getTextsBetweenPathPositionsAsArray(startPath, endPath) {\n    warning(\n      false,\n      'As of slate@0.47, the `getTextsBetweenPathPositionsAsArray` method is deprecated.'\n    )\n\n    // PERF: the most common case is when the range is in a single text node,\n    // where we can avoid a lot of iterating of the tree.\n    if (startPath && endPath && PathUtils.isEqual(startPath, endPath)) {\n      return [this.getDescendant(startPath)]\n    } else if (!startPath && !endPath) {\n      return this.getTextsAsArray()\n    }\n\n    const startIndex = startPath ? startPath.get(0, 0) : 0\n    const endIndex = endPath\n      ? endPath.get(0, this.nodes.size - 1)\n      : this.nodes.size - 1\n\n    let array = []\n\n    this.nodes.slice(startIndex, endIndex + 1).forEach((node, i) => {\n      if (node.object === 'text') {\n        array.push(node)\n      } else {\n        // For the node at start and end of this list, we want to provide a start and end path\n        // For other nodes, we can just get all their text nodes, they are between the paths\n        const childStartPath =\n          startPath && i === 0 ? PathUtils.drop(startPath) : null\n        const childEndPath =\n          endPath && i === endIndex - startIndex\n            ? PathUtils.drop(endPath)\n            : null\n\n        array = array.concat(\n          node.getTextsBetweenPathPositionsAsArray(childStartPath, childEndPath)\n        )\n      }\n    })\n\n    return array\n  }\n\n  getFurthestAncestor(path) {\n    warning(\n      false,\n      'As of slate@0.47, the `getFurthestAncestor` method has been renamed to `getFurthestChild`.'\n    )\n\n    return this.getFurthestChild(path)\n  }\n\n  getLeafBlocksAtRangeAsArray(range) {\n    warning(\n      false,\n      'As of slate@0.47, the `getLeafBlocksAtRangeAsArray` method is deprecated.'\n    )\n\n    range = this.resolveRange(range)\n    if (range.isUnset) return []\n\n    const { start, end } = range\n\n    return this.getLeafBlocksBetweenPathPositionsAsArray(start.path, end.path)\n  }\n\n  getLeafBlocksBetweenPathPositionsAsArray(startPath, endPath) {\n    warning(\n      false,\n      'As of slate@0.47, the `getLeafBlocksBetweenPathPositionsAsArray` method is deprecated.'\n    )\n\n    // PERF: the most common case is when the range is in a single block node,\n    // where we can avoid a lot of iterating of the tree.\n    if (startPath && endPath && PathUtils.isEqual(startPath, endPath)) {\n      return [this.getClosestBlock(startPath)]\n    } else if (!startPath && !endPath) {\n      return this.getBlocksAsArray()\n    }\n\n    const startIndex = startPath ? startPath.get(0, 0) : 0\n    const endIndex = endPath\n      ? endPath.get(0, this.nodes.size - 1)\n      : this.nodes.size - 1\n\n    let array = []\n\n    this.nodes.slice(startIndex, endIndex + 1).forEach((node, i) => {\n      if (node.object !== 'block') {\n        return\n      } else if (node.isLeafBlock()) {\n        array.push(node)\n      } else {\n        const childStartPath =\n          startPath && i === 0 ? PathUtils.drop(startPath) : null\n        const childEndPath =\n          endPath && i === endIndex - startIndex\n            ? PathUtils.drop(endPath)\n            : null\n\n        array = array.concat(\n          node.getLeafBlocksBetweenPathPositionsAsArray(\n            childStartPath,\n            childEndPath\n          )\n        )\n      }\n    })\n\n    return array\n  }\n\n  getBlocksAsArray() {\n    warning(\n      false,\n      'As of slate@0.47, the `getBlocksAsArray` method is deprecated.'\n    )\n\n    const iterable = this.blocks({ onlyLeaves: true })\n    const array = Array.from(iterable, ([node]) => node)\n    return array\n  }\n\n  getBlocksByTypeAsArray(type) {\n    warning(\n      false,\n      'As of slate@0.47, the `getBlocksByTypeAsArray` method is deprecated.'\n    )\n\n    const iterable = this.blocks({ onlyLeaves: true, onlyTypes: [type] })\n    const array = Array.from(iterable, ([node]) => node)\n    return array\n  }\n\n  getFurthestOnlyChildAncestor(path) {\n    warning(\n      false,\n      'As of slate@0.47, the `getFurthestOnlyChildAncestor` method is deprecated.'\n    )\n\n    const ancestors = this.getAncestors(path)\n    if (!ancestors) return null\n\n    const furthest = ancestors\n      .rest()\n      .reverse()\n      .takeUntil(p => p.nodes.size > 1)\n      .last()\n\n    return furthest || null\n  }\n\n  getInlinesAsArray() {\n    warning(\n      false,\n      'As of slate@0.47, the `getInlinesAsArray` method is deprecated.'\n    )\n\n    const array = Array.from(\n      this.inlines({ onlyLeaves: true }),\n      ([node]) => node\n    )\n    return array\n  }\n\n  getInlinesByTypeAsArray(type) {\n    warning(\n      false,\n      'As of slate@0.47, the `getInlinesByTypeAsArray` method is deprecated.'\n    )\n\n    const array = Array.from(\n      this.inlines({ onlyLeaves: true, onlyTypes: [type] }),\n      ([node]) => node\n    )\n    return array\n  }\n\n  getLeafInlinesAtRangeAsArray(range) {\n    warning(\n      false,\n      'As of slate@0.47, the `getLeafInlinesAtRangeAsArray` method is deprecated.'\n    )\n\n    range = this.resolveRange(range)\n    if (range.isUnset) return []\n\n    const array = this.getTextsAtRangeAsArray(range)\n      .map(text => this.getClosestInline(text.key))\n      .filter(exists => exists)\n\n    return array\n  }\n\n  getOrderedMarks() {\n    warning(\n      false,\n      'As of slate@0.47, the `getOrderedMarks` method has been folded into `getMarks`, which will now return an ordered set.'\n    )\n    return this.getMarks()\n  }\n\n  getOrderedMarksAtRange(range) {\n    warning(\n      false,\n      'As of slate@0.47, the `getOrderedMarksAtRange` method has been folded into `getMarksAtRange`, which will now return an ordered set.'\n    )\n    return this.getMarksAtRange(range)\n  }\n\n  getOrderedMarksByType(type) {\n    warning(\n      false,\n      'As of slate@0.47, the `getOrderedMarksByType` method has been folded into `getMarksByType`, which will now return an ordered set.'\n    )\n    return this.getMarksByType(type)\n  }\n\n  getMarksByTypeAsArray(type) {\n    warning(\n      false,\n      'As of slate@0.47, the `getMarksByTypeAsArray` method is deprecated.'\n    )\n\n    const array = this.nodes.reduce((memo, node) => {\n      return node.object === 'text'\n        ? memo.concat(node.marks.filter(m => m.type === type))\n        : memo.concat(node.getMarksByTypeAsArray(type))\n    }, [])\n\n    return array\n  }\n\n  getMarksAsArray() {\n    warning(\n      false,\n      'As of slate@0.47, the `getMarksAsArray` method is deprecated.'\n    )\n\n    const result = []\n\n    for (const [node] of this.texts()) {\n      result.push(node.marks.toArray())\n    }\n\n    // PERF: use only one concat rather than multiple for speed.\n    const array = [].concat(...result)\n    return array\n  }\n\n  getRootInlinesAtRangeAsArray(range) {\n    warning(\n      false,\n      'As of slate@0.47, the `getRootInlinesAtRangeAsArray` method is deprecated.'\n    )\n\n    range = this.resolveRange(range)\n    if (range.isUnset) return List()\n\n    const array = this.getTextsAtRangeAsArray(range)\n      .map(text => this.getFurthestInline(text.key))\n      .filter(exists => exists)\n\n    return array\n  }\n\n  getTextsAsArray() {\n    warning(\n      false,\n      'As of slate@0.47, the `getTextsAsArray` method is deprecated.'\n    )\n\n    const iterable = this.texts()\n    const array = Array.from(iterable, ([node]) => node)\n    return array\n  }\n\n  getTextsAtRangeAsArray(range) {\n    warning(\n      false,\n      'As of slate@0.47, the `getTextsAtRangeAsArray` method is deprecated.'\n    )\n\n    const iterable = this.texts({ range })\n    const array = Array.from(iterable, ([node]) => node)\n    return array\n  }\n\n  getMarksAtPosition(path, offset) {\n    warning(\n      false,\n      'As of slate@0.47, the `getMarksAtPosition` method is deprecated.'\n    )\n\n    path = this.resolvePath(path)\n    const text = this.getDescendant(path)\n    const currentMarks = text.marks\n\n    if (offset !== 0) {\n      return OrderedSet(currentMarks)\n    }\n\n    const closestBlock = this.getClosestBlock(path)\n\n    // insert mark for empty block; the empty block are often created by split node or add marks in a range including empty blocks\n    if (closestBlock.text === '') {\n      return OrderedSet(currentMarks)\n    }\n\n    const [previous] = this.texts({ path, direction: 'backward' })\n\n    if (!previous) {\n      return OrderedSet()\n    }\n\n    const [previousText, previousPath] = previous\n\n    if (closestBlock.hasDescendant(previousPath)) {\n      return OrderedSet(previousText.marks)\n    }\n\n    return OrderedSet(currentMarks)\n  }\n\n  getNodesAtRange(range) {\n    warning(\n      false,\n      'As of slate@0.47, the `getNodesAtRange` method has been renamed to `getDescendantsAtRange`.'\n    )\n\n    const iterable = this.descendants({ range })\n    const array = Array.from(iterable, ([node]) => node)\n    const list = List(array)\n    return list\n  }\n\n  isNodeInRange(path, range) {\n    warning(\n      false,\n      'As of slate@0.47, the `isNodeInRange` method has been renamed to `isInRange`.'\n    )\n\n    return this.isInRange(path, range)\n  }\n}\n\n/**\n * Mix in assertion variants.\n */\n\nconst ASSERTS = ['Child', 'Depth', 'Descendant', 'Node', 'Parent', 'Path']\n\nfor (const method of ASSERTS) {\n  ElementInterface.prototype[`assert${method}`] = function(path, ...args) {\n    const ret = this[`get${method}`](path, ...args)\n\n    if (ret == null) {\n      throw new Error(\n        `\\`Node.assert${method}\\` could not find node with path or key: ${path}`\n      )\n    }\n\n    return ret\n  }\n}\n\n/**\n * Memoize read methods.\n */\n\nmemoize(ElementInterface.prototype, [\n  'getBlocksAsArray',\n  'getBlocksByTypeAsArray',\n  'getDecorations',\n  'getFragmentAtRange',\n  'getInlinesAsArray',\n  'getInlinesByTypeAsArray',\n  'getInsertMarksAtRange',\n  'getLeafBlocksAtRangeAsArray',\n  'getLeafBlocksAtRangeAsArray',\n  'getLeafInlinesAtRangeAsArray',\n  'getMarksAsArray',\n  'getMarksAtPosition',\n  'getMarksByTypeAsArray',\n  'getNextBlock',\n  'getNodesAtRange',\n  'getNodesToPathsMap',\n  'getOffset',\n  'getOffsetAtRange',\n  'getOrderedMarksBetweenPositions',\n  'getPreviousBlock',\n  'getRootBlocksAtRange',\n  'getRootInlinesAtRangeAsArray',\n  'getTextAtOffset',\n  'getTextDirection',\n  'getTextsAsArray',\n  'getTextsBetweenPathPositionsAsArray',\n])\n\n/**\n * Mix in the element interface.\n */\n\nmixin(ElementInterface, [Block, Document, Inline])\n","import mixin from '../utils/mixin'\nimport Annotation from '../models/annotation'\nimport Decoration from '../models/decoration'\nimport PathUtils from '../utils/path-utils'\nimport Point from '../models/point'\nimport Range from '../models/range'\nimport Selection from '../models/selection'\n\n/**\n * The interface that `Decoration`, `Range` and `Selection` all implement, to make\n * working anchor and focus points easier.\n *\n * @type {Class}\n */\n\nclass RangeInterface {\n  /**\n   * Check whether the range is collapsed.\n   *\n   * @return {Boolean}\n   */\n\n  get isCollapsed() {\n    return (\n      this.anchor === this.focus ||\n      (this.anchor.key === this.focus.key &&\n        this.anchor.offset === this.focus.offset)\n    )\n  }\n\n  /**\n   * Check whether the range is expanded.\n   *\n   * @return {Boolean}\n   */\n\n  get isExpanded() {\n    return !this.isCollapsed\n  }\n\n  /**\n   * Check whether the range is backward.\n   *\n   * @return {Boolean}\n   */\n\n  get isBackward() {\n    const { isUnset, anchor, focus } = this\n\n    if (isUnset) {\n      return null\n    }\n\n    if (anchor.key === focus.key) {\n      return anchor.offset > focus.offset\n    }\n\n    const isBackward = PathUtils.isBefore(focus.path, anchor.path)\n    return isBackward\n  }\n\n  /**\n   * Check whether the range is forward.\n   *\n   * @return {Boolean}\n   */\n\n  get isForward() {\n    const { isBackward } = this\n    const isForward = isBackward == null ? null : !isBackward\n    return isForward\n  }\n\n  /**\n   * Check whether the range isn't set.\n   *\n   * @return {Boolean}\n   */\n\n  get isUnset() {\n    const { anchor, focus } = this\n    const isUnset = anchor.isUnset || focus.isUnset\n    return isUnset\n  }\n\n  /**\n   * Check whether the range is set.\n   *\n   * @return {Boolean}\n   */\n\n  get isSet() {\n    return !this.isUnset\n  }\n\n  /**\n   * Get the start point.\n   *\n   * @return {String}\n   */\n\n  get start() {\n    return this.isBackward ? this.focus : this.anchor\n  }\n\n  /**\n   * Get the end point.\n   *\n   * @return {String}\n   */\n\n  get end() {\n    return this.isBackward ? this.anchor : this.focus\n  }\n\n  /**\n   * Flip the range.\n   *\n   * @return {Range}\n   */\n\n  flip() {\n    const range = this.setPoints([this.focus, this.anchor])\n    return range\n  }\n\n  /**\n   * Move the anchor and focus offsets forward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveForward(n) {\n    return this.updatePoints(point => point.moveForward(n))\n  }\n\n  /**\n   * Move the anchor and focus offsets backward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveBackward(n) {\n    return this.updatePoints(point => point.moveBackward(n))\n  }\n\n  /**\n   * Move the anchor offset backward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveAnchorBackward(n) {\n    const range = this.setAnchor(this.anchor.moveBackward(n))\n    return range\n  }\n\n  /**\n   * Move the anchor offset forward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveAnchorForward(n) {\n    const range = this.setAnchor(this.anchor.moveForward(n))\n    return range\n  }\n\n  /**\n   * Move the range's anchor point to a new `path` and `offset`.\n   *\n   * Optionally, the `path` can be a key string, or omitted entirely in which\n   * case it would be the offset number.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @return {Range}\n   */\n\n  moveAnchorTo(path, offset) {\n    const range = this.setAnchor(this.anchor.moveTo(path, offset))\n    return range\n  }\n\n  /**\n   * Move the range's anchor point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveAnchorToStartOfNode(node) {\n    const range = this.setAnchor(this.anchor.moveToStartOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the range's anchor point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveAnchorToEndOfNode(node) {\n    const range = this.setAnchor(this.anchor.moveToEndOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the end offset backward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveEndBackward(n) {\n    const range = this.setEnd(this.end.moveBackward(n))\n    return range\n  }\n\n  /**\n   * Move the end offset forward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveEndForward(n) {\n    const range = this.setEnd(this.end.moveForward(n))\n    return range\n  }\n\n  /**\n   * Move the range's end point to a new `path` and `offset`.\n   *\n   * Optionally, the `path` can be a key string, or omitted entirely in which\n   * case it would be the offset number.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @return {Range}\n   */\n\n  moveEndTo(path, offset) {\n    const range = this.setEnd(this.end.moveTo(path, offset))\n    return range\n  }\n\n  /**\n   * Move the range's end point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveEndToStartOfNode(node) {\n    const range = this.setEnd(this.end.moveToStartOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the range's end point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveEndToEndOfNode(node) {\n    const range = this.setEnd(this.end.moveToEndOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the focus offset backward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveFocusBackward(n) {\n    const range = this.setFocus(this.focus.moveBackward(n))\n    return range\n  }\n\n  /**\n   * Move the focus offset forward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveFocusForward(n) {\n    const range = this.setFocus(this.focus.moveForward(n))\n    return range\n  }\n\n  /**\n   * Move the range's focus point to a new `path` and `offset`.\n   *\n   * Optionally, the `path` can be a key string, or omitted entirely in which\n   * case it would be the offset number.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @return {Range}\n   */\n\n  moveFocusTo(path, offset) {\n    const range = this.setFocus(this.focus.moveTo(path, offset))\n    return range\n  }\n\n  /**\n   * Move the range's focus point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveFocusToStartOfNode(node) {\n    const range = this.setFocus(this.focus.moveToStartOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the range's focus point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveFocusToEndOfNode(node) {\n    const range = this.setFocus(this.focus.moveToEndOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the start offset backward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveStartBackward(n) {\n    const range = this.setStart(this.start.moveBackward(n))\n    return range\n  }\n\n  /**\n   * Move the start offset forward `n` characters.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveStartForward(n) {\n    const range = this.setStart(this.start.moveForward(n))\n    return range\n  }\n\n  /**\n   * Move the range's start point to a new `path` and `offset`.\n   *\n   * Optionally, the `path` can be a key string, or omitted entirely in which\n   * case it would be the offset number.\n   *\n   * @param {List|String} path\n   * @param {Number} offset\n   * @return {Range}\n   */\n\n  moveStartTo(path, offset) {\n    const range = this.setStart(this.start.moveTo(path, offset))\n    return range\n  }\n\n  /**\n   * Move the range's start point to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveStartToStartOfNode(node) {\n    const range = this.setStart(this.start.moveToStartOfNode(node))\n    return range\n  }\n\n  /**\n   * Move the range's start point to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveStartToEndOfNode(node) {\n    const range = this.setStart(this.start.moveToEndOfNode(node))\n    return range\n  }\n\n  /**\n   * Move range's points to a new `path` and `offset`.\n   *\n   * @param {Number} n\n   * @return {Range}\n   */\n\n  moveTo(path, offset) {\n    return this.updatePoints(point => point.moveTo(path, offset))\n  }\n\n  /**\n   * Move the focus point to the anchor point.\n   *\n   * @return {Range}\n   */\n\n  moveToAnchor() {\n    const range = this.setFocus(this.anchor)\n    return range\n  }\n\n  /**\n   * Move the start point to the end point.\n   *\n   * @return {Range}\n   */\n\n  moveToEnd() {\n    const range = this.setStart(this.end)\n    return range\n  }\n\n  /**\n   * Move the range's points to the end of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveToEndOfNode(node) {\n    return this.updatePoints(point => point.moveToEndOfNode(node))\n  }\n\n  /**\n   * Move the anchor point to the focus point.\n   *\n   * @return {Range}\n   */\n\n  moveToFocus() {\n    const range = this.setAnchor(this.focus)\n    return range\n  }\n\n  /**\n   * Move to the entire range of `start` and `end` nodes.\n   *\n   * @param {Node} start\n   * @param {Node} end (optional)\n   * @return {Range}\n   */\n\n  moveToRangeOfNode(start, end = start) {\n    const range = this.setPoints([\n      this.anchor.moveToStartOfNode(start),\n      this.focus.moveToEndOfNode(end),\n    ])\n\n    return range\n  }\n\n  /**\n   * Move the end point to the start point.\n   *\n   * @return {Range}\n   */\n\n  moveToStart() {\n    const range = this.setEnd(this.start)\n    return range\n  }\n\n  /**\n   * Move the range's points to the start of a `node`.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  moveToStartOfNode(node) {\n    return this.updatePoints(point => point.moveToStartOfNode(node))\n  }\n\n  /**\n   * Normalize the range, relative to a `node`, ensuring that the anchor\n   * and focus nodes of the range always refer to leaf text nodes.\n   *\n   * @param {Node} node\n   * @return {Range}\n   */\n\n  normalize(node) {\n    return this.updatePoints(point => point.normalize(node))\n  }\n\n  /**\n   * Set the anchor point to a new `anchor`.\n   *\n   * @param {Point} anchor\n   * @return {Range}\n   */\n\n  setAnchor(anchor) {\n    const range = this.set('anchor', anchor)\n    return range\n  }\n\n  /**\n   * Set the end point to a new `point`.\n   *\n   * @param {Point} point\n   * @return {Range}\n   */\n\n  setEnd(point) {\n    const range = this.isBackward ? this.setAnchor(point) : this.setFocus(point)\n    return range\n  }\n\n  /**\n   * Set the focus point to a new `focus`.\n   *\n   * @param {Point} focus\n   * @return {Range}\n   */\n\n  setFocus(focus) {\n    const range = this.set('focus', focus)\n    return range\n  }\n\n  /**\n   * Set the anchor and focus points to new `values`.\n   *\n   * @param {Array<Point>} values\n   * @return {Range}\n   */\n\n  setPoints(values) {\n    const [anchor, focus] = values\n    const range = this.set('anchor', anchor).set('focus', focus)\n    return range\n  }\n\n  /**\n   * Set the anchor and focus points with `updater` callback\n   *\n   * @param {Function} updater\n   * @return {Range}\n   */\n\n  updatePoints(updater) {\n    let { anchor, focus } = this\n    anchor = updater(anchor)\n    focus = updater(focus)\n    return this.merge({ anchor, focus })\n  }\n\n  /**\n   * Set the start point to a new `point`.\n   *\n   * @param {Point} point\n   * @return {Range}\n   */\n\n  setStart(point) {\n    const range = this.isBackward ? this.setFocus(point) : this.setAnchor(point)\n    return range\n  }\n\n  /**\n   * Set new `properties` on the range.\n   *\n   * @param {Object|Range} properties\n   * @return {Range}\n   */\n\n  setProperties(properties) {\n    properties = Range.createProperties(properties)\n    const { anchor, focus, ...props } = properties\n\n    if (anchor) {\n      props.anchor = Point.create(anchor)\n    }\n\n    if (focus) {\n      props.focus = Point.create(focus)\n    }\n\n    const range = this.merge(props)\n    return range\n  }\n\n  /**\n   * Return a JSON representation of the range.\n   *\n   * @param {Object} options\n   * @return {Object}\n   */\n\n  toJSON(options = {}) {\n    const object = {\n      object: this.object,\n      anchor: this.anchor.toJSON(options),\n      focus: this.focus.toJSON(options),\n    }\n\n    return object\n  }\n\n  /**\n   * Return a `Range` instance from any range-like instance.\n   *\n   * @return {Range}\n   */\n\n  toRange() {\n    const properties = Range.createProperties(this)\n    const range = Range.create(properties)\n    return range\n  }\n\n  /**\n   * Unset the range.\n   *\n   * @return {Range}\n   */\n\n  unset() {\n    const range = this.updatePoints(p => p.unset())\n    return range\n  }\n}\n\n/**\n * Mix in the range interface.\n *\n * @param {Record}\n */\n\nmixin(RangeInterface, [Annotation, Decoration, Range, Selection])\n","import './interfaces/object'\nimport './interfaces/model'\nimport './interfaces/node'\nimport './interfaces/element'\nimport './interfaces/range'\n\nimport Annotation from './models/annotation'\nimport Block from './models/block'\nimport Change from './models/change'\nimport Data from './models/data'\nimport Decoration from './models/decoration'\nimport Document from './models/document'\nimport Editor from './controllers/editor'\nimport Inline from './models/inline'\nimport KeyUtils from './utils/key-utils'\nimport Leaf from './models/leaf'\nimport Mark from './models/mark'\nimport Node from './models/node'\nimport Operation from './models/operation'\nimport PathUtils from './utils/path-utils'\nimport Point from './models/point'\nimport Range from './models/range'\nimport Selection from './models/selection'\nimport Text from './models/text'\nimport TextUtils from './utils/text-utils'\nimport Value from './models/value'\nimport { resetMemoization, useMemoization } from './utils/memoize'\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nexport {\n  Annotation,\n  Block,\n  Change,\n  Data,\n  Decoration,\n  Document,\n  Editor,\n  Inline,\n  KeyUtils,\n  Leaf,\n  Mark,\n  Node,\n  Operation,\n  PathUtils,\n  Point,\n  Range,\n  resetMemoization,\n  Selection,\n  Text,\n  TextUtils,\n  useMemoization,\n  Value,\n}\n\nexport default {\n  Annotation,\n  Block,\n  Change,\n  Data,\n  Decoration,\n  Document,\n  Editor,\n  Inline,\n  KeyUtils,\n  Leaf,\n  Mark,\n  Node,\n  Operation,\n  PathUtils,\n  Point,\n  Range,\n  resetMemoization,\n  Selection,\n  Text,\n  TextUtils,\n  useMemoization,\n  Value,\n}\n"]},"metadata":{},"sourceType":"module"}