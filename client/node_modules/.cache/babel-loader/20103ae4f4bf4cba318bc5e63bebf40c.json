{"ast":null,"code":"import isPlainObject from 'is-plain-object';\nimport { Operation, Editor, Path } from 'slate';\nvar History = {\n  /**\r\n   * Check if a value is a `History` object.\r\n   */\n  isHistory(value) {\n    return isPlainObject(value) && Array.isArray(value.redos) && Array.isArray(value.undos) && (value.redos.length === 0 || Operation.isOperationList(value.redos[0])) && (value.undos.length === 0 || Operation.isOperationList(value.undos[0]));\n  }\n\n};\n/**\r\n * Weakmaps for attaching state to the editor.\r\n */\n\nvar HISTORY = new WeakMap();\nvar SAVING = new WeakMap();\nvar MERGING = new WeakMap();\nvar HistoryEditor = {\n  /**\r\n   * Check if a value is a `HistoryEditor` object.\r\n   */\n  isHistoryEditor(value) {\n    return Editor.isEditor(value) && History.isHistory(value.history);\n  },\n\n  /**\r\n   * Get the merge flag's current value.\r\n   */\n  isMerging(editor) {\n    return MERGING.get(editor);\n  },\n\n  /**\r\n   * Get the saving flag's current value.\r\n   */\n  isSaving(editor) {\n    return SAVING.get(editor);\n  },\n\n  /**\r\n   * Redo to the previous saved state.\r\n   */\n  redo(editor) {\n    editor.redo();\n  },\n\n  /**\r\n   * Undo to the previous saved state.\r\n   */\n  undo(editor) {\n    editor.undo();\n  },\n\n  /**\r\n   * Apply a series of changes inside a synchronous `fn`, without merging any of\r\n   * the new operations into previous save point in the history.\r\n   */\n  withoutMerging(editor, fn) {\n    var prev = HistoryEditor.isMerging(editor);\n    MERGING.set(editor, false);\n    fn();\n    MERGING.set(editor, prev);\n  },\n\n  /**\r\n   * Apply a series of changes inside a synchronous `fn`, without saving any of\r\n   * their operations into the history.\r\n   */\n  withoutSaving(editor, fn) {\n    var prev = HistoryEditor.isSaving(editor);\n    SAVING.set(editor, false);\n    fn();\n    SAVING.set(editor, prev);\n  }\n\n};\n/**\r\n * The `withHistory` plugin keeps track of the operation history of a Slate\r\n * editor as operations are applied to it, using undo and redo stacks.\r\n */\n\nvar withHistory = editor => {\n  var e = editor;\n  var {\n    apply\n  } = e;\n  e.history = {\n    undos: [],\n    redos: []\n  };\n\n  e.redo = () => {\n    var {\n      history\n    } = e;\n    var {\n      redos\n    } = history;\n\n    if (redos.length > 0) {\n      var batch = redos[redos.length - 1];\n      HistoryEditor.withoutSaving(e, () => {\n        Editor.withoutNormalizing(e, () => {\n          for (var op of batch) {\n            e.apply(op);\n          }\n        });\n      });\n      history.redos.pop();\n      history.undos.push(batch);\n    }\n  };\n\n  e.undo = () => {\n    var {\n      history\n    } = e;\n    var {\n      undos\n    } = history;\n\n    if (undos.length > 0) {\n      var batch = undos[undos.length - 1];\n      HistoryEditor.withoutSaving(e, () => {\n        Editor.withoutNormalizing(e, () => {\n          var inverseOps = batch.map(Operation.inverse).reverse();\n\n          for (var op of inverseOps) {\n            // If the final operation is deselecting the editor, skip it. This is\n            if (op === inverseOps[inverseOps.length - 1] && op.type === 'set_selection' && op.newProperties == null) {\n              continue;\n            } else {\n              e.apply(op);\n            }\n          }\n        });\n      });\n      history.redos.push(batch);\n      history.undos.pop();\n    }\n  };\n\n  e.apply = op => {\n    var {\n      operations,\n      history\n    } = e;\n    var {\n      undos\n    } = history;\n    var lastBatch = undos[undos.length - 1];\n    var lastOp = lastBatch && lastBatch[lastBatch.length - 1];\n    var overwrite = shouldOverwrite(op, lastOp);\n    var save = HistoryEditor.isSaving(e);\n    var merge = HistoryEditor.isMerging(e);\n\n    if (save == null) {\n      save = shouldSave(op);\n    }\n\n    if (save) {\n      if (merge == null) {\n        if (lastBatch == null) {\n          merge = false;\n        } else if (operations.length !== 0) {\n          merge = true;\n        } else {\n          merge = shouldMerge(op, lastOp) || overwrite;\n        }\n      }\n\n      if (lastBatch && merge) {\n        if (overwrite) {\n          lastBatch.pop();\n        }\n\n        lastBatch.push(op);\n      } else {\n        var batch = [op];\n        undos.push(batch);\n      }\n\n      while (undos.length > 100) {\n        undos.shift();\n      }\n\n      if (shouldClear(op)) {\n        history.redos = [];\n      }\n    }\n\n    apply(op);\n  };\n\n  return e;\n};\n/**\r\n * Check whether to merge an operation into the previous operation.\r\n */\n\n\nvar shouldMerge = (op, prev) => {\n  if (op.type === 'set_selection') {\n    return true;\n  }\n\n  if (prev && op.type === 'insert_text' && prev.type === 'insert_text' && op.offset === prev.offset + prev.text.length && Path.equals(op.path, prev.path)) {\n    return true;\n  }\n\n  if (prev && op.type === 'remove_text' && prev.type === 'remove_text' && op.offset + op.text.length === prev.offset && Path.equals(op.path, prev.path)) {\n    return true;\n  }\n\n  return false;\n};\n/**\r\n * Check whether an operation needs to be saved to the history.\r\n */\n\n\nvar shouldSave = (op, prev) => {\n  if (op.type === 'set_selection' && op.newProperties == null) {\n    return false;\n  }\n\n  return true;\n};\n/**\r\n * Check whether an operation should overwrite the previous one.\r\n */\n\n\nvar shouldOverwrite = (op, prev) => {\n  if (prev && op.type === 'set_selection' && prev.type === 'set_selection') {\n    return true;\n  }\n\n  return false;\n};\n/**\r\n * Check whether an operation should clear the redos stack.\r\n */\n\n\nvar shouldClear = op => {\n  if (op.type === 'set_selection') {\n    return false;\n  }\n\n  return true;\n};\n\nexport { HISTORY, History, HistoryEditor, MERGING, SAVING, withHistory };","map":{"version":3,"sources":["../src/history.ts","../src/history-editor.ts","../src/with-history.ts"],"names":["History","isHistory","isPlainObject","Array","value","Operation","HISTORY","SAVING","MERGING","HistoryEditor","isHistoryEditor","Editor","isMerging","isSaving","redo","editor","undo","withoutMerging","prev","fn","withoutSaving","withHistory","e","apply","undos","redos","history","batch","inverseOps","op","lastBatch","lastOp","overwrite","shouldOverwrite","save","merge","shouldSave","operations","shouldMerge","shouldClear","Path"],"mappings":"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","sourcesContent":["import isPlainObject from 'is-plain-object'\nimport { Operation } from 'slate'\n\n/**\n * `History` objects hold all of the operations that are applied to a value, so\n * they can be undone or redone as necessary.\n */\n\nexport interface History {\n  redos: Operation[][]\n  undos: Operation[][]\n}\n\nexport const History = {\n  /**\n   * Check if a value is a `History` object.\n   */\n\n  isHistory(value: any): value is History {\n    return (\n      isPlainObject(value) &&\n      Array.isArray(value.redos) &&\n      Array.isArray(value.undos) &&\n      (value.redos.length === 0 || Operation.isOperationList(value.redos[0])) &&\n      (value.undos.length === 0 || Operation.isOperationList(value.undos[0]))\n    )\n  },\n}\n","import { Editor } from 'slate'\nimport { History } from './history'\n\n/**\n * Weakmaps for attaching state to the editor.\n */\n\nexport const HISTORY = new WeakMap<Editor, History>()\nexport const SAVING = new WeakMap<Editor, boolean | undefined>()\nexport const MERGING = new WeakMap<Editor, boolean | undefined>()\n\n/**\n * `HistoryEditor` contains helpers for history-enabled editors.\n */\n\nexport interface HistoryEditor extends Editor {\n  history: History\n  undo: () => void\n  redo: () => void\n}\n\nexport const HistoryEditor = {\n  /**\n   * Check if a value is a `HistoryEditor` object.\n   */\n\n  isHistoryEditor(value: any): value is HistoryEditor {\n    return Editor.isEditor(value) && History.isHistory(value.history)\n  },\n\n  /**\n   * Get the merge flag's current value.\n   */\n\n  isMerging(editor: HistoryEditor): boolean | undefined {\n    return MERGING.get(editor)\n  },\n\n  /**\n   * Get the saving flag's current value.\n   */\n\n  isSaving(editor: HistoryEditor): boolean | undefined {\n    return SAVING.get(editor)\n  },\n\n  /**\n   * Redo to the previous saved state.\n   */\n\n  redo(editor: HistoryEditor): void {\n    editor.redo()\n  },\n\n  /**\n   * Undo to the previous saved state.\n   */\n\n  undo(editor: HistoryEditor): void {\n    editor.undo()\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without merging any of\n   * the new operations into previous save point in the history.\n   */\n\n  withoutMerging(editor: HistoryEditor, fn: () => void): void {\n    const prev = HistoryEditor.isMerging(editor)\n    MERGING.set(editor, false)\n    fn()\n    MERGING.set(editor, prev)\n  },\n\n  /**\n   * Apply a series of changes inside a synchronous `fn`, without saving any of\n   * their operations into the history.\n   */\n\n  withoutSaving(editor: HistoryEditor, fn: () => void): void {\n    const prev = HistoryEditor.isSaving(editor)\n    SAVING.set(editor, false)\n    fn()\n    SAVING.set(editor, prev)\n  },\n}\n","import { Editor, Operation, Path } from 'slate'\n\nimport { HistoryEditor } from './history-editor'\n\n/**\n * The `withHistory` plugin keeps track of the operation history of a Slate\n * editor as operations are applied to it, using undo and redo stacks.\n */\n\nexport const withHistory = <T extends Editor>(editor: T) => {\n  const e = editor as T & HistoryEditor\n  const { apply } = e\n  e.history = { undos: [], redos: [] }\n\n  e.redo = () => {\n    const { history } = e\n    const { redos } = history\n\n    if (redos.length > 0) {\n      const batch = redos[redos.length - 1]\n\n      HistoryEditor.withoutSaving(e, () => {\n        Editor.withoutNormalizing(e, () => {\n          for (const op of batch) {\n            e.apply(op)\n          }\n        })\n      })\n\n      history.redos.pop()\n      history.undos.push(batch)\n    }\n  }\n\n  e.undo = () => {\n    const { history } = e\n    const { undos } = history\n\n    if (undos.length > 0) {\n      const batch = undos[undos.length - 1]\n\n      HistoryEditor.withoutSaving(e, () => {\n        Editor.withoutNormalizing(e, () => {\n          const inverseOps = batch.map(Operation.inverse).reverse()\n\n          for (const op of inverseOps) {\n            // If the final operation is deselecting the editor, skip it. This is\n            if (\n              op === inverseOps[inverseOps.length - 1] &&\n              op.type === 'set_selection' &&\n              op.newProperties == null\n            ) {\n              continue\n            } else {\n              e.apply(op)\n            }\n          }\n        })\n      })\n\n      history.redos.push(batch)\n      history.undos.pop()\n    }\n  }\n\n  e.apply = (op: Operation) => {\n    const { operations, history } = e\n    const { undos } = history\n    const lastBatch = undos[undos.length - 1]\n    const lastOp = lastBatch && lastBatch[lastBatch.length - 1]\n    const overwrite = shouldOverwrite(op, lastOp)\n    let save = HistoryEditor.isSaving(e)\n    let merge = HistoryEditor.isMerging(e)\n\n    if (save == null) {\n      save = shouldSave(op, lastOp)\n    }\n\n    if (save) {\n      if (merge == null) {\n        if (lastBatch == null) {\n          merge = false\n        } else if (operations.length !== 0) {\n          merge = true\n        } else {\n          merge = shouldMerge(op, lastOp) || overwrite\n        }\n      }\n\n      if (lastBatch && merge) {\n        if (overwrite) {\n          lastBatch.pop()\n        }\n\n        lastBatch.push(op)\n      } else {\n        const batch = [op]\n        undos.push(batch)\n      }\n\n      while (undos.length > 100) {\n        undos.shift()\n      }\n\n      if (shouldClear(op)) {\n        history.redos = []\n      }\n    }\n\n    apply(op)\n  }\n\n  return e\n}\n\n/**\n * Check whether to merge an operation into the previous operation.\n */\n\nconst shouldMerge = (op: Operation, prev: Operation | undefined): boolean => {\n  if (op.type === 'set_selection') {\n    return true\n  }\n\n  if (\n    prev &&\n    op.type === 'insert_text' &&\n    prev.type === 'insert_text' &&\n    op.offset === prev.offset + prev.text.length &&\n    Path.equals(op.path, prev.path)\n  ) {\n    return true\n  }\n\n  if (\n    prev &&\n    op.type === 'remove_text' &&\n    prev.type === 'remove_text' &&\n    op.offset + op.text.length === prev.offset &&\n    Path.equals(op.path, prev.path)\n  ) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Check whether an operation needs to be saved to the history.\n */\n\nconst shouldSave = (op: Operation, prev: Operation | undefined): boolean => {\n  if (op.type === 'set_selection' && op.newProperties == null) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * Check whether an operation should overwrite the previous one.\n */\n\nconst shouldOverwrite = (\n  op: Operation,\n  prev: Operation | undefined\n): boolean => {\n  if (prev && op.type === 'set_selection' && prev.type === 'set_selection') {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Check whether an operation should clear the redos stack.\n */\n\nconst shouldClear = (op: Operation): boolean => {\n  if (op.type === 'set_selection') {\n    return false\n  }\n\n  return true\n}\n"]},"metadata":{},"sourceType":"module"}