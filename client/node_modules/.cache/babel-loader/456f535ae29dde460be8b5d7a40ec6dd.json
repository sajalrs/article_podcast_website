{"ast":null,"code":"import React from 'react';\nimport { renderToStaticMarkup } from 'react-dom/server';\nimport typeOf from 'type-of';\nimport { Node, Value } from 'slate';\nimport { Record } from 'immutable';\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n/**\n * String.\n *\n * @type {String}\n */\n\n\nvar String = new Record({\n  object: 'string',\n  text: ''\n});\n/**\n * A rule to (de)serialize text nodes. This is automatically added to the HTML\n * serializer so that users don't have to worry about text-level serialization.\n *\n * @type {Object}\n */\n\nvar TEXT_RULE = {\n  deserialize: function deserialize(el) {\n    if (el.tagName && el.tagName.toLowerCase() === 'br') {\n      return {\n        object: 'text',\n        text: '\\n',\n        marks: []\n      };\n    }\n\n    if (el.nodeName === '#text') {\n      if (el.nodeValue && el.nodeValue.match(/<!--.*?-->/)) return;\n      return {\n        object: 'text',\n        text: el.nodeValue,\n        marks: []\n      };\n    }\n  },\n  serialize: function serialize(obj, children) {\n    if (obj.object === 'string') {\n      return children.split('\\n').reduce(function (array, text, i) {\n        if (i !== 0) array.push(React.createElement('br', {\n          key: i\n        }));\n        array.push(text);\n        return array;\n      }, []);\n    }\n  }\n};\n/**\n * A default `parseHtml` function that returns the `<body>` using `DOMParser`.\n *\n * @param {String} html\n * @return {Object}\n */\n\nfunction defaultParseHtml(html) {\n  if (typeof DOMParser == 'undefined') {\n    throw new Error('The native `DOMParser` global which the `Html` serializer uses by default is not present in this environment. You must supply the `options.parseHtml` function instead.');\n  }\n\n  var parsed = new DOMParser().parseFromString(html, 'text/html');\n  var body = parsed.body; // COMPAT: in IE 11 body is null if html is an empty string\n\n  return body || window.document.createElement('body');\n}\n/**\n * HTML serializer.\n *\n * @type {Html}\n */\n\n\nvar Html =\n/**\n * Create a new serializer with `rules`.\n *\n * @param {Object} options\n *   @property {Array} rules\n *   @property {String|Object|Block} defaultBlock\n *   @property {Function} parseHtml\n */\nfunction Html() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  classCallCheck(this, Html);\n\n  _initialiseProps.call(this);\n\n  var _options$defaultBlock = options.defaultBlock,\n      defaultBlock = _options$defaultBlock === undefined ? 'paragraph' : _options$defaultBlock,\n      _options$parseHtml = options.parseHtml,\n      parseHtml = _options$parseHtml === undefined ? defaultParseHtml : _options$parseHtml,\n      _options$rules = options.rules,\n      rules = _options$rules === undefined ? [] : _options$rules;\n  defaultBlock = Node.createProperties(defaultBlock);\n  this.rules = [].concat(toConsumableArray(rules), [TEXT_RULE]);\n  this.defaultBlock = defaultBlock;\n  this.parseHtml = parseHtml;\n};\n/**\n * Add a unique key to a React `element`.\n *\n * @param {Element} element\n * @return {Element}\n */\n\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this = this;\n\n  this.deserialize = function (html) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$toJSON = options.toJSON,\n        toJSON = _options$toJSON === undefined ? false : _options$toJSON;\n    var defaultBlock = _this.defaultBlock,\n        parseHtml = _this.parseHtml;\n    var fragment = parseHtml(html);\n    var children = Array.from(fragment.childNodes);\n\n    var nodes = _this.deserializeElements(children); // COMPAT: ensure that all top-level inline nodes are wrapped into a block.\n\n\n    nodes = nodes.reduce(function (memo, node, i, original) {\n      if (node.object === 'block') {\n        memo.push(node);\n        return memo;\n      }\n\n      if (i > 0 && original[i - 1].object !== 'block') {\n        var _block = memo[memo.length - 1];\n\n        _block.nodes.push(node);\n\n        return memo;\n      }\n\n      var block = _extends({\n        object: 'block',\n        data: {}\n      }, defaultBlock, {\n        nodes: [node]\n      });\n\n      memo.push(block);\n      return memo;\n    }, []); // TODO: pretty sure this is no longer needed.\n\n    if (nodes.length === 0) {\n      nodes = [_extends({\n        object: 'block',\n        data: {}\n      }, defaultBlock, {\n        nodes: [{\n          object: 'text',\n          text: '',\n          marks: []\n        }]\n      })];\n    }\n\n    var json = {\n      object: 'value',\n      document: {\n        object: 'document',\n        data: {},\n        nodes: nodes\n      }\n    };\n    var ret = toJSON ? json : Value.fromJSON(json);\n    return ret;\n  };\n\n  this.deserializeElements = function () {\n    var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var nodes = [];\n    elements.filter(_this.cruftNewline).forEach(function (element) {\n      var node = _this.deserializeElement(element);\n\n      switch (typeOf(node)) {\n        case 'array':\n          nodes = nodes.concat(node);\n          break;\n\n        case 'object':\n          nodes.push(node);\n          break;\n      }\n    });\n    return nodes;\n  };\n\n  this.deserializeElement = function (element) {\n    var node = void 0;\n\n    if (!element.tagName) {\n      element.tagName = '';\n    }\n\n    var next = function next(elements) {\n      if (Object.prototype.toString.call(elements) === '[object NodeList]') {\n        elements = Array.from(elements);\n      }\n\n      switch (typeOf(elements)) {\n        case 'array':\n          return _this.deserializeElements(elements);\n\n        case 'object':\n          return _this.deserializeElement(elements);\n\n        case 'null':\n        case 'undefined':\n          return;\n\n        default:\n          throw new Error('The `next` argument was called with invalid children: \"' + elements + '\".');\n      }\n    };\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = _this.rules[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var rule = _step.value;\n        if (!rule.deserialize) continue;\n        var ret = rule.deserialize(element, next);\n        var type = typeOf(ret);\n\n        if (type !== 'array' && type !== 'object' && type !== 'null' && type !== 'undefined') {\n          throw new Error('A rule returned an invalid deserialized representation: \"' + node + '\".');\n        }\n\n        if (ret === undefined) {\n          continue;\n        } else if (ret === null) {\n          return null;\n        } else if (ret.object === 'mark') {\n          node = _this.deserializeMark(ret);\n        } else {\n          node = ret;\n        }\n\n        if (node.object === 'block' || node.object === 'inline') {\n          node.data = node.data || {};\n          node.nodes = node.nodes || [];\n        } else if (node.object === 'text') {\n          node.marks = node.marks || [];\n          node.text = node.text || '';\n        }\n\n        break;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return node || next(element.childNodes);\n  };\n\n  this.deserializeMark = function (mark) {\n    var type = mark.type,\n        data = mark.data;\n\n    var applyMark = function applyMark(node) {\n      if (node.object === 'mark') {\n        var ret = _this.deserializeMark(node);\n\n        return ret;\n      } else if (node.object === 'text') {\n        node.marks = node.marks || [];\n        node.marks.push({\n          type: type,\n          data: data\n        });\n      } else if (node.nodes) {\n        node.nodes = node.nodes.map(applyMark);\n      }\n\n      return node;\n    };\n\n    return mark.nodes.reduce(function (nodes, node) {\n      var ret = applyMark(node);\n      if (Array.isArray(ret)) return nodes.concat(ret);\n      nodes.push(ret);\n      return nodes;\n    }, []);\n  };\n\n  this.serialize = function (value) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var document = value.document;\n    var elements = document.nodes.map(_this.serializeNode).filter(function (el) {\n      return el;\n    });\n    if (options.render === false) return elements;\n    var html = renderToStaticMarkup(React.createElement('body', null, elements));\n    var inner = html.slice(6, -7);\n    return inner;\n  };\n\n  this.serializeNode = function (node) {\n    if (node.object === 'text') {\n      var string = new String({\n        text: node.text\n      });\n\n      var text = _this.serializeString(string);\n\n      return node.marks.reduce(function (children, mark) {\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = _this.rules[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var rule = _step2.value;\n            if (!rule.serialize) continue;\n            var ret = rule.serialize(mark, children);\n            if (ret === null) return;\n            if (ret) return addKey(ret);\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        throw new Error('No serializer defined for mark of type \"' + mark.type + '\".');\n      }, text);\n    }\n\n    var children = node.nodes.map(_this.serializeNode);\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = _this.rules[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var rule = _step3.value;\n        if (!rule.serialize) continue;\n        var ret = rule.serialize(node, children);\n        if (ret === null) return;\n        if (ret) return addKey(ret);\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    throw new Error('No serializer defined for node of type \"' + node.type + '\".');\n  };\n\n  this.serializeString = function (string) {\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = _this.rules[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var rule = _step4.value;\n        if (!rule.serialize) continue;\n        var ret = rule.serialize(string, string.text);\n        if (ret) return ret;\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n  };\n\n  this.cruftNewline = function (element) {\n    return !(element.nodeName === '#text' && element.nodeValue === '\\n');\n  };\n};\n\nvar key = 0;\n\nfunction addKey(element) {\n  return React.cloneElement(element, {\n    key: key++\n  });\n}\n\nexport default Html;","map":{"version":3,"sources":["../src/index.js"],"names":["String","TEXT_RULE","el","obj","i","array","parsed","body","window","Html","options","defaultBlock","parseHtml","rules","Node","deserialize","toJSON","fragment","children","Array","nodes","node","original","block","memo","json","ret","Value","deserializeElements","elements","typeOf","deserializeElement","element","next","Object","rule","type","deserializeMark","data","mark","applyMark","serialize","document","value","html","inner","serializeNode","string","text","addKey","serializeString","cruftNewline","key","React"],"mappings":"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","sourcesContent":["import React from 'react'\nimport { renderToStaticMarkup } from 'react-dom/server'\nimport typeOf from 'type-of'\nimport { Node, Value } from 'slate'\nimport { Record } from 'immutable'\n\n/**\n * String.\n *\n * @type {String}\n */\n\nconst String = new Record({\n  object: 'string',\n  text: '',\n})\n\n/**\n * A rule to (de)serialize text nodes. This is automatically added to the HTML\n * serializer so that users don't have to worry about text-level serialization.\n *\n * @type {Object}\n */\n\nconst TEXT_RULE = {\n  deserialize(el) {\n    if (el.tagName && el.tagName.toLowerCase() === 'br') {\n      return {\n        object: 'text',\n        text: '\\n',\n        marks: [],\n      }\n    }\n\n    if (el.nodeName === '#text') {\n      if (el.nodeValue && el.nodeValue.match(/<!--.*?-->/)) return\n\n      return {\n        object: 'text',\n        text: el.nodeValue,\n        marks: [],\n      }\n    }\n  },\n\n  serialize(obj, children) {\n    if (obj.object === 'string') {\n      return children.split('\\n').reduce((array, text, i) => {\n        if (i !== 0) array.push(<br key={i} />)\n        array.push(text)\n        return array\n      }, [])\n    }\n  },\n}\n\n/**\n * A default `parseHtml` function that returns the `<body>` using `DOMParser`.\n *\n * @param {String} html\n * @return {Object}\n */\n\nfunction defaultParseHtml(html) {\n  if (typeof DOMParser == 'undefined') {\n    throw new Error(\n      'The native `DOMParser` global which the `Html` serializer uses by default is not present in this environment. You must supply the `options.parseHtml` function instead.'\n    )\n  }\n\n  const parsed = new DOMParser().parseFromString(html, 'text/html')\n  const { body } = parsed\n  // COMPAT: in IE 11 body is null if html is an empty string\n  return body || window.document.createElement('body')\n}\n\n/**\n * HTML serializer.\n *\n * @type {Html}\n */\n\nclass Html {\n  /**\n   * Create a new serializer with `rules`.\n   *\n   * @param {Object} options\n   *   @property {Array} rules\n   *   @property {String|Object|Block} defaultBlock\n   *   @property {Function} parseHtml\n   */\n\n  constructor(options = {}) {\n    let {\n      defaultBlock = 'paragraph',\n      parseHtml = defaultParseHtml,\n      rules = [],\n    } = options\n\n    defaultBlock = Node.createProperties(defaultBlock)\n\n    this.rules = [...rules, TEXT_RULE]\n    this.defaultBlock = defaultBlock\n    this.parseHtml = parseHtml\n  }\n\n  /**\n   * Deserialize pasted HTML.\n   *\n   * @param {String} html\n   * @param {Object} options\n   *   @property {Boolean} toRaw\n   * @return {Value}\n   */\n\n  deserialize = (html, options = {}) => {\n    const { toJSON = false } = options\n    const { defaultBlock, parseHtml } = this\n    const fragment = parseHtml(html)\n    const children = Array.from(fragment.childNodes)\n    let nodes = this.deserializeElements(children)\n\n    // COMPAT: ensure that all top-level inline nodes are wrapped into a block.\n    nodes = nodes.reduce((memo, node, i, original) => {\n      if (node.object === 'block') {\n        memo.push(node)\n        return memo\n      }\n\n      if (i > 0 && original[i - 1].object !== 'block') {\n        const block = memo[memo.length - 1]\n        block.nodes.push(node)\n        return memo\n      }\n\n      const block = {\n        object: 'block',\n        data: {},\n        ...defaultBlock,\n        nodes: [node],\n      }\n\n      memo.push(block)\n      return memo\n    }, [])\n\n    // TODO: pretty sure this is no longer needed.\n    if (nodes.length === 0) {\n      nodes = [\n        {\n          object: 'block',\n          data: {},\n          ...defaultBlock,\n          nodes: [\n            {\n              object: 'text',\n              text: '',\n              marks: [],\n            },\n          ],\n        },\n      ]\n    }\n\n    const json = {\n      object: 'value',\n      document: {\n        object: 'document',\n        data: {},\n        nodes,\n      },\n    }\n\n    const ret = toJSON ? json : Value.fromJSON(json)\n    return ret\n  }\n\n  /**\n   * Deserialize an array of DOM elements.\n   *\n   * @param {Array} elements\n   * @return {Array}\n   */\n\n  deserializeElements = (elements = []) => {\n    let nodes = []\n\n    elements.filter(this.cruftNewline).forEach(element => {\n      const node = this.deserializeElement(element)\n\n      switch (typeOf(node)) {\n        case 'array':\n          nodes = nodes.concat(node)\n          break\n        case 'object':\n          nodes.push(node)\n          break\n      }\n    })\n\n    return nodes\n  }\n\n  /**\n   * Deserialize a DOM element.\n   *\n   * @param {Object} element\n   * @return {Any}\n   */\n\n  deserializeElement = element => {\n    let node\n\n    if (!element.tagName) {\n      element.tagName = ''\n    }\n\n    const next = elements => {\n      if (Object.prototype.toString.call(elements) === '[object NodeList]') {\n        elements = Array.from(elements)\n      }\n\n      switch (typeOf(elements)) {\n        case 'array':\n          return this.deserializeElements(elements)\n        case 'object':\n          return this.deserializeElement(elements)\n        case 'null':\n        case 'undefined':\n          return\n        default:\n          throw new Error(\n            `The \\`next\\` argument was called with invalid children: \"${elements}\".`\n          )\n      }\n    }\n\n    for (const rule of this.rules) {\n      if (!rule.deserialize) continue\n      const ret = rule.deserialize(element, next)\n      const type = typeOf(ret)\n\n      if (\n        type !== 'array' &&\n        type !== 'object' &&\n        type !== 'null' &&\n        type !== 'undefined'\n      ) {\n        throw new Error(\n          `A rule returned an invalid deserialized representation: \"${node}\".`\n        )\n      }\n\n      if (ret === undefined) {\n        continue\n      } else if (ret === null) {\n        return null\n      } else if (ret.object === 'mark') {\n        node = this.deserializeMark(ret)\n      } else {\n        node = ret\n      }\n\n      if (node.object === 'block' || node.object === 'inline') {\n        node.data = node.data || {}\n        node.nodes = node.nodes || []\n      } else if (node.object === 'text') {\n        node.marks = node.marks || []\n        node.text = node.text || ''\n      }\n\n      break\n    }\n\n    return node || next(element.childNodes)\n  }\n\n  /**\n   * Deserialize a `mark` object.\n   *\n   * @param {Object} mark\n   * @return {Array}\n   */\n\n  deserializeMark = mark => {\n    const { type, data } = mark\n\n    const applyMark = node => {\n      if (node.object === 'mark') {\n        const ret = this.deserializeMark(node)\n        return ret\n      } else if (node.object === 'text') {\n        node.marks = node.marks || []\n        node.marks.push({ type, data })\n      } else if (node.nodes) {\n        node.nodes = node.nodes.map(applyMark)\n      }\n\n      return node\n    }\n\n    return mark.nodes.reduce((nodes, node) => {\n      const ret = applyMark(node)\n      if (Array.isArray(ret)) return nodes.concat(ret)\n      nodes.push(ret)\n      return nodes\n    }, [])\n  }\n\n  /**\n   * Serialize a `value` object into an HTML string.\n   *\n   * @param {Value} value\n   * @param {Object} options\n   *   @property {Boolean} render\n   * @return {String|Array}\n   */\n\n  serialize = (value, options = {}) => {\n    const { document } = value\n    const elements = document.nodes.map(this.serializeNode).filter(el => el)\n    if (options.render === false) return elements\n\n    const html = renderToStaticMarkup(<body>{elements}</body>)\n    const inner = html.slice(6, -7)\n    return inner\n  }\n\n  /**\n   * Serialize a `node`.\n   *\n   * @param {Node} node\n   * @return {String}\n   */\n\n  serializeNode = node => {\n    if (node.object === 'text') {\n      const string = new String({ text: node.text })\n      const text = this.serializeString(string)\n\n      return node.marks.reduce((children, mark) => {\n        for (const rule of this.rules) {\n          if (!rule.serialize) continue\n          const ret = rule.serialize(mark, children)\n          if (ret === null) return\n          if (ret) return addKey(ret)\n        }\n\n        throw new Error(\n          `No serializer defined for mark of type \"${mark.type}\".`\n        )\n      }, text)\n    }\n\n    const children = node.nodes.map(this.serializeNode)\n\n    for (const rule of this.rules) {\n      if (!rule.serialize) continue\n      const ret = rule.serialize(node, children)\n      if (ret === null) return\n      if (ret) return addKey(ret)\n    }\n\n    throw new Error(`No serializer defined for node of type \"${node.type}\".`)\n  }\n\n  /**\n   * Serialize a `string`.\n   *\n   * @param {String} string\n   * @return {String}\n   */\n\n  serializeString = string => {\n    for (const rule of this.rules) {\n      if (!rule.serialize) continue\n      const ret = rule.serialize(string, string.text)\n      if (ret) return ret\n    }\n  }\n\n  /**\n   * Filter out cruft newline nodes inserted by the DOM parser.\n   *\n   * @param {Object} element\n   * @return {Boolean}\n   */\n\n  cruftNewline = element => {\n    return !(element.nodeName === '#text' && element.nodeValue === '\\n')\n  }\n}\n\n/**\n * Add a unique key to a React `element`.\n *\n * @param {Element} element\n * @return {Element}\n */\n\nlet key = 0\n\nfunction addKey(element) {\n  return React.cloneElement(element, { key: key++ })\n}\n\n/**\n * Export.\n *\n * @type {Html}\n */\n\nexport default Html\n"]},"metadata":{},"sourceType":"module"}